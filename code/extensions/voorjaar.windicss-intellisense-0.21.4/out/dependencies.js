'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var require$$0$3 = require('crypto');
var fs$r = require('fs');
var require$$2 = require('module');
var require$$3$1 = require('os');
var require$$0$4 = require('path');
var require$$5 = require('vm');
var require$$1$2 = require('util');
var require$$0$5 = require('assert');
var require$$1$3 = require('buffer');
var require$$0$6 = require('tty');
var require$$7 = require('url');
var require$$9 = require('v8');
require('http');
var require$$0$7 = require('stream');
var require$$0$8 = require('events');
var require$$4 = require('net');
require('querystring');
var require$$0$9 = require('constants');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () {
						return e[k];
					}
				});
			}
		});
	}
	n['default'] = e;
	return Object.freeze(n);
}

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs$r);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3$1);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$4);
var require$$5__default = /*#__PURE__*/_interopDefaultLegacy(require$$5);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1$2);
var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$5);
var require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$3);
var require$$0__default$3 = /*#__PURE__*/_interopDefaultLegacy(require$$0$6);
var require$$7__default = /*#__PURE__*/_interopDefaultLegacy(require$$7);
var require$$9__default = /*#__PURE__*/_interopDefaultLegacy(require$$9);
var require$$0__default$4 = /*#__PURE__*/_interopDefaultLegacy(require$$0$7);
var require$$0__default$5 = /*#__PURE__*/_interopDefaultLegacy(require$$0$8);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);
var require$$0__default$6 = /*#__PURE__*/_interopDefaultLegacy(require$$0$9);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var esm = {};

esm.dynamicImport = function (id) {
  return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(id)); })
};

/*! For license information please see v8cache.js.LICENSE.txt */

(()=>{var e={"./node_modules/v8-compile-cache/v8-compile-cache.js":(e,t,s)=>{const o=s("module"),r=s("crypto"),i=s("fs"),c=s("path"),n=s("vm"),a=s("os"),l=Object.prototype.hasOwnProperty;class h{constructor(e,t){const s=t?function(e){const t={"\\":"zB",":":"zC","/":"zS","\0":"z0",z:"zZ"};return e.replace(/[\\:/\x00z]/g,(e=>t[e]))}(t+"."):"";this._blobFilename=c.join(e,s+"BLOB"),this._mapFilename=c.join(e,s+"MAP"),this._lockFilename=c.join(e,s+"LOCK"),this._directory=e,this._load();}has(e,t){return l.call(this._memoryBlobs,e)?this._invalidationKeys[e]===t:!!l.call(this._storedMap,e)&&this._storedMap[e][0]===t}get(e,t){if(l.call(this._memoryBlobs,e)){if(this._invalidationKeys[e]===t)return this._memoryBlobs[e]}else if(l.call(this._storedMap,e)){const s=this._storedMap[e];if(s[0]===t)return this._storedBlob.slice(s[1],s[2])}}set(e,t,s){this._invalidationKeys[e]=t,this._memoryBlobs[e]=s,this._dirty=!0;}delete(e){l.call(this._memoryBlobs,e)&&(this._dirty=!0,delete this._memoryBlobs[e]),l.call(this._invalidationKeys,e)&&(this._dirty=!0,delete this._invalidationKeys[e]),l.call(this._storedMap,e)&&(this._dirty=!0,delete this._storedMap[e]);}isDirty(){return this._dirty}save(){const e=this._getDump(),t=Buffer.concat(e[0]),s=JSON.stringify(e[1]);try{o=this._directory,d(c.resolve(o),511),i.writeFileSync(this._lockFilename,"LOCK",{flag:"wx"});}catch(e){return !1}var o;try{i.writeFileSync(this._blobFilename,t),i.writeFileSync(this._mapFilename,s);}finally{i.unlinkSync(this._lockFilename);}return !0}_load(){try{this._storedBlob=i.readFileSync(this._blobFilename),this._storedMap=JSON.parse(i.readFileSync(this._mapFilename));}catch(e){this._storedBlob=Buffer.alloc(0),this._storedMap={};}this._dirty=!1,this._memoryBlobs={},this._invalidationKeys={};}_getDump(){const e=[],t={};let s=0;function o(o,r,i){e.push(i),t[o]=[r,s,s+i.length],s+=i.length;}for(const e of Object.keys(this._memoryBlobs)){const t=this._memoryBlobs[e];o(e,this._invalidationKeys[e],t);}for(const e of Object.keys(this._storedMap)){if(l.call(t,e))continue;const s=this._storedMap[e],r=this._storedBlob.slice(s[1],s[2]);o(e,s[0],r);}return [e,t]}}class p{constructor(){this._cacheStore=null,this._previousModuleCompile=null;}setCacheStore(e){this._cacheStore=e;}install(){const e=this,t="function"==typeof s("./node_modules/v8-compile-cache sync recursive").resolve.paths;this._previousModuleCompile=o.prototype._compile,o.prototype._compile=function(s,r){const i=this;function n(e){return i.require(e)}function a(e,t){return o._resolveFilename(e,i,!1,t)}n.resolve=a,t&&(a.paths=function(e){return o._resolveLookupPaths(e,i,!0)}),n.main=process.mainModule,n.extensions=o._extensions,n.cache=o._cache;const l=c.dirname(r),h=e._moduleCompile(r,s),p=[i.exports,n,i,r,l,process,commonjsGlobal,Buffer];return h.apply(i.exports,p)};}uninstall(){o.prototype._compile=this._previousModuleCompile;}_moduleCompile(e,t){var s=t.length;if(s>=2&&35===t.charCodeAt(0)&&33===t.charCodeAt(1))if(2===s)t="";else {for(var i=2;i<s;++i){var c=t.charCodeAt(i);if(10===c||13===c)break}t=i===s?"":t.slice(i);}var a=o.wrap(t),l=r.createHash("sha1").update(t,"utf8").digest("hex"),h=this._cacheStore.get(e,l),p=new n.Script(a,{filename:e,lineOffset:0,displayErrors:!0,cachedData:h,produceCachedData:!0});return p.cachedDataProduced?this._cacheStore.set(e,l,p.cachedData):p.cachedDataRejected&&this._cacheStore.delete(e),p.runInThisContext({filename:e,lineOffset:0,columnOffset:0,displayErrors:!0})}}function d(e,t){try{i.mkdirSync(e,t);}catch(t){if("ENOENT"===t.code)d(c.dirname(e)),d(e);else try{if(!i.statSync(e).isDirectory())throw t}catch(e){throw t}}}if(!process.env.DISABLE_V8_COMPILE_CACHE&&!0===new n.Script('""',{produceCachedData:!0}).cachedDataProduced){const e=new h(function(){const e=process.env.V8_COMPILE_CACHE_CACHE_DIR;if(e)return e;const t="function"==typeof process.getuid?"v8-compile-cache-"+process.getuid():"v8-compile-cache",s="string"==typeof process.versions.v8?process.versions.v8:"string"==typeof process.versions.chakracore?"chakracore-"+process.versions.chakracore:"node-"+process.version;return c.join(a.tmpdir(),t,s)}(),s.c[s.s]&&"string"==typeof s.c[s.s].filename?s.c[s.s].filename:process.cwd()),t=new p;t.setCacheStore(e),t.install(),process.once("exit",(()=>{e.isDirty()&&e.save(),t.uninstall();}));}},"./node_modules/v8-compile-cache sync recursive":e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id="./node_modules/v8-compile-cache sync recursive",e.exports=t;},crypto:e=>{e.exports=require$$0__default['default'];},fs:e=>{e.exports=fs__default['default'];},module:e=>{e.exports=require$$2__default['default'];},os:e=>{e.exports=require$$3__default['default'];},path:e=>{e.exports=require$$0__default$1['default'];},vm:e=>{e.exports=require$$5__default['default'];}},t={};function s(o){var r=t[o];if(void 0!==r)return r.exports;var i=t[o]={exports:{}};return e[o](i,i.exports,s),i.exports}s.c=t,s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);s(s.s="./node_modules/v8-compile-cache/v8-compile-cache.js");})();

var jiti$1 = {exports: {}};

(()=>{var e={"./node_modules/create-require/create-require.js":(e,t,r)=>{const s=r("module"),n=r("path"),o=r("fs");e.exports=function(e){return e||(e=process.cwd()),function(e){try{return o.lstatSync(e).isDirectory()}catch(e){return !1}}(e)&&(e=n.join(e,"index.js")),s.createRequire?s.createRequire(e):s.createRequireFromPath?s.createRequireFromPath(e):function(e){const t=new s.Module(e,null);return t.filename=e,t.paths=s.Module._nodeModulePaths(n.dirname(e)),t._compile("module.exports = require;",e),t.exports}(e)};},"./node_modules/lru-cache/index.js":(e,t,r)=>{const s=r("./node_modules/yallist/yallist.js"),n=Symbol("max"),o=Symbol("length"),i=Symbol("lengthCalculator"),a=Symbol("allowStale"),l=Symbol("maxAge"),u=Symbol("dispose"),c=Symbol("noDisposeOnSet"),d=Symbol("lruList"),h=Symbol("cache"),m=Symbol("updateAgeOnGet"),p=()=>1,f=(e,t,r)=>{const s=e[h].get(t);if(s){const t=s.value;if(v(e,t)){if(g(e,s),!e[a])return}else r&&(e[m]&&(s.value.now=Date.now()),e[d].unshiftNode(s));return t.value}},v=(e,t)=>{if(!t||!t.maxAge&&!e[l])return !1;const r=Date.now()-t.now;return t.maxAge?r>t.maxAge:e[l]&&r>e[l]},E=e=>{if(e[o]>e[n])for(let t=e[d].tail;e[o]>e[n]&&null!==t;){const r=t.prev;g(e,t),t=r;}},g=(e,t)=>{if(t){const r=t.value;e[u]&&e[u](r.key,r.value),e[o]-=r.length,e[h].delete(r.key),e[d].removeNode(t);}};class _{constructor(e,t,r,s,n){this.key=e,this.value=t,this.length=r,this.now=s,this.maxAge=n||0;}}const y=(e,t,r,s)=>{let n=r.value;v(e,n)&&(g(e,r),e[a]||(n=void 0)),n&&t.call(s,n.value,n.key,e);};e.exports=class{constructor(e){if("number"==typeof e&&(e={max:e}),e||(e={}),e.max&&("number"!=typeof e.max||e.max<0))throw new TypeError("max must be a non-negative number");this[n]=e.max||1/0;const t=e.length||p;if(this[i]="function"!=typeof t?p:t,this[a]=e.stale||!1,e.maxAge&&"number"!=typeof e.maxAge)throw new TypeError("maxAge must be a number");this[l]=e.maxAge||0,this[u]=e.dispose,this[c]=e.noDisposeOnSet||!1,this[m]=e.updateAgeOnGet||!1,this.reset();}set max(e){if("number"!=typeof e||e<0)throw new TypeError("max must be a non-negative number");this[n]=e||1/0,E(this);}get max(){return this[n]}set allowStale(e){this[a]=!!e;}get allowStale(){return this[a]}set maxAge(e){if("number"!=typeof e)throw new TypeError("maxAge must be a non-negative number");this[l]=e,E(this);}get maxAge(){return this[l]}set lengthCalculator(e){"function"!=typeof e&&(e=p),e!==this[i]&&(this[i]=e,this[o]=0,this[d].forEach((e=>{e.length=this[i](e.value,e.key),this[o]+=e.length;}))),E(this);}get lengthCalculator(){return this[i]}get length(){return this[o]}get itemCount(){return this[d].length}rforEach(e,t){t=t||this;for(let r=this[d].tail;null!==r;){const s=r.prev;y(this,e,r,t),r=s;}}forEach(e,t){t=t||this;for(let r=this[d].head;null!==r;){const s=r.next;y(this,e,r,t),r=s;}}keys(){return this[d].toArray().map((e=>e.key))}values(){return this[d].toArray().map((e=>e.value))}reset(){this[u]&&this[d]&&this[d].length&&this[d].forEach((e=>this[u](e.key,e.value))),this[h]=new Map,this[d]=new s,this[o]=0;}dump(){return this[d].map((e=>!v(this,e)&&{k:e.key,v:e.value,e:e.now+(e.maxAge||0)})).toArray().filter((e=>e))}dumpLru(){return this[d]}set(e,t,r){if((r=r||this[l])&&"number"!=typeof r)throw new TypeError("maxAge must be a number");const s=r?Date.now():0,a=this[i](t,e);if(this[h].has(e)){if(a>this[n])return g(this,this[h].get(e)),!1;const i=this[h].get(e).value;return this[u]&&(this[c]||this[u](e,i.value)),i.now=s,i.maxAge=r,i.value=t,this[o]+=a-i.length,i.length=a,this.get(e),E(this),!0}const m=new _(e,t,a,s,r);return m.length>this[n]?(this[u]&&this[u](e,t),!1):(this[o]+=m.length,this[d].unshift(m),this[h].set(e,this[d].head),E(this),!0)}has(e){if(!this[h].has(e))return !1;const t=this[h].get(e).value;return !v(this,t)}get(e){return f(this,e,!0)}peek(e){return f(this,e,!1)}pop(){const e=this[d].tail;return e?(g(this,e),e.value):null}del(e){g(this,this[h].get(e));}load(e){this.reset();const t=Date.now();for(let r=e.length-1;r>=0;r--){const s=e[r],n=s.e||0;if(0===n)this.set(s.k,s.v);else {const e=n-t;e>0&&this.set(s.k,s.v,e);}}}prune(){this[h].forEach(((e,t)=>f(this,t,!1)));}};},"./node_modules/mkdirp/index.js":(e,t,r)=>{const s=r("./node_modules/mkdirp/lib/opts-arg.js"),n=r("./node_modules/mkdirp/lib/path-arg.js"),{mkdirpNative:o,mkdirpNativeSync:i}=r("./node_modules/mkdirp/lib/mkdirp-native.js"),{mkdirpManual:a,mkdirpManualSync:l}=r("./node_modules/mkdirp/lib/mkdirp-manual.js"),{useNative:u,useNativeSync:c}=r("./node_modules/mkdirp/lib/use-native.js"),d=(e,t)=>(e=n(e),t=s(t),u(t)?o(e,t):a(e,t));d.sync=(e,t)=>(e=n(e),t=s(t),c(t)?i(e,t):l(e,t)),d.native=(e,t)=>o(n(e),s(t)),d.manual=(e,t)=>a(n(e),s(t)),d.nativeSync=(e,t)=>i(n(e),s(t)),d.manualSync=(e,t)=>l(n(e),s(t)),e.exports=d;},"./node_modules/mkdirp/lib/find-made.js":(e,t,r)=>{const{dirname:s}=r("path"),n=(e,t,r)=>r===t?Promise.resolve():e.statAsync(t).then((e=>e.isDirectory()?r:void 0),(r=>"ENOENT"===r.code?n(e,s(t),t):void 0)),o=(e,t,r)=>{if(r!==t)try{return e.statSync(t).isDirectory()?r:void 0}catch(r){return "ENOENT"===r.code?o(e,s(t),t):void 0}};e.exports={findMade:n,findMadeSync:o};},"./node_modules/mkdirp/lib/mkdirp-manual.js":(e,t,r)=>{const{dirname:s}=r("path"),n=(e,t,r)=>{t.recursive=!1;const o=s(e);return o===e?t.mkdirAsync(e,t).catch((e=>{if("EISDIR"!==e.code)throw e})):t.mkdirAsync(e,t).then((()=>r||e),(s=>{if("ENOENT"===s.code)return n(o,t).then((r=>n(e,t,r)));if("EEXIST"!==s.code&&"EROFS"!==s.code)throw s;return t.statAsync(e).then((e=>{if(e.isDirectory())return r;throw s}),(()=>{throw s}))}))},o=(e,t,r)=>{const n=s(e);if(t.recursive=!1,n===e)try{return t.mkdirSync(e,t)}catch(e){if("EISDIR"!==e.code)throw e;return}try{return t.mkdirSync(e,t),r||e}catch(s){if("ENOENT"===s.code)return o(e,t,o(n,t,r));if("EEXIST"!==s.code&&"EROFS"!==s.code)throw s;try{if(!t.statSync(e).isDirectory())throw s}catch(e){throw s}}};e.exports={mkdirpManual:n,mkdirpManualSync:o};},"./node_modules/mkdirp/lib/mkdirp-native.js":(e,t,r)=>{const{dirname:s}=r("path"),{findMade:n,findMadeSync:o}=r("./node_modules/mkdirp/lib/find-made.js"),{mkdirpManual:i,mkdirpManualSync:a}=r("./node_modules/mkdirp/lib/mkdirp-manual.js");e.exports={mkdirpNative:(e,t)=>(t.recursive=!0,s(e)===e?t.mkdirAsync(e,t):n(t,e).then((r=>t.mkdirAsync(e,t).then((()=>r)).catch((r=>{if("ENOENT"===r.code)return i(e,t);throw r}))))),mkdirpNativeSync:(e,t)=>{if(t.recursive=!0,s(e)===e)return t.mkdirSync(e,t);const r=o(t,e);try{return t.mkdirSync(e,t),r}catch(r){if("ENOENT"===r.code)return a(e,t);throw r}}};},"./node_modules/mkdirp/lib/opts-arg.js":(e,t,r)=>{const{promisify:s}=r("util"),n=r("fs");e.exports=e=>{if(e)if("object"==typeof e)e={mode:511,fs:n,...e};else if("number"==typeof e)e={mode:e,fs:n};else {if("string"!=typeof e)throw new TypeError("invalid options argument");e={mode:parseInt(e,8),fs:n};}else e={mode:511,fs:n};return e.mkdir=e.mkdir||e.fs.mkdir||n.mkdir,e.mkdirAsync=s(e.mkdir),e.stat=e.stat||e.fs.stat||n.stat,e.statAsync=s(e.stat),e.statSync=e.statSync||e.fs.statSync||n.statSync,e.mkdirSync=e.mkdirSync||e.fs.mkdirSync||n.mkdirSync,e};},"./node_modules/mkdirp/lib/path-arg.js":(e,t,r)=>{const s=process.env.__TESTING_MKDIRP_PLATFORM__||process.platform,{resolve:n,parse:o}=r("path");e.exports=e=>{if(/\0/.test(e))throw Object.assign(new TypeError("path must be a string without null bytes"),{path:e,code:"ERR_INVALID_ARG_VALUE"});if(e=n(e),"win32"===s){const t=/[*|"<>?:]/,{root:r}=o(e);if(t.test(e.substr(r.length)))throw Object.assign(new Error("Illegal characters in path."),{path:e,code:"EINVAL"})}return e};},"./node_modules/mkdirp/lib/use-native.js":(e,t,r)=>{const s=r("fs"),n=(process.env.__TESTING_MKDIRP_NODE_VERSION__||process.version).replace(/^v/,"").split("."),o=+n[0]>10||10==+n[0]&&+n[1]>=12,i=o?e=>e.mkdir===s.mkdir:()=>!1,a=o?e=>e.mkdirSync===s.mkdirSync:()=>!1;e.exports={useNative:i,useNativeSync:a};},"./node_modules/node-modules-regexp/index.js":e=>{e.exports=/^(?:.*[\\\/])?node_modules(?:[\\\/].*)?$/;},"./node_modules/object-hash/index.js":(e,t,r)=>{var s=r("crypto");function n(e,t){return function(e,t){var r;if(void 0===(r="passthrough"!==t.algorithm?s.createHash(t.algorithm):new c).write&&(r.write=r.update,r.end=r.update),u(t,r).dispatch(e),r.update||r.end(""),r.digest)return r.digest("buffer"===t.encoding?void 0:t.encoding);var n=r.read();return "buffer"===t.encoding?n:n.toString(t.encoding)}(e,t=a(e,t))}(t=e.exports=n).sha1=function(e){return n(e)},t.keys=function(e){return n(e,{excludeValues:!0,algorithm:"sha1",encoding:"hex"})},t.MD5=function(e){return n(e,{algorithm:"md5",encoding:"hex"})},t.keysMD5=function(e){return n(e,{algorithm:"md5",encoding:"hex",excludeValues:!0})};var o=s.getHashes?s.getHashes().slice():["sha1","md5"];o.push("passthrough");var i=["buffer","hex","binary","base64"];function a(e,t){t=t||{};var r={};if(r.algorithm=t.algorithm||"sha1",r.encoding=t.encoding||"hex",r.excludeValues=!!t.excludeValues,r.algorithm=r.algorithm.toLowerCase(),r.encoding=r.encoding.toLowerCase(),r.ignoreUnknown=!0===t.ignoreUnknown,r.respectType=!1!==t.respectType,r.respectFunctionNames=!1!==t.respectFunctionNames,r.respectFunctionProperties=!1!==t.respectFunctionProperties,r.unorderedArrays=!0===t.unorderedArrays,r.unorderedSets=!1!==t.unorderedSets,r.unorderedObjects=!1!==t.unorderedObjects,r.replacer=t.replacer||void 0,r.excludeKeys=t.excludeKeys||void 0,void 0===e)throw new Error("Object argument required.");for(var s=0;s<o.length;++s)o[s].toLowerCase()===r.algorithm.toLowerCase()&&(r.algorithm=o[s]);if(-1===o.indexOf(r.algorithm))throw new Error('Algorithm "'+r.algorithm+'"  not supported. supported values: '+o.join(", "));if(-1===i.indexOf(r.encoding)&&"passthrough"!==r.algorithm)throw new Error('Encoding "'+r.encoding+'"  not supported. supported values: '+i.join(", "));return r}function l(e){return "function"==typeof e&&null!=/^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e))}function u(e,t,r){r=r||[];var s=function(e){return t.update?t.update(e,"utf8"):t.write(e,"utf8")};return {dispatch:function(t){e.replacer&&(t=e.replacer(t));var r=typeof t;return null===t&&(r="null"),this["_"+r](t)},_object:function(t){var n,o=Object.prototype.toString.call(t),i=/\[object (.*)\]/i.exec(o);if(i=(i=i?i[1]:"unknown:["+o+"]").toLowerCase(),(n=r.indexOf(t))>=0)return this.dispatch("[CIRCULAR:"+n+"]");if(r.push(t),"undefined"!=typeof Buffer&&Buffer.isBuffer&&Buffer.isBuffer(t))return s("buffer:"),s(t);if("object"===i||"function"===i||"asyncfunction"===i){var a=Object.keys(t);e.unorderedObjects&&(a=a.sort()),!1===e.respectType||l(t)||a.splice(0,0,"prototype","__proto__","constructor"),e.excludeKeys&&(a=a.filter((function(t){return !e.excludeKeys(t)}))),s("object:"+a.length+":");var u=this;return a.forEach((function(r){u.dispatch(r),s(":"),e.excludeValues||u.dispatch(t[r]),s(",");}))}if(!this["_"+i]){if(e.ignoreUnknown)return s("["+i+"]");throw new Error('Unknown object type "'+i+'"')}this["_"+i](t);},_array:function(t,n){n=void 0!==n?n:!1!==e.unorderedArrays;var o=this;if(s("array:"+t.length+":"),!n||t.length<=1)return t.forEach((function(e){return o.dispatch(e)}));var i=[],a=t.map((function(t){var s=new c,n=r.slice();return u(e,s,n).dispatch(t),i=i.concat(n.slice(r.length)),s.read().toString()}));return r=r.concat(i),a.sort(),this._array(a,!1)},_date:function(e){return s("date:"+e.toJSON())},_symbol:function(e){return s("symbol:"+e.toString())},_error:function(e){return s("error:"+e.toString())},_boolean:function(e){return s("bool:"+e.toString())},_string:function(e){s("string:"+e.length+":"),s(e.toString());},_function:function(t){s("fn:"),l(t)?this.dispatch("[native]"):this.dispatch(t.toString()),!1!==e.respectFunctionNames&&this.dispatch("function-name:"+String(t.name)),e.respectFunctionProperties&&this._object(t);},_number:function(e){return s("number:"+e.toString())},_xml:function(e){return s("xml:"+e.toString())},_null:function(){return s("Null")},_undefined:function(){return s("Undefined")},_regexp:function(e){return s("regex:"+e.toString())},_uint8array:function(e){return s("uint8array:"),this.dispatch(Array.prototype.slice.call(e))},_uint8clampedarray:function(e){return s("uint8clampedarray:"),this.dispatch(Array.prototype.slice.call(e))},_int8array:function(e){return s("uint8array:"),this.dispatch(Array.prototype.slice.call(e))},_uint16array:function(e){return s("uint16array:"),this.dispatch(Array.prototype.slice.call(e))},_int16array:function(e){return s("uint16array:"),this.dispatch(Array.prototype.slice.call(e))},_uint32array:function(e){return s("uint32array:"),this.dispatch(Array.prototype.slice.call(e))},_int32array:function(e){return s("uint32array:"),this.dispatch(Array.prototype.slice.call(e))},_float32array:function(e){return s("float32array:"),this.dispatch(Array.prototype.slice.call(e))},_float64array:function(e){return s("float64array:"),this.dispatch(Array.prototype.slice.call(e))},_arraybuffer:function(e){return s("arraybuffer:"),this.dispatch(new Uint8Array(e))},_url:function(e){return s("url:"+e.toString())},_map:function(t){s("map:");var r=Array.from(t);return this._array(r,!1!==e.unorderedSets)},_set:function(t){s("set:");var r=Array.from(t);return this._array(r,!1!==e.unorderedSets)},_file:function(e){return s("file:"),this.dispatch([e.name,e.size,e.type,e.lastModfied])},_blob:function(){if(e.ignoreUnknown)return s("[blob]");throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n')},_domwindow:function(){return s("domwindow")},_bigint:function(e){return s("bigint:"+e.toString())},_process:function(){return s("process")},_timer:function(){return s("timer")},_pipe:function(){return s("pipe")},_tcp:function(){return s("tcp")},_udp:function(){return s("udp")},_tty:function(){return s("tty")},_statwatcher:function(){return s("statwatcher")},_securecontext:function(){return s("securecontext")},_connection:function(){return s("connection")},_zlib:function(){return s("zlib")},_context:function(){return s("context")},_nodescript:function(){return s("nodescript")},_httpparser:function(){return s("httpparser")},_dataview:function(){return s("dataview")},_signal:function(){return s("signal")},_fsevent:function(){return s("fsevent")},_tlswrap:function(){return s("tlswrap")}}}function c(){return {buf:"",write:function(e){this.buf+=e;},end:function(e){this.buf+=e;},read:function(){return this.buf}}}t.writeToStream=function(e,t,r){return void 0===r&&(r=t,t={}),u(t=a(e,t),r).dispatch(e)};},"./node_modules/pirates/lib/index.js":(e,t,r)=>{e=r.nmd(e),Object.defineProperty(t,"__esModule",{value:!0}),t.addHook=function(e,t={}){let r=!1;const s=[],i=[];let l;const u=a._extensions[".js"],c=t.matcher||null,d=!1!==t.ignoreNodeModules;return l=t.extensions||t.exts||t.extension||t.ext||[".js"],Array.isArray(l)||(l=[l]),l.forEach((t=>{if("string"!=typeof t)throw new TypeError(`Invalid Extension: ${t}`);const h=a._extensions[t]||u;i[t]=h,s[t]=a._extensions[t]=function(t,s){let i;r||function(e,t,r,s){if("string"!=typeof e)return !1;if(-1===t.indexOf(n.default.extname(e)))return !1;const i=n.default.resolve(e);return (!s||!o.default.test(i))&&(!r||"function"!=typeof r||!!r(i))}(s,l,c,d)&&(i=t._compile,t._compile=function(r){t._compile=i;const n=e(r,s);if("string"!=typeof n)throw new Error("[Pirates] A hook returned a non-string, or nothing at all! This is a violation of intergalactic law!\n--------------------\nIf you have no idea what this means or what Pirates is, let me explain: Pirates is a module that makes is easy to implement require hooks. One of the require hooks you're using uses it. One of these require hooks didn't return anything from it's handler, so we don't know what to do. You might want to debug this.");return t._compile(n,s)}),h(t,s);};})),function(){r||(r=!0,l.forEach((e=>{a._extensions[e]===s[e]&&(a._extensions[e]=i[e]);})));}};var s=i(r("module")),n=i(r("path")),o=i(r("./node_modules/node-modules-regexp/index.js"));function i(e){return e&&e.__esModule?e:{default:e}}const a=e.constructor.length>1?e.constructor:s.default;},"./node_modules/semver/classes/comparator.js":(e,t,r)=>{const s=Symbol("SemVer ANY");class n{static get ANY(){return s}constructor(e,t){if(t=o(t),e instanceof n){if(e.loose===!!t.loose)return e;e=e.value;}u("comparator",e,t),this.options=t,this.loose=!!t.loose,this.parse(e),this.semver===s?this.value="":this.value=this.operator+this.semver.version,u("comp",this);}parse(e){const t=this.options.loose?i[a.COMPARATORLOOSE]:i[a.COMPARATOR],r=e.match(t);if(!r)throw new TypeError(`Invalid comparator: ${e}`);this.operator=void 0!==r[1]?r[1]:"","="===this.operator&&(this.operator=""),r[2]?this.semver=new c(r[2],this.options.loose):this.semver=s;}toString(){return this.value}test(e){if(u("Comparator.test",e,this.options.loose),this.semver===s||e===s)return !0;if("string"==typeof e)try{e=new c(e,this.options);}catch(e){return !1}return l(e,this.operator,this.semver,this.options)}intersects(e,t){if(!(e instanceof n))throw new TypeError("a Comparator is required");if(t&&"object"==typeof t||(t={loose:!!t,includePrerelease:!1}),""===this.operator)return ""===this.value||new d(e.value,t).test(this.value);if(""===e.operator)return ""===e.value||new d(this.value,t).test(e.semver);const r=!(">="!==this.operator&&">"!==this.operator||">="!==e.operator&&">"!==e.operator),s=!("<="!==this.operator&&"<"!==this.operator||"<="!==e.operator&&"<"!==e.operator),o=this.semver.version===e.semver.version,i=!(">="!==this.operator&&"<="!==this.operator||">="!==e.operator&&"<="!==e.operator),a=l(this.semver,"<",e.semver,t)&&(">="===this.operator||">"===this.operator)&&("<="===e.operator||"<"===e.operator),u=l(this.semver,">",e.semver,t)&&("<="===this.operator||"<"===this.operator)&&(">="===e.operator||">"===e.operator);return r||s||o&&i||a||u}}e.exports=n;const o=r("./node_modules/semver/internal/parse-options.js"),{re:i,t:a}=r("./node_modules/semver/internal/re.js"),l=r("./node_modules/semver/functions/cmp.js"),u=r("./node_modules/semver/internal/debug.js"),c=r("./node_modules/semver/classes/semver.js"),d=r("./node_modules/semver/classes/range.js");},"./node_modules/semver/classes/range.js":(e,t,r)=>{class s{constructor(e,t){if(t=o(t),e instanceof s)return e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease?e:new s(e.raw,t);if(e instanceof i)return this.raw=e.value,this.set=[[e]],this.format(),this;if(this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease,this.raw=e,this.set=e.split(/\s*\|\|\s*/).map((e=>this.parseRange(e.trim()))).filter((e=>e.length)),!this.set.length)throw new TypeError(`Invalid SemVer Range: ${e}`);if(this.set.length>1){const e=this.set[0];if(this.set=this.set.filter((e=>!p(e[0]))),0===this.set.length)this.set=[e];else if(this.set.length>1)for(const e of this.set)if(1===e.length&&f(e[0])){this.set=[e];break}}this.format();}format(){return this.range=this.set.map((e=>e.join(" ").trim())).join("||").trim(),this.range}toString(){return this.range}parseRange(e){e=e.trim();const t=`parseRange:${Object.keys(this.options).join(",")}:${e}`,r=n.get(t);if(r)return r;const s=this.options.loose,o=s?u[c.HYPHENRANGELOOSE]:u[c.HYPHENRANGE];e=e.replace(o,N(this.options.includePrerelease)),a("hyphen replace",e),e=e.replace(u[c.COMPARATORTRIM],d),a("comparator trim",e,u[c.COMPARATORTRIM]),e=(e=(e=e.replace(u[c.TILDETRIM],h)).replace(u[c.CARETTRIM],m)).split(/\s+/).join(" ");const l=s?u[c.COMPARATORLOOSE]:u[c.COMPARATOR],f=e.split(" ").map((e=>E(e,this.options))).join(" ").split(/\s+/).map((e=>x(e,this.options))).filter(this.options.loose?e=>!!e.match(l):()=>!0).map((e=>new i(e,this.options))),v=(f.length,new Map);for(const e of f){if(p(e))return [e];v.set(e.value,e);}v.size>1&&v.has("")&&v.delete("");const g=[...v.values()];return n.set(t,g),g}intersects(e,t){if(!(e instanceof s))throw new TypeError("a Range is required");return this.set.some((r=>v(r,t)&&e.set.some((e=>v(e,t)&&r.every((r=>e.every((e=>r.intersects(e,t)))))))))}test(e){if(!e)return !1;if("string"==typeof e)try{e=new l(e,this.options);}catch(e){return !1}for(let t=0;t<this.set.length;t++)if(O(this.set[t],e,this.options))return !0;return !1}}e.exports=s;const n=new(r("./node_modules/lru-cache/index.js"))({max:1e3}),o=r("./node_modules/semver/internal/parse-options.js"),i=r("./node_modules/semver/classes/comparator.js"),a=r("./node_modules/semver/internal/debug.js"),l=r("./node_modules/semver/classes/semver.js"),{re:u,t:c,comparatorTrimReplace:d,tildeTrimReplace:h,caretTrimReplace:m}=r("./node_modules/semver/internal/re.js"),p=e=>"<0.0.0-0"===e.value,f=e=>""===e.value,v=(e,t)=>{let r=!0;const s=e.slice();let n=s.pop();for(;r&&s.length;)r=s.every((e=>n.intersects(e,t))),n=s.pop();return r},E=(e,t)=>(a("comp",e,t),e=j(e,t),a("caret",e),e=_(e,t),a("tildes",e),e=R(e,t),a("xrange",e),e=w(e,t),a("stars",e),e),g=e=>!e||"x"===e.toLowerCase()||"*"===e,_=(e,t)=>e.trim().split(/\s+/).map((e=>y(e,t))).join(" "),y=(e,t)=>{const r=t.loose?u[c.TILDELOOSE]:u[c.TILDE];return e.replace(r,((t,r,s,n,o)=>{let i;return a("tilde",e,t,r,s,n,o),g(r)?i="":g(s)?i=`>=${r}.0.0 <${+r+1}.0.0-0`:g(n)?i=`>=${r}.${s}.0 <${r}.${+s+1}.0-0`:o?(a("replaceTilde pr",o),i=`>=${r}.${s}.${n}-${o} <${r}.${+s+1}.0-0`):i=`>=${r}.${s}.${n} <${r}.${+s+1}.0-0`,a("tilde return",i),i}))},j=(e,t)=>e.trim().split(/\s+/).map((e=>I(e,t))).join(" "),I=(e,t)=>{a("caret",e,t);const r=t.loose?u[c.CARETLOOSE]:u[c.CARET],s=t.includePrerelease?"-0":"";return e.replace(r,((t,r,n,o,i)=>{let l;return a("caret",e,t,r,n,o,i),g(r)?l="":g(n)?l=`>=${r}.0.0${s} <${+r+1}.0.0-0`:g(o)?l="0"===r?`>=${r}.${n}.0${s} <${r}.${+n+1}.0-0`:`>=${r}.${n}.0${s} <${+r+1}.0.0-0`:i?(a("replaceCaret pr",i),l="0"===r?"0"===n?`>=${r}.${n}.${o}-${i} <${r}.${n}.${+o+1}-0`:`>=${r}.${n}.${o}-${i} <${r}.${+n+1}.0-0`:`>=${r}.${n}.${o}-${i} <${+r+1}.0.0-0`):(a("no pr"),l="0"===r?"0"===n?`>=${r}.${n}.${o}${s} <${r}.${n}.${+o+1}-0`:`>=${r}.${n}.${o}${s} <${r}.${+n+1}.0-0`:`>=${r}.${n}.${o} <${+r+1}.0.0-0`),a("caret return",l),l}))},R=(e,t)=>(a("replaceXRanges",e,t),e.split(/\s+/).map((e=>$(e,t))).join(" ")),$=(e,t)=>{e=e.trim();const r=t.loose?u[c.XRANGELOOSE]:u[c.XRANGE];return e.replace(r,((r,s,n,o,i,l)=>{a("xRange",e,r,s,n,o,i,l);const u=g(n),c=u||g(o),d=c||g(i),h=d;return "="===s&&h&&(s=""),l=t.includePrerelease?"-0":"",u?r=">"===s||"<"===s?"<0.0.0-0":"*":s&&h?(c&&(o=0),i=0,">"===s?(s=">=",c?(n=+n+1,o=0,i=0):(o=+o+1,i=0)):"<="===s&&(s="<",c?n=+n+1:o=+o+1),"<"===s&&(l="-0"),r=`${s+n}.${o}.${i}${l}`):c?r=`>=${n}.0.0${l} <${+n+1}.0.0-0`:d&&(r=`>=${n}.${o}.0${l} <${n}.${+o+1}.0-0`),a("xRange return",r),r}))},w=(e,t)=>(a("replaceStars",e,t),e.trim().replace(u[c.STAR],"")),x=(e,t)=>(a("replaceGTE0",e,t),e.trim().replace(u[t.includePrerelease?c.GTE0PRE:c.GTE0],"")),N=e=>(t,r,s,n,o,i,a,l,u,c,d,h,m)=>`${r=g(s)?"":g(n)?`>=${s}.0.0${e?"-0":""}`:g(o)?`>=${s}.${n}.0${e?"-0":""}`:i?`>=${r}`:`>=${r}${e?"-0":""}`} ${l=g(u)?"":g(c)?`<${+u+1}.0.0-0`:g(d)?`<${u}.${+c+1}.0-0`:h?`<=${u}.${c}.${d}-${h}`:e?`<${u}.${c}.${+d+1}-0`:`<=${l}`}`.trim(),O=(e,t,r)=>{for(let r=0;r<e.length;r++)if(!e[r].test(t))return !1;if(t.prerelease.length&&!r.includePrerelease){for(let r=0;r<e.length;r++)if(a(e[r].semver),e[r].semver!==i.ANY&&e[r].semver.prerelease.length>0){const s=e[r].semver;if(s.major===t.major&&s.minor===t.minor&&s.patch===t.patch)return !0}return !1}return !0};},"./node_modules/semver/classes/semver.js":(e,t,r)=>{const s=r("./node_modules/semver/internal/debug.js"),{MAX_LENGTH:n,MAX_SAFE_INTEGER:o}=r("./node_modules/semver/internal/constants.js"),{re:i,t:a}=r("./node_modules/semver/internal/re.js"),l=r("./node_modules/semver/internal/parse-options.js"),{compareIdentifiers:u}=r("./node_modules/semver/internal/identifiers.js");class c{constructor(e,t){if(t=l(t),e instanceof c){if(e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease)return e;e=e.version;}else if("string"!=typeof e)throw new TypeError(`Invalid Version: ${e}`);if(e.length>n)throw new TypeError(`version is longer than ${n} characters`);s("SemVer",e,t),this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease;const r=e.trim().match(t.loose?i[a.LOOSE]:i[a.FULL]);if(!r)throw new TypeError(`Invalid Version: ${e}`);if(this.raw=e,this.major=+r[1],this.minor=+r[2],this.patch=+r[3],this.major>o||this.major<0)throw new TypeError("Invalid major version");if(this.minor>o||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>o||this.patch<0)throw new TypeError("Invalid patch version");r[4]?this.prerelease=r[4].split(".").map((e=>{if(/^[0-9]+$/.test(e)){const t=+e;if(t>=0&&t<o)return t}return e})):this.prerelease=[],this.build=r[5]?r[5].split("."):[],this.format();}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(".")}`),this.version}toString(){return this.version}compare(e){if(s("SemVer.compare",this.version,this.options,e),!(e instanceof c)){if("string"==typeof e&&e===this.version)return 0;e=new c(e,this.options);}return e.version===this.version?0:this.compareMain(e)||this.comparePre(e)}compareMain(e){return e instanceof c||(e=new c(e,this.options)),u(this.major,e.major)||u(this.minor,e.minor)||u(this.patch,e.patch)}comparePre(e){if(e instanceof c||(e=new c(e,this.options)),this.prerelease.length&&!e.prerelease.length)return -1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;let t=0;do{const r=this.prerelease[t],n=e.prerelease[t];if(s("prerelease compare",t,r,n),void 0===r&&void 0===n)return 0;if(void 0===n)return 1;if(void 0===r)return -1;if(r!==n)return u(r,n)}while(++t)}compareBuild(e){e instanceof c||(e=new c(e,this.options));let t=0;do{const r=this.build[t],n=e.build[t];if(s("prerelease compare",t,r,n),void 0===r&&void 0===n)return 0;if(void 0===n)return 1;if(void 0===r)return -1;if(r!==n)return u(r,n)}while(++t)}inc(e,t){switch(e){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",t);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",t);break;case"prepatch":this.prerelease.length=0,this.inc("patch",t),this.inc("pre",t);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",t),this.inc("pre",t);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else {let e=this.prerelease.length;for(;--e>=0;)"number"==typeof this.prerelease[e]&&(this.prerelease[e]++,e=-2);-1===e&&this.prerelease.push(0);}t&&(this.prerelease[0]===t?isNaN(this.prerelease[1])&&(this.prerelease=[t,0]):this.prerelease=[t,0]);break;default:throw new Error(`invalid increment argument: ${e}`)}return this.format(),this.raw=this.version,this}}e.exports=c;},"./node_modules/semver/functions/clean.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/parse.js");e.exports=(e,t)=>{const r=s(e.trim().replace(/^[=v]+/,""),t);return r?r.version:null};},"./node_modules/semver/functions/cmp.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/eq.js"),n=r("./node_modules/semver/functions/neq.js"),o=r("./node_modules/semver/functions/gt.js"),i=r("./node_modules/semver/functions/gte.js"),a=r("./node_modules/semver/functions/lt.js"),l=r("./node_modules/semver/functions/lte.js");e.exports=(e,t,r,u)=>{switch(t){case"===":return "object"==typeof e&&(e=e.version),"object"==typeof r&&(r=r.version),e===r;case"!==":return "object"==typeof e&&(e=e.version),"object"==typeof r&&(r=r.version),e!==r;case"":case"=":case"==":return s(e,r,u);case"!=":return n(e,r,u);case">":return o(e,r,u);case">=":return i(e,r,u);case"<":return a(e,r,u);case"<=":return l(e,r,u);default:throw new TypeError(`Invalid operator: ${t}`)}};},"./node_modules/semver/functions/coerce.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js"),n=r("./node_modules/semver/functions/parse.js"),{re:o,t:i}=r("./node_modules/semver/internal/re.js");e.exports=(e,t)=>{if(e instanceof s)return e;if("number"==typeof e&&(e=String(e)),"string"!=typeof e)return null;let r=null;if((t=t||{}).rtl){let t;for(;(t=o[i.COERCERTL].exec(e))&&(!r||r.index+r[0].length!==e.length);)r&&t.index+t[0].length===r.index+r[0].length||(r=t),o[i.COERCERTL].lastIndex=t.index+t[1].length+t[2].length;o[i.COERCERTL].lastIndex=-1;}else r=e.match(o[i.COERCE]);return null===r?null:n(`${r[2]}.${r[3]||"0"}.${r[4]||"0"}`,t)};},"./node_modules/semver/functions/compare-build.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js");e.exports=(e,t,r)=>{const n=new s(e,r),o=new s(t,r);return n.compare(o)||n.compareBuild(o)};},"./node_modules/semver/functions/compare-loose.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/compare.js");e.exports=(e,t)=>s(e,t,!0);},"./node_modules/semver/functions/compare.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js");e.exports=(e,t,r)=>new s(e,r).compare(new s(t,r));},"./node_modules/semver/functions/diff.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/parse.js"),n=r("./node_modules/semver/functions/eq.js");e.exports=(e,t)=>{if(n(e,t))return null;{const r=s(e),n=s(t),o=r.prerelease.length||n.prerelease.length,i=o?"pre":"",a=o?"prerelease":"";for(const e in r)if(("major"===e||"minor"===e||"patch"===e)&&r[e]!==n[e])return i+e;return a}};},"./node_modules/semver/functions/eq.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/compare.js");e.exports=(e,t,r)=>0===s(e,t,r);},"./node_modules/semver/functions/gt.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/compare.js");e.exports=(e,t,r)=>s(e,t,r)>0;},"./node_modules/semver/functions/gte.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/compare.js");e.exports=(e,t,r)=>s(e,t,r)>=0;},"./node_modules/semver/functions/inc.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js");e.exports=(e,t,r,n)=>{"string"==typeof r&&(n=r,r=void 0);try{return new s(e,r).inc(t,n).version}catch(e){return null}};},"./node_modules/semver/functions/lt.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/compare.js");e.exports=(e,t,r)=>s(e,t,r)<0;},"./node_modules/semver/functions/lte.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/compare.js");e.exports=(e,t,r)=>s(e,t,r)<=0;},"./node_modules/semver/functions/major.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js");e.exports=(e,t)=>new s(e,t).major;},"./node_modules/semver/functions/minor.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js");e.exports=(e,t)=>new s(e,t).minor;},"./node_modules/semver/functions/neq.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/compare.js");e.exports=(e,t,r)=>0!==s(e,t,r);},"./node_modules/semver/functions/parse.js":(e,t,r)=>{const{MAX_LENGTH:s}=r("./node_modules/semver/internal/constants.js"),{re:n,t:o}=r("./node_modules/semver/internal/re.js"),i=r("./node_modules/semver/classes/semver.js"),a=r("./node_modules/semver/internal/parse-options.js");e.exports=(e,t)=>{if(t=a(t),e instanceof i)return e;if("string"!=typeof e)return null;if(e.length>s)return null;if(!(t.loose?n[o.LOOSE]:n[o.FULL]).test(e))return null;try{return new i(e,t)}catch(e){return null}};},"./node_modules/semver/functions/patch.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js");e.exports=(e,t)=>new s(e,t).patch;},"./node_modules/semver/functions/prerelease.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/parse.js");e.exports=(e,t)=>{const r=s(e,t);return r&&r.prerelease.length?r.prerelease:null};},"./node_modules/semver/functions/rcompare.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/compare.js");e.exports=(e,t,r)=>s(t,e,r);},"./node_modules/semver/functions/rsort.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/compare-build.js");e.exports=(e,t)=>e.sort(((e,r)=>s(r,e,t)));},"./node_modules/semver/functions/satisfies.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/range.js");e.exports=(e,t,r)=>{try{t=new s(t,r);}catch(e){return !1}return t.test(e)};},"./node_modules/semver/functions/sort.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/compare-build.js");e.exports=(e,t)=>e.sort(((e,r)=>s(e,r,t)));},"./node_modules/semver/functions/valid.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/parse.js");e.exports=(e,t)=>{const r=s(e,t);return r?r.version:null};},"./node_modules/semver/index.js":(e,t,r)=>{const s=r("./node_modules/semver/internal/re.js");e.exports={re:s.re,src:s.src,tokens:s.t,SEMVER_SPEC_VERSION:r("./node_modules/semver/internal/constants.js").SEMVER_SPEC_VERSION,SemVer:r("./node_modules/semver/classes/semver.js"),compareIdentifiers:r("./node_modules/semver/internal/identifiers.js").compareIdentifiers,rcompareIdentifiers:r("./node_modules/semver/internal/identifiers.js").rcompareIdentifiers,parse:r("./node_modules/semver/functions/parse.js"),valid:r("./node_modules/semver/functions/valid.js"),clean:r("./node_modules/semver/functions/clean.js"),inc:r("./node_modules/semver/functions/inc.js"),diff:r("./node_modules/semver/functions/diff.js"),major:r("./node_modules/semver/functions/major.js"),minor:r("./node_modules/semver/functions/minor.js"),patch:r("./node_modules/semver/functions/patch.js"),prerelease:r("./node_modules/semver/functions/prerelease.js"),compare:r("./node_modules/semver/functions/compare.js"),rcompare:r("./node_modules/semver/functions/rcompare.js"),compareLoose:r("./node_modules/semver/functions/compare-loose.js"),compareBuild:r("./node_modules/semver/functions/compare-build.js"),sort:r("./node_modules/semver/functions/sort.js"),rsort:r("./node_modules/semver/functions/rsort.js"),gt:r("./node_modules/semver/functions/gt.js"),lt:r("./node_modules/semver/functions/lt.js"),eq:r("./node_modules/semver/functions/eq.js"),neq:r("./node_modules/semver/functions/neq.js"),gte:r("./node_modules/semver/functions/gte.js"),lte:r("./node_modules/semver/functions/lte.js"),cmp:r("./node_modules/semver/functions/cmp.js"),coerce:r("./node_modules/semver/functions/coerce.js"),Comparator:r("./node_modules/semver/classes/comparator.js"),Range:r("./node_modules/semver/classes/range.js"),satisfies:r("./node_modules/semver/functions/satisfies.js"),toComparators:r("./node_modules/semver/ranges/to-comparators.js"),maxSatisfying:r("./node_modules/semver/ranges/max-satisfying.js"),minSatisfying:r("./node_modules/semver/ranges/min-satisfying.js"),minVersion:r("./node_modules/semver/ranges/min-version.js"),validRange:r("./node_modules/semver/ranges/valid.js"),outside:r("./node_modules/semver/ranges/outside.js"),gtr:r("./node_modules/semver/ranges/gtr.js"),ltr:r("./node_modules/semver/ranges/ltr.js"),intersects:r("./node_modules/semver/ranges/intersects.js"),simplifyRange:r("./node_modules/semver/ranges/simplify.js"),subset:r("./node_modules/semver/ranges/subset.js")};},"./node_modules/semver/internal/constants.js":e=>{const t=Number.MAX_SAFE_INTEGER||9007199254740991;e.exports={SEMVER_SPEC_VERSION:"2.0.0",MAX_LENGTH:256,MAX_SAFE_INTEGER:t,MAX_SAFE_COMPONENT_LENGTH:16};},"./node_modules/semver/internal/debug.js":e=>{const t="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?(...e)=>console.error("SEMVER",...e):()=>{};e.exports=t;},"./node_modules/semver/internal/identifiers.js":e=>{const t=/^[0-9]+$/,r=(e,r)=>{const s=t.test(e),n=t.test(r);return s&&n&&(e=+e,r=+r),e===r?0:s&&!n?-1:n&&!s?1:e<r?-1:1};e.exports={compareIdentifiers:r,rcompareIdentifiers:(e,t)=>r(t,e)};},"./node_modules/semver/internal/parse-options.js":e=>{const t=["includePrerelease","loose","rtl"];e.exports=e=>e?"object"!=typeof e?{loose:!0}:t.filter((t=>e[t])).reduce(((e,t)=>(e[t]=!0,e)),{}):{};},"./node_modules/semver/internal/re.js":(e,t,r)=>{const{MAX_SAFE_COMPONENT_LENGTH:s}=r("./node_modules/semver/internal/constants.js"),n=r("./node_modules/semver/internal/debug.js"),o=(t=e.exports={}).re=[],i=t.src=[],a=t.t={};let l=0;const u=(e,t,r)=>{const s=l++;n(s,t),a[e]=s,i[s]=t,o[s]=new RegExp(t,r?"g":void 0);};u("NUMERICIDENTIFIER","0|[1-9]\\d*"),u("NUMERICIDENTIFIERLOOSE","[0-9]+"),u("NONNUMERICIDENTIFIER","\\d*[a-zA-Z-][a-zA-Z0-9-]*"),u("MAINVERSION",`(${i[a.NUMERICIDENTIFIER]})\\.(${i[a.NUMERICIDENTIFIER]})\\.(${i[a.NUMERICIDENTIFIER]})`),u("MAINVERSIONLOOSE",`(${i[a.NUMERICIDENTIFIERLOOSE]})\\.(${i[a.NUMERICIDENTIFIERLOOSE]})\\.(${i[a.NUMERICIDENTIFIERLOOSE]})`),u("PRERELEASEIDENTIFIER",`(?:${i[a.NUMERICIDENTIFIER]}|${i[a.NONNUMERICIDENTIFIER]})`),u("PRERELEASEIDENTIFIERLOOSE",`(?:${i[a.NUMERICIDENTIFIERLOOSE]}|${i[a.NONNUMERICIDENTIFIER]})`),u("PRERELEASE",`(?:-(${i[a.PRERELEASEIDENTIFIER]}(?:\\.${i[a.PRERELEASEIDENTIFIER]})*))`),u("PRERELEASELOOSE",`(?:-?(${i[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i[a.PRERELEASEIDENTIFIERLOOSE]})*))`),u("BUILDIDENTIFIER","[0-9A-Za-z-]+"),u("BUILD",`(?:\\+(${i[a.BUILDIDENTIFIER]}(?:\\.${i[a.BUILDIDENTIFIER]})*))`),u("FULLPLAIN",`v?${i[a.MAINVERSION]}${i[a.PRERELEASE]}?${i[a.BUILD]}?`),u("FULL",`^${i[a.FULLPLAIN]}$`),u("LOOSEPLAIN",`[v=\\s]*${i[a.MAINVERSIONLOOSE]}${i[a.PRERELEASELOOSE]}?${i[a.BUILD]}?`),u("LOOSE",`^${i[a.LOOSEPLAIN]}$`),u("GTLT","((?:<|>)?=?)"),u("XRANGEIDENTIFIERLOOSE",`${i[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),u("XRANGEIDENTIFIER",`${i[a.NUMERICIDENTIFIER]}|x|X|\\*`),u("XRANGEPLAIN",`[v=\\s]*(${i[a.XRANGEIDENTIFIER]})(?:\\.(${i[a.XRANGEIDENTIFIER]})(?:\\.(${i[a.XRANGEIDENTIFIER]})(?:${i[a.PRERELEASE]})?${i[a.BUILD]}?)?)?`),u("XRANGEPLAINLOOSE",`[v=\\s]*(${i[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i[a.XRANGEIDENTIFIERLOOSE]})(?:${i[a.PRERELEASELOOSE]})?${i[a.BUILD]}?)?)?`),u("XRANGE",`^${i[a.GTLT]}\\s*${i[a.XRANGEPLAIN]}$`),u("XRANGELOOSE",`^${i[a.GTLT]}\\s*${i[a.XRANGEPLAINLOOSE]}$`),u("COERCE",`(^|[^\\d])(\\d{1,${s}})(?:\\.(\\d{1,${s}}))?(?:\\.(\\d{1,${s}}))?(?:$|[^\\d])`),u("COERCERTL",i[a.COERCE],!0),u("LONETILDE","(?:~>?)"),u("TILDETRIM",`(\\s*)${i[a.LONETILDE]}\\s+`,!0),t.tildeTrimReplace="$1~",u("TILDE",`^${i[a.LONETILDE]}${i[a.XRANGEPLAIN]}$`),u("TILDELOOSE",`^${i[a.LONETILDE]}${i[a.XRANGEPLAINLOOSE]}$`),u("LONECARET","(?:\\^)"),u("CARETTRIM",`(\\s*)${i[a.LONECARET]}\\s+`,!0),t.caretTrimReplace="$1^",u("CARET",`^${i[a.LONECARET]}${i[a.XRANGEPLAIN]}$`),u("CARETLOOSE",`^${i[a.LONECARET]}${i[a.XRANGEPLAINLOOSE]}$`),u("COMPARATORLOOSE",`^${i[a.GTLT]}\\s*(${i[a.LOOSEPLAIN]})$|^$`),u("COMPARATOR",`^${i[a.GTLT]}\\s*(${i[a.FULLPLAIN]})$|^$`),u("COMPARATORTRIM",`(\\s*)${i[a.GTLT]}\\s*(${i[a.LOOSEPLAIN]}|${i[a.XRANGEPLAIN]})`,!0),t.comparatorTrimReplace="$1$2$3",u("HYPHENRANGE",`^\\s*(${i[a.XRANGEPLAIN]})\\s+-\\s+(${i[a.XRANGEPLAIN]})\\s*$`),u("HYPHENRANGELOOSE",`^\\s*(${i[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${i[a.XRANGEPLAINLOOSE]})\\s*$`),u("STAR","(<|>)?=?\\s*\\*"),u("GTE0","^\\s*>=\\s*0.0.0\\s*$"),u("GTE0PRE","^\\s*>=\\s*0.0.0-0\\s*$");},"./node_modules/semver/ranges/gtr.js":(e,t,r)=>{const s=r("./node_modules/semver/ranges/outside.js");e.exports=(e,t,r)=>s(e,t,">",r);},"./node_modules/semver/ranges/intersects.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/range.js");e.exports=(e,t,r)=>(e=new s(e,r),t=new s(t,r),e.intersects(t));},"./node_modules/semver/ranges/ltr.js":(e,t,r)=>{const s=r("./node_modules/semver/ranges/outside.js");e.exports=(e,t,r)=>s(e,t,"<",r);},"./node_modules/semver/ranges/max-satisfying.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js"),n=r("./node_modules/semver/classes/range.js");e.exports=(e,t,r)=>{let o=null,i=null,a=null;try{a=new n(t,r);}catch(e){return null}return e.forEach((e=>{a.test(e)&&(o&&-1!==i.compare(e)||(o=e,i=new s(o,r)));})),o};},"./node_modules/semver/ranges/min-satisfying.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js"),n=r("./node_modules/semver/classes/range.js");e.exports=(e,t,r)=>{let o=null,i=null,a=null;try{a=new n(t,r);}catch(e){return null}return e.forEach((e=>{a.test(e)&&(o&&1!==i.compare(e)||(o=e,i=new s(o,r)));})),o};},"./node_modules/semver/ranges/min-version.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js"),n=r("./node_modules/semver/classes/range.js"),o=r("./node_modules/semver/functions/gt.js");e.exports=(e,t)=>{e=new n(e,t);let r=new s("0.0.0");if(e.test(r))return r;if(r=new s("0.0.0-0"),e.test(r))return r;r=null;for(let t=0;t<e.set.length;++t){const n=e.set[t];let i=null;n.forEach((e=>{const t=new s(e.semver.version);switch(e.operator){case">":0===t.prerelease.length?t.patch++:t.prerelease.push(0),t.raw=t.format();case"":case">=":i&&!o(t,i)||(i=t);break;case"<":case"<=":break;default:throw new Error(`Unexpected operation: ${e.operator}`)}})),!i||r&&!o(r,i)||(r=i);}return r&&e.test(r)?r:null};},"./node_modules/semver/ranges/outside.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/semver.js"),n=r("./node_modules/semver/classes/comparator.js"),{ANY:o}=n,i=r("./node_modules/semver/classes/range.js"),a=r("./node_modules/semver/functions/satisfies.js"),l=r("./node_modules/semver/functions/gt.js"),u=r("./node_modules/semver/functions/lt.js"),c=r("./node_modules/semver/functions/lte.js"),d=r("./node_modules/semver/functions/gte.js");e.exports=(e,t,r,h)=>{let m,p,f,v,E;switch(e=new s(e,h),t=new i(t,h),r){case">":m=l,p=c,f=u,v=">",E=">=";break;case"<":m=u,p=d,f=l,v="<",E="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(a(e,t,h))return !1;for(let r=0;r<t.set.length;++r){const s=t.set[r];let i=null,a=null;if(s.forEach((e=>{e.semver===o&&(e=new n(">=0.0.0")),i=i||e,a=a||e,m(e.semver,i.semver,h)?i=e:f(e.semver,a.semver,h)&&(a=e);})),i.operator===v||i.operator===E)return !1;if((!a.operator||a.operator===v)&&p(e,a.semver))return !1;if(a.operator===E&&f(e,a.semver))return !1}return !0};},"./node_modules/semver/ranges/simplify.js":(e,t,r)=>{const s=r("./node_modules/semver/functions/satisfies.js"),n=r("./node_modules/semver/functions/compare.js");e.exports=(e,t,r)=>{const o=[];let i=null,a=null;const l=e.sort(((e,t)=>n(e,t,r)));for(const e of l)s(e,t,r)?(a=e,i||(i=e)):(a&&o.push([i,a]),a=null,i=null);i&&o.push([i,null]);const u=[];for(const[e,t]of o)e===t?u.push(e):t||e!==l[0]?t?e===l[0]?u.push(`<=${t}`):u.push(`${e} - ${t}`):u.push(`>=${e}`):u.push("*");const c=u.join(" || "),d="string"==typeof t.raw?t.raw:String(t);return c.length<d.length?c:t};},"./node_modules/semver/ranges/subset.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/range.js"),n=r("./node_modules/semver/classes/comparator.js"),{ANY:o}=n,i=r("./node_modules/semver/functions/satisfies.js"),a=r("./node_modules/semver/functions/compare.js"),l=(e,t,r)=>{if(e===t)return !0;if(1===e.length&&e[0].semver===o){if(1===t.length&&t[0].semver===o)return !0;e=r.includePrerelease?[new n(">=0.0.0-0")]:[new n(">=0.0.0")];}if(1===t.length&&t[0].semver===o){if(r.includePrerelease)return !0;t=[new n(">=0.0.0")];}const s=new Set;let l,d,h,m,p,f,v;for(const t of e)">"===t.operator||">="===t.operator?l=u(l,t,r):"<"===t.operator||"<="===t.operator?d=c(d,t,r):s.add(t.semver);if(s.size>1)return null;if(l&&d){if(h=a(l.semver,d.semver,r),h>0)return null;if(0===h&&(">="!==l.operator||"<="!==d.operator))return null}for(const e of s){if(l&&!i(e,String(l),r))return null;if(d&&!i(e,String(d),r))return null;for(const s of t)if(!i(e,String(s),r))return !1;return !0}let E=!(!d||r.includePrerelease||!d.semver.prerelease.length)&&d.semver,g=!(!l||r.includePrerelease||!l.semver.prerelease.length)&&l.semver;E&&1===E.prerelease.length&&"<"===d.operator&&0===E.prerelease[0]&&(E=!1);for(const e of t){if(v=v||">"===e.operator||">="===e.operator,f=f||"<"===e.operator||"<="===e.operator,l)if(g&&e.semver.prerelease&&e.semver.prerelease.length&&e.semver.major===g.major&&e.semver.minor===g.minor&&e.semver.patch===g.patch&&(g=!1),">"===e.operator||">="===e.operator){if(m=u(l,e,r),m===e&&m!==l)return !1}else if(">="===l.operator&&!i(l.semver,String(e),r))return !1;if(d)if(E&&e.semver.prerelease&&e.semver.prerelease.length&&e.semver.major===E.major&&e.semver.minor===E.minor&&e.semver.patch===E.patch&&(E=!1),"<"===e.operator||"<="===e.operator){if(p=c(d,e,r),p===e&&p!==d)return !1}else if("<="===d.operator&&!i(d.semver,String(e),r))return !1;if(!e.operator&&(d||l)&&0!==h)return !1}return !(l&&f&&!d&&0!==h||d&&v&&!l&&0!==h||g||E)},u=(e,t,r)=>{if(!e)return t;const s=a(e.semver,t.semver,r);return s>0?e:s<0||">"===t.operator&&">="===e.operator?t:e},c=(e,t,r)=>{if(!e)return t;const s=a(e.semver,t.semver,r);return s<0?e:s>0||"<"===t.operator&&"<="===e.operator?t:e};e.exports=(e,t,r={})=>{if(e===t)return !0;e=new s(e,r),t=new s(t,r);let n=!1;e:for(const s of e.set){for(const e of t.set){const t=l(s,e,r);if(n=n||null!==t,t)continue e}if(n)return !1}return !0};},"./node_modules/semver/ranges/to-comparators.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/range.js");e.exports=(e,t)=>new s(e,t).set.map((e=>e.map((e=>e.value)).join(" ").trim().split(" ")));},"./node_modules/semver/ranges/valid.js":(e,t,r)=>{const s=r("./node_modules/semver/classes/range.js");e.exports=(e,t)=>{try{return new s(e,t).range||"*"}catch(e){return null}};},"./node_modules/yallist/iterator.js":e=>{e.exports=function(e){e.prototype[Symbol.iterator]=function*(){for(let e=this.head;e;e=e.next)yield e.value;};};},"./node_modules/yallist/yallist.js":(e,t,r)=>{function s(e){var t=this;if(t instanceof s||(t=new s),t.tail=null,t.head=null,t.length=0,e&&"function"==typeof e.forEach)e.forEach((function(e){t.push(e);}));else if(arguments.length>0)for(var r=0,n=arguments.length;r<n;r++)t.push(arguments[r]);return t}function n(e,t){e.tail=new i(t,e.tail,null,e),e.head||(e.head=e.tail),e.length++;}function o(e,t){e.head=new i(t,null,e.head,e),e.tail||(e.tail=e.head),e.length++;}function i(e,t,r,s){if(!(this instanceof i))return new i(e,t,r,s);this.list=s,this.value=e,t?(t.next=this,this.prev=t):this.prev=null,r?(r.prev=this,this.next=r):this.next=null;}e.exports=s,s.Node=i,s.create=s,s.prototype.removeNode=function(e){if(e.list!==this)throw new Error("removing node which does not belong to this list");var t=e.next,r=e.prev;return t&&(t.prev=r),r&&(r.next=t),e===this.head&&(this.head=t),e===this.tail&&(this.tail=r),e.list.length--,e.next=null,e.prev=null,e.list=null,t},s.prototype.unshiftNode=function(e){if(e!==this.head){e.list&&e.list.removeNode(e);var t=this.head;e.list=this,e.next=t,t&&(t.prev=e),this.head=e,this.tail||(this.tail=e),this.length++;}},s.prototype.pushNode=function(e){if(e!==this.tail){e.list&&e.list.removeNode(e);var t=this.tail;e.list=this,e.prev=t,t&&(t.next=e),this.tail=e,this.head||(this.head=e),this.length++;}},s.prototype.push=function(){for(var e=0,t=arguments.length;e<t;e++)n(this,arguments[e]);return this.length},s.prototype.unshift=function(){for(var e=0,t=arguments.length;e<t;e++)o(this,arguments[e]);return this.length},s.prototype.pop=function(){if(this.tail){var e=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,e}},s.prototype.shift=function(){if(this.head){var e=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,e}},s.prototype.forEach=function(e,t){t=t||this;for(var r=this.head,s=0;null!==r;s++)e.call(t,r.value,s,this),r=r.next;},s.prototype.forEachReverse=function(e,t){t=t||this;for(var r=this.tail,s=this.length-1;null!==r;s--)e.call(t,r.value,s,this),r=r.prev;},s.prototype.get=function(e){for(var t=0,r=this.head;null!==r&&t<e;t++)r=r.next;if(t===e&&null!==r)return r.value},s.prototype.getReverse=function(e){for(var t=0,r=this.tail;null!==r&&t<e;t++)r=r.prev;if(t===e&&null!==r)return r.value},s.prototype.map=function(e,t){t=t||this;for(var r=new s,n=this.head;null!==n;)r.push(e.call(t,n.value,this)),n=n.next;return r},s.prototype.mapReverse=function(e,t){t=t||this;for(var r=new s,n=this.tail;null!==n;)r.push(e.call(t,n.value,this)),n=n.prev;return r},s.prototype.reduce=function(e,t){var r,s=this.head;if(arguments.length>1)r=t;else {if(!this.head)throw new TypeError("Reduce of empty list with no initial value");s=this.head.next,r=this.head.value;}for(var n=0;null!==s;n++)r=e(r,s.value,n),s=s.next;return r},s.prototype.reduceReverse=function(e,t){var r,s=this.tail;if(arguments.length>1)r=t;else {if(!this.tail)throw new TypeError("Reduce of empty list with no initial value");s=this.tail.prev,r=this.tail.value;}for(var n=this.length-1;null!==s;n--)r=e(r,s.value,n),s=s.prev;return r},s.prototype.toArray=function(){for(var e=new Array(this.length),t=0,r=this.head;null!==r;t++)e[t]=r.value,r=r.next;return e},s.prototype.toArrayReverse=function(){for(var e=new Array(this.length),t=0,r=this.tail;null!==r;t++)e[t]=r.value,r=r.prev;return e},s.prototype.slice=function(e,t){(t=t||this.length)<0&&(t+=this.length),(e=e||0)<0&&(e+=this.length);var r=new s;if(t<e||t<0)return r;e<0&&(e=0),t>this.length&&(t=this.length);for(var n=0,o=this.head;null!==o&&n<e;n++)o=o.next;for(;null!==o&&n<t;n++,o=o.next)r.push(o.value);return r},s.prototype.sliceReverse=function(e,t){(t=t||this.length)<0&&(t+=this.length),(e=e||0)<0&&(e+=this.length);var r=new s;if(t<e||t<0)return r;e<0&&(e=0),t>this.length&&(t=this.length);for(var n=this.length,o=this.tail;null!==o&&n>t;n--)o=o.prev;for(;null!==o&&n>e;n--,o=o.prev)r.push(o.value);return r},s.prototype.splice=function(e,t,...r){e>this.length&&(e=this.length-1),e<0&&(e=this.length+e);for(var s=0,n=this.head;null!==n&&s<e;s++)n=n.next;var o,a,l,u,c=[];for(s=0;n&&s<t;s++)c.push(n.value),n=this.removeNode(n);for(null===n&&(n=this.tail),n!==this.head&&n!==this.tail&&(n=n.prev),s=0;s<r.length;s++)o=this,a=n,l=r[s],u=void 0,null===(u=a===o.head?new i(l,null,a,o):new i(l,a,a.next,o)).next&&(o.tail=u),null===u.prev&&(o.head=u),o.length++,n=u;return c},s.prototype.reverse=function(){for(var e=this.head,t=this.tail,r=e;null!==r;r=r.prev){var s=r.prev;r.prev=r.next,r.next=s;}return this.head=t,this.tail=e,this};try{r("./node_modules/yallist/iterator.js")(s);}catch(e){}},crypto:e=>{e.exports=require$$0__default['default'];},fs:e=>{e.exports=fs__default['default'];},module:e=>{e.exports=require$$2__default['default'];},path:e=>{e.exports=require$$0__default$1['default'];},util:e=>{e.exports=require$$1__default['default'];}},t={};function r(s){var n=t[s];if(void 0!==n)return n.exports;var o=t[s]={id:s,loaded:!1,exports:{}};return e[s](o,o.exports,r),o.loaded=!0,o.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var s in t)r.o(t,s)&&!r.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]});},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.nmd=e=>(e.paths=[],e.children||(e.children=[]),e);var s={};(()=>{r.d(s,{default:()=>O});var e=r("fs"),t=r("module"),n=r("path");const o=require$$3__default['default'],i=require$$5__default['default'];var a=r.n(i),l=r("./node_modules/mkdirp/index.js"),u=r.n(l);const c=/"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/,d=/"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,h=/^["{[]|^-?[0-9][0-9.]{0,14}$/;function m(e,t){if("__proto__"!==e&&"constructor"!==e)return t}const p=function(e){if("string"!=typeof e)return e;const t=e.toLowerCase();if("true"===t)return !0;if("false"===t)return !1;if("null"===t)return null;if("nan"===t)return NaN;if("infinity"===t)return 1/0;if("undefined"!==t){if(!h.test(e))return e;try{return c.test(e)||d.test(e)?JSON.parse(e,m):JSON.parse(e)}catch(t){return e}}};var f=r("./node_modules/create-require/create-require.js"),v=r.n(f),E=r("./node_modules/semver/index.js"),g=r.n(E),_=r("./node_modules/pirates/lib/index.js"),y=r("./node_modules/object-hash/index.js"),j=r.n(y),I=r("crypto");function R(e,t=8){return (0, I.createHash)("md5").update(e).digest("hex").substr(0,t)}const $=p(process.env.JITI_DEBUG),w=p(process.env.JITI_CACHE),x=p(process.env.JITI_REQUIRE_CACHE),N={debug:$,cache:void 0===w||!!w,requireCache:void 0===x||!!x,interopDefault:!1,cacheVersion:"6",legacy:g().lt(process.version||"0.0.0","14.0.0"),extensions:[".js",".mjs",".ts"]};function O(r=process.cwd(),s={},i){function l(...e){s.debug&&console.log("[jiti]",...e);}if((s=Object.assign(Object.assign({},N),s)).legacy&&(s.cacheVersion+="-legacy"),s.transformOptions&&(s.cacheVersion+="-"+j()(s.transformOptions)),function(t){try{return (0,e.lstatSync)(t).isDirectory()}catch(e){return !1}}(r)&&(r=(0, n.join)(r,"index.js")),!0===s.cache&&(s.cache=(0, n.join)((0, o.tmpdir)(),"node-jiti")),s.cache)try{if(u().sync(s.cache),!function(t){try{return (0,e.accessSync)(t,e.constants.W_OK),!0}catch(e){return !1}}(s.cache))throw new Error("directory is not writable")}catch(e){l("Error creating cache directory at ",s.cache,e),s.cache=!1;}const c=v()(r),d=(e,t)=>{try{return c.resolve(e,t)}catch(e){}},h=[...s.extensions].filter((e=>".js"!==e)),m=(e,t)=>{if(s.extensions.includes((0, n.extname)(e)))return c.resolve(e,t);let r,o;try{return c.resolve(e,t)}catch(e){o=e;}for(const s of h)if(r=d(e+s,t)||d(e+"/index"+s,t),r)return r;throw o};function p(t){let r=function(t,r,o){if(!s.cache||!t)return o();const i=` /* v${s.cacheVersion}-${R(r,16)} */`,a=(0, n.basename)((0, n.dirname)(t))+"-"+(0, n.basename)(t),u=(0, n.join)(s.cache,a+"."+R(t)+".js");if((0, e.existsSync)(u)){const r=(0, e.readFileSync)(u,"utf-8");if(r.endsWith(i))return l("[cache hit]",t,"~>",u),r}l("[cache miss]",t);const c=o();return c.includes("__JITI_ERROR__")||(0, e.writeFileSync)(u,c+i,"utf-8"),c}(t.filename,t.source,(()=>{const e=s.transform(Object.assign(Object.assign({legacy:s.legacy},s.transformOptions),t));return e.error&&s.debug&&l(e.error),e.code}));return r.startsWith("#!")&&(r="// "+r),r}function f(r){var o;if(t.builtinModules.includes(r)||".pnp.js"===r)return c(r);const u=m(r),d=(0, n.extname)(u);if(d&&!s.extensions.includes(d))return l("[unknown]",u),c(r);if(s.requireCache&&c.cache[u])return null===(o=c.cache[u])||void 0===o?void 0:o.exports;let h=(0, e.readFileSync)(u,"utf-8");const v=".ts"===d;if(v||h.match(/^\s*import .* from|\s*export |import\s*\(/m)||s.legacy&&h.match(/\?\.|\?\?/))l("[transpile]",u),h=p({filename:u,source:h,ts:v});else try{return l("[native]",u),c(r)}catch(e){l("Native require error:",e),l("[fallback]",u),h=p({filename:u,source:h,ts:v});}const E=new t.Module(u);let g;E.filename=u,i&&(E.parent=i,Array.isArray(i.children)&&!i.children.includes(E)&&i.children.push(E)),E.require=O(u,s,E),E.path=(0, n.dirname)(u),E.paths=t.Module._nodeModulePaths(E.path),s.requireCache&&(c.cache[u]=E);try{g=a().runInThisContext(t.Module.wrap(h),{filename:u,lineOffset:0,displayErrors:!1});}catch(e){s.requireCache&&delete c.cache[u],s.onError(e);}try{g(E.exports,E.require,E,E.filename,(0,n.dirname)(E.filename));}catch(e){s.requireCache&&delete c.cache[u],s.onError(e);}if(E.exports&&E.exports.__JITI_ERROR__){const{filename:e,line:t,column:r,code:n,message:o}=E.exports.__JITI_ERROR__,i=new Error(`${n}: ${o} \n ${e}:${t}:${r}`);Error.captureStackTrace(i,f),s.onError(i);}E.loaded=!0;let _=E.exports;var y;return s.interopDefault&&(_=(y=_)&&"object"==typeof y&&"default"in y?y.default:y),_}return m.paths=c.resolve.paths,f.resolve=m,f.cache=s.requireCache?c.cache:{},f.extensions=c.extensions,f.main=c.main,f.transform=p,f.register=function(){return (0, _.addHook)(((e,t)=>f.transform({source:e,filename:t,ts:!!t.match(/.ts$/)})),{exts:s.extensions})},f}})(),jiti$1.exports=s.default;})();

var babel = {exports: {}};

(()=>{var e={"./node_modules/@babel/core/lib/config/cache-contexts.js":()=>{},"./node_modules/@babel/core/lib/config/caching.js":(e,t,r)=>{function n(){const e=r("./node_modules/gensync/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.makeWeakCache=l,t.makeWeakCacheSync=function(e){return o(l(e))},t.makeStrongCache=u,t.makeStrongCacheSync=function(e){return o(u(e))},t.assertSimpleType=h;var s=r("./node_modules/@babel/core/lib/gensync-utils/async.js"),i=r("./node_modules/@babel/core/lib/config/util.js");const o=e=>n()(e).sync;function*a(){return !0}function l(e){return c(WeakMap,e)}function u(e){return c(Map,e)}function c(e,t){const r=new e,n=new e,o=new e;return function*(e,a){const l=yield*(0, s.isAsync)(),u=l?n:r,c=yield*function*(e,t,r,n,i){const o=yield*p(t,n,i);if(o.valid)return o;if(e){const e=yield*p(r,n,i);if(e.valid)return {valid:!0,value:yield*(0, s.waitFor)(e.value.promise)}}return {valid:!1,value:null}}(l,u,o,e,a);if(c.valid)return c.value;const h=new f(a),y=t(e,h);let b,g;if((0, i.isIterableIterator)(y)){const t=y;g=yield*(0, s.onFirstPause)(t,(()=>{b=function(e,t,r){const n=new m;return d(t,e,r,n),n}(h,o,e);}));}else g=y;return d(u,h,e,g),b&&(o.delete(e),b.release(g)),g}}function*p(e,t,r){const n=e.get(t);if(n)for(const{value:e,valid:t}of n)if(yield*t(r))return {valid:!0,value:e};return {valid:!1,value:null}}function d(e,t,r,n){t.configured()||t.forever();let s=e.get(r);switch(t.deactivate(),t.mode()){case"forever":s=[{value:n,valid:a}],e.set(r,s);break;case"invalidate":s=[{value:n,valid:t.validator()}],e.set(r,s);break;case"valid":s?s.push({value:n,valid:t.validator()}):(s=[{value:n,valid:t.validator()}],e.set(r,s));}}class f{constructor(e){this._active=!0,this._never=!1,this._forever=!1,this._invalidate=!1,this._configured=!1,this._pairs=[],this._data=void 0,this._data=e;}simple(){return function(e){function t(t){if("boolean"!=typeof t)return e.using((()=>h(t())));t?e.forever():e.never();}return t.forever=()=>e.forever(),t.never=()=>e.never(),t.using=t=>e.using((()=>h(t()))),t.invalidate=t=>e.invalidate((()=>h(t()))),t}(this)}mode(){return this._never?"never":this._forever?"forever":this._invalidate?"invalidate":"valid"}forever(){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._never)throw new Error("Caching has already been configured with .never()");this._forever=!0,this._configured=!0;}never(){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._forever)throw new Error("Caching has already been configured with .forever()");this._never=!0,this._configured=!0;}using(e){if(!this._active)throw new Error("Cannot change caching after evaluation has completed.");if(this._never||this._forever)throw new Error("Caching has already been configured with .never or .forever()");this._configured=!0;const t=e(this._data),r=(0, s.maybeAsync)(e,"You appear to be using an async cache handler, but Babel has been called synchronously");return (0, s.isThenable)(t)?t.then((e=>(this._pairs.push([e,r]),e))):(this._pairs.push([t,r]),t)}invalidate(e){return this._invalidate=!0,this.using(e)}validator(){const e=this._pairs;return function*(t){for(const[r,n]of e)if(r!==(yield*n(t)))return !1;return !0}}deactivate(){this._active=!1;}configured(){return this._configured}}function h(e){if((0, s.isThenable)(e))throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");if(null!=e&&"string"!=typeof e&&"boolean"!=typeof e&&"number"!=typeof e)throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");return e}class m{constructor(){this.released=!1,this.promise=void 0,this._resolve=void 0,this.promise=new Promise((e=>{this._resolve=e;}));}release(e){this.released=!0,this._resolve(e);}}},"./node_modules/@babel/core/lib/config/config-chain.js":(e,t,r)=>{function n(){const e=r("path");return n=function(){return e},e}function s(){const e=r("./node_modules/debug/src/index.js");return s=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.buildPresetChain=function*(e,t){const r=yield*d(e,t);return r?{plugins:M(r.plugins),presets:M(r.presets),options:r.options.map((e=>L(e))),files:new Set}:null},t.buildRootChain=function*(e,t){let r,s;const i=new a.ConfigPrinter,u=yield*v({options:e,dirname:t.cwd},t,void 0,i);if(!u)return null;const c=yield*i.output();let p;"string"==typeof e.configFile?p=yield*(0, l.loadConfig)(e.configFile,t.cwd,t.envName,t.caller):!1!==e.configFile&&(p=yield*(0, l.findRootConfig)(t.root,t.envName,t.caller));let{babelrc:d,babelrcRoots:f}=e,h=t.cwd;const m=F(),y=new a.ConfigPrinter;if(p){const e=b(p),n=yield*T(e,t,void 0,y);if(!n)return null;r=yield*y.output(),void 0===d&&(d=e.options.babelrc),void 0===f&&(h=e.dirname,f=e.options.babelrcRoots),N(m,n);}let E,x,S=!1;const P=F();if((!0===d||void 0===d)&&"string"==typeof t.filename){const e=yield*(0, l.findPackageData)(t.filename);if(e&&function(e,t,r,s){if("boolean"==typeof r)return r;const i=e.root;if(void 0===r)return -1!==t.directories.indexOf(i);let a=r;return Array.isArray(a)||(a=[a]),a=a.map((e=>"string"==typeof e?n().resolve(s,e):e)),1===a.length&&a[0]===i?-1!==t.directories.indexOf(i):a.some((r=>("string"==typeof r&&(r=(0, o.default)(r,s)),t.directories.some((t=>W(r,s,t,e))))))}(t,e,f,h)){if(({ignore:E,config:x}=yield*(0, l.findRelativeConfig)(e,t.envName,t.caller)),E&&P.files.add(E.filepath),E&&U(t,E.ignore,null,E.dirname)&&(S=!0),x&&!S){const e=g(x),r=new a.ConfigPrinter,n=yield*T(e,t,void 0,r);n?(s=yield*r.output(),N(P,n)):S=!0;}x&&S&&P.files.add(x.filepath);}}t.showConfig&&console.log(`Babel configs on "${t.filename}" (ascending priority):\n`+[r,s,c].filter((e=>!!e)).join("\n\n")+"\n-----End Babel configs-----");const A=N(N(N(F(),m),P),u);return {plugins:S?[]:M(A.plugins),presets:S?[]:M(A.presets),options:S?[]:A.options.map((e=>L(e))),fileHandling:S?"ignored":"transpile",ignore:E||void 0,babelrc:x||void 0,config:p||void 0,files:A.files}},t.buildPresetChainWalker=void 0;var i=r("./node_modules/@babel/core/lib/config/validation/options.js"),o=r("./node_modules/@babel/core/lib/config/pattern-to-regex.js"),a=r("./node_modules/@babel/core/lib/config/printer.js"),l=r("./node_modules/@babel/core/lib/config/files/index.js"),u=r("./node_modules/@babel/core/lib/config/caching.js"),c=r("./node_modules/@babel/core/lib/config/config-descriptors.js");const p=s()("babel:config:config-chain"),d=j({root:e=>f(e),env:(e,t)=>h(e)(t),overrides:(e,t)=>m(e)(t),overridesEnv:(e,t,r)=>y(e)(t)(r),createLogger:()=>()=>{}});t.buildPresetChainWalker=d;const f=(0, u.makeWeakCacheSync)((e=>C(e,e.alias,c.createUncachedDescriptors))),h=(0, u.makeWeakCacheSync)((e=>(0, u.makeStrongCacheSync)((t=>D(e,e.alias,c.createUncachedDescriptors,t))))),m=(0, u.makeWeakCacheSync)((e=>(0, u.makeStrongCacheSync)((t=>_(e,e.alias,c.createUncachedDescriptors,t))))),y=(0, u.makeWeakCacheSync)((e=>(0, u.makeStrongCacheSync)((t=>(0, u.makeStrongCacheSync)((r=>O(e,e.alias,c.createUncachedDescriptors,t,r))))))),b=(0, u.makeWeakCacheSync)((e=>({filepath:e.filepath,dirname:e.dirname,options:(0, i.validate)("configfile",e.options)}))),g=(0, u.makeWeakCacheSync)((e=>({filepath:e.filepath,dirname:e.dirname,options:(0, i.validate)("babelrcfile",e.options)}))),E=(0, u.makeWeakCacheSync)((e=>({filepath:e.filepath,dirname:e.dirname,options:(0, i.validate)("extendsfile",e.options)}))),v=j({root:e=>C(e,"base",c.createCachedDescriptors),env:(e,t)=>D(e,"base",c.createCachedDescriptors,t),overrides:(e,t)=>_(e,"base",c.createCachedDescriptors,t),overridesEnv:(e,t,r)=>O(e,"base",c.createCachedDescriptors,t,r),createLogger:(e,t,r)=>function(e,t,r){var n;return r?r.configure(t.showConfig,a.ChainFormatter.Programmatic,{callerName:null==(n=t.caller)?void 0:n.name}):()=>{}}(0,t,r)}),x=j({root:e=>S(e),env:(e,t)=>P(e)(t),overrides:(e,t)=>A(e)(t),overridesEnv:(e,t,r)=>w(e)(t)(r),createLogger:(e,t,r)=>function(e,t,r){return r?r.configure(t.showConfig,a.ChainFormatter.Config,{filepath:e}):()=>{}}(e.filepath,t,r)});function*T(e,t,r,n){const s=yield*x(e,t,r,n);return s&&s.files.add(e.filepath),s}const S=(0, u.makeWeakCacheSync)((e=>C(e,e.filepath,c.createUncachedDescriptors))),P=(0, u.makeWeakCacheSync)((e=>(0, u.makeStrongCacheSync)((t=>D(e,e.filepath,c.createUncachedDescriptors,t))))),A=(0, u.makeWeakCacheSync)((e=>(0, u.makeStrongCacheSync)((t=>_(e,e.filepath,c.createUncachedDescriptors,t))))),w=(0, u.makeWeakCacheSync)((e=>(0, u.makeStrongCacheSync)((t=>(0, u.makeStrongCacheSync)((r=>O(e,e.filepath,c.createUncachedDescriptors,t,r)))))));function C({dirname:e,options:t},r,n){return n(e,t,r)}function D({dirname:e,options:t},r,n,s){const i=t.env&&t.env[s];return i?n(e,i,`${r}.env["${s}"]`):null}function _({dirname:e,options:t},r,n,s){const i=t.overrides&&t.overrides[s];if(!i)throw new Error("Assertion failure - missing override");return n(e,i,`${r}.overrides[${s}]`)}function O({dirname:e,options:t},r,n,s,i){const o=t.overrides&&t.overrides[s];if(!o)throw new Error("Assertion failure - missing override");const a=o.env&&o.env[i];return a?n(e,a,`${r}.overrides[${s}].env["${i}"]`):null}function j({root:e,env:t,overrides:r,overridesEnv:n,createLogger:s}){return function*(i,o,a=new Set,l){const{dirname:u}=i,c=[],p=e(i);if(B(p,u,o)){c.push({config:p,envName:void 0,index:void 0});const e=t(i,o.envName);e&&B(e,u,o)&&c.push({config:e,envName:o.envName,index:void 0}),(p.options.overrides||[]).forEach(((e,t)=>{const s=r(i,t);if(B(s,u,o)){c.push({config:s,index:t,envName:void 0});const e=n(i,t,o.envName);e&&B(e,u,o)&&c.push({config:e,index:t,envName:o.envName});}}));}if(c.some((({config:{options:{ignore:e,only:t}}})=>U(o,e,t,u))))return null;const d=F(),f=s(i,o,l);for(const{config:e,index:t,envName:r}of c){if(!(yield*I(d,e.options,u,o,a,l)))return null;f(e,t,r),yield*k(d,e);}return d}}function*I(e,t,r,n,s,i){if(void 0===t.extends)return !0;const o=yield*(0, l.loadConfig)(t.extends,r,n.envName,n.caller);if(s.has(o))throw new Error(`Configuration cycle detected loading ${o.filepath}.\nFile already loaded following the config chain:\n`+Array.from(s,(e=>` - ${e.filepath}`)).join("\n"));s.add(o);const a=yield*T(E(o),n,s,i);return s.delete(o),!!a&&(N(e,a),!0)}function N(e,t){e.options.push(...t.options),e.plugins.push(...t.plugins),e.presets.push(...t.presets);for(const r of t.files)e.files.add(r);return e}function*k(e,{options:t,plugins:r,presets:n}){return e.options.push(t),e.plugins.push(...yield*r()),e.presets.push(...yield*n()),e}function F(){return {options:[],presets:[],plugins:[],files:new Set}}function L(e){const t=Object.assign({},e);return delete t.extends,delete t.env,delete t.overrides,delete t.plugins,delete t.presets,delete t.passPerPreset,delete t.ignore,delete t.only,delete t.test,delete t.include,delete t.exclude,Object.prototype.hasOwnProperty.call(t,"sourceMap")&&(t.sourceMaps=t.sourceMap,delete t.sourceMap),t}function M(e){const t=new Map,r=[];for(const n of e)if("function"==typeof n.value){const e=n.value;let s=t.get(e);s||(s=new Map,t.set(e,s));let i=s.get(n.name);i?i.value=n:(i={value:n},r.push(i),n.ownPass||s.set(n.name,i));}else r.push({value:n});return r.reduce(((e,t)=>(e.push(t.value),e)),[])}function B({options:e},t,r){return (void 0===e.test||R(r,e.test,t))&&(void 0===e.include||R(r,e.include,t))&&(void 0===e.exclude||!R(r,e.exclude,t))}function R(e,t,r){return V(e,Array.isArray(t)?t:[t],r)}function U(e,t,r,n){if(t&&V(e,t,n)){var s;const r=`No config is applied to "${null!=(s=e.filename)?s:"(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(t)}\` from "${n}"`;return p(r),e.showConfig&&console.log(r),!0}if(r&&!V(e,r,n)){var i;const t=`No config is applied to "${null!=(i=e.filename)?i:"(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(r)}\` from "${n}"`;return p(t),e.showConfig&&console.log(t),!0}return !1}function V(e,t,r){return t.some((t=>W(t,r,e.filename,e)))}function W(e,t,r,n){if("function"==typeof e)return !!e(r,{dirname:t,envName:n.envName,caller:n.caller});if("string"!=typeof r)throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");return "string"==typeof e&&(e=(0, o.default)(e,t)),e.test(r)}},"./node_modules/@babel/core/lib/config/config-descriptors.js":(e,t,r)=>{function n(){const e=r("./node_modules/gensync/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.createCachedDescriptors=function(e,t,r){const{plugins:n,presets:s,passPerPreset:i}=t;return {options:u(t,e),plugins:n?()=>f(n,e)(r):()=>l([]),presets:s?()=>p(s,e)(r)(!!i):()=>l([])}},t.createUncachedDescriptors=function(e,t,r){let n,s;return {options:u(t,e),*plugins(){return n||(n=yield*b(t.plugins||[],e,r)),n},*presets(){return s||(s=yield*y(t.presets||[],e,r,!!t.passPerPreset)),s}}},t.createDescriptor=E;var s=r("./node_modules/@babel/core/lib/config/files/index.js"),i=r("./node_modules/@babel/core/lib/config/item.js"),o=r("./node_modules/@babel/core/lib/config/caching.js"),a=r("./node_modules/@babel/core/lib/config/resolve-targets.js");function*l(e){return e}function u(e,t){return "string"==typeof e.browserslistConfigFile&&(e.browserslistConfigFile=(0, a.resolveBrowserslistConfigFile)(e.browserslistConfigFile,t)),e}const c=new WeakMap,p=(0, o.makeWeakCacheSync)(((e,t)=>{const r=t.using((e=>e));return (0, o.makeStrongCacheSync)((t=>(0, o.makeStrongCache)((function*(n){return (yield*y(e,r,t,n)).map((e=>m(c,e)))}))))})),d=new WeakMap,f=(0, o.makeWeakCacheSync)(((e,t)=>{const r=t.using((e=>e));return (0, o.makeStrongCache)((function*(t){return (yield*b(e,r,t)).map((e=>m(d,e)))}))})),h={};function m(e,t){const{value:r,options:n=h}=t;if(!1===n)return t;let s=e.get(r);s||(s=new WeakMap,e.set(r,s));let i=s.get(n);if(i||(i=[],s.set(n,i)),-1===i.indexOf(t)){const e=i.filter((e=>{return n=t,(r=e).name===n.name&&r.value===n.value&&r.options===n.options&&r.dirname===n.dirname&&r.alias===n.alias&&r.ownPass===n.ownPass&&(r.file&&r.file.request)===(n.file&&n.file.request)&&(r.file&&r.file.resolved)===(n.file&&n.file.resolved);var r,n;}));if(e.length>0)return e[0];i.push(t);}return t}function*y(e,t,r,n){return yield*g("preset",e,t,r,n)}function*b(e,t,r){return yield*g("plugin",e,t,r)}function*g(e,t,r,s,i){const o=yield*n().all(t.map(((t,n)=>E(t,r,{type:e,alias:`${s}$${n}`,ownPass:!!i}))));return function(e){const t=new Map;for(const r of e){if("function"!=typeof r.value)continue;let n=t.get(r.value);if(n||(n=new Set,t.set(r.value,n)),n.has(r.name)){const t=e.filter((e=>e.value===r.value));throw new Error(["Duplicate plugin/preset detected.","If you'd like to use two separate instances of a plugin,","they need separate names, e.g.","","  plugins: [","    ['some-plugin', {}],","    ['some-plugin', {}, 'some unique name'],","  ]","","Duplicates detected are:",`${JSON.stringify(t,null,2)}`].join("\n"))}n.add(r.name);}}(o),o}function*E(e,t,{type:r,alias:n,ownPass:o}){const a=(0, i.getItemDescriptor)(e);if(a)return a;let l,u,c,p=e;Array.isArray(p)&&(3===p.length?[p,u,l]=p:[p,u]=p);let d=null;if("string"==typeof p){if("string"!=typeof r)throw new Error("To resolve a string-based item, the type of item must be given");const e="plugin"===r?s.loadPlugin:s.loadPreset,n=p;(({filepath:d,value:p}=yield*e(p,t))),c={request:n,resolved:d};}if(!p)throw new Error(`Unexpected falsy value: ${String(p)}`);if("object"==typeof p&&p.__esModule){if(!p.default)throw new Error("Must export a default export when using ES6 modules.");p=p.default;}if("object"!=typeof p&&"function"!=typeof p)throw new Error(`Unsupported format: ${typeof p}. Expected an object or a function.`);if(null!==d&&"object"==typeof p&&p)throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${d}`);return {name:l,alias:d||n,value:p,options:u,dirname:t,ownPass:o,file:c}}},"./node_modules/@babel/core/lib/config/files/configuration.js":(e,t,r)=>{function n(){const e=r("./node_modules/debug/src/index.js");return n=function(){return e},e}function s(){const e=r("fs");return s=function(){return e},e}function i(){const e=r("path");return i=function(){return e},e}function o(){const e=r("./node_modules/json5/dist/index.mjs");return o=function(){return e},e}function a(){const e=r("./node_modules/gensync/index.js");return a=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.findConfigUpwards=function(e){let t=e;for(;;){for(const e of m)if(s().existsSync(i().join(t,e)))return t;const e=i().dirname(t);if(t===e)break;t=e;}return null},t.findRelativeConfig=function*(e,t,r){let n=null,s=null;const o=i().dirname(e.filepath);for(const l of e.directories){var a;if(n||(n=yield*b(y,l,t,r,(null==(a=e.pkg)?void 0:a.dirname)===l?x(e.pkg):null)),!s){const e=i().join(l,".babelignore");s=yield*S(e),s&&h("Found ignore %o from %o.",s.filepath,o);}}return {config:n,ignore:s}},t.findRootConfig=function(e,t,r){return b(m,e,t,r)},t.loadConfig=function*(e,t,n,s){const i=(l="8.9",a=(a=process.versions.node).split("."),l=l.split("."),+a[0]>+l[0]||a[0]==l[0]&&+a[1]>=+l[1]?r("./node_modules/@babel/core/lib/config/files sync recursive").resolve:(e,{paths:[t]},n=r("module"))=>{let s=n._findPath(e,n._nodeModulePaths(t).concat(t));if(s)return s;throw s=new Error(`Cannot resolve module '${e}'`),s.code="MODULE_NOT_FOUND",s})(e,{paths:[t]}),o=yield*g(i,n,s);var a,l;if(!o)throw new Error(`Config file ${i} contains no configuration data`);return h("Loaded config %o from %o.",e,t),o},t.resolveShowConfigPath=function*(e){const t=process.env.BABEL_SHOW_CONFIG_FOR;if(null!=t){const r=i().resolve(e,t);if(!(yield*f.stat(r)).isFile())throw new Error(`${r}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);return r}return null},t.ROOT_CONFIG_FILENAMES=void 0;var l=r("./node_modules/@babel/core/lib/config/caching.js"),u=r("./node_modules/@babel/core/lib/config/helpers/config-api.js"),c=r("./node_modules/@babel/core/lib/config/files/utils.js"),p=r("./node_modules/@babel/core/lib/config/files/module-types.js"),d=r("./node_modules/@babel/core/lib/config/pattern-to-regex.js"),f=r("./node_modules/@babel/core/lib/gensync-utils/fs.js");const h=n()("babel:config:loading:files:configuration"),m=["babel.config.js","babel.config.cjs","babel.config.mjs","babel.config.json"];t.ROOT_CONFIG_FILENAMES=m;const y=[".babelrc",".babelrc.js",".babelrc.cjs",".babelrc.mjs",".babelrc.json"];function*b(e,t,r,n,s=null){const o=(yield*a().all(e.map((e=>g(i().join(t,e),r,n))))).reduce(((e,r)=>{if(r&&e)throw new Error(`Multiple configuration files found. Please remove one:\n - ${i().basename(e.filepath)}\n - ${r.filepath}\nfrom ${t}`);return r||e}),s);return o&&h("Found configuration %o from %o.",o.filepath,t),o}function g(e,t,r){const n=i().extname(e);return ".js"===n||".cjs"===n||".mjs"===n?v(e,{envName:t,caller:r}):T(e)}const E=new Set,v=(0, l.makeStrongCache)((function*(e,t){if(!s().existsSync(e))return t.never(),null;if(E.has(e))return t.never(),h("Auto-ignoring usage of config %o.",e),{filepath:e,dirname:i().dirname(e),options:{}};let r;try{E.add(e),r=yield*(0,p.default)(e,"You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously.");}catch(t){throw t.message=`${e}: Error while loading config - ${t.message}`,t}finally{E.delete(e);}let n=!1;if("function"==typeof r&&(yield*[],r=r((0, u.makeConfigAPI)(t)),n=!0),!r||"object"!=typeof r||Array.isArray(r))throw new Error(`${e}: Configuration should be an exported JavaScript object.`);if("function"==typeof r.then)throw new Error("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.");return n&&!t.configured()&&function(){throw new Error('Caching was left unconfigured. Babel\'s plugins, presets, and .babelrc.js files can be configured\nfor various types of caching, using the first param of their handler functions:\n\nmodule.exports = function(api) {\n  // The API exposes the following:\n\n  // Cache the returned value forever and don\'t call this function again.\n  api.cache(true);\n\n  // Don\'t cache at all. Not recommended because it will be very slow.\n  api.cache(false);\n\n  // Cached based on the value of some function. If this function returns a value different from\n  // a previously-encountered value, the plugins will re-evaluate.\n  var env = api.cache(() => process.env.NODE_ENV);\n\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\n  // any possible NODE_ENV value that might come up during plugin execution.\n  var isProd = api.cache(() => process.env.NODE_ENV === "production");\n\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\n  // previous instance whenever something changes, you may use:\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");\n\n  // Note, we also expose the following more-verbose versions of the above examples:\n  api.cache.forever(); // api.cache(true)\n  api.cache.never();   // api.cache(false)\n  api.cache.using(fn); // api.cache(fn)\n\n  // Return the value that will be cached.\n  return { };\n};')}(),{filepath:e,dirname:i().dirname(e),options:r}})),x=(0, l.makeWeakCacheSync)((e=>{const t=e.options.babel;if(void 0===t)return null;if("object"!=typeof t||Array.isArray(t)||null===t)throw new Error(`${e.filepath}: .babel property must be an object`);return {filepath:e.filepath,dirname:e.dirname,options:t}})),T=(0, c.makeStaticFileCache)(((e,t)=>{let r;try{r=o().parse(t);}catch(t){throw t.message=`${e}: Error while parsing config - ${t.message}`,t}if(!r)throw new Error(`${e}: No config detected`);if("object"!=typeof r)throw new Error(`${e}: Config returned typeof ${typeof r}`);if(Array.isArray(r))throw new Error(`${e}: Expected config object but found array`);return {filepath:e,dirname:i().dirname(e),options:r}})),S=(0, c.makeStaticFileCache)(((e,t)=>{const r=i().dirname(e),n=t.split("\n").map((e=>e.replace(/#(.*?)$/,"").trim())).filter((e=>!!e));for(const e of n)if("!"===e[0])throw new Error("Negation of file paths is not supported.");return {filepath:e,dirname:i().dirname(e),ignore:n.map((e=>(0, d.default)(e,r)))}}));},"./node_modules/@babel/core/lib/config/files/import.js":(e,t,r)=>{t.Z=function(e){return r("./node_modules/@babel/core/lib/config/files lazy recursive")(e)};},"./node_modules/@babel/core/lib/config/files/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"findPackageData",{enumerable:!0,get:function(){return n.findPackageData}}),Object.defineProperty(t,"findConfigUpwards",{enumerable:!0,get:function(){return s.findConfigUpwards}}),Object.defineProperty(t,"findRelativeConfig",{enumerable:!0,get:function(){return s.findRelativeConfig}}),Object.defineProperty(t,"findRootConfig",{enumerable:!0,get:function(){return s.findRootConfig}}),Object.defineProperty(t,"loadConfig",{enumerable:!0,get:function(){return s.loadConfig}}),Object.defineProperty(t,"resolveShowConfigPath",{enumerable:!0,get:function(){return s.resolveShowConfigPath}}),Object.defineProperty(t,"ROOT_CONFIG_FILENAMES",{enumerable:!0,get:function(){return s.ROOT_CONFIG_FILENAMES}}),Object.defineProperty(t,"resolvePlugin",{enumerable:!0,get:function(){return i.resolvePlugin}}),Object.defineProperty(t,"resolvePreset",{enumerable:!0,get:function(){return i.resolvePreset}}),Object.defineProperty(t,"loadPlugin",{enumerable:!0,get:function(){return i.loadPlugin}}),Object.defineProperty(t,"loadPreset",{enumerable:!0,get:function(){return i.loadPreset}});var n=r("./node_modules/@babel/core/lib/config/files/package.js"),s=r("./node_modules/@babel/core/lib/config/files/configuration.js"),i=r("./node_modules/@babel/core/lib/config/files/plugins.js");},"./node_modules/@babel/core/lib/config/files/module-types.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function*(e,t,r=!1){switch(function(e){switch(s().extname(e)){case".cjs":return "cjs";case".mjs":return "mjs";default:return "unknown"}}(e)){case"cjs":return u(e,r);case"unknown":try{return u(e,r)}catch(e){if("ERR_REQUIRE_ESM"!==e.code)throw e}case"mjs":if(yield*(0, n.isAsync)())return yield*(0, n.waitFor)(function(e){return c.apply(this,arguments)}(e));throw new Error(t)}};var n=r("./node_modules/@babel/core/lib/gensync-utils/async.js");function s(){const e=r("path");return s=function(){return e},e}function i(){const e=r("url");return i=function(){return e},e}function o(e,t,r,n,s,i,o){try{var a=e[i](o),l=a.value;}catch(e){return void r(e)}a.done?t(l):Promise.resolve(l).then(n,s);}function a(e){return function(){var t=this,r=arguments;return new Promise((function(n,s){var i=e.apply(t,r);function a(e){o(i,n,s,a,l,"next",e);}function l(e){o(i,n,s,a,l,"throw",e);}a(void 0);}))}}let l;try{l=r("./node_modules/@babel/core/lib/config/files/import.js").Z;}catch(e){}function u(e,t){const n=r("./node_modules/@babel/core/lib/config/files sync recursive")(e);return null!=n&&n.__esModule?n.default||(t?n:void 0):n}function c(){return (c=a((function*(e){if(!l)throw new Error("Internal error: Native ECMAScript modules aren't supported by this platform.\n");return (yield l((0, i().pathToFileURL)(e))).default}))).apply(this,arguments)}},"./node_modules/@babel/core/lib/config/files/package.js":(e,t,r)=>{function n(){const e=r("path");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.findPackageData=function*(e){let t=null;const r=[];let i=!0,o=n().dirname(e);for(;!t&&"node_modules"!==n().basename(o);){r.push(o),t=yield*s(n().join(o,"package.json"));const e=n().dirname(o);if(o===e){i=!1;break}o=e;}return {filepath:e,directories:r,pkg:t,isPackage:i}};const s=(0, r("./node_modules/@babel/core/lib/config/files/utils.js").makeStaticFileCache)(((e,t)=>{let r;try{r=JSON.parse(t);}catch(t){throw t.message=`${e}: Error while parsing JSON - ${t.message}`,t}if(!r)throw new Error(`${e}: No config detected`);if("object"!=typeof r)throw new Error(`${e}: Config returned typeof ${typeof r}`);if(Array.isArray(r))throw new Error(`${e}: Expected config object but found array`);return {filepath:e,dirname:n().dirname(e),options:r}}));},"./node_modules/@babel/core/lib/config/files/plugins.js":(e,t,r)=>{function n(){const e=r("./node_modules/debug/src/index.js");return n=function(){return e},e}function s(){const e=r("path");return s=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.resolvePlugin=m,t.resolvePreset=y,t.loadPlugin=function*(e,t){const r=m(e,t);if(!r)throw new Error(`Plugin ${e} not found relative to ${t}`);const n=yield*v("plugin",r);return o("Loaded plugin %o from %o.",e,t),{filepath:r,value:n}},t.loadPreset=function*(e,t){const r=y(e,t);if(!r)throw new Error(`Preset ${e} not found relative to ${t}`);const n=yield*v("preset",r);return o("Loaded preset %o from %o.",e,t),{filepath:r,value:n}};var i=r("./node_modules/@babel/core/lib/config/files/module-types.js");const o=n()("babel:config:loading:files:plugins"),a=/^module:/,l=/^(?!@|module:|[^/]+\/|babel-plugin-)/,u=/^(?!@|module:|[^/]+\/|babel-preset-)/,c=/^(@babel\/)(?!plugin-|[^/]+\/)/,p=/^(@babel\/)(?!preset-|[^/]+\/)/,d=/^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/,f=/^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/,h=/^(@(?!babel$)[^/]+)$/;function m(e,t){return g("plugin",e,t)}function y(e,t){return g("preset",e,t)}function b(e,t){if(s().isAbsolute(t))return t;const r="preset"===e;return t.replace(r?u:l,`babel-${e}-`).replace(r?p:c,`$1${e}-`).replace(r?f:d,`$1babel-${e}-`).replace(h,`$1/babel-${e}`).replace(a,"")}function g(e,t,n=process.cwd()){const s=b(e,t);try{return (i=process.versions.node,o="8.9",i=i.split("."),o=o.split("."),+i[0]>+o[0]||i[0]==o[0]&&+i[1]>=+o[1]?r("./node_modules/@babel/core/lib/config/files sync recursive").resolve:(e,{paths:[t]},n=r("module"))=>{let s=n._findPath(e,n._nodeModulePaths(t).concat(t));if(s)return s;throw s=new Error(`Cannot resolve module '${e}'`),s.code="MODULE_NOT_FOUND",s})(s,{paths:[n]})}catch(i){if("MODULE_NOT_FOUND"!==i.code)throw i;if(s!==t){let e=!1;try{(((e,t)=>(e=e.split("."),t=t.split("."),+e[0]>+t[0]||e[0]==t[0]&&+e[1]>=+t[1]))(process.versions.node,"8.9")?r("./node_modules/@babel/core/lib/config/files sync recursive").resolve:(e,{paths:[t]},n=r("module"))=>{let s=n._findPath(e,n._nodeModulePaths(t).concat(t));if(s)return s;throw s=new Error(`Cannot resolve module '${e}'`),s.code="MODULE_NOT_FOUND",s})(t,{paths:[n]}),e=!0;}catch(e){}e&&(i.message+=`\n- If you want to resolve "${t}", use "module:${t}"`);}let o=!1;try{(((e,t)=>(e=e.split("."),t=t.split("."),+e[0]>+t[0]||e[0]==t[0]&&+e[1]>=+t[1]))(process.versions.node,"8.9")?r("./node_modules/@babel/core/lib/config/files sync recursive").resolve:(e,{paths:[t]},n=r("module"))=>{let s=n._findPath(e,n._nodeModulePaths(t).concat(t));if(s)return s;throw s=new Error(`Cannot resolve module '${e}'`),s.code="MODULE_NOT_FOUND",s})(b(e,"@babel/"+t),{paths:[n]}),o=!0;}catch(e){}o&&(i.message+=`\n- Did you mean "@babel/${t}"?`);let a=!1;const l="preset"===e?"plugin":"preset";try{(((e,t)=>(e=e.split("."),t=t.split("."),+e[0]>+t[0]||e[0]==t[0]&&+e[1]>=+t[1]))(process.versions.node,"8.9")?r("./node_modules/@babel/core/lib/config/files sync recursive").resolve:(e,{paths:[t]},n=r("module"))=>{let s=n._findPath(e,n._nodeModulePaths(t).concat(t));if(s)return s;throw s=new Error(`Cannot resolve module '${e}'`),s.code="MODULE_NOT_FOUND",s})(b(l,t),{paths:[n]}),a=!0;}catch(e){}throw a&&(i.message+=`\n- Did you accidentally pass a ${l} as a ${e}?`),i}var i,o;}const E=new Set;function*v(e,t){if(E.has(t))throw new Error(`Reentrant ${e} detected trying to load "${t}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);try{return E.add(t),yield*(0,i.default)(t,`You appear to be using a native ECMAScript module ${e}, which is only supported when running Babel asynchronously.`,!0)}catch(e){throw e.message=`[BABEL]: ${e.message} (While processing: ${t})`,e}finally{E.delete(t);}}},"./node_modules/@babel/core/lib/config/files/utils.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.makeStaticFileCache=function(e){return (0, n.makeStrongCache)((function*(t,r){return null===r.invalidate((()=>function(e){if(!i().existsSync(e))return null;try{return +i().statSync(e).mtime}catch(e){if("ENOENT"!==e.code&&"ENOTDIR"!==e.code)throw e}return null}(t)))?null:e(t,yield*s.readFile(t,"utf8"))}))};var n=r("./node_modules/@babel/core/lib/config/caching.js"),s=r("./node_modules/@babel/core/lib/gensync-utils/fs.js");function i(){const e=r("fs");return i=function(){return e},e}},"./node_modules/@babel/core/lib/config/files lazy recursive":e=>{function t(e){return Promise.resolve().then((()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}))}t.keys=()=>[],t.resolve=t,t.id="./node_modules/@babel/core/lib/config/files lazy recursive",e.exports=t;},"./node_modules/@babel/core/lib/config/files sync recursive":e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id="./node_modules/@babel/core/lib/config/files sync recursive",e.exports=t;},"./node_modules/@babel/core/lib/config/full.js":(e,t,r)=>{function n(){const e=r("./node_modules/gensync/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s=r("./node_modules/@babel/core/lib/gensync-utils/async.js"),i=r("./node_modules/@babel/core/lib/config/util.js"),o=r("./node_modules/@babel/core/lib/index.js"),a=r("./node_modules/@babel/core/lib/config/plugin.js"),l=r("./node_modules/@babel/core/lib/config/item.js"),u=r("./node_modules/@babel/core/lib/config/config-chain.js");function c(){const e=r("./node_modules/@babel/traverse/lib/index.js");return c=function(){return e},e}var p=r("./node_modules/@babel/core/lib/config/caching.js"),d=r("./node_modules/@babel/core/lib/config/validation/options.js"),f=r("./node_modules/@babel/core/lib/config/validation/plugins.js"),h=r("./node_modules/@babel/core/lib/config/helpers/config-api.js"),m=r("./node_modules/@babel/core/lib/config/partial.js"),y=(r("./node_modules/@babel/core/lib/config/cache-contexts.js"),n()((function*(e){var t;const r=yield*(0, m.default)(e);if(!r)return null;const{options:n,context:s,fileHandling:o}=r;if("ignored"===o)return null;const a={},{plugins:u,presets:c}=n;if(!u||!c)throw new Error("Assertion failure - plugins and presets exist");const p=Object.assign({},s,{targets:n.targets}),f=e=>{const t=(0, l.getItemDescriptor)(e);if(!t)throw new Error("Assertion failure - must be config item");return t},h=c.map(f),y=u.map(f),g=[[]],E=[];if(yield*b(s,(function*e(t,r){const n=[];for(let e=0;e<t.length;e++){const s=t[e];if(!1!==s.options)try{s.ownPass?n.push({preset:yield*P(s,p),pass:[]}):n.unshift({preset:yield*P(s,p),pass:r});}catch(r){throw "BABEL_UNKNOWN_OPTION"===r.code&&(0,d.checkNoUnwrappedItemOptionPairs)(t,e,"preset",r),r}}if(n.length>0){g.splice(1,0,...n.map((e=>e.pass)).filter((e=>e!==r)));for(const{preset:t,pass:r}of n){if(!t)return !0;if(r.push(...t.plugins),yield*e(t.presets,r))return !0;t.options.forEach((e=>{(0,i.mergeOptions)(a,e);}));}}}))(h,g[0]))return null;const v=a;(0, i.mergeOptions)(v,n);const T=Object.assign({},p,{assumptions:null!=(t=v.assumptions)?t:{}});return yield*b(s,(function*(){g[0].unshift(...y);for(const e of g){const t=[];E.push(t);for(let r=0;r<e.length;r++){const n=e[r];if(!1!==n.options)try{t.push(yield*x(n,T));}catch(t){throw "BABEL_UNKNOWN_PLUGIN_PROPERTY"===t.code&&(0,d.checkNoUnwrappedItemOptionPairs)(e,r,"plugin",t),t}}}}))(),v.plugins=E[0],v.presets=E.slice(1).filter((e=>e.length>0)).map((e=>({plugins:e}))),v.passPerPreset=v.presets.length>0,{options:v,passes:E}})));function b(e,t){return function*(r,n){try{return yield*t(r,n)}catch(t){throw /^\[BABEL\]/.test(t.message)||(t.message=`[BABEL] ${e.filename||"unknown"}: ${t.message}`),t}}}t.default=y;const g=e=>(0, p.makeWeakCache)((function*({value:t,options:r,dirname:n,alias:i},a){if(!1===r)throw new Error("Assertion failure");r=r||{};let l=t;if("function"==typeof t){const u=(0, s.maybeAsync)(t,"You appear to be using an async plugin/preset, but Babel has been called synchronously"),c=Object.assign({},o,e(a));try{l=yield*u(c,r,n);}catch(e){throw i&&(e.message+=` (While processing: ${JSON.stringify(i)})`),e}}if(!l||"object"!=typeof l)throw new Error("Plugin/Preset did not return an object.");if((0, s.isThenable)(l))throw yield*[],new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(i)})`);return {value:l,options:r,dirname:n,alias:i}})),E=g(h.makePluginAPI),v=g(h.makePresetAPI);function*x(e,t){if(e.value instanceof a.default){if(e.options)throw new Error("Passed options to an existing Plugin instance will not work.");return e.value}return yield*T(yield*E(e,t),t)}const T=(0, p.makeWeakCache)((function*({value:e,options:t,dirname:r,alias:n},i){const o=(0, f.validatePluginObject)(e),l=Object.assign({},o);if(l.visitor&&(l.visitor=c().default.explode(Object.assign({},l.visitor))),l.inherits){const e={name:void 0,alias:`${n}$inherits`,value:l.inherits,options:t,dirname:r},o=yield*(0, s.forwardAsync)(x,(t=>i.invalidate((r=>t(e,r)))));l.pre=w(o.pre,l.pre),l.post=w(o.post,l.post),l.manipulateOptions=w(o.manipulateOptions,l.manipulateOptions),l.visitor=c().default.visitors.merge([o.visitor||{},l.visitor||{}]);}return new a.default(l,t,n)})),S=(e,t)=>{if(e.test||e.include||e.exclude){const e=t.name?`"${t.name}"`:"/* your preset */";throw new Error([`Preset ${e} requires a filename to be set when babel is called directly,`,"```",`babel.transform(code, { filename: 'file.ts', presets: [${e}] });`,"```","See https://babeljs.io/docs/en/options#filename for more information."].join("\n"))}};function*P(e,t){const r=A(yield*v(e,t));return ((e,t,r)=>{if(!t.filename){const{options:t}=e;S(t,r),t.overrides&&t.overrides.forEach((e=>S(e,r)));}})(r,t,e),yield*(0, u.buildPresetChain)(r,t)}const A=(0, p.makeWeakCacheSync)((({value:e,dirname:t,alias:r})=>({options:(0, d.validate)("preset",e),alias:r,dirname:t})));function w(e,t){const r=[e,t].filter(Boolean);return r.length<=1?r[0]:function(...e){for(const t of r)t.apply(this,e);}}},"./node_modules/@babel/core/lib/config/helpers/config-api.js":(e,t,r)=>{function n(){const e=r("./node_modules/@babel/core/node_modules/semver/semver.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.makeConfigAPI=o,t.makePresetAPI=a,t.makePluginAPI=function(e){return Object.assign({},a(e),{assumption:t=>e.using((e=>e.assumptions[t]))})};var s=r("./node_modules/@babel/core/lib/index.js"),i=r("./node_modules/@babel/core/lib/config/caching.js");function o(e){return {version:s.version,cache:e.simple(),env:t=>e.using((e=>void 0===t?e.envName:"function"==typeof t?(0, i.assertSimpleType)(t(e.envName)):(Array.isArray(t)||(t=[t]),t.some((t=>{if("string"!=typeof t)throw new Error("Unexpected non-string value");return t===e.envName}))))),async:()=>!1,caller:t=>e.using((e=>(0, i.assertSimpleType)(t(e.caller)))),assertVersion:l}}function a(e){return Object.assign({},o(e),{targets:()=>JSON.parse(e.using((e=>JSON.stringify(e.targets))))})}function l(e){if("number"==typeof e){if(!Number.isInteger(e))throw new Error("Expected string or integer value.");e=`^${e}.0.0-0`;}if("string"!=typeof e)throw new Error("Expected string or integer value.");if(n().satisfies(s.version,e))return;const t=Error.stackTraceLimit;"number"==typeof t&&t<25&&(Error.stackTraceLimit=25);const r=new Error(`Requires Babel "${e}", but was loaded with "${s.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);throw "number"==typeof t&&(Error.stackTraceLimit=t),Object.assign(r,{code:"BABEL_VERSION_UNSUPPORTED",version:s.version,range:e})}r("./node_modules/@babel/core/lib/config/cache-contexts.js");},"./node_modules/@babel/core/lib/config/helpers/environment.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getEnv=function(e="development"){return process.env.BABEL_ENV||process.env.NODE_ENV||e};},"./node_modules/@babel/core/lib/config/index.js":(e,t,r)=>{function n(){const e=r("./node_modules/gensync/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.createConfigItem=function(e,t,r){return void 0!==r?l.errback(e,t,r):"function"==typeof t?l.errback(e,void 0,r):l.sync(e,t)},Object.defineProperty(t,"default",{enumerable:!0,get:function(){return s.default}}),t.createConfigItemAsync=t.createConfigItemSync=t.loadOptionsAsync=t.loadOptionsSync=t.loadOptions=t.loadPartialConfigAsync=t.loadPartialConfigSync=t.loadPartialConfig=void 0;var s=r("./node_modules/@babel/core/lib/config/full.js"),i=r("./node_modules/@babel/core/lib/config/partial.js"),o=r("./node_modules/@babel/core/lib/config/item.js");const a=n()((function*(e){var t;const r=yield*(0, s.default)(e);return null!=(t=null==r?void 0:r.options)?t:null})),l=n()(o.createConfigItem),u=e=>(t,r)=>(void 0===r&&"function"==typeof t&&(r=t,t=void 0),r?e.errback(t,r):e.sync(t)),c=u(i.loadPartialConfig);t.loadPartialConfig=c;const p=i.loadPartialConfig.sync;t.loadPartialConfigSync=p;const d=i.loadPartialConfig.async;t.loadPartialConfigAsync=d;const f=u(a);t.loadOptions=f;const h=a.sync;t.loadOptionsSync=h;const m=a.async;t.loadOptionsAsync=m;const y=l.sync;t.createConfigItemSync=y;const b=l.async;t.createConfigItemAsync=b;},"./node_modules/@babel/core/lib/config/item.js":(e,t,r)=>{function n(){const e=r("path");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.createItemFromDescriptor=i,t.createConfigItem=function*(e,{dirname:t=".",type:r}={}){return i(yield*(0, s.createDescriptor)(e,n().resolve(t),{type:r,alias:"programmatic item"}))},t.getItemDescriptor=function(e){if(null!=e&&e[o])return e._descriptor};var s=r("./node_modules/@babel/core/lib/config/config-descriptors.js");function i(e){return new a(e)}const o=Symbol.for("@babel/core@7 - ConfigItem");class a{constructor(e){this._descriptor=void 0,this[o]=!0,this.value=void 0,this.options=void 0,this.dirname=void 0,this.name=void 0,this.file=void 0,this._descriptor=e,Object.defineProperty(this,"_descriptor",{enumerable:!1}),Object.defineProperty(this,o,{enumerable:!1}),this.value=this._descriptor.value,this.options=this._descriptor.options,this.dirname=this._descriptor.dirname,this.name=this._descriptor.name,this.file=this._descriptor.file?{request:this._descriptor.file.request,resolved:this._descriptor.file.resolved}:void 0,Object.freeze(this);}}Object.freeze(a.prototype);},"./node_modules/@babel/core/lib/config/partial.js":(e,t,r)=>{function n(){const e=r("path");return n=function(){return e},e}function s(){const e=r("./node_modules/gensync/index.js");return s=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=f,t.loadPartialConfig=void 0;var i=r("./node_modules/@babel/core/lib/config/plugin.js"),o=r("./node_modules/@babel/core/lib/config/util.js"),a=r("./node_modules/@babel/core/lib/config/item.js"),l=r("./node_modules/@babel/core/lib/config/config-chain.js"),u=r("./node_modules/@babel/core/lib/config/helpers/environment.js"),c=r("./node_modules/@babel/core/lib/config/validation/options.js"),p=r("./node_modules/@babel/core/lib/config/files/index.js"),d=r("./node_modules/@babel/core/lib/config/resolve-targets.js");function*f(e){if(null!=e&&("object"!=typeof e||Array.isArray(e)))throw new Error("Babel options must be an object, null, or undefined");const t=e?(0, c.validate)("arguments",e):{},{envName:r=(0, u.getEnv)(),cwd:s=".",root:i=".",rootMode:f="root",caller:h,cloneInputAst:m=!0}=t,y=n().resolve(s),b=function(e,t){switch(t){case"root":return e;case"upward-optional":{const t=(0, p.findConfigUpwards)(e);return null===t?e:t}case"upward":{const t=(0, p.findConfigUpwards)(e);if(null!==t)return t;throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e}".\nOne of the following config files must be in the directory tree: "${p.ROOT_CONFIG_FILENAMES.join(", ")}".`),{code:"BABEL_ROOT_NOT_FOUND",dirname:e})}default:throw new Error("Assertion failure - unknown rootMode value.")}}(n().resolve(y,i),f),g="string"==typeof t.filename?n().resolve(s,t.filename):void 0,E={filename:g,cwd:y,root:b,envName:r,caller:h,showConfig:(yield*(0, p.resolveShowConfigPath)(y))===g},v=yield*(0, l.buildRootChain)(t,E);if(!v)return null;const x={assumptions:{}};return v.options.forEach((e=>{(0, o.mergeOptions)(x,e);})),{options:Object.assign({},x,{targets:(0, d.resolveTargets)(x,b),cloneInputAst:m,babelrc:!1,configFile:!1,browserslistConfigFile:!1,passPerPreset:!1,envName:E.envName,cwd:E.cwd,root:E.root,rootMode:"root",filename:"string"==typeof E.filename?E.filename:void 0,plugins:v.plugins.map((e=>(0, a.createItemFromDescriptor)(e))),presets:v.presets.map((e=>(0, a.createItemFromDescriptor)(e)))}),context:E,fileHandling:v.fileHandling,ignore:v.ignore,babelrc:v.babelrc,config:v.config,files:v.files}}const h=s()((function*(e){let t=!1;if("object"==typeof e&&null!==e&&!Array.isArray(e)){var r=e;(({showIgnoredFiles:t}=r)),e=function(e,t){if(null==e)return {};var r,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(s[r]=e[r]);return s}(r,["showIgnoredFiles"]);}const n=yield*f(e);if(!n)return null;const{options:s,babelrc:o,ignore:a,config:l,fileHandling:u,files:c}=n;return "ignored"!==u||t?((s.plugins||[]).forEach((e=>{if(e.value instanceof i.default)throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()")})),new m(s,o?o.filepath:void 0,a?a.filepath:void 0,l?l.filepath:void 0,u,c)):null}));t.loadPartialConfig=h;class m{constructor(e,t,r,n,s,i){this.options=void 0,this.babelrc=void 0,this.babelignore=void 0,this.config=void 0,this.fileHandling=void 0,this.files=void 0,this.options=e,this.babelignore=r,this.babelrc=t,this.config=n,this.fileHandling=s,this.files=i,Object.freeze(this);}hasFilesystemConfig(){return void 0!==this.babelrc||void 0!==this.config}}Object.freeze(m.prototype);},"./node_modules/@babel/core/lib/config/pattern-to-regex.js":(e,t,r)=>{function n(){const e=r("path");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){const r=n().resolve(t,e).split(n().sep);return new RegExp(["^",...r.map(((e,t)=>{const n=t===r.length-1;return "**"===e?n?c:u:"*"===e?n?l:a:0===e.indexOf("*.")?o+p(e.slice(1))+(n?i:s):p(e)+(n?i:s)}))].join(""))};const s=`\\${n().sep}`,i=`(?:${s}|$)`,o=`[^${s}]+`,a=`(?:${o}${s})`,l=`(?:${o}${i})`,u=`${a}*?`,c=`${a}*?${l}?`;function p(e){return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&")}},"./node_modules/@babel/core/lib/config/plugin.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,t.default=class{constructor(e,t,r){this.key=void 0,this.manipulateOptions=void 0,this.post=void 0,this.pre=void 0,this.visitor=void 0,this.parserOverride=void 0,this.generatorOverride=void 0,this.options=void 0,this.key=e.name||r,this.manipulateOptions=e.manipulateOptions,this.post=e.post,this.pre=e.pre,this.visitor=e.visitor||{},this.parserOverride=e.parserOverride,this.generatorOverride=e.generatorOverride,this.options=t;}};},"./node_modules/@babel/core/lib/config/printer.js":(e,t,r)=>{function n(){const e=r("./node_modules/gensync/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.ConfigPrinter=t.ChainFormatter=void 0;const s={Programmatic:0,Config:1};t.ChainFormatter=s;const i={title(e,t,r){let n="";return e===s.Programmatic?(n="programmatic options",t&&(n+=" from "+t)):n="config "+r,n},loc(e,t){let r="";return null!=e&&(r+=`.overrides[${e}]`),null!=t&&(r+=`.env["${t}"]`),r},*optionsAndDescriptors(e){const t=Object.assign({},e.options);delete t.overrides,delete t.env;const r=[...yield*e.plugins()];r.length&&(t.plugins=r.map((e=>o(e))));const n=[...yield*e.presets()];return n.length&&(t.presets=[...n].map((e=>o(e)))),JSON.stringify(t,void 0,2)}};function o(e){var t;let r=null==(t=e.file)?void 0:t.request;return null==r&&("object"==typeof e.value?r=e.value:"function"==typeof e.value&&(r=`[Function: ${e.value.toString().substr(0,50)} ... ]`)),null==r&&(r="[Unknown]"),void 0===e.options?r:null==e.name?[r,e.options]:[r,e.options,e.name]}class a{constructor(){this._stack=[];}configure(e,t,{callerName:r,filepath:n}){return e?(e,s,i)=>{this._stack.push({type:t,callerName:r,filepath:n,content:e,index:s,envName:i});}:()=>{}}static*format(e){let t=i.title(e.type,e.callerName,e.filepath);const r=i.loc(e.index,e.envName);return r&&(t+=` ${r}`),`${t}\n${yield*i.optionsAndDescriptors(e.content)}`}*output(){return 0===this._stack.length?"":(yield*n().all(this._stack.map((e=>a.format(e))))).join("\n\n")}}t.ConfigPrinter=a;},"./node_modules/@babel/core/lib/config/resolve-targets.js":(e,t,r)=>{function n(){const e=r("path");return n=function(){return e},e}function s(){const e=r("./stubs/helper_compilation_targets.js");return s=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.resolveBrowserslistConfigFile=function(e,t){return n().resolve(t,e)},t.resolveTargets=function(e,t){let r=e.targets;("string"==typeof r||Array.isArray(r))&&(r={browsers:r}),r&&r.esmodules&&(r=Object.assign({},r,{esmodules:"intersect"}));const{browserslistConfigFile:n}=e;let i,o=!1;return "string"==typeof n?i=n:o=!1===n,(0, s().default)(r,{ignoreBrowserslistConfig:o,configFile:i,configPath:t,browserslistEnv:e.browserslistEnv})};},"./node_modules/@babel/core/lib/config/util.js":(e,t)=>{function r(e,t){for(const r of Object.keys(t)){const n=t[r];void 0!==n&&(e[r]=n);}}Object.defineProperty(t,"__esModule",{value:!0}),t.mergeOptions=function(e,t){for(const n of Object.keys(t))if("parserOpts"!==n&&"generatorOpts"!==n&&"assumptions"!==n||!t[n]){const r=t[n];void 0!==r&&(e[n]=r);}else {const s=t[n];r(e[n]||(e[n]={}),s);}},t.isIterableIterator=function(e){return !!e&&"function"==typeof e.next&&"function"==typeof e[Symbol.iterator]};},"./node_modules/@babel/core/lib/config/validation/option-assertions.js":(e,t,r)=>{function n(){const e=r("./stubs/helper_compilation_targets.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.msg=i,t.access=o,t.assertRootMode=function(e,t){if(void 0!==t&&"root"!==t&&"upward"!==t&&"upward-optional"!==t)throw new Error(`${i(e)} must be a "root", "upward", "upward-optional" or undefined`);return t},t.assertSourceMaps=function(e,t){if(void 0!==t&&"boolean"!=typeof t&&"inline"!==t&&"both"!==t)throw new Error(`${i(e)} must be a boolean, "inline", "both", or undefined`);return t},t.assertCompact=function(e,t){if(void 0!==t&&"boolean"!=typeof t&&"auto"!==t)throw new Error(`${i(e)} must be a boolean, "auto", or undefined`);return t},t.assertSourceType=function(e,t){if(void 0!==t&&"module"!==t&&"script"!==t&&"unambiguous"!==t)throw new Error(`${i(e)} must be "module", "script", "unambiguous", or undefined`);return t},t.assertCallerMetadata=function(e,t){const r=l(e,t);if(r){if("string"!=typeof r.name)throw new Error(`${i(e)} set but does not contain "name" property string`);for(const t of Object.keys(r)){const n=o(e,t),s=r[t];if(null!=s&&"boolean"!=typeof s&&"string"!=typeof s&&"number"!=typeof s)throw new Error(`${i(n)} must be null, undefined, a boolean, a string, or a number.`)}}return t},t.assertInputSourceMap=function(e,t){if(void 0!==t&&"boolean"!=typeof t&&("object"!=typeof t||!t))throw new Error(`${i(e)} must be a boolean, object, or undefined`);return t},t.assertString=function(e,t){if(void 0!==t&&"string"!=typeof t)throw new Error(`${i(e)} must be a string, or undefined`);return t},t.assertFunction=function(e,t){if(void 0!==t&&"function"!=typeof t)throw new Error(`${i(e)} must be a function, or undefined`);return t},t.assertBoolean=a,t.assertObject=l,t.assertArray=u,t.assertIgnoreList=function(e,t){const r=u(e,t);return r&&r.forEach(((t,r)=>function(e,t){if("string"!=typeof t&&"function"!=typeof t&&!(t instanceof RegExp))throw new Error(`${i(e)} must be an array of string/Function/RegExp values, or undefined`);return t}(o(e,r),t))),r},t.assertConfigApplicableTest=function(e,t){if(void 0===t)return t;if(Array.isArray(t))t.forEach(((t,r)=>{if(!c(t))throw new Error(`${i(o(e,r))} must be a string/Function/RegExp.`)}));else if(!c(t))throw new Error(`${i(e)} must be a string/Function/RegExp, or an array of those`);return t},t.assertConfigFileSearch=function(e,t){if(void 0!==t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`${i(e)} must be a undefined, a boolean, a string, got ${JSON.stringify(t)}`);return t},t.assertBabelrcSearch=function(e,t){if(void 0===t||"boolean"==typeof t)return t;if(Array.isArray(t))t.forEach(((t,r)=>{if(!c(t))throw new Error(`${i(o(e,r))} must be a string/Function/RegExp.`)}));else if(!c(t))throw new Error(`${i(e)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t)}`);return t},t.assertPluginList=function(e,t){const r=u(e,t);return r&&r.forEach(((t,r)=>function(e,t){if(Array.isArray(t)){if(0===t.length)throw new Error(`${i(e)} must include an object`);if(t.length>3)throw new Error(`${i(e)} may only be a two-tuple or three-tuple`);if(p(o(e,0),t[0]),t.length>1){const r=t[1];if(void 0!==r&&!1!==r&&("object"!=typeof r||Array.isArray(r)||null===r))throw new Error(`${i(o(e,1))} must be an object, false, or undefined`)}if(3===t.length){const r=t[2];if(void 0!==r&&"string"!=typeof r)throw new Error(`${i(o(e,2))} must be a string, or undefined`)}}else p(e,t);return t}(o(e,r),t))),r},t.assertTargets=function(e,t){if((0, n().isBrowsersQueryValid)(t))return t;if("object"!=typeof t||!t||Array.isArray(t))throw new Error(`${i(e)} must be a string, an array of strings or an object`);const r=o(e,"browsers"),s=o(e,"esmodules");d(r,t.browsers),a(s,t.esmodules);for(const r of Object.keys(t)){const s=t[r],l=o(e,r);if("esmodules"===r)a(l,s);else if("browsers"===r)d(l,s);else {if(!Object.hasOwnProperty.call(n().TargetNames,r)){const e=Object.keys(n().TargetNames).join(", ");throw new Error(`${i(l)} is not a valid target. Supported targets are ${e}`)}f(l,s);}}return t},t.assertAssumptions=function(e,t){if(void 0===t)return;if("object"!=typeof t||null===t)throw new Error(`${i(e)} must be an object or undefined.`);let r=e;do{r=r.parent;}while("root"!==r.type);const n="preset"===r.source;for(const r of Object.keys(t)){const a=o(e,r);if(!s.assumptionsNames.has(r))throw new Error(`${i(a)} is not a supported assumption.`);if("boolean"!=typeof t[r])throw new Error(`${i(a)} must be a boolean.`);if(n&&!1===t[r])throw new Error(`${i(a)} cannot be set to 'false' inside presets.`)}return t};var s=r("./node_modules/@babel/core/lib/config/validation/options.js");function i(e){switch(e.type){case"root":return "";case"env":return `${i(e.parent)}.env["${e.name}"]`;case"overrides":return `${i(e.parent)}.overrides[${e.index}]`;case"option":return `${i(e.parent)}.${e.name}`;case"access":return `${i(e.parent)}[${JSON.stringify(e.name)}]`;default:throw new Error(`Assertion failure: Unknown type ${e.type}`)}}function o(e,t){return {type:"access",name:t,parent:e}}function a(e,t){if(void 0!==t&&"boolean"!=typeof t)throw new Error(`${i(e)} must be a boolean, or undefined`);return t}function l(e,t){if(void 0!==t&&("object"!=typeof t||Array.isArray(t)||!t))throw new Error(`${i(e)} must be an object, or undefined`);return t}function u(e,t){if(null!=t&&!Array.isArray(t))throw new Error(`${i(e)} must be an array, or undefined`);return t}function c(e){return "string"==typeof e||"function"==typeof e||e instanceof RegExp}function p(e,t){if(("object"!=typeof t||!t)&&"string"!=typeof t&&"function"!=typeof t)throw new Error(`${i(e)} must be a string, object, function`);return t}function d(e,t){if(void 0!==t&&!(0, n().isBrowsersQueryValid)(t))throw new Error(`${i(e)} must be undefined, a string or an array of strings`)}function f(e,t){if(("number"!=typeof t||Math.round(t)!==t)&&"string"!=typeof t)throw new Error(`${i(e)} must be a string or an integer number`)}},"./node_modules/@babel/core/lib/config/validation/options.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.validate=function(e,t){return p({type:"root",source:e},t)},t.checkNoUnwrappedItemOptionPairs=function(e,t,r,n){if(0===t)return;const s=e[t-1],i=e[t];s.file&&void 0===s.options&&"object"==typeof i.value&&(n.message+=`\n- Maybe you meant to use\n"${r}": [\n  ["${s.file.request}", ${JSON.stringify(i.value,void 0,2)}]\n]\nTo be a valid ${r}, its name and options should be wrapped in a pair of brackets`);},t.assumptionsNames=void 0,r("./node_modules/@babel/core/lib/config/plugin.js");var n=r("./node_modules/@babel/core/lib/config/validation/removed.js"),s=r("./node_modules/@babel/core/lib/config/validation/option-assertions.js");const i={cwd:s.assertString,root:s.assertString,rootMode:s.assertRootMode,configFile:s.assertConfigFileSearch,caller:s.assertCallerMetadata,filename:s.assertString,filenameRelative:s.assertString,code:s.assertBoolean,ast:s.assertBoolean,cloneInputAst:s.assertBoolean,envName:s.assertString},o={babelrc:s.assertBoolean,babelrcRoots:s.assertBabelrcSearch},a={extends:s.assertString,ignore:s.assertIgnoreList,only:s.assertIgnoreList,targets:s.assertTargets,browserslistConfigFile:s.assertConfigFileSearch,browserslistEnv:s.assertString},l={inputSourceMap:s.assertInputSourceMap,presets:s.assertPluginList,plugins:s.assertPluginList,passPerPreset:s.assertBoolean,assumptions:s.assertAssumptions,env:function(e,t){if("env"===e.parent.type)throw new Error(`${(0, s.msg)(e)} is not allowed inside of another .env block`);const r=e.parent,n=(0, s.assertObject)(e,t);if(n)for(const t of Object.keys(n)){const i=(0, s.assertObject)((0, s.access)(e,t),n[t]);i&&p({type:"env",name:t,parent:r},i);}return n},overrides:function(e,t){if("env"===e.parent.type)throw new Error(`${(0, s.msg)(e)} is not allowed inside an .env block`);if("overrides"===e.parent.type)throw new Error(`${(0, s.msg)(e)} is not allowed inside an .overrides block`);const r=e.parent,n=(0, s.assertArray)(e,t);if(n)for(const[t,i]of n.entries()){const n=(0, s.access)(e,t),o=(0, s.assertObject)(n,i);if(!o)throw new Error(`${(0, s.msg)(n)} must be an object`);p({type:"overrides",index:t,parent:r},o);}return n},test:s.assertConfigApplicableTest,include:s.assertConfigApplicableTest,exclude:s.assertConfigApplicableTest,retainLines:s.assertBoolean,comments:s.assertBoolean,shouldPrintComment:s.assertFunction,compact:s.assertCompact,minified:s.assertBoolean,auxiliaryCommentBefore:s.assertString,auxiliaryCommentAfter:s.assertString,sourceType:s.assertSourceType,wrapPluginVisitorMethod:s.assertFunction,highlightCode:s.assertBoolean,sourceMaps:s.assertSourceMaps,sourceMap:s.assertSourceMaps,sourceFileName:s.assertString,sourceRoot:s.assertString,parserOpts:s.assertObject,generatorOpts:s.assertObject};Object.assign(l,{getModuleId:s.assertFunction,moduleRoot:s.assertString,moduleIds:s.assertBoolean,moduleId:s.assertString});const u=new Set(["arrayLikeIsIterable","constantReexports","constantSuper","enumerableModuleMeta","ignoreFunctionLength","ignoreToPrimitiveHint","iterableIsArray","mutableTemplateObject","noClassCalls","noDocumentAll","noNewArrows","objectRestNoSymbols","privateFieldsAsProperties","pureGetters","setClassMethods","setComputedProperties","setPublicClassFields","setSpreadProperties","skipForOfIteratorClosing","superIsCallableConstructor"]);function c(e){return "root"===e.type?e.source:c(e.parent)}function p(e,t){const r=c(e);return function(e){if(f(e,"sourceMap")&&f(e,"sourceMaps"))throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both")}(t),Object.keys(t).forEach((n=>{const u={type:"option",name:n,parent:e};if("preset"===r&&a[n])throw new Error(`${(0, s.msg)(u)} is not allowed in preset options`);if("arguments"!==r&&i[n])throw new Error(`${(0, s.msg)(u)} is only allowed in root programmatic options`);if("arguments"!==r&&"configfile"!==r&&o[n]){if("babelrcfile"===r||"extendsfile"===r)throw new Error(`${(0, s.msg)(u)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);throw new Error(`${(0, s.msg)(u)} is only allowed in root programmatic options, or babel.config.js/config file options`)}(l[n]||a[n]||o[n]||i[n]||d)(u,t[n]);})),t}function d(e){const t=e.name;if(n.default[t]){const{message:r,version:i=5}=n.default[t];throw new Error(`Using removed Babel ${i} option: ${(0, s.msg)(e)} - ${r}`)}{const t=new Error(`Unknown option: ${(0, s.msg)(e)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);throw t.code="BABEL_UNKNOWN_OPTION",t}}function f(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.assumptionsNames=u;},"./node_modules/@babel/core/lib/config/validation/plugins.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.validatePluginObject=function(e){const t={type:"root",source:"plugin"};return Object.keys(e).forEach((r=>{const n=s[r];if(!n){const e=new Error(`.${r} is not a valid Plugin property`);throw e.code="BABEL_UNKNOWN_PLUGIN_PROPERTY",e}n({type:"option",name:r,parent:t},e[r]);})),e};var n=r("./node_modules/@babel/core/lib/config/validation/option-assertions.js");const s={name:n.assertString,manipulateOptions:n.assertFunction,pre:n.assertFunction,post:n.assertFunction,inherits:n.assertFunction,visitor:function(e,t){const r=(0, n.assertObject)(e,t);if(r&&(Object.keys(r).forEach((e=>function(e,t){if(t&&"object"==typeof t)Object.keys(t).forEach((t=>{if("enter"!==t&&"exit"!==t)throw new Error(`.visitor["${e}"] may only have .enter and/or .exit handlers.`)}));else if("function"!=typeof t)throw new Error(`.visitor["${e}"] must be a function`);return t}(e,r[e]))),r.enter||r.exit))throw new Error(`${(0, n.msg)(e)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);return r},parserOverride:n.assertFunction,generatorOverride:n.assertFunction};},"./node_modules/@babel/core/lib/config/validation/removed.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,t.default={auxiliaryComment:{message:"Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"},blacklist:{message:"Put the specific transforms you want in the `plugins` option"},breakConfig:{message:"This is not a necessary option in Babel 6"},experimental:{message:"Put the specific transforms you want in the `plugins` option"},externalHelpers:{message:"Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"},extra:{message:""},jsxPragma:{message:"use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"},loose:{message:"Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."},metadataUsedHelpers:{message:"Not required anymore as this is enabled by default"},modules:{message:"Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"},nonStandard:{message:"Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"},optional:{message:"Put the specific transforms you want in the `plugins` option"},sourceMapName:{message:"The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."},stage:{message:"Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"},whitelist:{message:"Put the specific transforms you want in the `plugins` option"},resolveModuleSource:{version:6,message:"Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"},metadata:{version:6,message:"Generated plugin metadata is always included in the output result"},sourceMapTarget:{version:6,message:"The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."}};},"./node_modules/@babel/core/lib/gensync-utils/async.js":(e,t,r)=>{function n(){const e=r("./node_modules/gensync/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.maybeAsync=function(e,t){return n()({sync(...r){const n=e.apply(this,r);if(c(n))throw new Error(t);return n},async(...t){return Promise.resolve(e.apply(this,t))}})},t.forwardAsync=function(e,t){const r=n()(e);return a((e=>{const n=r[e];return t(n)}))},t.isThenable=c,t.waitFor=t.onFirstPause=t.isAsync=void 0;const s=e=>e,i=n()((function*(e){return yield*e})),o=n()({sync:()=>!1,errback:e=>e(null,!0)});t.isAsync=o;const a=n()({sync:e=>e("sync"),async:e=>e("async")}),l=n()({name:"onFirstPause",arity:2,sync:function(e){return i.sync(e)},errback:function(e,t,r){let n=!1;i.errback(e,((e,t)=>{n=!0,r(e,t);})),n||t();}});t.onFirstPause=l;const u=n()({sync:s,async:s});function c(e){return !(!e||"object"!=typeof e&&"function"!=typeof e||!e.then||"function"!=typeof e.then)}t.waitFor=u;},"./node_modules/@babel/core/lib/gensync-utils/fs.js":(e,t,r)=>{function n(){const e=r("fs");return n=function(){return e},e}function s(){const e=r("./node_modules/gensync/index.js");return s=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.stat=t.readFile=void 0;const i=s()({sync:n().readFileSync,errback:n().readFile});t.readFile=i;const o=s()({sync:n().statSync,errback:n().stat});t.stat=o;},"./node_modules/@babel/core/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Plugin=function(e){throw new Error(`The (${e}) Babel 5 plugin is being run with an unsupported Babel version.`)},Object.defineProperty(t,"File",{enumerable:!0,get:function(){return n.default}}),Object.defineProperty(t,"buildExternalHelpers",{enumerable:!0,get:function(){return s.default}}),Object.defineProperty(t,"resolvePlugin",{enumerable:!0,get:function(){return i.resolvePlugin}}),Object.defineProperty(t,"resolvePreset",{enumerable:!0,get:function(){return i.resolvePreset}}),Object.defineProperty(t,"getEnv",{enumerable:!0,get:function(){return o.getEnv}}),Object.defineProperty(t,"tokTypes",{enumerable:!0,get:function(){return l().tokTypes}}),Object.defineProperty(t,"traverse",{enumerable:!0,get:function(){return u().default}}),Object.defineProperty(t,"template",{enumerable:!0,get:function(){return c().default}}),Object.defineProperty(t,"createConfigItem",{enumerable:!0,get:function(){return p.createConfigItem}}),Object.defineProperty(t,"createConfigItemSync",{enumerable:!0,get:function(){return p.createConfigItemSync}}),Object.defineProperty(t,"createConfigItemAsync",{enumerable:!0,get:function(){return p.createConfigItemAsync}}),Object.defineProperty(t,"loadPartialConfig",{enumerable:!0,get:function(){return p.loadPartialConfig}}),Object.defineProperty(t,"loadPartialConfigSync",{enumerable:!0,get:function(){return p.loadPartialConfigSync}}),Object.defineProperty(t,"loadPartialConfigAsync",{enumerable:!0,get:function(){return p.loadPartialConfigAsync}}),Object.defineProperty(t,"loadOptions",{enumerable:!0,get:function(){return p.loadOptions}}),Object.defineProperty(t,"loadOptionsSync",{enumerable:!0,get:function(){return p.loadOptionsSync}}),Object.defineProperty(t,"loadOptionsAsync",{enumerable:!0,get:function(){return p.loadOptionsAsync}}),Object.defineProperty(t,"transform",{enumerable:!0,get:function(){return d.transform}}),Object.defineProperty(t,"transformSync",{enumerable:!0,get:function(){return d.transformSync}}),Object.defineProperty(t,"transformAsync",{enumerable:!0,get:function(){return d.transformAsync}}),Object.defineProperty(t,"transformFile",{enumerable:!0,get:function(){return f.transformFile}}),Object.defineProperty(t,"transformFileSync",{enumerable:!0,get:function(){return f.transformFileSync}}),Object.defineProperty(t,"transformFileAsync",{enumerable:!0,get:function(){return f.transformFileAsync}}),Object.defineProperty(t,"transformFromAst",{enumerable:!0,get:function(){return h.transformFromAst}}),Object.defineProperty(t,"transformFromAstSync",{enumerable:!0,get:function(){return h.transformFromAstSync}}),Object.defineProperty(t,"transformFromAstAsync",{enumerable:!0,get:function(){return h.transformFromAstAsync}}),Object.defineProperty(t,"parse",{enumerable:!0,get:function(){return m.parse}}),Object.defineProperty(t,"parseSync",{enumerable:!0,get:function(){return m.parseSync}}),Object.defineProperty(t,"parseAsync",{enumerable:!0,get:function(){return m.parseAsync}}),t.types=t.OptionManager=t.DEFAULT_EXTENSIONS=t.version=void 0;var n=r("./node_modules/@babel/core/lib/transformation/file/file.js"),s=r("./node_modules/@babel/core/lib/tools/build-external-helpers.js"),i=r("./node_modules/@babel/core/lib/config/files/index.js"),o=r("./node_modules/@babel/core/lib/config/helpers/environment.js");function a(){const e=r("./node_modules/@babel/types/lib/index.js");return a=function(){return e},e}function l(){const e=r("./node_modules/@babel/parser/lib/index.js");return l=function(){return e},e}function u(){const e=r("./node_modules/@babel/traverse/lib/index.js");return u=function(){return e},e}function c(){const e=r("./node_modules/@babel/template/lib/index.js");return c=function(){return e},e}Object.defineProperty(t,"types",{enumerable:!0,get:function(){return a()}});var p=r("./node_modules/@babel/core/lib/config/index.js"),d=r("./node_modules/@babel/core/lib/transform.js"),f=r("./node_modules/@babel/core/lib/transform-file.js"),h=r("./node_modules/@babel/core/lib/transform-ast.js"),m=r("./node_modules/@babel/core/lib/parse.js");t.version="7.14.3";const y=Object.freeze([".js",".jsx",".es6",".es",".mjs",".cjs"]);t.DEFAULT_EXTENSIONS=y,t.OptionManager=class{init(e){return (0, p.loadOptions)(e)}};},"./node_modules/@babel/core/lib/parse.js":(e,t,r)=>{function n(){const e=r("./node_modules/gensync/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.parseAsync=t.parseSync=t.parse=void 0;var s=r("./node_modules/@babel/core/lib/config/index.js"),i=r("./node_modules/@babel/core/lib/parser/index.js"),o=r("./node_modules/@babel/core/lib/transformation/normalize-opts.js");const a=n()((function*(e,t){const r=yield*(0, s.default)(t);return null===r?null:yield*(0, i.default)(r.passes,(0, o.default)(r),e)}));t.parse=function(e,t,r){if("function"==typeof t&&(r=t,t=void 0),void 0===r)return a.sync(e,t);a.errback(e,t,r);};const l=a.sync;t.parseSync=l;const u=a.async;t.parseAsync=u;},"./node_modules/@babel/core/lib/parser/index.js":(e,t,r)=>{function n(){const e=r("./node_modules/@babel/parser/lib/index.js");return n=function(){return e},e}function s(){const e=r("./stubs/babel_codeframe.js");return s=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function*(e,{parserOpts:t,highlightCode:r=!0,filename:o="unknown"},a){try{const r=[];for(const s of e)for(const e of s){const{parserOverride:s}=e;if(s){const e=s(a,t,n().parse);void 0!==e&&r.push(e);}}if(0===r.length)return (0,n().parse)(a,t);if(1===r.length){if(yield*[],"function"==typeof r[0].then)throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");return r[0]}throw new Error("More than one plugin attempted to override parsing.")}catch(e){"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"===e.code&&(e.message+="\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.");const{loc:t,missingPlugin:n}=e;if(t){const l=(0, s().codeFrameColumns)(a,{start:{line:t.line,column:t.column+1}},{highlightCode:r});e.message=n?`${o}: `+(0, i.default)(n[0],t,l):`${o}: ${e.message}\n\n`+l,e.code="BABEL_PARSE_ERROR";}throw e}};var i=r("./node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js");},"./node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,s){let i=`Support for the experimental syntax '${e}' isn't currently enabled (${t.line}:${t.column+1}):\n\n`+s;const o=r[e];if(o){const{syntax:e,transform:t}=o;if(e){const r=n(e);if(t){i+=`\n\nAdd ${n(t)} to the '${t.name.startsWith("@babel/plugin")?"plugins":"presets"}' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add ${r} to the 'plugins' section to enable parsing.`;}else i+=`\n\nAdd ${r} to the 'plugins' section of your Babel config to enable parsing.`;}}return i};const r={asyncDoExpressions:{syntax:{name:"@babel/plugin-syntax-async-do-expressions",url:"https://git.io/JYer8"}},classProperties:{syntax:{name:"@babel/plugin-syntax-class-properties",url:"https://git.io/vb4yQ"},transform:{name:"@babel/plugin-proposal-class-properties",url:"https://git.io/vb4SL"}},classPrivateProperties:{syntax:{name:"@babel/plugin-syntax-class-properties",url:"https://git.io/vb4yQ"},transform:{name:"@babel/plugin-proposal-class-properties",url:"https://git.io/vb4SL"}},classPrivateMethods:{syntax:{name:"@babel/plugin-syntax-class-properties",url:"https://git.io/vb4yQ"},transform:{name:"@babel/plugin-proposal-private-methods",url:"https://git.io/JvpRG"}},classStaticBlock:{syntax:{name:"@babel/plugin-syntax-class-static-block",url:"https://git.io/JTLB6"},transform:{name:"@babel/plugin-proposal-class-static-block",url:"https://git.io/JTLBP"}},decimal:{syntax:{name:"@babel/plugin-syntax-decimal",url:"https://git.io/JfKOH"}},decorators:{syntax:{name:"@babel/plugin-syntax-decorators",url:"https://git.io/vb4y9"},transform:{name:"@babel/plugin-proposal-decorators",url:"https://git.io/vb4ST"}},doExpressions:{syntax:{name:"@babel/plugin-syntax-do-expressions",url:"https://git.io/vb4yh"},transform:{name:"@babel/plugin-proposal-do-expressions",url:"https://git.io/vb4S3"}},dynamicImport:{syntax:{name:"@babel/plugin-syntax-dynamic-import",url:"https://git.io/vb4Sv"}},exportDefaultFrom:{syntax:{name:"@babel/plugin-syntax-export-default-from",url:"https://git.io/vb4SO"},transform:{name:"@babel/plugin-proposal-export-default-from",url:"https://git.io/vb4yH"}},exportNamespaceFrom:{syntax:{name:"@babel/plugin-syntax-export-namespace-from",url:"https://git.io/vb4Sf"},transform:{name:"@babel/plugin-proposal-export-namespace-from",url:"https://git.io/vb4SG"}},flow:{syntax:{name:"@babel/plugin-syntax-flow",url:"https://git.io/vb4yb"},transform:{name:"@babel/preset-flow",url:"https://git.io/JfeDn"}},functionBind:{syntax:{name:"@babel/plugin-syntax-function-bind",url:"https://git.io/vb4y7"},transform:{name:"@babel/plugin-proposal-function-bind",url:"https://git.io/vb4St"}},functionSent:{syntax:{name:"@babel/plugin-syntax-function-sent",url:"https://git.io/vb4yN"},transform:{name:"@babel/plugin-proposal-function-sent",url:"https://git.io/vb4SZ"}},importMeta:{syntax:{name:"@babel/plugin-syntax-import-meta",url:"https://git.io/vbKK6"}},jsx:{syntax:{name:"@babel/plugin-syntax-jsx",url:"https://git.io/vb4yA"},transform:{name:"@babel/preset-react",url:"https://git.io/JfeDR"}},importAssertions:{syntax:{name:"@babel/plugin-syntax-import-assertions",url:"https://git.io/JUbkv"}},moduleStringNames:{syntax:{name:"@babel/plugin-syntax-module-string-names",url:"https://git.io/JTL8G"}},numericSeparator:{syntax:{name:"@babel/plugin-syntax-numeric-separator",url:"https://git.io/vb4Sq"},transform:{name:"@babel/plugin-proposal-numeric-separator",url:"https://git.io/vb4yS"}},optionalChaining:{syntax:{name:"@babel/plugin-syntax-optional-chaining",url:"https://git.io/vb4Sc"},transform:{name:"@babel/plugin-proposal-optional-chaining",url:"https://git.io/vb4Sk"}},pipelineOperator:{syntax:{name:"@babel/plugin-syntax-pipeline-operator",url:"https://git.io/vb4yj"},transform:{name:"@babel/plugin-proposal-pipeline-operator",url:"https://git.io/vb4SU"}},privateIn:{syntax:{name:"@babel/plugin-syntax-private-property-in-object",url:"https://git.io/JfK3q"},transform:{name:"@babel/plugin-proposal-private-property-in-object",url:"https://git.io/JfK3O"}},recordAndTuple:{syntax:{name:"@babel/plugin-syntax-record-and-tuple",url:"https://git.io/JvKp3"}},throwExpressions:{syntax:{name:"@babel/plugin-syntax-throw-expressions",url:"https://git.io/vb4SJ"},transform:{name:"@babel/plugin-proposal-throw-expressions",url:"https://git.io/vb4yF"}},typescript:{syntax:{name:"@babel/plugin-syntax-typescript",url:"https://git.io/vb4SC"},transform:{name:"@babel/preset-typescript",url:"https://git.io/JfeDz"}},asyncGenerators:{syntax:{name:"@babel/plugin-syntax-async-generators",url:"https://git.io/vb4SY"},transform:{name:"@babel/plugin-proposal-async-generator-functions",url:"https://git.io/vb4yp"}},logicalAssignment:{syntax:{name:"@babel/plugin-syntax-logical-assignment-operators",url:"https://git.io/vAlBp"},transform:{name:"@babel/plugin-proposal-logical-assignment-operators",url:"https://git.io/vAlRe"}},nullishCoalescingOperator:{syntax:{name:"@babel/plugin-syntax-nullish-coalescing-operator",url:"https://git.io/vb4yx"},transform:{name:"@babel/plugin-proposal-nullish-coalescing-operator",url:"https://git.io/vb4Se"}},objectRestSpread:{syntax:{name:"@babel/plugin-syntax-object-rest-spread",url:"https://git.io/vb4y5"},transform:{name:"@babel/plugin-proposal-object-rest-spread",url:"https://git.io/vb4Ss"}},optionalCatchBinding:{syntax:{name:"@babel/plugin-syntax-optional-catch-binding",url:"https://git.io/vb4Sn"},transform:{name:"@babel/plugin-proposal-optional-catch-binding",url:"https://git.io/vb4SI"}}};r.privateIn.syntax=r.privateIn.transform;const n=({name:e,url:t})=>`${e} (${t})`;},"./node_modules/@babel/core/lib/tools/build-external-helpers.js":(e,t,r)=>{function n(){const e=r("./node_modules/@babel/helpers/lib/index.js");return n=function(){return e},e}function s(){const e=r("./node_modules/@babel/generator/lib/index.js");return s=function(){return e},e}function i(){const e=r("./node_modules/@babel/template/lib/index.js");return i=function(){return e},e}function o(){const e=r("./node_modules/@babel/types/lib/index.js");return o=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t="global"){let r;const n={global:l,module:u,umd:c,var:p}[t];if(!n)throw new Error(`Unsupported output type ${t}`);return r=n(e),(0, s().default)(r).code};var a=r("./node_modules/@babel/core/lib/transformation/file/file.js");function l(e){const t=o().identifier("babelHelpers"),r=[],n=o().functionExpression(null,[o().identifier("global")],o().blockStatement(r)),s=o().program([o().expressionStatement(o().callExpression(n,[o().conditionalExpression(o().binaryExpression("===",o().unaryExpression("typeof",o().identifier("global")),o().stringLiteral("undefined")),o().identifier("self"),o().identifier("global"))]))]);return r.push(o().variableDeclaration("var",[o().variableDeclarator(t,o().assignmentExpression("=",o().memberExpression(o().identifier("global"),t),o().objectExpression([])))])),d(r,t,e),s}function u(e){const t=[],r=d(t,null,e);return t.unshift(o().exportNamedDeclaration(null,Object.keys(r).map((e=>o().exportSpecifier(o().cloneNode(r[e]),o().identifier(e)))))),o().program(t,[],"module")}function c(e){const t=o().identifier("babelHelpers"),r=[];return r.push(o().variableDeclaration("var",[o().variableDeclarator(t,o().identifier("global"))])),d(r,t,e),o().program([(n={FACTORY_PARAMETERS:o().identifier("global"),BROWSER_ARGUMENTS:o().assignmentExpression("=",o().memberExpression(o().identifier("root"),t),o().objectExpression([])),COMMON_ARGUMENTS:o().identifier("exports"),AMD_ARGUMENTS:o().arrayExpression([o().stringLiteral("exports")]),FACTORY_BODY:r,UMD_ROOT:o().identifier("this")},i().default`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(n))]);var n;}function p(e){const t=o().identifier("babelHelpers"),r=[];r.push(o().variableDeclaration("var",[o().variableDeclarator(t,o().objectExpression([]))]));const n=o().program(r);return d(r,t,e),r.push(o().expressionStatement(t)),n}function d(e,t,r){const s=e=>t?o().memberExpression(t,o().identifier(e)):o().identifier(`_${e}`),i={};return n().list.forEach((function(t){if(r&&r.indexOf(t)<0)return;const o=i[t]=s(t);n().ensure(t,a.default);const{nodes:l}=n().get(t,s,o);e.push(...l);})),i}},"./node_modules/@babel/core/lib/transform-ast.js":(e,t,r)=>{function n(){const e=r("./node_modules/gensync/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.transformFromAstAsync=t.transformFromAstSync=t.transformFromAst=void 0;var s=r("./node_modules/@babel/core/lib/config/index.js"),i=r("./node_modules/@babel/core/lib/transformation/index.js");const o=n()((function*(e,t,r){const n=yield*(0, s.default)(r);if(null===n)return null;if(!e)throw new Error("No AST given");return yield*(0, i.run)(n,t,e)}));t.transformFromAst=function(e,t,r,n){if("function"==typeof r&&(n=r,r=void 0),void 0===n)return o.sync(e,t,r);o.errback(e,t,r,n);};const a=o.sync;t.transformFromAstSync=a;const l=o.async;t.transformFromAstAsync=l;},"./node_modules/@babel/core/lib/transform-file.js":(e,t,r)=>{function n(){const e=r("./node_modules/gensync/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.transformFileAsync=t.transformFileSync=t.transformFile=void 0;var s=r("./node_modules/@babel/core/lib/config/index.js"),i=r("./node_modules/@babel/core/lib/transformation/index.js"),o=r("./node_modules/@babel/core/lib/gensync-utils/fs.js");const a=n()((function*(e,t){const r=Object.assign({},t,{filename:e}),n=yield*(0, s.default)(r);if(null===n)return null;const a=yield*o.readFile(e,"utf8");return yield*(0, i.run)(n,a)})),l=a.errback;t.transformFile=l;const u=a.sync;t.transformFileSync=u;const c=a.async;t.transformFileAsync=c;},"./node_modules/@babel/core/lib/transform.js":(e,t,r)=>{function n(){const e=r("./node_modules/gensync/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.transformAsync=t.transformSync=t.transform=void 0;var s=r("./node_modules/@babel/core/lib/config/index.js"),i=r("./node_modules/@babel/core/lib/transformation/index.js");const o=n()((function*(e,t){const r=yield*(0, s.default)(t);return null===r?null:yield*(0, i.run)(r,e)}));t.transform=function(e,t,r){if("function"==typeof t&&(r=t,t=void 0),void 0===r)return o.sync(e,t);o.errback(e,t,r);};const a=o.sync;t.transformSync=a;const l=o.async;t.transformAsync=l;},"./node_modules/@babel/core/lib/transformation/block-hoist-plugin.js":(e,t,r)=>{function n(){const e=r("./node_modules/@babel/traverse/lib/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){return i||(i=new s.default(Object.assign({},a,{visitor:n().default.explode(a.visitor)}),{})),i};var s=r("./node_modules/@babel/core/lib/config/plugin.js");let i;function o(e){const t=null==e?void 0:e._blockHoist;return null==t?1:!0===t?2:t}const a={name:"internal.blockHoist",visitor:{Block:{exit({node:e}){const{body:t}=e;let r=Math.pow(2,30)-1,n=!1;for(let e=0;e<t.length;e++){const s=o(t[e]);if(s>r){n=!0;break}r=s;}n&&(e.body=function(e){const t=Object.create(null);for(let r=0;r<e.length;r++){const n=e[r],s=o(n);(t[s]||(t[s]=[])).push(n);}const r=Object.keys(t).map((e=>+e)).sort(((e,t)=>t-e));let n=0;for(const s of r){const r=t[s];for(const t of r)e[n++]=t;}return e}(t.slice()));}}}};},"./node_modules/@babel/core/lib/transformation/file/file.js":(e,t,r)=>{function n(){const e=r("./node_modules/@babel/helpers/lib/index.js");return n=function(){return e},e}function s(){const e=r("./node_modules/@babel/traverse/lib/index.js");return s=function(){return e},e}function i(){const e=r("./stubs/babel_codeframe.js");return i=function(){return e},e}function o(){const e=r("./node_modules/@babel/types/lib/index.js");return o=function(){return e},e}function a(){const e=r("./node_modules/@babel/helper-module-transforms/lib/index.js");return a=function(){return e},e}function l(){const e=r("./node_modules/@babel/core/node_modules/semver/semver.js");return l=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;const u={enter(e,t){const r=e.node.loc;r&&(t.loc=r,e.stop());}};class c{constructor(e,{code:t,ast:r,inputMap:n}){this._map=new Map,this.opts=void 0,this.declarations={},this.path=null,this.ast={},this.scope=void 0,this.metadata={},this.code="",this.inputMap=null,this.hub={file:this,getCode:()=>this.code,getScope:()=>this.scope,addHelper:this.addHelper.bind(this),buildError:this.buildCodeFrameError.bind(this)},this.opts=e,this.code=t,this.ast=r,this.inputMap=n,this.path=s().NodePath.get({hub:this.hub,parentPath:null,parent:this.ast,container:this.ast,key:"program"}).setContext(),this.scope=this.path.scope;}get shebang(){const{interpreter:e}=this.path.node;return e?e.value:""}set shebang(e){e?this.path.get("interpreter").replaceWith(o().interpreterDirective(e)):this.path.get("interpreter").remove();}set(e,t){if("helpersNamespace"===e)throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");this._map.set(e,t);}get(e){return this._map.get(e)}has(e){return this._map.has(e)}getModuleName(){return (0, a().getModuleName)(this.opts,this.opts)}addImport(){throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.")}availableHelper(e,t){let r;try{r=n().minVersion(e);}catch(e){if("BABEL_HELPER_UNKNOWN"!==e.code)throw e;return !1}return "string"!=typeof t||(l().valid(t)&&(t=`^${t}`),!l().intersects(`<${r}`,t)&&!l().intersects(">=8.0.0",t))}addHelper(e){const t=this.declarations[e];if(t)return o().cloneNode(t);const r=this.get("helperGenerator");if(r){const t=r(e);if(t)return t}n().ensure(e,c);const s=this.declarations[e]=this.scope.generateUidIdentifier(e),i={};for(const t of n().getDependencies(e))i[t]=this.addHelper(t);const{nodes:a,globals:l}=n().get(e,(e=>i[e]),s,Object.keys(this.scope.getAllBindings()));return l.forEach((e=>{this.path.scope.hasBinding(e,!0)&&this.path.scope.rename(e);})),a.forEach((e=>{e._compact=!0;})),this.path.unshiftContainer("body",a),this.path.get("body").forEach((e=>{-1!==a.indexOf(e.node)&&e.isVariableDeclaration()&&this.scope.registerDeclaration(e);})),s}addTemplateObject(){throw new Error("This function has been moved into the template literal transform itself.")}buildCodeFrameError(e,t,r=SyntaxError){let n=e&&(e.loc||e._loc);if(!n&&e){const r={loc:null};(0, s().default)(e,u,this.scope,r),n=r.loc;let i="This is an error on an internal node. Probably an internal error.";n&&(i+=" Location has been estimated."),t+=` (${i})`;}if(n){const{highlightCode:e=!0}=this.opts;t+="\n"+(0, i().codeFrameColumns)(this.code,{start:{line:n.start.line,column:n.start.column+1},end:n.end&&n.start.line===n.end.line?{line:n.end.line,column:n.end.column+1}:void 0},{highlightCode:e});}return new r(t)}}t.default=c;},"./node_modules/@babel/core/lib/transformation/file/generate.js":(e,t,r)=>{function n(){const e=r("./node_modules/convert-source-map/index.js");return n=function(){return e},e}function s(){const e=r("./node_modules/@babel/generator/lib/index.js");return s=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){const{opts:r,ast:o,code:a,inputMap:l}=t,u=[];for(const t of e)for(const e of t){const{generatorOverride:t}=e;if(t){const e=t(o,r.generatorOpts,a,s().default);void 0!==e&&u.push(e);}}let c;if(0===u.length)c=(0, s().default)(o,r.generatorOpts,a);else {if(1!==u.length)throw new Error("More than one plugin attempted to override codegen.");if(c=u[0],"function"==typeof c.then)throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.")}let{code:p,map:d}=c;return d&&l&&(d=(0, i.default)(l.toObject(),d)),"inline"!==r.sourceMaps&&"both"!==r.sourceMaps||(p+="\n"+n().fromObject(d).toComment()),"inline"===r.sourceMaps&&(d=null),{outputCode:p,outputMap:d}};var i=r("./node_modules/@babel/core/lib/transformation/file/merge-map.js");},"./node_modules/@babel/core/lib/transformation/file/merge-map.js":(e,t,r)=>{function n(){const e=r("./node_modules/@babel/core/node_modules/source-map/source-map.js");return n=function(){return e},e}function s(e){return `${e.line}/${e.columnStart}`}function i(e){const t=new(n().SourceMapConsumer)(Object.assign({},e,{sourceRoot:null})),r=new Map,s=new Map;let i=null;return t.computeColumnSpans(),t.eachMapping((e=>{if(null===e.originalLine)return;let n=r.get(e.source);n||(n={path:e.source,content:t.sourceContentFor(e.source,!0)},r.set(e.source,n));let o=s.get(n);o||(o={source:n,mappings:[]},s.set(n,o));const a={line:e.originalLine,columnStart:e.originalColumn,columnEnd:1/0,name:e.name};i&&i.source===n&&i.mapping.line===e.originalLine&&(i.mapping.columnEnd=e.originalColumn),i={source:n,mapping:a},o.mappings.push({original:a,generated:t.allGeneratedPositionsFor({source:e.source,line:e.originalLine,column:e.originalColumn}).map((e=>({line:e.line,columnStart:e.column,columnEnd:e.lastColumn+1})))});}),null,n().SourceMapConsumer.ORIGINAL_ORDER),{file:e.file,sourceRoot:e.sourceRoot,sources:Array.from(s.values())}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){const r=i(e),o=i(t),a=new(n().SourceMapGenerator);for(const{source:e}of r.sources)"string"==typeof e.content&&a.setSourceContent(e.path,e.content);if(1===o.sources.length){const e=o.sources[0],t=new Map;!function(e,t){for(const{source:r,mappings:n}of e.sources)for(const{original:e,generated:s}of n)for(const n of s)t(n,e,r);}(r,((r,n,i)=>{!function(e,t,r){const n=function({mappings:e},{line:t,columnStart:r,columnEnd:n}){return function(e,t){const r=[];for(let n=function(e,t){let r=0,n=e.length;for(;r<n;){const s=Math.floor((r+n)/2),i=t(e[s]);if(0===i){r=s;break}i>=0?n=s:r=s+1;}let s=r;if(s<e.length){for(;s>=0&&t(e[s])>=0;)s--;return s+1}return s}(e,t);n<e.length&&0===t(e[n]);n++)r.push(e[n]);return r}(e,(({original:e})=>t>e.line?-1:t<e.line?1:r>=e.columnEnd?-1:n<=e.columnStart?1:0))}(e,t);for(const{generated:e}of n)for(const t of e)r(t);}(e,r,(e=>{const r=s(e);t.has(r)||(t.set(r,e),a.addMapping({source:i.path,original:{line:n.line,column:n.columnStart},generated:{line:e.line,column:e.columnStart},name:n.name}));}));}));for(const e of t.values()){if(e.columnEnd===1/0)continue;const r={line:e.line,columnStart:e.columnEnd},n=s(r);t.has(n)||a.addMapping({generated:{line:r.line,column:r.columnStart}});}}const l=a.toJSON();return "string"==typeof r.sourceRoot&&(l.sourceRoot=r.sourceRoot),l};},"./node_modules/@babel/core/lib/transformation/index.js":(e,t,r)=>{function n(){const e=r("./node_modules/@babel/traverse/lib/index.js");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.run=function*(e,t,r){const c=yield*(0, a.default)(e.passes,(0, o.default)(e),t,r),p=c.opts;try{yield*function*(e,t){for(const r of t){const t=[],o=[],a=[];for(const n of r.concat([(0,i.default)()])){const r=new s.default(e,n.key,n.options);t.push([n,r]),o.push(r),a.push(n.visitor);}for(const[r,n]of t){const t=r.pre;if(t){const r=t.call(n,e);if(yield*[],u(r))throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.")}}const l=n().default.visitors.merge(a,o,e.opts.wrapPluginVisitorMethod);(0,n().default)(e.ast,l,e.scope);for(const[r,n]of t){const t=r.post;if(t){const r=t.call(n,e);if(yield*[],u(r))throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.")}}}}(c,e.passes);}catch(e){var d;throw e.message=`${null!=(d=p.filename)?d:"unknown"}: ${e.message}`,e.code||(e.code="BABEL_TRANSFORM_ERROR"),e}let f,h;try{!1!==p.code&&({outputCode:f,outputMap:h}=(0,l.default)(e.passes,c));}catch(e){var m;throw e.message=`${null!=(m=p.filename)?m:"unknown"}: ${e.message}`,e.code||(e.code="BABEL_GENERATE_ERROR"),e}return {metadata:c.metadata,options:p,ast:!0===p.ast?c.ast:null,code:void 0===f?null:f,map:void 0===h?null:h,sourceType:c.ast.program.sourceType}};var s=r("./node_modules/@babel/core/lib/transformation/plugin-pass.js"),i=r("./node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"),o=r("./node_modules/@babel/core/lib/transformation/normalize-opts.js"),a=r("./node_modules/@babel/core/lib/transformation/normalize-file.js"),l=r("./node_modules/@babel/core/lib/transformation/file/generate.js");function u(e){return !(!e||"object"!=typeof e&&"function"!=typeof e||!e.then||"function"!=typeof e.then)}},"./node_modules/@babel/core/lib/transformation/normalize-file.js":(e,t,r)=>{function n(){const e=r("fs");return n=function(){return e},e}function s(){const e=r("path");return s=function(){return e},e}function i(){const e=r("./node_modules/debug/src/index.js");return i=function(){return e},e}function o(){const e=r("./node_modules/@babel/types/lib/index.js");return o=function(){return e},e}function a(){const e=r("./node_modules/convert-source-map/index.js");return a=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function*(e,t,r,i){if(r=`${r||""}`,i){if("Program"===i.type)i=o().file(i,[],[]);else if("File"!==i.type)throw new Error("AST root must be a Program or File node");t.cloneInputAst&&(i=(0, c.default)(i));}else i=yield*(0, u.default)(e,t,r);let h=null;if(!1!==t.inputSourceMap){if("object"==typeof t.inputSourceMap&&(h=a().fromObject(t.inputSourceMap)),!h){const e=m(d,i);if(e)try{h=a().fromComment(e);}catch(e){p("discarding unknown inline input sourcemap",e);}}if(!h){const e=m(f,i);if("string"==typeof t.filename&&e)try{const r=f.exec(e),i=n().readFileSync(s().resolve(s().dirname(t.filename),r[1]));i.length>1e6?p("skip merging input map > 1 MB"):h=a().fromJSON(i);}catch(e){p("discarding unknown file input sourcemap",e);}else e&&p("discarding un-loadable file input sourcemap");}}return new l.default(t,{code:r,ast:i,inputMap:h})};var l=r("./node_modules/@babel/core/lib/transformation/file/file.js"),u=r("./node_modules/@babel/core/lib/parser/index.js"),c=r("./node_modules/@babel/core/lib/transformation/util/clone-deep.js");const p=i()("babel:transform:file"),d=/^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/,f=/^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;function h(e,t,r){return t&&(t=t.filter((({value:t})=>!e.test(t)||(r=t,!1)))),[t,r]}function m(e,t){let r=null;return o().traverseFast(t,(t=>{[t.leadingComments,r]=h(e,t.leadingComments,r),[t.innerComments,r]=h(e,t.innerComments,r),[t.trailingComments,r]=h(e,t.trailingComments,r);})),r}},"./node_modules/@babel/core/lib/transformation/normalize-opts.js":(e,t,r)=>{function n(){const e=r("path");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){const{filename:t,cwd:r,filenameRelative:s=("string"==typeof t?n().relative(r,t):"unknown"),sourceType:i="module",inputSourceMap:o,sourceMaps:a=!!o,sourceRoot:l=e.options.moduleRoot,sourceFileName:u=n().basename(s),comments:c=!0,compact:p="auto"}=e.options,d=e.options,f=Object.assign({},d,{parserOpts:Object.assign({sourceType:".mjs"===n().extname(s)?"module":i,sourceFileName:t,plugins:[]},d.parserOpts),generatorOpts:Object.assign({filename:t,auxiliaryCommentBefore:d.auxiliaryCommentBefore,auxiliaryCommentAfter:d.auxiliaryCommentAfter,retainLines:d.retainLines,comments:c,shouldPrintComment:d.shouldPrintComment,compact:p,minified:d.minified,sourceMaps:a,sourceRoot:l,sourceFileName:u},d.generatorOpts)});for(const t of e.passes)for(const e of t)e.manipulateOptions&&e.manipulateOptions(f,f.parserOpts);return f};},"./node_modules/@babel/core/lib/transformation/plugin-pass.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;class r{constructor(e,t,r){this._map=new Map,this.key=void 0,this.file=void 0,this.opts=void 0,this.cwd=void 0,this.filename=void 0,this.key=t,this.file=e,this.opts=r||{},this.cwd=e.opts.cwd,this.filename=e.opts.filename;}set(e,t){this._map.set(e,t);}get(e){return this._map.get(e)}availableHelper(e,t){return this.file.availableHelper(e,t)}addHelper(e){return this.file.addHelper(e)}addImport(){return this.file.addImport()}buildCodeFrameError(e,t,r){return this.file.buildCodeFrameError(e,t,r)}}t.default=r,r.prototype.getModuleName=function(){return this.file.getModuleName()};},"./node_modules/@babel/core/lib/transformation/util/clone-deep-browser.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return JSON.parse(JSON.stringify(e,n),s)};const r="$$ babel internal serialized type"+Math.random();function n(e,t){return "bigint"!=typeof t?t:{[r]:"BigInt",value:t.toString()}}function s(e,t){return t&&"object"==typeof t?"BigInt"!==t[r]?t:BigInt(t.value):t}},"./node_modules/@babel/core/lib/transformation/util/clone-deep.js":(e,t,r)=>{function n(){const e=r("v8");return n=function(){return e},e}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return n().deserialize&&n().serialize?n().deserialize(n().serialize(e)):(0, s.default)(e)};var s=r("./node_modules/@babel/core/lib/transformation/util/clone-deep-browser.js");},"./node_modules/@babel/core/node_modules/semver/semver.js":(e,t)=>{var r;t=e.exports=p,r="object"==typeof process&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?function(){var e=Array.prototype.slice.call(arguments,0);e.unshift("SEMVER"),console.log.apply(console,e);}:function(){},t.SEMVER_SPEC_VERSION="2.0.0";var n=Number.MAX_SAFE_INTEGER||9007199254740991,s=t.re=[],i=t.src=[],o=t.tokens={},a=0;function l(e){o[e]=a++;}l("NUMERICIDENTIFIER"),i[o.NUMERICIDENTIFIER]="0|[1-9]\\d*",l("NUMERICIDENTIFIERLOOSE"),i[o.NUMERICIDENTIFIERLOOSE]="[0-9]+",l("NONNUMERICIDENTIFIER"),i[o.NONNUMERICIDENTIFIER]="\\d*[a-zA-Z-][a-zA-Z0-9-]*",l("MAINVERSION"),i[o.MAINVERSION]="("+i[o.NUMERICIDENTIFIER]+")\\.("+i[o.NUMERICIDENTIFIER]+")\\.("+i[o.NUMERICIDENTIFIER]+")",l("MAINVERSIONLOOSE"),i[o.MAINVERSIONLOOSE]="("+i[o.NUMERICIDENTIFIERLOOSE]+")\\.("+i[o.NUMERICIDENTIFIERLOOSE]+")\\.("+i[o.NUMERICIDENTIFIERLOOSE]+")",l("PRERELEASEIDENTIFIER"),i[o.PRERELEASEIDENTIFIER]="(?:"+i[o.NUMERICIDENTIFIER]+"|"+i[o.NONNUMERICIDENTIFIER]+")",l("PRERELEASEIDENTIFIERLOOSE"),i[o.PRERELEASEIDENTIFIERLOOSE]="(?:"+i[o.NUMERICIDENTIFIERLOOSE]+"|"+i[o.NONNUMERICIDENTIFIER]+")",l("PRERELEASE"),i[o.PRERELEASE]="(?:-("+i[o.PRERELEASEIDENTIFIER]+"(?:\\."+i[o.PRERELEASEIDENTIFIER]+")*))",l("PRERELEASELOOSE"),i[o.PRERELEASELOOSE]="(?:-?("+i[o.PRERELEASEIDENTIFIERLOOSE]+"(?:\\."+i[o.PRERELEASEIDENTIFIERLOOSE]+")*))",l("BUILDIDENTIFIER"),i[o.BUILDIDENTIFIER]="[0-9A-Za-z-]+",l("BUILD"),i[o.BUILD]="(?:\\+("+i[o.BUILDIDENTIFIER]+"(?:\\."+i[o.BUILDIDENTIFIER]+")*))",l("FULL"),l("FULLPLAIN"),i[o.FULLPLAIN]="v?"+i[o.MAINVERSION]+i[o.PRERELEASE]+"?"+i[o.BUILD]+"?",i[o.FULL]="^"+i[o.FULLPLAIN]+"$",l("LOOSEPLAIN"),i[o.LOOSEPLAIN]="[v=\\s]*"+i[o.MAINVERSIONLOOSE]+i[o.PRERELEASELOOSE]+"?"+i[o.BUILD]+"?",l("LOOSE"),i[o.LOOSE]="^"+i[o.LOOSEPLAIN]+"$",l("GTLT"),i[o.GTLT]="((?:<|>)?=?)",l("XRANGEIDENTIFIERLOOSE"),i[o.XRANGEIDENTIFIERLOOSE]=i[o.NUMERICIDENTIFIERLOOSE]+"|x|X|\\*",l("XRANGEIDENTIFIER"),i[o.XRANGEIDENTIFIER]=i[o.NUMERICIDENTIFIER]+"|x|X|\\*",l("XRANGEPLAIN"),i[o.XRANGEPLAIN]="[v=\\s]*("+i[o.XRANGEIDENTIFIER]+")(?:\\.("+i[o.XRANGEIDENTIFIER]+")(?:\\.("+i[o.XRANGEIDENTIFIER]+")(?:"+i[o.PRERELEASE]+")?"+i[o.BUILD]+"?)?)?",l("XRANGEPLAINLOOSE"),i[o.XRANGEPLAINLOOSE]="[v=\\s]*("+i[o.XRANGEIDENTIFIERLOOSE]+")(?:\\.("+i[o.XRANGEIDENTIFIERLOOSE]+")(?:\\.("+i[o.XRANGEIDENTIFIERLOOSE]+")(?:"+i[o.PRERELEASELOOSE]+")?"+i[o.BUILD]+"?)?)?",l("XRANGE"),i[o.XRANGE]="^"+i[o.GTLT]+"\\s*"+i[o.XRANGEPLAIN]+"$",l("XRANGELOOSE"),i[o.XRANGELOOSE]="^"+i[o.GTLT]+"\\s*"+i[o.XRANGEPLAINLOOSE]+"$",l("COERCE"),i[o.COERCE]="(^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])",l("COERCERTL"),s[o.COERCERTL]=new RegExp(i[o.COERCE],"g"),l("LONETILDE"),i[o.LONETILDE]="(?:~>?)",l("TILDETRIM"),i[o.TILDETRIM]="(\\s*)"+i[o.LONETILDE]+"\\s+",s[o.TILDETRIM]=new RegExp(i[o.TILDETRIM],"g"),l("TILDE"),i[o.TILDE]="^"+i[o.LONETILDE]+i[o.XRANGEPLAIN]+"$",l("TILDELOOSE"),i[o.TILDELOOSE]="^"+i[o.LONETILDE]+i[o.XRANGEPLAINLOOSE]+"$",l("LONECARET"),i[o.LONECARET]="(?:\\^)",l("CARETTRIM"),i[o.CARETTRIM]="(\\s*)"+i[o.LONECARET]+"\\s+",s[o.CARETTRIM]=new RegExp(i[o.CARETTRIM],"g"),l("CARET"),i[o.CARET]="^"+i[o.LONECARET]+i[o.XRANGEPLAIN]+"$",l("CARETLOOSE"),i[o.CARETLOOSE]="^"+i[o.LONECARET]+i[o.XRANGEPLAINLOOSE]+"$",l("COMPARATORLOOSE"),i[o.COMPARATORLOOSE]="^"+i[o.GTLT]+"\\s*("+i[o.LOOSEPLAIN]+")$|^$",l("COMPARATOR"),i[o.COMPARATOR]="^"+i[o.GTLT]+"\\s*("+i[o.FULLPLAIN]+")$|^$",l("COMPARATORTRIM"),i[o.COMPARATORTRIM]="(\\s*)"+i[o.GTLT]+"\\s*("+i[o.LOOSEPLAIN]+"|"+i[o.XRANGEPLAIN]+")",s[o.COMPARATORTRIM]=new RegExp(i[o.COMPARATORTRIM],"g"),l("HYPHENRANGE"),i[o.HYPHENRANGE]="^\\s*("+i[o.XRANGEPLAIN]+")\\s+-\\s+("+i[o.XRANGEPLAIN]+")\\s*$",l("HYPHENRANGELOOSE"),i[o.HYPHENRANGELOOSE]="^\\s*("+i[o.XRANGEPLAINLOOSE]+")\\s+-\\s+("+i[o.XRANGEPLAINLOOSE]+")\\s*$",l("STAR"),i[o.STAR]="(<|>)?=?\\s*\\*";for(var u=0;u<a;u++)r(u,i[u]),s[u]||(s[u]=new RegExp(i[u]));function c(e,t){if(t&&"object"==typeof t||(t={loose:!!t,includePrerelease:!1}),e instanceof p)return e;if("string"!=typeof e)return null;if(e.length>256)return null;if(!(t.loose?s[o.LOOSE]:s[o.FULL]).test(e))return null;try{return new p(e,t)}catch(e){return null}}function p(e,t){if(t&&"object"==typeof t||(t={loose:!!t,includePrerelease:!1}),e instanceof p){if(e.loose===t.loose)return e;e=e.version;}else if("string"!=typeof e)throw new TypeError("Invalid Version: "+e);if(e.length>256)throw new TypeError("version is longer than 256 characters");if(!(this instanceof p))return new p(e,t);r("SemVer",e,t),this.options=t,this.loose=!!t.loose;var i=e.trim().match(t.loose?s[o.LOOSE]:s[o.FULL]);if(!i)throw new TypeError("Invalid Version: "+e);if(this.raw=e,this.major=+i[1],this.minor=+i[2],this.patch=+i[3],this.major>n||this.major<0)throw new TypeError("Invalid major version");if(this.minor>n||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>n||this.patch<0)throw new TypeError("Invalid patch version");i[4]?this.prerelease=i[4].split(".").map((function(e){if(/^[0-9]+$/.test(e)){var t=+e;if(t>=0&&t<n)return t}return e})):this.prerelease=[],this.build=i[5]?i[5].split("."):[],this.format();}t.parse=c,t.valid=function(e,t){var r=c(e,t);return r?r.version:null},t.clean=function(e,t){var r=c(e.trim().replace(/^[=v]+/,""),t);return r?r.version:null},t.SemVer=p,p.prototype.format=function(){return this.version=this.major+"."+this.minor+"."+this.patch,this.prerelease.length&&(this.version+="-"+this.prerelease.join(".")),this.version},p.prototype.toString=function(){return this.version},p.prototype.compare=function(e){return r("SemVer.compare",this.version,this.options,e),e instanceof p||(e=new p(e,this.options)),this.compareMain(e)||this.comparePre(e)},p.prototype.compareMain=function(e){return e instanceof p||(e=new p(e,this.options)),f(this.major,e.major)||f(this.minor,e.minor)||f(this.patch,e.patch)},p.prototype.comparePre=function(e){if(e instanceof p||(e=new p(e,this.options)),this.prerelease.length&&!e.prerelease.length)return -1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;var t=0;do{var n=this.prerelease[t],s=e.prerelease[t];if(r("prerelease compare",t,n,s),void 0===n&&void 0===s)return 0;if(void 0===s)return 1;if(void 0===n)return -1;if(n!==s)return f(n,s)}while(++t)},p.prototype.compareBuild=function(e){e instanceof p||(e=new p(e,this.options));var t=0;do{var n=this.build[t],s=e.build[t];if(r("prerelease compare",t,n,s),void 0===n&&void 0===s)return 0;if(void 0===s)return 1;if(void 0===n)return -1;if(n!==s)return f(n,s)}while(++t)},p.prototype.inc=function(e,t){switch(e){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",t);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",t);break;case"prepatch":this.prerelease.length=0,this.inc("patch",t),this.inc("pre",t);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",t),this.inc("pre",t);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else {for(var r=this.prerelease.length;--r>=0;)"number"==typeof this.prerelease[r]&&(this.prerelease[r]++,r=-2);-1===r&&this.prerelease.push(0);}t&&(this.prerelease[0]===t?isNaN(this.prerelease[1])&&(this.prerelease=[t,0]):this.prerelease=[t,0]);break;default:throw new Error("invalid increment argument: "+e)}return this.format(),this.raw=this.version,this},t.inc=function(e,t,r,n){"string"==typeof r&&(n=r,r=void 0);try{return new p(e,r).inc(t,n).version}catch(e){return null}},t.diff=function(e,t){if(b(e,t))return null;var r=c(e),n=c(t),s="";if(r.prerelease.length||n.prerelease.length){s="pre";var i="prerelease";}for(var o in r)if(("major"===o||"minor"===o||"patch"===o)&&r[o]!==n[o])return s+o;return i},t.compareIdentifiers=f;var d=/^[0-9]+$/;function f(e,t){var r=d.test(e),n=d.test(t);return r&&n&&(e=+e,t=+t),e===t?0:r&&!n?-1:n&&!r?1:e<t?-1:1}function h(e,t,r){return new p(e,r).compare(new p(t,r))}function m(e,t,r){return h(e,t,r)>0}function y(e,t,r){return h(e,t,r)<0}function b(e,t,r){return 0===h(e,t,r)}function g(e,t,r){return 0!==h(e,t,r)}function E(e,t,r){return h(e,t,r)>=0}function v(e,t,r){return h(e,t,r)<=0}function x(e,t,r,n){switch(t){case"===":return "object"==typeof e&&(e=e.version),"object"==typeof r&&(r=r.version),e===r;case"!==":return "object"==typeof e&&(e=e.version),"object"==typeof r&&(r=r.version),e!==r;case"":case"=":case"==":return b(e,r,n);case"!=":return g(e,r,n);case">":return m(e,r,n);case">=":return E(e,r,n);case"<":return y(e,r,n);case"<=":return v(e,r,n);default:throw new TypeError("Invalid operator: "+t)}}function T(e,t){if(t&&"object"==typeof t||(t={loose:!!t,includePrerelease:!1}),e instanceof T){if(e.loose===!!t.loose)return e;e=e.value;}if(!(this instanceof T))return new T(e,t);r("comparator",e,t),this.options=t,this.loose=!!t.loose,this.parse(e),this.semver===S?this.value="":this.value=this.operator+this.semver.version,r("comp",this);}t.rcompareIdentifiers=function(e,t){return f(t,e)},t.major=function(e,t){return new p(e,t).major},t.minor=function(e,t){return new p(e,t).minor},t.patch=function(e,t){return new p(e,t).patch},t.compare=h,t.compareLoose=function(e,t){return h(e,t,!0)},t.compareBuild=function(e,t,r){var n=new p(e,r),s=new p(t,r);return n.compare(s)||n.compareBuild(s)},t.rcompare=function(e,t,r){return h(t,e,r)},t.sort=function(e,r){return e.sort((function(e,n){return t.compareBuild(e,n,r)}))},t.rsort=function(e,r){return e.sort((function(e,n){return t.compareBuild(n,e,r)}))},t.gt=m,t.lt=y,t.eq=b,t.neq=g,t.gte=E,t.lte=v,t.cmp=x,t.Comparator=T;var S={};function P(e,t){if(t&&"object"==typeof t||(t={loose:!!t,includePrerelease:!1}),e instanceof P)return e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease?e:new P(e.raw,t);if(e instanceof T)return new P(e.value,t);if(!(this instanceof P))return new P(e,t);if(this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease,this.raw=e,this.set=e.split(/\s*\|\|\s*/).map((function(e){return this.parseRange(e.trim())}),this).filter((function(e){return e.length})),!this.set.length)throw new TypeError("Invalid SemVer Range: "+e);this.format();}function A(e,t){for(var r=!0,n=e.slice(),s=n.pop();r&&n.length;)r=n.every((function(e){return s.intersects(e,t)})),s=n.pop();return r}function w(e){return !e||"x"===e.toLowerCase()||"*"===e}function C(e,t,r,n,s,i,o,a,l,u,c,p,d){return ((t=w(r)?"":w(n)?">="+r+".0.0":w(s)?">="+r+"."+n+".0":">="+t)+" "+(a=w(l)?"":w(u)?"<"+(+l+1)+".0.0":w(c)?"<"+l+"."+(+u+1)+".0":p?"<="+l+"."+u+"."+c+"-"+p:"<="+a)).trim()}function D(e,t,n){for(var s=0;s<e.length;s++)if(!e[s].test(t))return !1;if(t.prerelease.length&&!n.includePrerelease){for(s=0;s<e.length;s++)if(r(e[s].semver),e[s].semver!==S&&e[s].semver.prerelease.length>0){var i=e[s].semver;if(i.major===t.major&&i.minor===t.minor&&i.patch===t.patch)return !0}return !1}return !0}function _(e,t,r){try{t=new P(t,r);}catch(e){return !1}return t.test(e)}function O(e,t,r,n){var s,i,o,a,l;switch(e=new p(e,n),t=new P(t,n),r){case">":s=m,i=v,o=y,a=">",l=">=";break;case"<":s=y,i=E,o=m,a="<",l="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(_(e,t,n))return !1;for(var u=0;u<t.set.length;++u){var c=t.set[u],d=null,f=null;if(c.forEach((function(e){e.semver===S&&(e=new T(">=0.0.0")),d=d||e,f=f||e,s(e.semver,d.semver,n)?d=e:o(e.semver,f.semver,n)&&(f=e);})),d.operator===a||d.operator===l)return !1;if((!f.operator||f.operator===a)&&i(e,f.semver))return !1;if(f.operator===l&&o(e,f.semver))return !1}return !0}T.prototype.parse=function(e){var t=this.options.loose?s[o.COMPARATORLOOSE]:s[o.COMPARATOR],r=e.match(t);if(!r)throw new TypeError("Invalid comparator: "+e);this.operator=void 0!==r[1]?r[1]:"","="===this.operator&&(this.operator=""),r[2]?this.semver=new p(r[2],this.options.loose):this.semver=S;},T.prototype.toString=function(){return this.value},T.prototype.test=function(e){if(r("Comparator.test",e,this.options.loose),this.semver===S||e===S)return !0;if("string"==typeof e)try{e=new p(e,this.options);}catch(e){return !1}return x(e,this.operator,this.semver,this.options)},T.prototype.intersects=function(e,t){if(!(e instanceof T))throw new TypeError("a Comparator is required");var r;if(t&&"object"==typeof t||(t={loose:!!t,includePrerelease:!1}),""===this.operator)return ""===this.value||(r=new P(e.value,t),_(this.value,r,t));if(""===e.operator)return ""===e.value||(r=new P(this.value,t),_(e.semver,r,t));var n=!(">="!==this.operator&&">"!==this.operator||">="!==e.operator&&">"!==e.operator),s=!("<="!==this.operator&&"<"!==this.operator||"<="!==e.operator&&"<"!==e.operator),i=this.semver.version===e.semver.version,o=!(">="!==this.operator&&"<="!==this.operator||">="!==e.operator&&"<="!==e.operator),a=x(this.semver,"<",e.semver,t)&&(">="===this.operator||">"===this.operator)&&("<="===e.operator||"<"===e.operator),l=x(this.semver,">",e.semver,t)&&("<="===this.operator||"<"===this.operator)&&(">="===e.operator||">"===e.operator);return n||s||i&&o||a||l},t.Range=P,P.prototype.format=function(){return this.range=this.set.map((function(e){return e.join(" ").trim()})).join("||").trim(),this.range},P.prototype.toString=function(){return this.range},P.prototype.parseRange=function(e){var t=this.options.loose;e=e.trim();var n=t?s[o.HYPHENRANGELOOSE]:s[o.HYPHENRANGE];e=e.replace(n,C),r("hyphen replace",e),e=e.replace(s[o.COMPARATORTRIM],"$1$2$3"),r("comparator trim",e,s[o.COMPARATORTRIM]),e=(e=(e=e.replace(s[o.TILDETRIM],"$1~")).replace(s[o.CARETTRIM],"$1^")).split(/\s+/).join(" ");var i=t?s[o.COMPARATORLOOSE]:s[o.COMPARATOR],a=e.split(" ").map((function(e){return function(e,t){return r("comp",e,t),e=function(e,t){return e.trim().split(/\s+/).map((function(e){return function(e,t){r("caret",e,t);var n=t.loose?s[o.CARETLOOSE]:s[o.CARET];return e.replace(n,(function(t,n,s,i,o){var a;return r("caret",e,t,n,s,i,o),w(n)?a="":w(s)?a=">="+n+".0.0 <"+(+n+1)+".0.0":w(i)?a="0"===n?">="+n+"."+s+".0 <"+n+"."+(+s+1)+".0":">="+n+"."+s+".0 <"+(+n+1)+".0.0":o?(r("replaceCaret pr",o),a="0"===n?"0"===s?">="+n+"."+s+"."+i+"-"+o+" <"+n+"."+s+"."+(+i+1):">="+n+"."+s+"."+i+"-"+o+" <"+n+"."+(+s+1)+".0":">="+n+"."+s+"."+i+"-"+o+" <"+(+n+1)+".0.0"):(r("no pr"),a="0"===n?"0"===s?">="+n+"."+s+"."+i+" <"+n+"."+s+"."+(+i+1):">="+n+"."+s+"."+i+" <"+n+"."+(+s+1)+".0":">="+n+"."+s+"."+i+" <"+(+n+1)+".0.0"),r("caret return",a),a}))}(e,t)})).join(" ")}(e,t),r("caret",e),e=function(e,t){return e.trim().split(/\s+/).map((function(e){return function(e,t){var n=t.loose?s[o.TILDELOOSE]:s[o.TILDE];return e.replace(n,(function(t,n,s,i,o){var a;return r("tilde",e,t,n,s,i,o),w(n)?a="":w(s)?a=">="+n+".0.0 <"+(+n+1)+".0.0":w(i)?a=">="+n+"."+s+".0 <"+n+"."+(+s+1)+".0":o?(r("replaceTilde pr",o),a=">="+n+"."+s+"."+i+"-"+o+" <"+n+"."+(+s+1)+".0"):a=">="+n+"."+s+"."+i+" <"+n+"."+(+s+1)+".0",r("tilde return",a),a}))}(e,t)})).join(" ")}(e,t),r("tildes",e),e=function(e,t){return r("replaceXRanges",e,t),e.split(/\s+/).map((function(e){return function(e,t){e=e.trim();var n=t.loose?s[o.XRANGELOOSE]:s[o.XRANGE];return e.replace(n,(function(n,s,i,o,a,l){r("xRange",e,n,s,i,o,a,l);var u=w(i),c=u||w(o),p=c||w(a),d=p;return "="===s&&d&&(s=""),l=t.includePrerelease?"-0":"",u?n=">"===s||"<"===s?"<0.0.0-0":"*":s&&d?(c&&(o=0),a=0,">"===s?(s=">=",c?(i=+i+1,o=0,a=0):(o=+o+1,a=0)):"<="===s&&(s="<",c?i=+i+1:o=+o+1),n=s+i+"."+o+"."+a+l):c?n=">="+i+".0.0"+l+" <"+(+i+1)+".0.0"+l:p&&(n=">="+i+"."+o+".0"+l+" <"+i+"."+(+o+1)+".0"+l),r("xRange return",n),n}))}(e,t)})).join(" ")}(e,t),r("xrange",e),e=function(e,t){return r("replaceStars",e,t),e.trim().replace(s[o.STAR],"")}(e,t),r("stars",e),e}(e,this.options)}),this).join(" ").split(/\s+/);return this.options.loose&&(a=a.filter((function(e){return !!e.match(i)}))),a.map((function(e){return new T(e,this.options)}),this)},P.prototype.intersects=function(e,t){if(!(e instanceof P))throw new TypeError("a Range is required");return this.set.some((function(r){return A(r,t)&&e.set.some((function(e){return A(e,t)&&r.every((function(r){return e.every((function(e){return r.intersects(e,t)}))}))}))}))},t.toComparators=function(e,t){return new P(e,t).set.map((function(e){return e.map((function(e){return e.value})).join(" ").trim().split(" ")}))},P.prototype.test=function(e){if(!e)return !1;if("string"==typeof e)try{e=new p(e,this.options);}catch(e){return !1}for(var t=0;t<this.set.length;t++)if(D(this.set[t],e,this.options))return !0;return !1},t.satisfies=_,t.maxSatisfying=function(e,t,r){var n=null,s=null;try{var i=new P(t,r);}catch(e){return null}return e.forEach((function(e){i.test(e)&&(n&&-1!==s.compare(e)||(s=new p(n=e,r)));})),n},t.minSatisfying=function(e,t,r){var n=null,s=null;try{var i=new P(t,r);}catch(e){return null}return e.forEach((function(e){i.test(e)&&(n&&1!==s.compare(e)||(s=new p(n=e,r)));})),n},t.minVersion=function(e,t){e=new P(e,t);var r=new p("0.0.0");if(e.test(r))return r;if(r=new p("0.0.0-0"),e.test(r))return r;r=null;for(var n=0;n<e.set.length;++n)e.set[n].forEach((function(e){var t=new p(e.semver.version);switch(e.operator){case">":0===t.prerelease.length?t.patch++:t.prerelease.push(0),t.raw=t.format();case"":case">=":r&&!m(r,t)||(r=t);break;case"<":case"<=":break;default:throw new Error("Unexpected operation: "+e.operator)}}));return r&&e.test(r)?r:null},t.validRange=function(e,t){try{return new P(e,t).range||"*"}catch(e){return null}},t.ltr=function(e,t,r){return O(e,t,"<",r)},t.gtr=function(e,t,r){return O(e,t,">",r)},t.outside=O,t.prerelease=function(e,t){var r=c(e,t);return r&&r.prerelease.length?r.prerelease:null},t.intersects=function(e,t,r){return e=new P(e,r),t=new P(t,r),e.intersects(t)},t.coerce=function(e,t){if(e instanceof p)return e;if("number"==typeof e&&(e=String(e)),"string"!=typeof e)return null;var r=null;if((t=t||{}).rtl){for(var n;(n=s[o.COERCERTL].exec(e))&&(!r||r.index+r[0].length!==e.length);)r&&n.index+n[0].length===r.index+r[0].length||(r=n),s[o.COERCERTL].lastIndex=n.index+n[1].length+n[2].length;s[o.COERCERTL].lastIndex=-1;}else r=e.match(s[o.COERCE]);return null===r?null:c(r[2]+"."+(r[3]||"0")+"."+(r[4]||"0"),t)};},"./node_modules/@babel/core/node_modules/source-map/lib/array-set.js":(e,t,r)=>{var n=r("./node_modules/@babel/core/node_modules/source-map/lib/util.js"),s=Object.prototype.hasOwnProperty,i="undefined"!=typeof Map;function o(){this._array=[],this._set=i?new Map:Object.create(null);}o.fromArray=function(e,t){for(var r=new o,n=0,s=e.length;n<s;n++)r.add(e[n],t);return r},o.prototype.size=function(){return i?this._set.size:Object.getOwnPropertyNames(this._set).length},o.prototype.add=function(e,t){var r=i?e:n.toSetString(e),o=i?this.has(e):s.call(this._set,r),a=this._array.length;o&&!t||this._array.push(e),o||(i?this._set.set(e,a):this._set[r]=a);},o.prototype.has=function(e){if(i)return this._set.has(e);var t=n.toSetString(e);return s.call(this._set,t)},o.prototype.indexOf=function(e){if(i){var t=this._set.get(e);if(t>=0)return t}else {var r=n.toSetString(e);if(s.call(this._set,r))return this._set[r]}throw new Error('"'+e+'" is not in the set.')},o.prototype.at=function(e){if(e>=0&&e<this._array.length)return this._array[e];throw new Error("No element indexed by "+e)},o.prototype.toArray=function(){return this._array.slice()},t.I=o;},"./node_modules/@babel/core/node_modules/source-map/lib/base64-vlq.js":(e,t,r)=>{var n=r("./node_modules/@babel/core/node_modules/source-map/lib/base64.js");t.encode=function(e){var t,r="",s=function(e){return e<0?1+(-e<<1):0+(e<<1)}(e);do{t=31&s,(s>>>=5)>0&&(t|=32),r+=n.encode(t);}while(s>0);return r},t.decode=function(e,t,r){var s,i,o,a,l=e.length,u=0,c=0;do{if(t>=l)throw new Error("Expected more digits in base 64 VLQ value.");if(-1===(i=n.decode(e.charCodeAt(t++))))throw new Error("Invalid base64 digit: "+e.charAt(t-1));s=!!(32&i),u+=(i&=31)<<c,c+=5;}while(s);r.value=(a=(o=u)>>1,1==(1&o)?-a:a),r.rest=t;};},"./node_modules/@babel/core/node_modules/source-map/lib/base64.js":(e,t)=>{var r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");t.encode=function(e){if(0<=e&&e<r.length)return r[e];throw new TypeError("Must be between 0 and 63: "+e)},t.decode=function(e){return 65<=e&&e<=90?e-65:97<=e&&e<=122?e-97+26:48<=e&&e<=57?e-48+52:43==e?62:47==e?63:-1};},"./node_modules/@babel/core/node_modules/source-map/lib/binary-search.js":(e,t)=>{function r(e,n,s,i,o,a){var l=Math.floor((n-e)/2)+e,u=o(s,i[l],!0);return 0===u?l:u>0?n-l>1?r(l,n,s,i,o,a):a==t.LEAST_UPPER_BOUND?n<i.length?n:-1:l:l-e>1?r(e,l,s,i,o,a):a==t.LEAST_UPPER_BOUND?l:e<0?-1:e}t.GREATEST_LOWER_BOUND=1,t.LEAST_UPPER_BOUND=2,t.search=function(e,n,s,i){if(0===n.length)return -1;var o=r(-1,n.length,e,n,s,i||t.GREATEST_LOWER_BOUND);if(o<0)return -1;for(;o-1>=0&&0===s(n[o],n[o-1],!0);)--o;return o};},"./node_modules/@babel/core/node_modules/source-map/lib/mapping-list.js":(e,t,r)=>{var n=r("./node_modules/@babel/core/node_modules/source-map/lib/util.js");function s(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0};}s.prototype.unsortedForEach=function(e,t){this._array.forEach(e,t);},s.prototype.add=function(e){var t,r,s,i,o,a;r=e,s=(t=this._last).generatedLine,i=r.generatedLine,o=t.generatedColumn,a=r.generatedColumn,i>s||i==s&&a>=o||n.compareByGeneratedPositionsInflated(t,r)<=0?(this._last=e,this._array.push(e)):(this._sorted=!1,this._array.push(e));},s.prototype.toArray=function(){return this._sorted||(this._array.sort(n.compareByGeneratedPositionsInflated),this._sorted=!0),this._array},t.H=s;},"./node_modules/@babel/core/node_modules/source-map/lib/quick-sort.js":(e,t)=>{function r(e,t,r){var n=e[t];e[t]=e[r],e[r]=n;}function n(e,t,s,i){if(s<i){var o=s-1;r(e,(c=s,p=i,Math.round(c+Math.random()*(p-c))),i);for(var a=e[i],l=s;l<i;l++)t(e[l],a)<=0&&r(e,o+=1,l);r(e,o+1,l);var u=o+1;n(e,t,s,u-1),n(e,t,u+1,i);}var c,p;}t.U=function(e,t){n(e,t,0,e.length-1);};},"./node_modules/@babel/core/node_modules/source-map/lib/source-map-consumer.js":(e,t,r)=>{var n=r("./node_modules/@babel/core/node_modules/source-map/lib/util.js"),s=r("./node_modules/@babel/core/node_modules/source-map/lib/binary-search.js"),i=r("./node_modules/@babel/core/node_modules/source-map/lib/array-set.js").I,o=r("./node_modules/@babel/core/node_modules/source-map/lib/base64-vlq.js"),a=r("./node_modules/@babel/core/node_modules/source-map/lib/quick-sort.js").U;function l(e){var t=e;return "string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,""))),null!=t.sections?new p(t):new u(t)}function u(e){var t=e;"string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,"")));var r=n.getArg(t,"version"),s=n.getArg(t,"sources"),o=n.getArg(t,"names",[]),a=n.getArg(t,"sourceRoot",null),l=n.getArg(t,"sourcesContent",null),u=n.getArg(t,"mappings"),c=n.getArg(t,"file",null);if(r!=this._version)throw new Error("Unsupported version: "+r);s=s.map(String).map(n.normalize).map((function(e){return a&&n.isAbsolute(a)&&n.isAbsolute(e)?n.relative(a,e):e})),this._names=i.fromArray(o.map(String),!0),this._sources=i.fromArray(s,!0),this.sourceRoot=a,this.sourcesContent=l,this._mappings=u,this.file=c;}function c(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null;}function p(e){var t=e;"string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,"")));var r=n.getArg(t,"version"),s=n.getArg(t,"sections");if(r!=this._version)throw new Error("Unsupported version: "+r);this._sources=new i,this._names=new i;var o={line:-1,column:0};this._sections=s.map((function(e){if(e.url)throw new Error("Support for url field in sections not implemented.");var t=n.getArg(e,"offset"),r=n.getArg(t,"line"),s=n.getArg(t,"column");if(r<o.line||r===o.line&&s<o.column)throw new Error("Section offsets must be ordered and non-overlapping.");return o=t,{generatedOffset:{generatedLine:r+1,generatedColumn:s+1},consumer:new l(n.getArg(e,"map"))}}));}l.fromSourceMap=function(e){return u.fromSourceMap(e)},l.prototype._version=3,l.prototype.__generatedMappings=null,Object.defineProperty(l.prototype,"_generatedMappings",{get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),l.prototype.__originalMappings=null,Object.defineProperty(l.prototype,"_originalMappings",{get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),l.prototype._charIsMappingSeparator=function(e,t){var r=e.charAt(t);return ";"===r||","===r},l.prototype._parseMappings=function(e,t){throw new Error("Subclasses must implement _parseMappings")},l.GENERATED_ORDER=1,l.ORIGINAL_ORDER=2,l.GREATEST_LOWER_BOUND=1,l.LEAST_UPPER_BOUND=2,l.prototype.eachMapping=function(e,t,r){var s,i=t||null;switch(r||l.GENERATED_ORDER){case l.GENERATED_ORDER:s=this._generatedMappings;break;case l.ORIGINAL_ORDER:s=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var o=this.sourceRoot;s.map((function(e){var t=null===e.source?null:this._sources.at(e.source);return null!=t&&null!=o&&(t=n.join(o,t)),{source:t,generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:null===e.name?null:this._names.at(e.name)}}),this).forEach(e,i);},l.prototype.allGeneratedPositionsFor=function(e){var t=n.getArg(e,"line"),r={source:n.getArg(e,"source"),originalLine:t,originalColumn:n.getArg(e,"column",0)};if(null!=this.sourceRoot&&(r.source=n.relative(this.sourceRoot,r.source)),!this._sources.has(r.source))return [];r.source=this._sources.indexOf(r.source);var i=[],o=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",n.compareByOriginalPositions,s.LEAST_UPPER_BOUND);if(o>=0){var a=this._originalMappings[o];if(void 0===e.column)for(var l=a.originalLine;a&&a.originalLine===l;)i.push({line:n.getArg(a,"generatedLine",null),column:n.getArg(a,"generatedColumn",null),lastColumn:n.getArg(a,"lastGeneratedColumn",null)}),a=this._originalMappings[++o];else for(var u=a.originalColumn;a&&a.originalLine===t&&a.originalColumn==u;)i.push({line:n.getArg(a,"generatedLine",null),column:n.getArg(a,"generatedColumn",null),lastColumn:n.getArg(a,"lastGeneratedColumn",null)}),a=this._originalMappings[++o];}return i},t.SourceMapConsumer=l,u.prototype=Object.create(l.prototype),u.prototype.consumer=l,u.fromSourceMap=function(e){var t=Object.create(u.prototype),r=t._names=i.fromArray(e._names.toArray(),!0),s=t._sources=i.fromArray(e._sources.toArray(),!0);t.sourceRoot=e._sourceRoot,t.sourcesContent=e._generateSourcesContent(t._sources.toArray(),t.sourceRoot),t.file=e._file;for(var o=e._mappings.toArray().slice(),l=t.__generatedMappings=[],p=t.__originalMappings=[],d=0,f=o.length;d<f;d++){var h=o[d],m=new c;m.generatedLine=h.generatedLine,m.generatedColumn=h.generatedColumn,h.source&&(m.source=s.indexOf(h.source),m.originalLine=h.originalLine,m.originalColumn=h.originalColumn,h.name&&(m.name=r.indexOf(h.name)),p.push(m)),l.push(m);}return a(t.__originalMappings,n.compareByOriginalPositions),t},u.prototype._version=3,Object.defineProperty(u.prototype,"sources",{get:function(){return this._sources.toArray().map((function(e){return null!=this.sourceRoot?n.join(this.sourceRoot,e):e}),this)}}),u.prototype._parseMappings=function(e,t){for(var r,s,i,l,u,p=1,d=0,f=0,h=0,m=0,y=0,b=e.length,g=0,E={},v={},x=[],T=[];g<b;)if(";"===e.charAt(g))p++,g++,d=0;else if(","===e.charAt(g))g++;else {for((r=new c).generatedLine=p,l=g;l<b&&!this._charIsMappingSeparator(e,l);l++);if(i=E[s=e.slice(g,l)])g+=s.length;else {for(i=[];g<l;)o.decode(e,g,v),u=v.value,g=v.rest,i.push(u);if(2===i.length)throw new Error("Found a source, but no line and column");if(3===i.length)throw new Error("Found a source and line, but no column");E[s]=i;}r.generatedColumn=d+i[0],d=r.generatedColumn,i.length>1&&(r.source=m+i[1],m+=i[1],r.originalLine=f+i[2],f=r.originalLine,r.originalLine+=1,r.originalColumn=h+i[3],h=r.originalColumn,i.length>4&&(r.name=y+i[4],y+=i[4])),T.push(r),"number"==typeof r.originalLine&&x.push(r);}a(T,n.compareByGeneratedPositionsDeflated),this.__generatedMappings=T,a(x,n.compareByOriginalPositions),this.__originalMappings=x;},u.prototype._findMapping=function(e,t,r,n,i,o){if(e[r]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+e[r]);if(e[n]<0)throw new TypeError("Column must be greater than or equal to 0, got "+e[n]);return s.search(e,t,i,o)},u.prototype.computeColumnSpans=function(){for(var e=0;e<this._generatedMappings.length;++e){var t=this._generatedMappings[e];if(e+1<this._generatedMappings.length){var r=this._generatedMappings[e+1];if(t.generatedLine===r.generatedLine){t.lastGeneratedColumn=r.generatedColumn-1;continue}}t.lastGeneratedColumn=1/0;}},u.prototype.originalPositionFor=function(e){var t={generatedLine:n.getArg(e,"line"),generatedColumn:n.getArg(e,"column")},r=this._findMapping(t,this._generatedMappings,"generatedLine","generatedColumn",n.compareByGeneratedPositionsDeflated,n.getArg(e,"bias",l.GREATEST_LOWER_BOUND));if(r>=0){var s=this._generatedMappings[r];if(s.generatedLine===t.generatedLine){var i=n.getArg(s,"source",null);null!==i&&(i=this._sources.at(i),null!=this.sourceRoot&&(i=n.join(this.sourceRoot,i)));var o=n.getArg(s,"name",null);return null!==o&&(o=this._names.at(o)),{source:i,line:n.getArg(s,"originalLine",null),column:n.getArg(s,"originalColumn",null),name:o}}}return {source:null,line:null,column:null,name:null}},u.prototype.hasContentsOfAllSources=function(){return !!this.sourcesContent&&this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some((function(e){return null==e}))},u.prototype.sourceContentFor=function(e,t){if(!this.sourcesContent)return null;if(null!=this.sourceRoot&&(e=n.relative(this.sourceRoot,e)),this._sources.has(e))return this.sourcesContent[this._sources.indexOf(e)];var r;if(null!=this.sourceRoot&&(r=n.urlParse(this.sourceRoot))){var s=e.replace(/^file:\/\//,"");if("file"==r.scheme&&this._sources.has(s))return this.sourcesContent[this._sources.indexOf(s)];if((!r.path||"/"==r.path)&&this._sources.has("/"+e))return this.sourcesContent[this._sources.indexOf("/"+e)]}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},u.prototype.generatedPositionFor=function(e){var t=n.getArg(e,"source");if(null!=this.sourceRoot&&(t=n.relative(this.sourceRoot,t)),!this._sources.has(t))return {line:null,column:null,lastColumn:null};var r={source:t=this._sources.indexOf(t),originalLine:n.getArg(e,"line"),originalColumn:n.getArg(e,"column")},s=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",n.compareByOriginalPositions,n.getArg(e,"bias",l.GREATEST_LOWER_BOUND));if(s>=0){var i=this._originalMappings[s];if(i.source===r.source)return {line:n.getArg(i,"generatedLine",null),column:n.getArg(i,"generatedColumn",null),lastColumn:n.getArg(i,"lastGeneratedColumn",null)}}return {line:null,column:null,lastColumn:null}},p.prototype=Object.create(l.prototype),p.prototype.constructor=l,p.prototype._version=3,Object.defineProperty(p.prototype,"sources",{get:function(){for(var e=[],t=0;t<this._sections.length;t++)for(var r=0;r<this._sections[t].consumer.sources.length;r++)e.push(this._sections[t].consumer.sources[r]);return e}}),p.prototype.originalPositionFor=function(e){var t={generatedLine:n.getArg(e,"line"),generatedColumn:n.getArg(e,"column")},r=s.search(t,this._sections,(function(e,t){return e.generatedLine-t.generatedOffset.generatedLine||e.generatedColumn-t.generatedOffset.generatedColumn})),i=this._sections[r];return i?i.consumer.originalPositionFor({line:t.generatedLine-(i.generatedOffset.generatedLine-1),column:t.generatedColumn-(i.generatedOffset.generatedLine===t.generatedLine?i.generatedOffset.generatedColumn-1:0),bias:e.bias}):{source:null,line:null,column:null,name:null}},p.prototype.hasContentsOfAllSources=function(){return this._sections.every((function(e){return e.consumer.hasContentsOfAllSources()}))},p.prototype.sourceContentFor=function(e,t){for(var r=0;r<this._sections.length;r++){var n=this._sections[r].consumer.sourceContentFor(e,!0);if(n)return n}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},p.prototype.generatedPositionFor=function(e){for(var t=0;t<this._sections.length;t++){var r=this._sections[t];if(-1!==r.consumer.sources.indexOf(n.getArg(e,"source"))){var s=r.consumer.generatedPositionFor(e);if(s)return {line:s.line+(r.generatedOffset.generatedLine-1),column:s.column+(r.generatedOffset.generatedLine===s.line?r.generatedOffset.generatedColumn-1:0)}}}return {line:null,column:null}},p.prototype._parseMappings=function(e,t){this.__generatedMappings=[],this.__originalMappings=[];for(var r=0;r<this._sections.length;r++)for(var s=this._sections[r],i=s.consumer._generatedMappings,o=0;o<i.length;o++){var l=i[o],u=s.consumer._sources.at(l.source);null!==s.consumer.sourceRoot&&(u=n.join(s.consumer.sourceRoot,u)),this._sources.add(u),u=this._sources.indexOf(u);var c=s.consumer._names.at(l.name);this._names.add(c),c=this._names.indexOf(c);var p={source:u,generatedLine:l.generatedLine+(s.generatedOffset.generatedLine-1),generatedColumn:l.generatedColumn+(s.generatedOffset.generatedLine===l.generatedLine?s.generatedOffset.generatedColumn-1:0),originalLine:l.originalLine,originalColumn:l.originalColumn,name:c};this.__generatedMappings.push(p),"number"==typeof p.originalLine&&this.__originalMappings.push(p);}a(this.__generatedMappings,n.compareByGeneratedPositionsDeflated),a(this.__originalMappings,n.compareByOriginalPositions);};},"./node_modules/@babel/core/node_modules/source-map/lib/source-map-generator.js":(e,t,r)=>{var n=r("./node_modules/@babel/core/node_modules/source-map/lib/base64-vlq.js"),s=r("./node_modules/@babel/core/node_modules/source-map/lib/util.js"),i=r("./node_modules/@babel/core/node_modules/source-map/lib/array-set.js").I,o=r("./node_modules/@babel/core/node_modules/source-map/lib/mapping-list.js").H;function a(e){e||(e={}),this._file=s.getArg(e,"file",null),this._sourceRoot=s.getArg(e,"sourceRoot",null),this._skipValidation=s.getArg(e,"skipValidation",!1),this._sources=new i,this._names=new i,this._mappings=new o,this._sourcesContents=null;}a.prototype._version=3,a.fromSourceMap=function(e){var t=e.sourceRoot,r=new a({file:e.file,sourceRoot:t});return e.eachMapping((function(e){var n={generated:{line:e.generatedLine,column:e.generatedColumn}};null!=e.source&&(n.source=e.source,null!=t&&(n.source=s.relative(t,n.source)),n.original={line:e.originalLine,column:e.originalColumn},null!=e.name&&(n.name=e.name)),r.addMapping(n);})),e.sources.forEach((function(t){var n=e.sourceContentFor(t);null!=n&&r.setSourceContent(t,n);})),r},a.prototype.addMapping=function(e){var t=s.getArg(e,"generated"),r=s.getArg(e,"original",null),n=s.getArg(e,"source",null),i=s.getArg(e,"name",null);this._skipValidation||this._validateMapping(t,r,n,i),null!=n&&(n=String(n),this._sources.has(n)||this._sources.add(n)),null!=i&&(i=String(i),this._names.has(i)||this._names.add(i)),this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:null!=r&&r.line,originalColumn:null!=r&&r.column,source:n,name:i});},a.prototype.setSourceContent=function(e,t){var r=e;null!=this._sourceRoot&&(r=s.relative(this._sourceRoot,r)),null!=t?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[s.toSetString(r)]=t):this._sourcesContents&&(delete this._sourcesContents[s.toSetString(r)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null));},a.prototype.applySourceMap=function(e,t,r){var n=t;if(null==t){if(null==e.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');n=e.file;}var o=this._sourceRoot;null!=o&&(n=s.relative(o,n));var a=new i,l=new i;this._mappings.unsortedForEach((function(t){if(t.source===n&&null!=t.originalLine){var i=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});null!=i.source&&(t.source=i.source,null!=r&&(t.source=s.join(r,t.source)),null!=o&&(t.source=s.relative(o,t.source)),t.originalLine=i.line,t.originalColumn=i.column,null!=i.name&&(t.name=i.name));}var u=t.source;null==u||a.has(u)||a.add(u);var c=t.name;null==c||l.has(c)||l.add(c);}),this),this._sources=a,this._names=l,e.sources.forEach((function(t){var n=e.sourceContentFor(t);null!=n&&(null!=r&&(t=s.join(r,t)),null!=o&&(t=s.relative(o,t)),this.setSourceContent(t,n));}),this);},a.prototype._validateMapping=function(e,t,r,n){if(t&&"number"!=typeof t.line&&"number"!=typeof t.column)throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");if((!(e&&"line"in e&&"column"in e&&e.line>0&&e.column>=0)||t||r||n)&&!(e&&"line"in e&&"column"in e&&t&&"line"in t&&"column"in t&&e.line>0&&e.column>=0&&t.line>0&&t.column>=0&&r))throw new Error("Invalid mapping: "+JSON.stringify({generated:e,source:r,original:t,name:n}))},a.prototype._serializeMappings=function(){for(var e,t,r,i,o=0,a=1,l=0,u=0,c=0,p=0,d="",f=this._mappings.toArray(),h=0,m=f.length;h<m;h++){if(e="",(t=f[h]).generatedLine!==a)for(o=0;t.generatedLine!==a;)e+=";",a++;else if(h>0){if(!s.compareByGeneratedPositionsInflated(t,f[h-1]))continue;e+=",";}e+=n.encode(t.generatedColumn-o),o=t.generatedColumn,null!=t.source&&(i=this._sources.indexOf(t.source),e+=n.encode(i-p),p=i,e+=n.encode(t.originalLine-1-u),u=t.originalLine-1,e+=n.encode(t.originalColumn-l),l=t.originalColumn,null!=t.name&&(r=this._names.indexOf(t.name),e+=n.encode(r-c),c=r)),d+=e;}return d},a.prototype._generateSourcesContent=function(e,t){return e.map((function(e){if(!this._sourcesContents)return null;null!=t&&(e=s.relative(t,e));var r=s.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,r)?this._sourcesContents[r]:null}),this)},a.prototype.toJSON=function(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(e.file=this._file),null!=this._sourceRoot&&(e.sourceRoot=this._sourceRoot),this._sourcesContents&&(e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)),e},a.prototype.toString=function(){return JSON.stringify(this.toJSON())},t.SourceMapGenerator=a;},"./node_modules/@babel/core/node_modules/source-map/lib/source-node.js":(e,t,r)=>{var n=r("./node_modules/@babel/core/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator,s=r("./node_modules/@babel/core/node_modules/source-map/lib/util.js"),i=/(\r?\n)/,o="$$$isSourceNode$$$";function a(e,t,r,n,s){this.children=[],this.sourceContents={},this.line=null==e?null:e,this.column=null==t?null:t,this.source=null==r?null:r,this.name=null==s?null:s,this[o]=!0,null!=n&&this.add(n);}a.fromStringWithSourceMap=function(e,t,r){var n=new a,o=e.split(i),l=0,u=function(){return e()+(e()||"");function e(){return l<o.length?o[l++]:void 0}},c=1,p=0,d=null;return t.eachMapping((function(e){if(null!==d){if(!(c<e.generatedLine)){var t=(r=o[l]).substr(0,e.generatedColumn-p);return o[l]=r.substr(e.generatedColumn-p),p=e.generatedColumn,f(d,t),void(d=e)}f(d,u()),c++,p=0;}for(;c<e.generatedLine;)n.add(u()),c++;if(p<e.generatedColumn){var r=o[l];n.add(r.substr(0,e.generatedColumn)),o[l]=r.substr(e.generatedColumn),p=e.generatedColumn;}d=e;}),this),l<o.length&&(d&&f(d,u()),n.add(o.splice(l).join(""))),t.sources.forEach((function(e){var i=t.sourceContentFor(e);null!=i&&(null!=r&&(e=s.join(r,e)),n.setSourceContent(e,i));})),n;function f(e,t){if(null===e||void 0===e.source)n.add(t);else {var i=r?s.join(r,e.source):e.source;n.add(new a(e.originalLine,e.originalColumn,i,t,e.name));}}},a.prototype.add=function(e){if(Array.isArray(e))e.forEach((function(e){this.add(e);}),this);else {if(!e[o]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);e&&this.children.push(e);}return this},a.prototype.prepend=function(e){if(Array.isArray(e))for(var t=e.length-1;t>=0;t--)this.prepend(e[t]);else {if(!e[o]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);this.children.unshift(e);}return this},a.prototype.walk=function(e){for(var t,r=0,n=this.children.length;r<n;r++)(t=this.children[r])[o]?t.walk(e):""!==t&&e(t,{source:this.source,line:this.line,column:this.column,name:this.name});},a.prototype.join=function(e){var t,r,n=this.children.length;if(n>0){for(t=[],r=0;r<n-1;r++)t.push(this.children[r]),t.push(e);t.push(this.children[r]),this.children=t;}return this},a.prototype.replaceRight=function(e,t){var r=this.children[this.children.length-1];return r[o]?r.replaceRight(e,t):"string"==typeof r?this.children[this.children.length-1]=r.replace(e,t):this.children.push("".replace(e,t)),this},a.prototype.setSourceContent=function(e,t){this.sourceContents[s.toSetString(e)]=t;},a.prototype.walkSourceContents=function(e){for(var t=0,r=this.children.length;t<r;t++)this.children[t][o]&&this.children[t].walkSourceContents(e);var n=Object.keys(this.sourceContents);for(t=0,r=n.length;t<r;t++)e(s.fromSetString(n[t]),this.sourceContents[n[t]]);},a.prototype.toString=function(){var e="";return this.walk((function(t){e+=t;})),e},a.prototype.toStringWithSourceMap=function(e){var t={code:"",line:1,column:0},r=new n(e),s=!1,i=null,o=null,a=null,l=null;return this.walk((function(e,n){t.code+=e,null!==n.source&&null!==n.line&&null!==n.column?(i===n.source&&o===n.line&&a===n.column&&l===n.name||r.addMapping({source:n.source,original:{line:n.line,column:n.column},generated:{line:t.line,column:t.column},name:n.name}),i=n.source,o=n.line,a=n.column,l=n.name,s=!0):s&&(r.addMapping({generated:{line:t.line,column:t.column}}),i=null,s=!1);for(var u=0,c=e.length;u<c;u++)10===e.charCodeAt(u)?(t.line++,t.column=0,u+1===c?(i=null,s=!1):s&&r.addMapping({source:n.source,original:{line:n.line,column:n.column},generated:{line:t.line,column:t.column},name:n.name})):t.column++;})),this.walkSourceContents((function(e,t){r.setSourceContent(e,t);})),{code:t.code,map:r}},t.SourceNode=a;},"./node_modules/@babel/core/node_modules/source-map/lib/util.js":(e,t)=>{t.getArg=function(e,t,r){if(t in e)return e[t];if(3===arguments.length)return r;throw new Error('"'+t+'" is a required argument.')};var r=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/,n=/^data:.+\,.+$/;function s(e){var t=e.match(r);return t?{scheme:t[1],auth:t[2],host:t[3],port:t[4],path:t[5]}:null}function i(e){var t="";return e.scheme&&(t+=e.scheme+":"),t+="//",e.auth&&(t+=e.auth+"@"),e.host&&(t+=e.host),e.port&&(t+=":"+e.port),e.path&&(t+=e.path),t}function o(e){var r=e,n=s(e);if(n){if(!n.path)return e;r=n.path;}for(var o,a=t.isAbsolute(r),l=r.split(/\/+/),u=0,c=l.length-1;c>=0;c--)"."===(o=l[c])?l.splice(c,1):".."===o?u++:u>0&&(""===o?(l.splice(c+1,u),u=0):(l.splice(c,2),u--));return ""===(r=l.join("/"))&&(r=a?"/":"."),n?(n.path=r,i(n)):r}t.urlParse=s,t.urlGenerate=i,t.normalize=o,t.join=function(e,t){""===e&&(e="."),""===t&&(t=".");var r=s(t),a=s(e);if(a&&(e=a.path||"/"),r&&!r.scheme)return a&&(r.scheme=a.scheme),i(r);if(r||t.match(n))return t;if(a&&!a.host&&!a.path)return a.host=t,i(a);var l="/"===t.charAt(0)?t:o(e.replace(/\/+$/,"")+"/"+t);return a?(a.path=l,i(a)):l},t.isAbsolute=function(e){return "/"===e.charAt(0)||!!e.match(r)},t.relative=function(e,t){""===e&&(e="."),e=e.replace(/\/$/,"");for(var r=0;0!==t.indexOf(e+"/");){var n=e.lastIndexOf("/");if(n<0)return t;if((e=e.slice(0,n)).match(/^([^\/]+:\/)?\/*$/))return t;++r;}return Array(r+1).join("../")+t.substr(e.length+1)};var a=!("__proto__"in Object.create(null));function l(e){return e}function u(e){if(!e)return !1;var t=e.length;if(t<9)return !1;if(95!==e.charCodeAt(t-1)||95!==e.charCodeAt(t-2)||111!==e.charCodeAt(t-3)||116!==e.charCodeAt(t-4)||111!==e.charCodeAt(t-5)||114!==e.charCodeAt(t-6)||112!==e.charCodeAt(t-7)||95!==e.charCodeAt(t-8)||95!==e.charCodeAt(t-9))return !1;for(var r=t-10;r>=0;r--)if(36!==e.charCodeAt(r))return !1;return !0}function c(e,t){return e===t?0:e>t?1:-1}t.toSetString=a?l:function(e){return u(e)?"$"+e:e},t.fromSetString=a?l:function(e){return u(e)?e.slice(1):e},t.compareByOriginalPositions=function(e,t,r){var n=e.source-t.source;return 0!==n||0!=(n=e.originalLine-t.originalLine)||0!=(n=e.originalColumn-t.originalColumn)||r||0!=(n=e.generatedColumn-t.generatedColumn)||0!=(n=e.generatedLine-t.generatedLine)?n:e.name-t.name},t.compareByGeneratedPositionsDeflated=function(e,t,r){var n=e.generatedLine-t.generatedLine;return 0!==n||0!=(n=e.generatedColumn-t.generatedColumn)||r||0!=(n=e.source-t.source)||0!=(n=e.originalLine-t.originalLine)||0!=(n=e.originalColumn-t.originalColumn)?n:e.name-t.name},t.compareByGeneratedPositionsInflated=function(e,t){var r=e.generatedLine-t.generatedLine;return 0!==r||0!=(r=e.generatedColumn-t.generatedColumn)||0!==(r=c(e.source,t.source))||0!=(r=e.originalLine-t.originalLine)||0!=(r=e.originalColumn-t.originalColumn)?r:c(e.name,t.name)};},"./node_modules/@babel/core/node_modules/source-map/source-map.js":(e,t,r)=>{t.SourceMapGenerator=r("./node_modules/@babel/core/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator,t.SourceMapConsumer=r("./node_modules/@babel/core/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer,t.SourceNode=r("./node_modules/@babel/core/node_modules/source-map/lib/source-node.js").SourceNode;},"./node_modules/@babel/generator/lib/buffer.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;const r=/^[ \t]+$/;t.default=class{constructor(e){this._map=null,this._buf=[],this._last="",this._queue=[],this._position={line:1,column:0},this._sourcePosition={identifierName:null,line:null,column:null,filename:null},this._disallowedPop=null,this._map=e;}get(){this._flush();const e=this._map,t={code:this._buf.join("").trimRight(),map:null,rawMappings:null==e?void 0:e.getRawMappings()};return e&&Object.defineProperty(t,"map",{configurable:!0,enumerable:!0,get(){return this.map=e.get()},set(e){Object.defineProperty(this,"map",{value:e,writable:!0});}}),t}append(e){this._flush();const{line:t,column:r,filename:n,identifierName:s,force:i}=this._sourcePosition;this._append(e,t,r,s,n,i);}queue(e){if("\n"===e)for(;this._queue.length>0&&r.test(this._queue[0][0]);)this._queue.shift();const{line:t,column:n,filename:s,identifierName:i,force:o}=this._sourcePosition;this._queue.unshift([e,t,n,i,s,o]);}_flush(){let e;for(;e=this._queue.pop();)this._append(...e);}_append(e,t,r,n,s,i){this._buf.push(e),this._last=e[e.length-1];let o=e.indexOf("\n"),a=0;for(0!==o&&this._mark(t,r,n,s,i);-1!==o;)this._position.line++,this._position.column=0,a=o+1,a<e.length&&this._mark(++t,0,n,s,i),o=e.indexOf("\n",a);this._position.column+=e.length-a;}_mark(e,t,r,n,s){var i;null==(i=this._map)||i.mark(this._position.line,this._position.column,e,t,r,n,s);}removeTrailingNewline(){this._queue.length>0&&"\n"===this._queue[0][0]&&this._queue.shift();}removeLastSemicolon(){this._queue.length>0&&";"===this._queue[0][0]&&this._queue.shift();}endsWith(e){if(1===e.length){let t;if(this._queue.length>0){const e=this._queue[0][0];t=e[e.length-1];}else t=this._last;return t===e}const t=this._last+this._queue.reduce(((e,t)=>t[0]+e),"");return e.length<=t.length&&t.slice(-e.length)===e}hasContent(){return this._queue.length>0||!!this._last}exactSource(e,t){this.source("start",e,!0),t(),this.source("end",e),this._disallowPop("start",e);}source(e,t,r){e&&!t||this._normalizePosition(e,t,this._sourcePosition,r);}withSource(e,t,r){if(!this._map)return r();const n=this._sourcePosition.line,s=this._sourcePosition.column,i=this._sourcePosition.filename,o=this._sourcePosition.identifierName;this.source(e,t),r(),this._sourcePosition.force&&this._sourcePosition.line===n&&this._sourcePosition.column===s&&this._sourcePosition.filename===i||this._disallowedPop&&this._disallowedPop.line===n&&this._disallowedPop.column===s&&this._disallowedPop.filename===i||(this._sourcePosition.line=n,this._sourcePosition.column=s,this._sourcePosition.filename=i,this._sourcePosition.identifierName=o,this._sourcePosition.force=!1,this._disallowedPop=null);}_disallowPop(e,t){e&&!t||(this._disallowedPop=this._normalizePosition(e,t));}_normalizePosition(e,t,r,n){const s=t?t[e]:null;void 0===r&&(r={identifierName:null,line:null,column:null,filename:null,force:!1});const i=r.line,o=r.column,a=r.filename;return r.identifierName="start"===e&&(null==t?void 0:t.identifierName)||null,r.line=null==s?void 0:s.line,r.column=null==s?void 0:s.column,r.filename=null==t?void 0:t.filename,(n||r.line!==i||r.column!==o||r.filename!==a)&&(r.force=n),r}getCurrentColumn(){const e=this._queue.reduce(((e,t)=>t[0]+e),""),t=e.lastIndexOf("\n");return -1===t?this._position.column+e.length:e.length-1-t}getCurrentLine(){const e=this._queue.reduce(((e,t)=>t[0]+e),"");let t=0;for(let r=0;r<e.length;r++)"\n"===e[r]&&t++;return this._position.line+t}};},"./node_modules/@babel/generator/lib/generators/base.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.File=function(e){e.program&&this.print(e.program.interpreter,e),this.print(e.program,e);},t.Program=function(e){this.printInnerComments(e,!1),this.printSequence(e.directives,e),e.directives&&e.directives.length&&this.newline(),this.printSequence(e.body,e);},t.BlockStatement=function(e){var t;this.token("{"),this.printInnerComments(e);const r=null==(t=e.directives)?void 0:t.length;e.body.length||r?(this.newline(),this.printSequence(e.directives,e,{indent:!0}),r&&this.newline(),this.printSequence(e.body,e,{indent:!0}),this.removeTrailingNewline(),this.source("end",e.loc),this.endsWith("\n")||this.newline(),this.rightBrace()):(this.source("end",e.loc),this.token("}"));},t.Directive=function(e){this.print(e.value,e),this.semicolon();},t.DirectiveLiteral=function(e){const t=this.getPossibleRaw(e);if(null!=t)return void this.token(t);const{value:r}=e;if(s.test(r)){if(n.test(r))throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");this.token(`'${r}'`);}else this.token(`"${r}"`);},t.InterpreterDirective=function(e){this.token(`#!${e.value}\n`);},t.Placeholder=function(e){this.token("%%"),this.print(e.name),this.token("%%"),"Statement"===e.expectedNode&&this.semicolon();},r("./node_modules/@babel/types/lib/index.js");const n=/(?:^|[^\\])(?:\\\\)*'/,s=/(?:^|[^\\])(?:\\\\)*"/;},"./node_modules/@babel/generator/lib/generators/classes.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ClassExpression=t.ClassDeclaration=function(e,t){this.format.decoratorsBeforeExport&&(n.isExportDefaultDeclaration(t)||n.isExportNamedDeclaration(t))||this.printJoin(e.decorators,e),e.declare&&(this.word("declare"),this.space()),e.abstract&&(this.word("abstract"),this.space()),this.word("class"),e.id&&(this.space(),this.print(e.id,e)),this.print(e.typeParameters,e),e.superClass&&(this.space(),this.word("extends"),this.space(),this.print(e.superClass,e),this.print(e.superTypeParameters,e)),e.implements&&(this.space(),this.word("implements"),this.space(),this.printList(e.implements,e)),this.space(),this.print(e.body,e);},t.ClassBody=function(e){this.token("{"),this.printInnerComments(e),0===e.body.length?this.token("}"):(this.newline(),this.indent(),this.printSequence(e.body,e),this.dedent(),this.endsWith("\n")||this.newline(),this.rightBrace());},t.ClassProperty=function(e){this.printJoin(e.decorators,e),this.source("end",e.key.loc),this.tsPrintClassMemberModifiers(e,!0),e.computed?(this.token("["),this.print(e.key,e),this.token("]")):(this._variance(e),this.print(e.key,e)),e.optional&&this.token("?"),e.definite&&this.token("!"),this.print(e.typeAnnotation,e),e.value&&(this.space(),this.token("="),this.space(),this.print(e.value,e)),this.semicolon();},t.ClassPrivateProperty=function(e){this.printJoin(e.decorators,e),e.static&&(this.word("static"),this.space()),this.print(e.key,e),this.print(e.typeAnnotation,e),e.value&&(this.space(),this.token("="),this.space(),this.print(e.value,e)),this.semicolon();},t.ClassMethod=function(e){this._classMethodHead(e),this.space(),this.print(e.body,e);},t.ClassPrivateMethod=function(e){this._classMethodHead(e),this.space(),this.print(e.body,e);},t._classMethodHead=function(e){this.printJoin(e.decorators,e),this.source("end",e.key.loc),this.tsPrintClassMemberModifiers(e,!1),this._methodHead(e);},t.StaticBlock=function(e){this.word("static"),this.space(),this.token("{"),0===e.body.length?this.token("}"):(this.newline(),this.printSequence(e.body,e,{indent:!0}),this.rightBrace());};var n=r("./node_modules/@babel/types/lib/index.js");},"./node_modules/@babel/generator/lib/generators/expressions.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.UnaryExpression=function(e){"void"===e.operator||"delete"===e.operator||"typeof"===e.operator||"throw"===e.operator?(this.word(e.operator),this.space()):this.token(e.operator),this.print(e.argument,e);},t.DoExpression=function(e){e.async&&(this.word("async"),this.space()),this.word("do"),this.space(),this.print(e.body,e);},t.ParenthesizedExpression=function(e){this.token("("),this.print(e.expression,e),this.token(")");},t.UpdateExpression=function(e){e.prefix?(this.token(e.operator),this.print(e.argument,e)):(this.startTerminatorless(!0),this.print(e.argument,e),this.endTerminatorless(),this.token(e.operator));},t.ConditionalExpression=function(e){this.print(e.test,e),this.space(),this.token("?"),this.space(),this.print(e.consequent,e),this.space(),this.token(":"),this.space(),this.print(e.alternate,e);},t.NewExpression=function(e,t){this.word("new"),this.space(),this.print(e.callee,e),(!this.format.minified||0!==e.arguments.length||e.optional||n.isCallExpression(t,{callee:e})||n.isMemberExpression(t)||n.isNewExpression(t))&&(this.print(e.typeArguments,e),this.print(e.typeParameters,e),e.optional&&this.token("?."),this.token("("),this.printList(e.arguments,e),this.token(")"));},t.SequenceExpression=function(e){this.printList(e.expressions,e);},t.ThisExpression=function(){this.word("this");},t.Super=function(){this.word("super");},t.Decorator=function(e){this.token("@"),this.print(e.expression,e),this.newline();},t.OptionalMemberExpression=function(e){if(this.print(e.object,e),!e.computed&&n.isMemberExpression(e.property))throw new TypeError("Got a MemberExpression for MemberExpression property");let t=e.computed;n.isLiteral(e.property)&&"number"==typeof e.property.value&&(t=!0),e.optional&&this.token("?."),t?(this.token("["),this.print(e.property,e),this.token("]")):(e.optional||this.token("."),this.print(e.property,e));},t.OptionalCallExpression=function(e){this.print(e.callee,e),this.print(e.typeArguments,e),this.print(e.typeParameters,e),e.optional&&this.token("?."),this.token("("),this.printList(e.arguments,e),this.token(")");},t.CallExpression=function(e){this.print(e.callee,e),this.print(e.typeArguments,e),this.print(e.typeParameters,e),this.token("("),this.printList(e.arguments,e),this.token(")");},t.Import=function(){this.word("import");},t.EmptyStatement=function(){this.semicolon(!0);},t.ExpressionStatement=function(e){this.print(e.expression,e),this.semicolon();},t.AssignmentPattern=function(e){this.print(e.left,e),e.left.optional&&this.token("?"),this.print(e.left.typeAnnotation,e),this.space(),this.token("="),this.space(),this.print(e.right,e);},t.LogicalExpression=t.BinaryExpression=t.AssignmentExpression=function(e,t){const r=this.inForStatementInitCounter&&"in"===e.operator&&!s.needsParens(e,t);r&&this.token("("),this.print(e.left,e),this.space(),"in"===e.operator||"instanceof"===e.operator?this.word(e.operator):this.token(e.operator),this.space(),this.print(e.right,e),r&&this.token(")");},t.BindExpression=function(e){this.print(e.object,e),this.token("::"),this.print(e.callee,e);},t.MemberExpression=function(e){if(this.print(e.object,e),!e.computed&&n.isMemberExpression(e.property))throw new TypeError("Got a MemberExpression for MemberExpression property");let t=e.computed;n.isLiteral(e.property)&&"number"==typeof e.property.value&&(t=!0),t?(this.token("["),this.print(e.property,e),this.token("]")):(this.token("."),this.print(e.property,e));},t.MetaProperty=function(e){this.print(e.meta,e),this.token("."),this.print(e.property,e);},t.PrivateName=function(e){this.token("#"),this.print(e.id,e);},t.V8IntrinsicIdentifier=function(e){this.token("%"),this.word(e.name);},t.ModuleExpression=function(e){this.word("module"),this.space(),this.token("{"),0===e.body.body.length?this.token("}"):(this.newline(),this.printSequence(e.body.body,e,{indent:!0}),this.rightBrace());},t.AwaitExpression=t.YieldExpression=void 0;var n=r("./node_modules/@babel/types/lib/index.js"),s=r("./node_modules/@babel/generator/lib/node/index.js");function i(e){return function(t){if(this.word(e),t.delegate&&this.token("*"),t.argument){this.space();const e=this.startTerminatorless();this.print(t.argument,t),this.endTerminatorless(e);}}}const o=i("yield");t.YieldExpression=o;const a=i("await");t.AwaitExpression=a;},"./node_modules/@babel/generator/lib/generators/flow.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.AnyTypeAnnotation=function(){this.word("any");},t.ArrayTypeAnnotation=function(e){this.print(e.elementType,e),this.token("["),this.token("]");},t.BooleanTypeAnnotation=function(){this.word("boolean");},t.BooleanLiteralTypeAnnotation=function(e){this.word(e.value?"true":"false");},t.NullLiteralTypeAnnotation=function(){this.word("null");},t.DeclareClass=function(e,t){n.isDeclareExportDeclaration(t)||(this.word("declare"),this.space()),this.word("class"),this.space(),this._interfaceish(e);},t.DeclareFunction=function(e,t){n.isDeclareExportDeclaration(t)||(this.word("declare"),this.space()),this.word("function"),this.space(),this.print(e.id,e),this.print(e.id.typeAnnotation.typeAnnotation,e),e.predicate&&(this.space(),this.print(e.predicate,e)),this.semicolon();},t.InferredPredicate=function(){this.token("%"),this.word("checks");},t.DeclaredPredicate=function(e){this.token("%"),this.word("checks"),this.token("("),this.print(e.value,e),this.token(")");},t.DeclareInterface=function(e){this.word("declare"),this.space(),this.InterfaceDeclaration(e);},t.DeclareModule=function(e){this.word("declare"),this.space(),this.word("module"),this.space(),this.print(e.id,e),this.space(),this.print(e.body,e);},t.DeclareModuleExports=function(e){this.word("declare"),this.space(),this.word("module"),this.token("."),this.word("exports"),this.print(e.typeAnnotation,e);},t.DeclareTypeAlias=function(e){this.word("declare"),this.space(),this.TypeAlias(e);},t.DeclareOpaqueType=function(e,t){n.isDeclareExportDeclaration(t)||(this.word("declare"),this.space()),this.OpaqueType(e);},t.DeclareVariable=function(e,t){n.isDeclareExportDeclaration(t)||(this.word("declare"),this.space()),this.word("var"),this.space(),this.print(e.id,e),this.print(e.id.typeAnnotation,e),this.semicolon();},t.DeclareExportDeclaration=function(e){this.word("declare"),this.space(),this.word("export"),this.space(),e.default&&(this.word("default"),this.space()),u.apply(this,arguments);},t.DeclareExportAllDeclaration=function(){this.word("declare"),this.space(),s.ExportAllDeclaration.apply(this,arguments);},t.EnumDeclaration=function(e){const{id:t,body:r}=e;this.word("enum"),this.space(),this.print(t,e),this.print(r,e);},t.EnumBooleanBody=function(e){const{explicitType:t}=e;o(this,"boolean",t),a(this,e);},t.EnumNumberBody=function(e){const{explicitType:t}=e;o(this,"number",t),a(this,e);},t.EnumStringBody=function(e){const{explicitType:t}=e;o(this,"string",t),a(this,e);},t.EnumSymbolBody=function(e){o(this,"symbol",!0),a(this,e);},t.EnumDefaultedMember=function(e){const{id:t}=e;this.print(t,e),this.token(",");},t.EnumBooleanMember=function(e){l(this,e);},t.EnumNumberMember=function(e){l(this,e);},t.EnumStringMember=function(e){l(this,e);},t.ExistsTypeAnnotation=function(){this.token("*");},t.FunctionTypeAnnotation=function(e,t){this.print(e.typeParameters,e),this.token("("),e.this&&(this.word("this"),this.token(":"),this.space(),this.print(e.this.typeAnnotation,e),(e.params.length||e.rest)&&(this.token(","),this.space())),this.printList(e.params,e),e.rest&&(e.params.length&&(this.token(","),this.space()),this.token("..."),this.print(e.rest,e)),this.token(")"),"ObjectTypeCallProperty"===t.type||"DeclareFunction"===t.type||"ObjectTypeProperty"===t.type&&t.method?this.token(":"):(this.space(),this.token("=>")),this.space(),this.print(e.returnType,e);},t.FunctionTypeParam=function(e){this.print(e.name,e),e.optional&&this.token("?"),e.name&&(this.token(":"),this.space()),this.print(e.typeAnnotation,e);},t.GenericTypeAnnotation=t.ClassImplements=t.InterfaceExtends=function(e){this.print(e.id,e),this.print(e.typeParameters,e);},t._interfaceish=function(e){var t;this.print(e.id,e),this.print(e.typeParameters,e),null!=(t=e.extends)&&t.length&&(this.space(),this.word("extends"),this.space(),this.printList(e.extends,e)),e.mixins&&e.mixins.length&&(this.space(),this.word("mixins"),this.space(),this.printList(e.mixins,e)),e.implements&&e.implements.length&&(this.space(),this.word("implements"),this.space(),this.printList(e.implements,e)),this.space(),this.print(e.body,e);},t._variance=function(e){e.variance&&("plus"===e.variance.kind?this.token("+"):"minus"===e.variance.kind&&this.token("-"));},t.InterfaceDeclaration=function(e){this.word("interface"),this.space(),this._interfaceish(e);},t.InterfaceTypeAnnotation=function(e){this.word("interface"),e.extends&&e.extends.length&&(this.space(),this.word("extends"),this.space(),this.printList(e.extends,e)),this.space(),this.print(e.body,e);},t.IntersectionTypeAnnotation=function(e){this.printJoin(e.types,e,{separator:c});},t.MixedTypeAnnotation=function(){this.word("mixed");},t.EmptyTypeAnnotation=function(){this.word("empty");},t.NullableTypeAnnotation=function(e){this.token("?"),this.print(e.typeAnnotation,e);},t.NumberTypeAnnotation=function(){this.word("number");},t.StringTypeAnnotation=function(){this.word("string");},t.ThisTypeAnnotation=function(){this.word("this");},t.TupleTypeAnnotation=function(e){this.token("["),this.printList(e.types,e),this.token("]");},t.TypeofTypeAnnotation=function(e){this.word("typeof"),this.space(),this.print(e.argument,e);},t.TypeAlias=function(e){this.word("type"),this.space(),this.print(e.id,e),this.print(e.typeParameters,e),this.space(),this.token("="),this.space(),this.print(e.right,e),this.semicolon();},t.TypeAnnotation=function(e){this.token(":"),this.space(),e.optional&&this.token("?"),this.print(e.typeAnnotation,e);},t.TypeParameterDeclaration=t.TypeParameterInstantiation=function(e){this.token("<"),this.printList(e.params,e,{}),this.token(">");},t.TypeParameter=function(e){this._variance(e),this.word(e.name),e.bound&&this.print(e.bound,e),e.default&&(this.space(),this.token("="),this.space(),this.print(e.default,e));},t.OpaqueType=function(e){this.word("opaque"),this.space(),this.word("type"),this.space(),this.print(e.id,e),this.print(e.typeParameters,e),e.supertype&&(this.token(":"),this.space(),this.print(e.supertype,e)),e.impltype&&(this.space(),this.token("="),this.space(),this.print(e.impltype,e)),this.semicolon();},t.ObjectTypeAnnotation=function(e){e.exact?this.token("{|"):this.token("{");const t=[...e.properties,...e.callProperties||[],...e.indexers||[],...e.internalSlots||[]];t.length&&(this.space(),this.printJoin(t,e,{addNewlines(e){if(e&&!t[0])return 1},indent:!0,statement:!0,iterator:()=>{(1!==t.length||e.inexact)&&(this.token(","),this.space());}}),this.space()),e.inexact&&(this.indent(),this.token("..."),t.length&&this.newline(),this.dedent()),e.exact?this.token("|}"):this.token("}");},t.ObjectTypeInternalSlot=function(e){e.static&&(this.word("static"),this.space()),this.token("["),this.token("["),this.print(e.id,e),this.token("]"),this.token("]"),e.optional&&this.token("?"),e.method||(this.token(":"),this.space()),this.print(e.value,e);},t.ObjectTypeCallProperty=function(e){e.static&&(this.word("static"),this.space()),this.print(e.value,e);},t.ObjectTypeIndexer=function(e){e.static&&(this.word("static"),this.space()),this._variance(e),this.token("["),e.id&&(this.print(e.id,e),this.token(":"),this.space()),this.print(e.key,e),this.token("]"),this.token(":"),this.space(),this.print(e.value,e);},t.ObjectTypeProperty=function(e){e.proto&&(this.word("proto"),this.space()),e.static&&(this.word("static"),this.space()),"get"!==e.kind&&"set"!==e.kind||(this.word(e.kind),this.space()),this._variance(e),this.print(e.key,e),e.optional&&this.token("?"),e.method||(this.token(":"),this.space()),this.print(e.value,e);},t.ObjectTypeSpreadProperty=function(e){this.token("..."),this.print(e.argument,e);},t.QualifiedTypeIdentifier=function(e){this.print(e.qualification,e),this.token("."),this.print(e.id,e);},t.SymbolTypeAnnotation=function(){this.word("symbol");},t.UnionTypeAnnotation=function(e){this.printJoin(e.types,e,{separator:p});},t.TypeCastExpression=function(e){this.token("("),this.print(e.expression,e),this.print(e.typeAnnotation,e),this.token(")");},t.Variance=function(e){"plus"===e.kind?this.token("+"):this.token("-");},t.VoidTypeAnnotation=function(){this.word("void");},t.IndexedAccessType=function(e){this.print(e.objectType,e),this.token("["),this.print(e.indexType,e),this.token("]");},t.OptionalIndexedAccessType=function(e){this.print(e.objectType,e),e.optional&&this.token("?."),this.token("["),this.print(e.indexType,e),this.token("]");},Object.defineProperty(t,"NumberLiteralTypeAnnotation",{enumerable:!0,get:function(){return i.NumericLiteral}}),Object.defineProperty(t,"StringLiteralTypeAnnotation",{enumerable:!0,get:function(){return i.StringLiteral}});var n=r("./node_modules/@babel/types/lib/index.js"),s=r("./node_modules/@babel/generator/lib/generators/modules.js"),i=r("./node_modules/@babel/generator/lib/generators/types.js");function o(e,t,r){r&&(e.space(),e.word("of"),e.space(),e.word(t)),e.space();}function a(e,t){const{members:r}=t;e.token("{"),e.indent(),e.newline();for(const n of r)e.print(n,t),e.newline();t.hasUnknownMembers&&(e.token("..."),e.newline()),e.dedent(),e.token("}");}function l(e,t){const{id:r,init:n}=t;e.print(r,t),e.space(),e.token("="),e.space(),e.print(n,t),e.token(",");}function u(e){if(e.declaration){const t=e.declaration;this.print(t,e),n.isStatement(t)||this.semicolon();}else this.token("{"),e.specifiers.length&&(this.space(),this.printList(e.specifiers,e),this.space()),this.token("}"),e.source&&(this.space(),this.word("from"),this.space(),this.print(e.source,e)),this.semicolon();}function c(){this.space(),this.token("&"),this.space();}function p(){this.space(),this.token("|"),this.space();}},"./node_modules/@babel/generator/lib/generators/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0});var n=r("./node_modules/@babel/generator/lib/generators/template-literals.js");Object.keys(n).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===n[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return n[e]}}));}));var s=r("./node_modules/@babel/generator/lib/generators/expressions.js");Object.keys(s).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===s[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return s[e]}}));}));var i=r("./node_modules/@babel/generator/lib/generators/statements.js");Object.keys(i).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===i[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return i[e]}}));}));var o=r("./node_modules/@babel/generator/lib/generators/classes.js");Object.keys(o).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===o[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return o[e]}}));}));var a=r("./node_modules/@babel/generator/lib/generators/methods.js");Object.keys(a).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===a[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return a[e]}}));}));var l=r("./node_modules/@babel/generator/lib/generators/modules.js");Object.keys(l).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===l[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return l[e]}}));}));var u=r("./node_modules/@babel/generator/lib/generators/types.js");Object.keys(u).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===u[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return u[e]}}));}));var c=r("./node_modules/@babel/generator/lib/generators/flow.js");Object.keys(c).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===c[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return c[e]}}));}));var p=r("./node_modules/@babel/generator/lib/generators/base.js");Object.keys(p).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===p[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return p[e]}}));}));var d=r("./node_modules/@babel/generator/lib/generators/jsx.js");Object.keys(d).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===d[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return d[e]}}));}));var f=r("./node_modules/@babel/generator/lib/generators/typescript.js");Object.keys(f).forEach((function(e){"default"!==e&&"__esModule"!==e&&(e in t&&t[e]===f[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return f[e]}}));}));},"./node_modules/@babel/generator/lib/generators/jsx.js":(e,t,r)=>{function n(){this.space();}Object.defineProperty(t,"__esModule",{value:!0}),t.JSXAttribute=function(e){this.print(e.name,e),e.value&&(this.token("="),this.print(e.value,e));},t.JSXIdentifier=function(e){this.word(e.name);},t.JSXNamespacedName=function(e){this.print(e.namespace,e),this.token(":"),this.print(e.name,e);},t.JSXMemberExpression=function(e){this.print(e.object,e),this.token("."),this.print(e.property,e);},t.JSXSpreadAttribute=function(e){this.token("{"),this.token("..."),this.print(e.argument,e),this.token("}");},t.JSXExpressionContainer=function(e){this.token("{"),this.print(e.expression,e),this.token("}");},t.JSXSpreadChild=function(e){this.token("{"),this.token("..."),this.print(e.expression,e),this.token("}");},t.JSXText=function(e){const t=this.getPossibleRaw(e);null!=t?this.token(t):this.token(e.value);},t.JSXElement=function(e){const t=e.openingElement;if(this.print(t,e),!t.selfClosing){this.indent();for(const t of e.children)this.print(t,e);this.dedent(),this.print(e.closingElement,e);}},t.JSXOpeningElement=function(e){this.token("<"),this.print(e.name,e),this.print(e.typeParameters,e),e.attributes.length>0&&(this.space(),this.printJoin(e.attributes,e,{separator:n})),e.selfClosing?(this.space(),this.token("/>")):this.token(">");},t.JSXClosingElement=function(e){this.token("</"),this.print(e.name,e),this.token(">");},t.JSXEmptyExpression=function(e){this.printInnerComments(e);},t.JSXFragment=function(e){this.print(e.openingFragment,e),this.indent();for(const t of e.children)this.print(t,e);this.dedent(),this.print(e.closingFragment,e);},t.JSXOpeningFragment=function(){this.token("<"),this.token(">");},t.JSXClosingFragment=function(){this.token("</"),this.token(">");},r("./node_modules/@babel/types/lib/index.js");},"./node_modules/@babel/generator/lib/generators/methods.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t._params=function(e){this.print(e.typeParameters,e),this.token("("),this._parameters(e.params,e),this.token(")"),this.print(e.returnType,e);},t._parameters=function(e,t){for(let r=0;r<e.length;r++)this._param(e[r],t),r<e.length-1&&(this.token(","),this.space());},t._param=function(e,t){this.printJoin(e.decorators,e),this.print(e,t),e.optional&&this.token("?"),this.print(e.typeAnnotation,e);},t._methodHead=function(e){const t=e.kind,r=e.key;"get"!==t&&"set"!==t||(this.word(t),this.space()),e.async&&(this._catchUp("start",r.loc),this.word("async"),this.space()),"method"!==t&&"init"!==t||e.generator&&this.token("*"),e.computed?(this.token("["),this.print(r,e),this.token("]")):this.print(r,e),e.optional&&this.token("?"),this._params(e);},t._predicate=function(e){e.predicate&&(e.returnType||this.token(":"),this.space(),this.print(e.predicate,e));},t._functionHead=function(e){e.async&&(this.word("async"),this.space()),this.word("function"),e.generator&&this.token("*"),this.space(),e.id&&this.print(e.id,e),this._params(e),this._predicate(e);},t.FunctionDeclaration=t.FunctionExpression=function(e){this._functionHead(e),this.space(),this.print(e.body,e);},t.ArrowFunctionExpression=function(e){e.async&&(this.word("async"),this.space());const t=e.params[0];this.format.retainLines||this.format.auxiliaryCommentBefore||this.format.auxiliaryCommentAfter||1!==e.params.length||!n.isIdentifier(t)||function(e,t){var r,n;return !!(e.typeParameters||e.returnType||e.predicate||t.typeAnnotation||t.optional||null!=(r=t.leadingComments)&&r.length||null!=(n=t.trailingComments)&&n.length)}(e,t)?this._params(e):this.print(t,e),this._predicate(e),this.space(),this.token("=>"),this.space(),this.print(e.body,e);};var n=r("./node_modules/@babel/types/lib/index.js");},"./node_modules/@babel/generator/lib/generators/modules.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ImportSpecifier=function(e){"type"!==e.importKind&&"typeof"!==e.importKind||(this.word(e.importKind),this.space()),this.print(e.imported,e),e.local&&e.local.name!==e.imported.name&&(this.space(),this.word("as"),this.space(),this.print(e.local,e));},t.ImportDefaultSpecifier=function(e){this.print(e.local,e);},t.ExportDefaultSpecifier=function(e){this.print(e.exported,e);},t.ExportSpecifier=function(e){this.print(e.local,e),e.exported&&e.local.name!==e.exported.name&&(this.space(),this.word("as"),this.space(),this.print(e.exported,e));},t.ExportNamespaceSpecifier=function(e){this.token("*"),this.space(),this.word("as"),this.space(),this.print(e.exported,e);},t.ExportAllDeclaration=function(e){this.word("export"),this.space(),"type"===e.exportKind&&(this.word("type"),this.space()),this.token("*"),this.space(),this.word("from"),this.space(),this.print(e.source,e),this.printAssertions(e),this.semicolon();},t.ExportNamedDeclaration=function(e){this.format.decoratorsBeforeExport&&n.isClassDeclaration(e.declaration)&&this.printJoin(e.declaration.decorators,e),this.word("export"),this.space(),s.apply(this,arguments);},t.ExportDefaultDeclaration=function(e){this.format.decoratorsBeforeExport&&n.isClassDeclaration(e.declaration)&&this.printJoin(e.declaration.decorators,e),this.word("export"),this.space(),this.word("default"),this.space(),s.apply(this,arguments);},t.ImportDeclaration=function(e){this.word("import"),this.space(),("type"===e.importKind||"typeof"===e.importKind)&&(this.word(e.importKind),this.space());const t=e.specifiers.slice(0);if(null!=t&&t.length){for(;;){const r=t[0];if(!n.isImportDefaultSpecifier(r)&&!n.isImportNamespaceSpecifier(r))break;this.print(t.shift(),e),t.length&&(this.token(","),this.space());}t.length&&(this.token("{"),this.space(),this.printList(t,e),this.space(),this.token("}")),this.space(),this.word("from"),this.space();}var r;this.print(e.source,e),this.printAssertions(e),null!=(r=e.attributes)&&r.length&&(this.space(),this.word("with"),this.space(),this.printList(e.attributes,e)),this.semicolon();},t.ImportAttribute=function(e){this.print(e.key),this.token(":"),this.space(),this.print(e.value);},t.ImportNamespaceSpecifier=function(e){this.token("*"),this.space(),this.word("as"),this.space(),this.print(e.local,e);};var n=r("./node_modules/@babel/types/lib/index.js");function s(e){if(e.declaration){const t=e.declaration;this.print(t,e),n.isStatement(t)||this.semicolon();}else {"type"===e.exportKind&&(this.word("type"),this.space());const t=e.specifiers.slice(0);let r=!1;for(;;){const s=t[0];if(!n.isExportDefaultSpecifier(s)&&!n.isExportNamespaceSpecifier(s))break;r=!0,this.print(t.shift(),e),t.length&&(this.token(","),this.space());}(t.length||!t.length&&!r)&&(this.token("{"),t.length&&(this.space(),this.printList(t,e),this.space()),this.token("}")),e.source&&(this.space(),this.word("from"),this.space(),this.print(e.source,e),this.printAssertions(e)),this.semicolon();}}},"./node_modules/@babel/generator/lib/generators/statements.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WithStatement=function(e){this.word("with"),this.space(),this.token("("),this.print(e.object,e),this.token(")"),this.printBlock(e);},t.IfStatement=function(e){this.word("if"),this.space(),this.token("("),this.print(e.test,e),this.token(")"),this.space();const t=e.alternate&&n.isIfStatement(s(e.consequent));t&&(this.token("{"),this.newline(),this.indent()),this.printAndIndentOnComments(e.consequent,e),t&&(this.dedent(),this.newline(),this.token("}")),e.alternate&&(this.endsWith("}")&&this.space(),this.word("else"),this.space(),this.printAndIndentOnComments(e.alternate,e));},t.ForStatement=function(e){this.word("for"),this.space(),this.token("("),this.inForStatementInitCounter++,this.print(e.init,e),this.inForStatementInitCounter--,this.token(";"),e.test&&(this.space(),this.print(e.test,e)),this.token(";"),e.update&&(this.space(),this.print(e.update,e)),this.token(")"),this.printBlock(e);},t.WhileStatement=function(e){this.word("while"),this.space(),this.token("("),this.print(e.test,e),this.token(")"),this.printBlock(e);},t.DoWhileStatement=function(e){this.word("do"),this.space(),this.print(e.body,e),this.space(),this.word("while"),this.space(),this.token("("),this.print(e.test,e),this.token(")"),this.semicolon();},t.LabeledStatement=function(e){this.print(e.label,e),this.token(":"),this.space(),this.print(e.body,e);},t.TryStatement=function(e){this.word("try"),this.space(),this.print(e.block,e),this.space(),e.handlers?this.print(e.handlers[0],e):this.print(e.handler,e),e.finalizer&&(this.space(),this.word("finally"),this.space(),this.print(e.finalizer,e));},t.CatchClause=function(e){this.word("catch"),this.space(),e.param&&(this.token("("),this.print(e.param,e),this.print(e.param.typeAnnotation,e),this.token(")"),this.space()),this.print(e.body,e);},t.SwitchStatement=function(e){this.word("switch"),this.space(),this.token("("),this.print(e.discriminant,e),this.token(")"),this.space(),this.token("{"),this.printSequence(e.cases,e,{indent:!0,addNewlines(t,r){if(!t&&e.cases[e.cases.length-1]===r)return -1}}),this.token("}");},t.SwitchCase=function(e){e.test?(this.word("case"),this.space(),this.print(e.test,e),this.token(":")):(this.word("default"),this.token(":")),e.consequent.length&&(this.newline(),this.printSequence(e.consequent,e,{indent:!0}));},t.DebuggerStatement=function(){this.word("debugger"),this.semicolon();},t.VariableDeclaration=function(e,t){e.declare&&(this.word("declare"),this.space()),this.word(e.kind),this.space();let r,s=!1;if(!n.isFor(t))for(const t of e.declarations)t.init&&(s=!0);if(s&&(r="const"===e.kind?h:f),this.printList(e.declarations,e,{separator:r}),n.isFor(t))if(n.isForStatement(t)){if(t.init===e)return}else if(t.left===e)return;this.semicolon();},t.VariableDeclarator=function(e){this.print(e.id,e),e.definite&&this.token("!"),this.print(e.id.typeAnnotation,e),e.init&&(this.space(),this.token("="),this.space(),this.print(e.init,e));},t.ThrowStatement=t.BreakStatement=t.ReturnStatement=t.ContinueStatement=t.ForOfStatement=t.ForInStatement=void 0;var n=r("./node_modules/@babel/types/lib/index.js");function s(e){return n.isStatement(e.body)?s(e.body):e}const i=function(e){return function(t){this.word("for"),this.space(),"of"===e&&t.await&&(this.word("await"),this.space()),this.token("("),this.print(t.left,t),this.space(),this.word(e),this.space(),this.print(t.right,t),this.token(")"),this.printBlock(t);}},o=i("in");t.ForInStatement=o;const a=i("of");function l(e,t="label"){return function(r){this.word(e);const n=r[t];if(n){this.space();const e="label"==t,s=this.startTerminatorless(e);this.print(n,r),this.endTerminatorless(s);}this.semicolon();}}t.ForOfStatement=a;const u=l("continue");t.ContinueStatement=u;const c=l("return","argument");t.ReturnStatement=c;const p=l("break");t.BreakStatement=p;const d=l("throw","argument");function f(){if(this.token(","),this.newline(),this.endsWith("\n"))for(let e=0;e<4;e++)this.space(!0);}function h(){if(this.token(","),this.newline(),this.endsWith("\n"))for(let e=0;e<6;e++)this.space(!0);}t.ThrowStatement=d;},"./node_modules/@babel/generator/lib/generators/template-literals.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TaggedTemplateExpression=function(e){this.print(e.tag,e),this.print(e.typeParameters,e),this.print(e.quasi,e);},t.TemplateElement=function(e,t){const r=t.quasis[0]===e,n=t.quasis[t.quasis.length-1]===e,s=(r?"`":"}")+e.value.raw+(n?"`":"${");this.token(s);},t.TemplateLiteral=function(e){const t=e.quasis;for(let r=0;r<t.length;r++)this.print(t[r],e),r+1<t.length&&this.print(e.expressions[r],e);},r("./node_modules/@babel/types/lib/index.js");},"./node_modules/@babel/generator/lib/generators/types.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Identifier=function(e){this.exactSource(e.loc,(()=>{this.word(e.name);}));},t.ArgumentPlaceholder=function(){this.token("?");},t.SpreadElement=t.RestElement=function(e){this.token("..."),this.print(e.argument,e);},t.ObjectPattern=t.ObjectExpression=function(e){const t=e.properties;this.token("{"),this.printInnerComments(e),t.length&&(this.space(),this.printList(t,e,{indent:!0,statement:!0}),this.space()),this.token("}");},t.ObjectMethod=function(e){this.printJoin(e.decorators,e),this._methodHead(e),this.space(),this.print(e.body,e);},t.ObjectProperty=function(e){if(this.printJoin(e.decorators,e),e.computed)this.token("["),this.print(e.key,e),this.token("]");else {if(n.isAssignmentPattern(e.value)&&n.isIdentifier(e.key)&&e.key.name===e.value.left.name)return void this.print(e.value,e);if(this.print(e.key,e),e.shorthand&&n.isIdentifier(e.key)&&n.isIdentifier(e.value)&&e.key.name===e.value.name)return}this.token(":"),this.space(),this.print(e.value,e);},t.ArrayPattern=t.ArrayExpression=function(e){const t=e.elements,r=t.length;this.token("["),this.printInnerComments(e);for(let n=0;n<t.length;n++){const s=t[n];s?(n>0&&this.space(),this.print(s,e),n<r-1&&this.token(",")):this.token(",");}this.token("]");},t.RecordExpression=function(e){const t=e.properties;let r,n;if("bar"===this.format.recordAndTupleSyntaxType)r="{|",n="|}";else {if("hash"!==this.format.recordAndTupleSyntaxType)throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);r="#{",n="}";}this.token(r),this.printInnerComments(e),t.length&&(this.space(),this.printList(t,e,{indent:!0,statement:!0}),this.space()),this.token(n);},t.TupleExpression=function(e){const t=e.elements,r=t.length;let n,s;if("bar"===this.format.recordAndTupleSyntaxType)n="[|",s="|]";else {if("hash"!==this.format.recordAndTupleSyntaxType)throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);n="#[",s="]";}this.token(n),this.printInnerComments(e);for(let n=0;n<t.length;n++){const s=t[n];s&&(n>0&&this.space(),this.print(s,e),n<r-1&&this.token(","));}this.token(s);},t.RegExpLiteral=function(e){this.word(`/${e.pattern}/${e.flags}`);},t.BooleanLiteral=function(e){this.word(e.value?"true":"false");},t.NullLiteral=function(){this.word("null");},t.NumericLiteral=function(e){const t=this.getPossibleRaw(e),r=this.format.jsescOption,n=e.value+"";r.numbers?this.number(s(e.value,r)):null==t?this.number(n):this.format.minified?this.number(t.length<n.length?t:n):this.number(t);},t.StringLiteral=function(e){const t=this.getPossibleRaw(e);if(!this.format.minified&&null!=t)return void this.token(t);const r=s(e.value,Object.assign(this.format.jsescOption,this.format.jsonCompatibleStrings&&{json:!0}));return this.token(r)},t.BigIntLiteral=function(e){const t=this.getPossibleRaw(e);this.format.minified||null==t?this.word(e.value+"n"):this.word(t);},t.DecimalLiteral=function(e){const t=this.getPossibleRaw(e);this.format.minified||null==t?this.word(e.value+"m"):this.word(t);},t.PipelineTopicExpression=function(e){this.print(e.expression,e);},t.PipelineBareFunction=function(e){this.print(e.callee,e);},t.PipelinePrimaryTopicReference=function(){this.token("#");};var n=r("./node_modules/@babel/types/lib/index.js"),s=r("./node_modules/jsesc/jsesc.js");},"./node_modules/@babel/generator/lib/generators/typescript.js":(e,t,r)=>{function n(e,t){!0!==t&&e.token(t);}Object.defineProperty(t,"__esModule",{value:!0}),t.TSTypeAnnotation=function(e){this.token(":"),this.space(),e.optional&&this.token("?"),this.print(e.typeAnnotation,e);},t.TSTypeParameterDeclaration=t.TSTypeParameterInstantiation=function(e){this.token("<"),this.printList(e.params,e,{}),this.token(">");},t.TSTypeParameter=function(e){this.word(e.name),e.constraint&&(this.space(),this.word("extends"),this.space(),this.print(e.constraint,e)),e.default&&(this.space(),this.token("="),this.space(),this.print(e.default,e));},t.TSParameterProperty=function(e){e.accessibility&&(this.word(e.accessibility),this.space()),e.readonly&&(this.word("readonly"),this.space()),this._param(e.parameter);},t.TSDeclareFunction=function(e){e.declare&&(this.word("declare"),this.space()),this._functionHead(e),this.token(";");},t.TSDeclareMethod=function(e){this._classMethodHead(e),this.token(";");},t.TSQualifiedName=function(e){this.print(e.left,e),this.token("."),this.print(e.right,e);},t.TSCallSignatureDeclaration=function(e){this.tsPrintSignatureDeclarationBase(e),this.token(";");},t.TSConstructSignatureDeclaration=function(e){this.word("new"),this.space(),this.tsPrintSignatureDeclarationBase(e),this.token(";");},t.TSPropertySignature=function(e){const{readonly:t,initializer:r}=e;t&&(this.word("readonly"),this.space()),this.tsPrintPropertyOrMethodName(e),this.print(e.typeAnnotation,e),r&&(this.space(),this.token("="),this.space(),this.print(r,e)),this.token(";");},t.tsPrintPropertyOrMethodName=function(e){e.computed&&this.token("["),this.print(e.key,e),e.computed&&this.token("]"),e.optional&&this.token("?");},t.TSMethodSignature=function(e){const{kind:t}=e;"set"!==t&&"get"!==t||(this.word(t),this.space()),this.tsPrintPropertyOrMethodName(e),this.tsPrintSignatureDeclarationBase(e),this.token(";");},t.TSIndexSignature=function(e){const{readonly:t,static:r}=e;r&&(this.word("static"),this.space()),t&&(this.word("readonly"),this.space()),this.token("["),this._parameters(e.parameters,e),this.token("]"),this.print(e.typeAnnotation,e),this.token(";");},t.TSAnyKeyword=function(){this.word("any");},t.TSBigIntKeyword=function(){this.word("bigint");},t.TSUnknownKeyword=function(){this.word("unknown");},t.TSNumberKeyword=function(){this.word("number");},t.TSObjectKeyword=function(){this.word("object");},t.TSBooleanKeyword=function(){this.word("boolean");},t.TSStringKeyword=function(){this.word("string");},t.TSSymbolKeyword=function(){this.word("symbol");},t.TSVoidKeyword=function(){this.word("void");},t.TSUndefinedKeyword=function(){this.word("undefined");},t.TSNullKeyword=function(){this.word("null");},t.TSNeverKeyword=function(){this.word("never");},t.TSIntrinsicKeyword=function(){this.word("intrinsic");},t.TSThisType=function(){this.word("this");},t.TSFunctionType=function(e){this.tsPrintFunctionOrConstructorType(e);},t.TSConstructorType=function(e){e.abstract&&(this.word("abstract"),this.space()),this.word("new"),this.space(),this.tsPrintFunctionOrConstructorType(e);},t.tsPrintFunctionOrConstructorType=function(e){const{typeParameters:t,parameters:r}=e;this.print(t,e),this.token("("),this._parameters(r,e),this.token(")"),this.space(),this.token("=>"),this.space(),this.print(e.typeAnnotation.typeAnnotation,e);},t.TSTypeReference=function(e){this.print(e.typeName,e),this.print(e.typeParameters,e);},t.TSTypePredicate=function(e){e.asserts&&(this.word("asserts"),this.space()),this.print(e.parameterName),e.typeAnnotation&&(this.space(),this.word("is"),this.space(),this.print(e.typeAnnotation.typeAnnotation));},t.TSTypeQuery=function(e){this.word("typeof"),this.space(),this.print(e.exprName);},t.TSTypeLiteral=function(e){this.tsPrintTypeLiteralOrInterfaceBody(e.members,e);},t.tsPrintTypeLiteralOrInterfaceBody=function(e,t){this.tsPrintBraced(e,t);},t.tsPrintBraced=function(e,t){if(this.token("{"),e.length){this.indent(),this.newline();for(const r of e)this.print(r,t),this.newline();this.dedent(),this.rightBrace();}else this.token("}");},t.TSArrayType=function(e){this.print(e.elementType,e),this.token("[]");},t.TSTupleType=function(e){this.token("["),this.printList(e.elementTypes,e),this.token("]");},t.TSOptionalType=function(e){this.print(e.typeAnnotation,e),this.token("?");},t.TSRestType=function(e){this.token("..."),this.print(e.typeAnnotation,e);},t.TSNamedTupleMember=function(e){this.print(e.label,e),e.optional&&this.token("?"),this.token(":"),this.space(),this.print(e.elementType,e);},t.TSUnionType=function(e){this.tsPrintUnionOrIntersectionType(e,"|");},t.TSIntersectionType=function(e){this.tsPrintUnionOrIntersectionType(e,"&");},t.tsPrintUnionOrIntersectionType=function(e,t){this.printJoin(e.types,e,{separator(){this.space(),this.token(t),this.space();}});},t.TSConditionalType=function(e){this.print(e.checkType),this.space(),this.word("extends"),this.space(),this.print(e.extendsType),this.space(),this.token("?"),this.space(),this.print(e.trueType),this.space(),this.token(":"),this.space(),this.print(e.falseType);},t.TSInferType=function(e){this.token("infer"),this.space(),this.print(e.typeParameter);},t.TSParenthesizedType=function(e){this.token("("),this.print(e.typeAnnotation,e),this.token(")");},t.TSTypeOperator=function(e){this.word(e.operator),this.space(),this.print(e.typeAnnotation,e);},t.TSIndexedAccessType=function(e){this.print(e.objectType,e),this.token("["),this.print(e.indexType,e),this.token("]");},t.TSMappedType=function(e){const{nameType:t,optional:r,readonly:s,typeParameter:i}=e;this.token("{"),this.space(),s&&(n(this,s),this.word("readonly"),this.space()),this.token("["),this.word(i.name),this.space(),this.word("in"),this.space(),this.print(i.constraint,i),t&&(this.space(),this.word("as"),this.space(),this.print(t,e)),this.token("]"),r&&(n(this,r),this.token("?")),this.token(":"),this.space(),this.print(e.typeAnnotation,e),this.space(),this.token("}");},t.TSLiteralType=function(e){this.print(e.literal,e);},t.TSExpressionWithTypeArguments=function(e){this.print(e.expression,e),this.print(e.typeParameters,e);},t.TSInterfaceDeclaration=function(e){const{declare:t,id:r,typeParameters:n,extends:s,body:i}=e;t&&(this.word("declare"),this.space()),this.word("interface"),this.space(),this.print(r,e),this.print(n,e),null!=s&&s.length&&(this.space(),this.word("extends"),this.space(),this.printList(s,e)),this.space(),this.print(i,e);},t.TSInterfaceBody=function(e){this.tsPrintTypeLiteralOrInterfaceBody(e.body,e);},t.TSTypeAliasDeclaration=function(e){const{declare:t,id:r,typeParameters:n,typeAnnotation:s}=e;t&&(this.word("declare"),this.space()),this.word("type"),this.space(),this.print(r,e),this.print(n,e),this.space(),this.token("="),this.space(),this.print(s,e),this.token(";");},t.TSAsExpression=function(e){const{expression:t,typeAnnotation:r}=e;this.print(t,e),this.space(),this.word("as"),this.space(),this.print(r,e);},t.TSTypeAssertion=function(e){const{typeAnnotation:t,expression:r}=e;this.token("<"),this.print(t,e),this.token(">"),this.space(),this.print(r,e);},t.TSEnumDeclaration=function(e){const{declare:t,const:r,id:n,members:s}=e;t&&(this.word("declare"),this.space()),r&&(this.word("const"),this.space()),this.word("enum"),this.space(),this.print(n,e),this.space(),this.tsPrintBraced(s,e);},t.TSEnumMember=function(e){const{id:t,initializer:r}=e;this.print(t,e),r&&(this.space(),this.token("="),this.space(),this.print(r,e)),this.token(",");},t.TSModuleDeclaration=function(e){const{declare:t,id:r}=e;if(t&&(this.word("declare"),this.space()),e.global||(this.word("Identifier"===r.type?"namespace":"module"),this.space()),this.print(r,e),!e.body)return void this.token(";");let n=e.body;for(;"TSModuleDeclaration"===n.type;)this.token("."),this.print(n.id,n),n=n.body;this.space(),this.print(n,e);},t.TSModuleBlock=function(e){this.tsPrintBraced(e.body,e);},t.TSImportType=function(e){const{argument:t,qualifier:r,typeParameters:n}=e;this.word("import"),this.token("("),this.print(t,e),this.token(")"),r&&(this.token("."),this.print(r,e)),n&&this.print(n,e);},t.TSImportEqualsDeclaration=function(e){const{isExport:t,id:r,moduleReference:n}=e;t&&(this.word("export"),this.space()),this.word("import"),this.space(),this.print(r,e),this.space(),this.token("="),this.space(),this.print(n,e),this.token(";");},t.TSExternalModuleReference=function(e){this.token("require("),this.print(e.expression,e),this.token(")");},t.TSNonNullExpression=function(e){this.print(e.expression,e),this.token("!");},t.TSExportAssignment=function(e){this.word("export"),this.space(),this.token("="),this.space(),this.print(e.expression,e),this.token(";");},t.TSNamespaceExportDeclaration=function(e){this.word("export"),this.space(),this.word("as"),this.space(),this.word("namespace"),this.space(),this.print(e.id,e);},t.tsPrintSignatureDeclarationBase=function(e){const{typeParameters:t,parameters:r}=e;this.print(t,e),this.token("("),this._parameters(r,e),this.token(")"),this.print(e.typeAnnotation,e);},t.tsPrintClassMemberModifiers=function(e,t){t&&e.declare&&(this.word("declare"),this.space()),e.accessibility&&(this.word(e.accessibility),this.space()),e.static&&(this.word("static"),this.space()),e.override&&(this.word("override"),this.space()),e.abstract&&(this.word("abstract"),this.space()),t&&e.readonly&&(this.word("readonly"),this.space());},r("./node_modules/@babel/types/lib/index.js");},"./node_modules/@babel/generator/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){return new i(e,t,r).generate()},t.CodeGenerator=void 0;var n=r("./node_modules/@babel/generator/lib/source-map.js"),s=r("./node_modules/@babel/generator/lib/printer.js");class i extends s.default{constructor(e,t={},r){super(function(e,t){const r={auxiliaryCommentBefore:t.auxiliaryCommentBefore,auxiliaryCommentAfter:t.auxiliaryCommentAfter,shouldPrintComment:t.shouldPrintComment,retainLines:t.retainLines,retainFunctionParens:t.retainFunctionParens,comments:null==t.comments||t.comments,compact:t.compact,minified:t.minified,concise:t.concise,indent:{adjustMultilineComment:!0,style:"  ",base:0},decoratorsBeforeExport:!!t.decoratorsBeforeExport,jsescOption:Object.assign({quotes:"double",wrap:!0,minimal:!1},t.jsescOption),recordAndTupleSyntaxType:t.recordAndTupleSyntaxType};return r.jsonCompatibleStrings=t.jsonCompatibleStrings,r.minified?(r.compact=!0,r.shouldPrintComment=r.shouldPrintComment||(()=>r.comments)):r.shouldPrintComment=r.shouldPrintComment||(e=>r.comments||e.indexOf("@license")>=0||e.indexOf("@preserve")>=0),"auto"===r.compact&&(r.compact=e.length>5e5,r.compact&&console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)),r.compact&&(r.indent.adjustMultilineComment=!1),r}(r,t),t.sourceMaps?new n.default(t,r):null),this.ast=void 0,this.ast=e;}generate(){return super.generate(this.ast)}}t.CodeGenerator=class{constructor(e,t,r){this._generator=void 0,this._generator=new i(e,t,r);}generate(){return this._generator.generate()}};},"./node_modules/@babel/generator/lib/node/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.needsWhitespace=d,t.needsWhitespaceBefore=function(e,t){return d(e,t,"before")},t.needsWhitespaceAfter=function(e,t){return d(e,t,"after")},t.needsParens=function(e,t,r){return !!t&&(!(!i.isNewExpression(t)||t.callee!==e||!p(e))||c(a,e,t,r))};var n=r("./node_modules/@babel/generator/lib/node/whitespace.js"),s=r("./node_modules/@babel/generator/lib/node/parentheses.js"),i=r("./node_modules/@babel/types/lib/index.js");function o(e){const t={};function r(e,r){const n=t[e];t[e]=n?function(e,t,s){const i=n(e,t,s);return null==i?r(e,t,s):i}:r;}for(const t of Object.keys(e)){const n=i.FLIPPED_ALIAS_KEYS[t];if(n)for(const s of n)r(s,e[t]);else r(t,e[t]);}return t}const a=o(s),l=o(n.nodes),u=o(n.list);function c(e,t,r,n){const s=e[t.type];return s?s(t,r,n):null}function p(e){return !!i.isCallExpression(e)||i.isMemberExpression(e)&&p(e.object)}function d(e,t,r){if(!e)return 0;i.isExpressionStatement(e)&&(e=e.expression);let n=c(l,e,t);if(!n){const s=c(u,e,t);if(s)for(let t=0;t<s.length&&(n=d(s[t],e,r),!n);t++);}return "object"==typeof n&&null!==n&&n[r]||0}},"./node_modules/@babel/generator/lib/node/parentheses.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.NullableTypeAnnotation=function(e,t){return n.isArrayTypeAnnotation(t)},t.FunctionTypeAnnotation=function(e,t,r){return n.isUnionTypeAnnotation(t)||n.isIntersectionTypeAnnotation(t)||n.isArrayTypeAnnotation(t)||n.isTypeAnnotation(t)&&n.isArrowFunctionExpression(r[r.length-3])},t.UpdateExpression=function(e,t){return o(e,t)||i(e,t)},t.ObjectExpression=function(e,t,r){return u(r,{expressionStatement:!0,arrowBody:!0})},t.DoExpression=function(e,t,r){return !e.async&&u(r,{expressionStatement:!0})},t.Binary=function(e,t){if("**"===e.operator&&n.isBinaryExpression(t,{operator:"**"}))return t.left===e;if(i(e,t))return !0;if(o(e,t)||n.isUnaryLike(t)||n.isAwaitExpression(t))return !0;if(n.isBinary(t)){const r=t.operator,i=s[r],o=e.operator,a=s[o];if(i===a&&t.right===e&&!n.isLogicalExpression(t)||i>a)return !0}},t.IntersectionTypeAnnotation=t.UnionTypeAnnotation=function(e,t){return n.isArrayTypeAnnotation(t)||n.isNullableTypeAnnotation(t)||n.isIntersectionTypeAnnotation(t)||n.isUnionTypeAnnotation(t)},t.OptionalIndexedAccessType=function(e,t){return n.isIndexedAccessType(t,{objectType:e})},t.TSAsExpression=function(){return !0},t.TSTypeAssertion=function(){return !0},t.TSIntersectionType=t.TSUnionType=function(e,t){return n.isTSArrayType(t)||n.isTSOptionalType(t)||n.isTSIntersectionType(t)||n.isTSUnionType(t)||n.isTSRestType(t)},t.TSInferType=function(e,t){return n.isTSArrayType(t)||n.isTSOptionalType(t)},t.BinaryExpression=function(e,t){return "in"===e.operator&&(n.isVariableDeclarator(t)||n.isFor(t))},t.SequenceExpression=function(e,t){return !(n.isForStatement(t)||n.isThrowStatement(t)||n.isReturnStatement(t)||n.isIfStatement(t)&&t.test===e||n.isWhileStatement(t)&&t.test===e||n.isForInStatement(t)&&t.right===e||n.isSwitchStatement(t)&&t.discriminant===e||n.isExpressionStatement(t)&&t.expression===e)},t.AwaitExpression=t.YieldExpression=function(e,t){return n.isBinary(t)||n.isUnaryLike(t)||o(e,t)||n.isAwaitExpression(t)&&n.isYieldExpression(e)||n.isConditionalExpression(t)&&e===t.test||i(e,t)},t.ClassExpression=function(e,t,r){return u(r,{expressionStatement:!0,exportDefault:!0})},t.UnaryLike=a,t.FunctionExpression=function(e,t,r){return u(r,{expressionStatement:!0,exportDefault:!0})},t.ArrowFunctionExpression=function(e,t){return n.isExportDeclaration(t)||l(e,t)},t.ConditionalExpression=l,t.OptionalCallExpression=t.OptionalMemberExpression=function(e,t){return n.isCallExpression(t,{callee:e})||n.isMemberExpression(t,{object:e})},t.AssignmentExpression=function(e,t){return !!n.isObjectPattern(e.left)||l(e,t)},t.LogicalExpression=function(e,t){switch(e.operator){case"||":return !!n.isLogicalExpression(t)&&("??"===t.operator||"&&"===t.operator);case"&&":return n.isLogicalExpression(t,{operator:"??"});case"??":return n.isLogicalExpression(t)&&"??"!==t.operator}},t.Identifier=function(e,t,r){if("let"===e.name){const s=n.isMemberExpression(t,{object:e,computed:!0})||n.isOptionalMemberExpression(t,{object:e,computed:!0,optional:!1});return u(r,{expressionStatement:s,forHead:s,forInHead:s,forOfHead:!0})}return "async"===e.name&&n.isForOfStatement(t)&&e===t.left};var n=r("./node_modules/@babel/types/lib/index.js");const s={"||":0,"??":0,"&&":1,"|":2,"^":3,"&":4,"==":5,"===":5,"!=":5,"!==":5,"<":6,">":6,"<=":6,">=":6,in:6,instanceof:6,">>":7,"<<":7,">>>":7,"+":8,"-":8,"*":9,"/":9,"%":9,"**":10},i=(e,t)=>(n.isClassDeclaration(t)||n.isClassExpression(t))&&t.superClass===e,o=(e,t)=>(n.isMemberExpression(t)||n.isOptionalMemberExpression(t))&&t.object===e||(n.isCallExpression(t)||n.isOptionalCallExpression(t)||n.isNewExpression(t))&&t.callee===e||n.isTaggedTemplateExpression(t)&&t.tag===e||n.isTSNonNullExpression(t);function a(e,t){return o(e,t)||n.isBinaryExpression(t,{operator:"**",left:e})||i(e,t)}function l(e,t){return !!(n.isUnaryLike(t)||n.isBinary(t)||n.isConditionalExpression(t,{test:e})||n.isAwaitExpression(t)||n.isTSTypeAssertion(t)||n.isTSAsExpression(t))||a(e,t)}function u(e,{expressionStatement:t=!1,arrowBody:r=!1,exportDefault:s=!1,forHead:i=!1,forInHead:a=!1,forOfHead:l=!1}){let u=e.length-1,c=e[u];u--;let p=e[u];for(;u>=0;){if(t&&n.isExpressionStatement(p,{expression:c})||s&&n.isExportDefaultDeclaration(p,{declaration:c})||r&&n.isArrowFunctionExpression(p,{body:c})||i&&n.isForStatement(p,{init:c})||a&&n.isForInStatement(p,{left:c})||l&&n.isForOfStatement(p,{left:c}))return !0;if(!(o(c,p)&&!n.isNewExpression(p)||n.isSequenceExpression(p)&&p.expressions[0]===c||n.isConditional(p,{test:c})||n.isBinary(p,{left:c})||n.isAssignmentExpression(p,{left:c})))return !1;c=p,u--,p=e[u];}return !1}},"./node_modules/@babel/generator/lib/node/whitespace.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.list=t.nodes=void 0;var n=r("./node_modules/@babel/types/lib/index.js");function s(e,t={}){return n.isMemberExpression(e)||n.isOptionalMemberExpression(e)?(s(e.object,t),e.computed&&s(e.property,t)):n.isBinary(e)||n.isAssignmentExpression(e)?(s(e.left,t),s(e.right,t)):n.isCallExpression(e)||n.isOptionalCallExpression(e)?(t.hasCall=!0,s(e.callee,t)):n.isFunction(e)?t.hasFunction=!0:n.isIdentifier(e)&&(t.hasHelper=t.hasHelper||i(e.callee)),t}function i(e){return n.isMemberExpression(e)?i(e.object)||i(e.property):n.isIdentifier(e)?"require"===e.name||"_"===e.name[0]:n.isCallExpression(e)?i(e.callee):!(!n.isBinary(e)&&!n.isAssignmentExpression(e))&&(n.isIdentifier(e.left)&&i(e.left)||i(e.right))}function o(e){return n.isLiteral(e)||n.isObjectExpression(e)||n.isArrayExpression(e)||n.isIdentifier(e)||n.isMemberExpression(e)}const a={AssignmentExpression(e){const t=s(e.right);if(t.hasCall&&t.hasHelper||t.hasFunction)return {before:t.hasFunction,after:!0}},SwitchCase:(e,t)=>({before:!!e.consequent.length||t.cases[0]===e,after:!e.consequent.length&&t.cases[t.cases.length-1]===e}),LogicalExpression(e){if(n.isFunction(e.left)||n.isFunction(e.right))return {after:!0}},Literal(e){if(n.isStringLiteral(e)&&"use strict"===e.value)return {after:!0}},CallExpression(e){if(n.isFunction(e.callee)||i(e))return {before:!0,after:!0}},OptionalCallExpression(e){if(n.isFunction(e.callee))return {before:!0,after:!0}},VariableDeclaration(e){for(let t=0;t<e.declarations.length;t++){const r=e.declarations[t];let n=i(r.id)&&!o(r.init);if(!n){const e=s(r.init);n=i(r.init)&&e.hasCall||e.hasFunction;}if(n)return {before:!0,after:!0}}},IfStatement(e){if(n.isBlockStatement(e.consequent))return {before:!0,after:!0}}};t.nodes=a,a.ObjectProperty=a.ObjectTypeProperty=a.ObjectMethod=function(e,t){if(t.properties[0]===e)return {before:!0}},a.ObjectTypeCallProperty=function(e,t){var r;if(t.callProperties[0]===e&&(null==(r=t.properties)||!r.length))return {before:!0}},a.ObjectTypeIndexer=function(e,t){var r,n;if(!(t.indexers[0]!==e||null!=(r=t.properties)&&r.length||null!=(n=t.callProperties)&&n.length))return {before:!0}},a.ObjectTypeInternalSlot=function(e,t){var r,n,s;if(!(t.internalSlots[0]!==e||null!=(r=t.properties)&&r.length||null!=(n=t.callProperties)&&n.length||null!=(s=t.indexers)&&s.length))return {before:!0}};t.list={VariableDeclaration:e=>e.declarations.map((e=>e.init)),ArrayExpression:e=>e.elements,ObjectExpression:e=>e.properties},[["Function",!0],["Class",!0],["Loop",!0],["LabeledStatement",!0],["SwitchStatement",!0],["TryStatement",!0]].forEach((function([e,t]){"boolean"==typeof t&&(t={after:t,before:t}),[e].concat(n.FLIPPED_ALIAS_KEYS[e]||[]).forEach((function(e){a[e]=function(){return t};}));}));},"./node_modules/@babel/generator/lib/printer.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/generator/lib/buffer.js"),s=r("./node_modules/@babel/generator/lib/node/index.js"),i=r("./node_modules/@babel/types/lib/index.js"),o=r("./node_modules/@babel/generator/lib/generators/index.js");const a=/e/i,l=/\.0+$/,u=/^0[box]/,c=/^\s*[@#]__PURE__\s*$/;class p{constructor(e,t){this.inForStatementInitCounter=0,this._printStack=[],this._indent=0,this._insideAux=!1,this._parenPushNewlineState=null,this._noLineTerminator=!1,this._printAuxAfterOnNextUserNode=!1,this._printedComments=new WeakSet,this._endsWithInteger=!1,this._endsWithWord=!1,this.format=e,this._buf=new n.default(t);}generate(e){return this.print(e),this._maybeAddAuxComment(),this._buf.get()}indent(){this.format.compact||this.format.concise||this._indent++;}dedent(){this.format.compact||this.format.concise||this._indent--;}semicolon(e=!1){this._maybeAddAuxComment(),this._append(";",!e);}rightBrace(){this.format.minified&&this._buf.removeLastSemicolon(),this.token("}");}space(e=!1){this.format.compact||(this._buf.hasContent()&&!this.endsWith(" ")&&!this.endsWith("\n")||e)&&this._space();}word(e){(this._endsWithWord||this.endsWith("/")&&0===e.indexOf("/"))&&this._space(),this._maybeAddAuxComment(),this._append(e),this._endsWithWord=!0;}number(e){this.word(e),this._endsWithInteger=Number.isInteger(+e)&&!u.test(e)&&!a.test(e)&&!l.test(e)&&"."!==e[e.length-1];}token(e){("--"===e&&this.endsWith("!")||"+"===e[0]&&this.endsWith("+")||"-"===e[0]&&this.endsWith("-")||"."===e[0]&&this._endsWithInteger)&&this._space(),this._maybeAddAuxComment(),this._append(e);}newline(e){if(!this.format.retainLines&&!this.format.compact)if(this.format.concise)this.space();else if(!(this.endsWith("\n\n")||("number"!=typeof e&&(e=1),e=Math.min(2,e),(this.endsWith("{\n")||this.endsWith(":\n"))&&e--,e<=0)))for(let t=0;t<e;t++)this._newline();}endsWith(e){return this._buf.endsWith(e)}removeTrailingNewline(){this._buf.removeTrailingNewline();}exactSource(e,t){this._catchUp("start",e),this._buf.exactSource(e,t);}source(e,t){this._catchUp(e,t),this._buf.source(e,t);}withSource(e,t,r){this._catchUp(e,t),this._buf.withSource(e,t,r);}_space(){this._append(" ",!0);}_newline(){this._append("\n",!0);}_append(e,t=!1){this._maybeAddParen(e),this._maybeIndent(e),t?this._buf.queue(e):this._buf.append(e),this._endsWithWord=!1,this._endsWithInteger=!1;}_maybeIndent(e){this._indent&&this.endsWith("\n")&&"\n"!==e[0]&&this._buf.queue(this._getIndent());}_maybeAddParen(e){const t=this._parenPushNewlineState;if(!t)return;let r;for(r=0;r<e.length&&" "===e[r];r++)continue;if(r===e.length)return;const n=e[r];if("\n"!==n){if("/"!==n||r+1===e.length)return void(this._parenPushNewlineState=null);const t=e[r+1];if("*"===t){if(c.test(e.slice(r+2,e.length-2)))return}else if("/"!==t)return void(this._parenPushNewlineState=null)}this.token("("),this.indent(),t.printed=!0;}_catchUp(e,t){if(!this.format.retainLines)return;const r=t?t[e]:null;if(null!=(null==r?void 0:r.line)){const e=r.line-this._buf.getCurrentLine();for(let t=0;t<e;t++)this._newline();}}_getIndent(){return this.format.indent.style.repeat(this._indent)}startTerminatorless(e=!1){return e?(this._noLineTerminator=!0,null):this._parenPushNewlineState={printed:!1}}endTerminatorless(e){this._noLineTerminator=!1,null!=e&&e.printed&&(this.dedent(),this.newline(),this.token(")"));}print(e,t){if(!e)return;const r=this.format.concise;e._compact&&(this.format.concise=!0);const n=this[e.type];if(!n)throw new ReferenceError(`unknown node of type ${JSON.stringify(e.type)} with constructor ${JSON.stringify(null==e?void 0:e.constructor.name)}`);this._printStack.push(e);const o=this._insideAux;this._insideAux=!e.loc,this._maybeAddAuxComment(this._insideAux&&!o);let a=s.needsParens(e,t,this._printStack);this.format.retainFunctionParens&&"FunctionExpression"===e.type&&e.extra&&e.extra.parenthesized&&(a=!0),a&&this.token("("),this._printLeadingComments(e);const l=i.isProgram(e)||i.isFile(e)?null:e.loc;this.withSource("start",l,(()=>{n.call(this,e,t);})),this._printTrailingComments(e),a&&this.token(")"),this._printStack.pop(),this.format.concise=r,this._insideAux=o;}_maybeAddAuxComment(e){e&&this._printAuxBeforeComment(),this._insideAux||this._printAuxAfterComment();}_printAuxBeforeComment(){if(this._printAuxAfterOnNextUserNode)return;this._printAuxAfterOnNextUserNode=!0;const e=this.format.auxiliaryCommentBefore;e&&this._printComment({type:"CommentBlock",value:e});}_printAuxAfterComment(){if(!this._printAuxAfterOnNextUserNode)return;this._printAuxAfterOnNextUserNode=!1;const e=this.format.auxiliaryCommentAfter;e&&this._printComment({type:"CommentBlock",value:e});}getPossibleRaw(e){const t=e.extra;if(t&&null!=t.raw&&null!=t.rawValue&&e.value===t.rawValue)return t.raw}printJoin(e,t,r={}){if(null==e||!e.length)return;r.indent&&this.indent();const n={addNewlines:r.addNewlines};for(let s=0;s<e.length;s++){const i=e[s];i&&(r.statement&&this._printNewline(!0,i,t,n),this.print(i,t),r.iterator&&r.iterator(i,s),r.separator&&s<e.length-1&&r.separator.call(this),r.statement&&this._printNewline(!1,i,t,n));}r.indent&&this.dedent();}printAndIndentOnComments(e,t){const r=e.leadingComments&&e.leadingComments.length>0;r&&this.indent(),this.print(e,t),r&&this.dedent();}printBlock(e){const t=e.body;i.isEmptyStatement(t)||this.space(),this.print(t,e);}_printTrailingComments(e){this._printComments(this._getComments(!1,e));}_printLeadingComments(e){this._printComments(this._getComments(!0,e),!0);}printInnerComments(e,t=!0){var r;null!=(r=e.innerComments)&&r.length&&(t&&this.indent(),this._printComments(e.innerComments),t&&this.dedent());}printSequence(e,t,r={}){return r.statement=!0,this.printJoin(e,t,r)}printList(e,t,r={}){return null==r.separator&&(r.separator=f),this.printJoin(e,t,r)}_printNewline(e,t,r,n){if(this.format.retainLines||this.format.compact)return;if(this.format.concise)return void this.space();let i=0;this._buf.hasContent()&&(e||i++,n.addNewlines&&(i+=n.addNewlines(e,t)||0),(e?s.needsWhitespaceBefore:s.needsWhitespaceAfter)(t,r)&&i++),this.newline(i);}_getComments(e,t){return t&&(e?t.leadingComments:t.trailingComments)||[]}_printComment(e,t){if(!this.format.shouldPrintComment(e.value))return;if(e.ignore)return;if(this._printedComments.has(e))return;this._printedComments.add(e);const r="CommentBlock"===e.type,n=r&&!t&&!this._noLineTerminator;n&&this._buf.hasContent()&&this.newline(1),this.endsWith("[")||this.endsWith("{")||this.space();let s=r||this._noLineTerminator?`/*${e.value}*/`:`//${e.value}\n`;if(r&&this.format.indent.adjustMultilineComment){var i;const t=null==(i=e.loc)?void 0:i.start.column;if(t){const e=new RegExp("\\n\\s{1,"+t+"}","g");s=s.replace(e,"\n");}const r=Math.max(this._getIndent().length,this.format.retainLines?0:this._buf.getCurrentColumn());s=s.replace(/\n(?!$)/g,`\n${" ".repeat(r)}`);}this.endsWith("/")&&this._space(),this.withSource("start",e.loc,(()=>{this._append(s);})),n&&this.newline(1);}_printComments(e,t){if(null!=e&&e.length)if(t&&1===e.length&&c.test(e[0].value))this._printComment(e[0],this._buf.hasContent()&&!this.endsWith("\n"));else for(const t of e)this._printComment(t);}printAssertions(e){var t;null!=(t=e.assertions)&&t.length&&(this.space(),this.word("assert"),this.space(),this.token("{"),this.space(),this.printList(e.assertions,e),this.space(),this.token("}"));}}Object.assign(p.prototype,o),p.prototype.Noop=function(){};var d=p;function f(){this.token(","),this.space();}t.default=d;},"./node_modules/@babel/generator/lib/source-map.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/generator/node_modules/source-map/source-map.js");t.default=class{constructor(e,t){this._cachedMap=void 0,this._code=void 0,this._opts=void 0,this._rawMappings=void 0,this._lastGenLine=void 0,this._lastSourceLine=void 0,this._lastSourceColumn=void 0,this._cachedMap=null,this._code=t,this._opts=e,this._rawMappings=[];}get(){if(!this._cachedMap){const e=this._cachedMap=new n.SourceMapGenerator({sourceRoot:this._opts.sourceRoot}),t=this._code;"string"==typeof t?e.setSourceContent(this._opts.sourceFileName.replace(/\\/g,"/"),t):"object"==typeof t&&Object.keys(t).forEach((r=>{e.setSourceContent(r.replace(/\\/g,"/"),t[r]);})),this._rawMappings.forEach((t=>e.addMapping(t)),e);}return this._cachedMap.toJSON()}getRawMappings(){return this._rawMappings.slice()}mark(e,t,r,n,s,i,o){this._lastGenLine!==e&&null===r||(o||this._lastGenLine!==e||this._lastSourceLine!==r||this._lastSourceColumn!==n)&&(this._cachedMap=null,this._lastGenLine=e,this._lastSourceLine=r,this._lastSourceColumn=n,this._rawMappings.push({name:s||void 0,generated:{line:e,column:t},source:null==r?void 0:(i||this._opts.sourceFileName).replace(/\\/g,"/"),original:null==r?void 0:{line:r,column:n}}));}};},"./node_modules/@babel/generator/node_modules/source-map/lib/array-set.js":(e,t,r)=>{var n=r("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"),s=Object.prototype.hasOwnProperty,i="undefined"!=typeof Map;function o(){this._array=[],this._set=i?new Map:Object.create(null);}o.fromArray=function(e,t){for(var r=new o,n=0,s=e.length;n<s;n++)r.add(e[n],t);return r},o.prototype.size=function(){return i?this._set.size:Object.getOwnPropertyNames(this._set).length},o.prototype.add=function(e,t){var r=i?e:n.toSetString(e),o=i?this.has(e):s.call(this._set,r),a=this._array.length;o&&!t||this._array.push(e),o||(i?this._set.set(e,a):this._set[r]=a);},o.prototype.has=function(e){if(i)return this._set.has(e);var t=n.toSetString(e);return s.call(this._set,t)},o.prototype.indexOf=function(e){if(i){var t=this._set.get(e);if(t>=0)return t}else {var r=n.toSetString(e);if(s.call(this._set,r))return this._set[r]}throw new Error('"'+e+'" is not in the set.')},o.prototype.at=function(e){if(e>=0&&e<this._array.length)return this._array[e];throw new Error("No element indexed by "+e)},o.prototype.toArray=function(){return this._array.slice()},t.I=o;},"./node_modules/@babel/generator/node_modules/source-map/lib/base64-vlq.js":(e,t,r)=>{var n=r("./node_modules/@babel/generator/node_modules/source-map/lib/base64.js");t.encode=function(e){var t,r="",s=function(e){return e<0?1+(-e<<1):0+(e<<1)}(e);do{t=31&s,(s>>>=5)>0&&(t|=32),r+=n.encode(t);}while(s>0);return r},t.decode=function(e,t,r){var s,i,o,a,l=e.length,u=0,c=0;do{if(t>=l)throw new Error("Expected more digits in base 64 VLQ value.");if(-1===(i=n.decode(e.charCodeAt(t++))))throw new Error("Invalid base64 digit: "+e.charAt(t-1));s=!!(32&i),u+=(i&=31)<<c,c+=5;}while(s);r.value=(a=(o=u)>>1,1==(1&o)?-a:a),r.rest=t;};},"./node_modules/@babel/generator/node_modules/source-map/lib/base64.js":(e,t)=>{var r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");t.encode=function(e){if(0<=e&&e<r.length)return r[e];throw new TypeError("Must be between 0 and 63: "+e)},t.decode=function(e){return 65<=e&&e<=90?e-65:97<=e&&e<=122?e-97+26:48<=e&&e<=57?e-48+52:43==e?62:47==e?63:-1};},"./node_modules/@babel/generator/node_modules/source-map/lib/binary-search.js":(e,t)=>{function r(e,n,s,i,o,a){var l=Math.floor((n-e)/2)+e,u=o(s,i[l],!0);return 0===u?l:u>0?n-l>1?r(l,n,s,i,o,a):a==t.LEAST_UPPER_BOUND?n<i.length?n:-1:l:l-e>1?r(e,l,s,i,o,a):a==t.LEAST_UPPER_BOUND?l:e<0?-1:e}t.GREATEST_LOWER_BOUND=1,t.LEAST_UPPER_BOUND=2,t.search=function(e,n,s,i){if(0===n.length)return -1;var o=r(-1,n.length,e,n,s,i||t.GREATEST_LOWER_BOUND);if(o<0)return -1;for(;o-1>=0&&0===s(n[o],n[o-1],!0);)--o;return o};},"./node_modules/@babel/generator/node_modules/source-map/lib/mapping-list.js":(e,t,r)=>{var n=r("./node_modules/@babel/generator/node_modules/source-map/lib/util.js");function s(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0};}s.prototype.unsortedForEach=function(e,t){this._array.forEach(e,t);},s.prototype.add=function(e){var t,r,s,i,o,a;r=e,s=(t=this._last).generatedLine,i=r.generatedLine,o=t.generatedColumn,a=r.generatedColumn,i>s||i==s&&a>=o||n.compareByGeneratedPositionsInflated(t,r)<=0?(this._last=e,this._array.push(e)):(this._sorted=!1,this._array.push(e));},s.prototype.toArray=function(){return this._sorted||(this._array.sort(n.compareByGeneratedPositionsInflated),this._sorted=!0),this._array},t.H=s;},"./node_modules/@babel/generator/node_modules/source-map/lib/quick-sort.js":(e,t)=>{function r(e,t,r){var n=e[t];e[t]=e[r],e[r]=n;}function n(e,t,s,i){if(s<i){var o=s-1;r(e,(c=s,p=i,Math.round(c+Math.random()*(p-c))),i);for(var a=e[i],l=s;l<i;l++)t(e[l],a)<=0&&r(e,o+=1,l);r(e,o+1,l);var u=o+1;n(e,t,s,u-1),n(e,t,u+1,i);}var c,p;}t.U=function(e,t){n(e,t,0,e.length-1);};},"./node_modules/@babel/generator/node_modules/source-map/lib/source-map-consumer.js":(e,t,r)=>{var n=r("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"),s=r("./node_modules/@babel/generator/node_modules/source-map/lib/binary-search.js"),i=r("./node_modules/@babel/generator/node_modules/source-map/lib/array-set.js").I,o=r("./node_modules/@babel/generator/node_modules/source-map/lib/base64-vlq.js"),a=r("./node_modules/@babel/generator/node_modules/source-map/lib/quick-sort.js").U;function l(e){var t=e;return "string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,""))),null!=t.sections?new p(t):new u(t)}function u(e){var t=e;"string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,"")));var r=n.getArg(t,"version"),s=n.getArg(t,"sources"),o=n.getArg(t,"names",[]),a=n.getArg(t,"sourceRoot",null),l=n.getArg(t,"sourcesContent",null),u=n.getArg(t,"mappings"),c=n.getArg(t,"file",null);if(r!=this._version)throw new Error("Unsupported version: "+r);s=s.map(String).map(n.normalize).map((function(e){return a&&n.isAbsolute(a)&&n.isAbsolute(e)?n.relative(a,e):e})),this._names=i.fromArray(o.map(String),!0),this._sources=i.fromArray(s,!0),this.sourceRoot=a,this.sourcesContent=l,this._mappings=u,this.file=c;}function c(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null;}function p(e){var t=e;"string"==typeof e&&(t=JSON.parse(e.replace(/^\)\]\}'/,"")));var r=n.getArg(t,"version"),s=n.getArg(t,"sections");if(r!=this._version)throw new Error("Unsupported version: "+r);this._sources=new i,this._names=new i;var o={line:-1,column:0};this._sections=s.map((function(e){if(e.url)throw new Error("Support for url field in sections not implemented.");var t=n.getArg(e,"offset"),r=n.getArg(t,"line"),s=n.getArg(t,"column");if(r<o.line||r===o.line&&s<o.column)throw new Error("Section offsets must be ordered and non-overlapping.");return o=t,{generatedOffset:{generatedLine:r+1,generatedColumn:s+1},consumer:new l(n.getArg(e,"map"))}}));}l.fromSourceMap=function(e){return u.fromSourceMap(e)},l.prototype._version=3,l.prototype.__generatedMappings=null,Object.defineProperty(l.prototype,"_generatedMappings",{get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),l.prototype.__originalMappings=null,Object.defineProperty(l.prototype,"_originalMappings",{get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),l.prototype._charIsMappingSeparator=function(e,t){var r=e.charAt(t);return ";"===r||","===r},l.prototype._parseMappings=function(e,t){throw new Error("Subclasses must implement _parseMappings")},l.GENERATED_ORDER=1,l.ORIGINAL_ORDER=2,l.GREATEST_LOWER_BOUND=1,l.LEAST_UPPER_BOUND=2,l.prototype.eachMapping=function(e,t,r){var s,i=t||null;switch(r||l.GENERATED_ORDER){case l.GENERATED_ORDER:s=this._generatedMappings;break;case l.ORIGINAL_ORDER:s=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var o=this.sourceRoot;s.map((function(e){var t=null===e.source?null:this._sources.at(e.source);return null!=t&&null!=o&&(t=n.join(o,t)),{source:t,generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:null===e.name?null:this._names.at(e.name)}}),this).forEach(e,i);},l.prototype.allGeneratedPositionsFor=function(e){var t=n.getArg(e,"line"),r={source:n.getArg(e,"source"),originalLine:t,originalColumn:n.getArg(e,"column",0)};if(null!=this.sourceRoot&&(r.source=n.relative(this.sourceRoot,r.source)),!this._sources.has(r.source))return [];r.source=this._sources.indexOf(r.source);var i=[],o=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",n.compareByOriginalPositions,s.LEAST_UPPER_BOUND);if(o>=0){var a=this._originalMappings[o];if(void 0===e.column)for(var l=a.originalLine;a&&a.originalLine===l;)i.push({line:n.getArg(a,"generatedLine",null),column:n.getArg(a,"generatedColumn",null),lastColumn:n.getArg(a,"lastGeneratedColumn",null)}),a=this._originalMappings[++o];else for(var u=a.originalColumn;a&&a.originalLine===t&&a.originalColumn==u;)i.push({line:n.getArg(a,"generatedLine",null),column:n.getArg(a,"generatedColumn",null),lastColumn:n.getArg(a,"lastGeneratedColumn",null)}),a=this._originalMappings[++o];}return i},t.SourceMapConsumer=l,u.prototype=Object.create(l.prototype),u.prototype.consumer=l,u.fromSourceMap=function(e){var t=Object.create(u.prototype),r=t._names=i.fromArray(e._names.toArray(),!0),s=t._sources=i.fromArray(e._sources.toArray(),!0);t.sourceRoot=e._sourceRoot,t.sourcesContent=e._generateSourcesContent(t._sources.toArray(),t.sourceRoot),t.file=e._file;for(var o=e._mappings.toArray().slice(),l=t.__generatedMappings=[],p=t.__originalMappings=[],d=0,f=o.length;d<f;d++){var h=o[d],m=new c;m.generatedLine=h.generatedLine,m.generatedColumn=h.generatedColumn,h.source&&(m.source=s.indexOf(h.source),m.originalLine=h.originalLine,m.originalColumn=h.originalColumn,h.name&&(m.name=r.indexOf(h.name)),p.push(m)),l.push(m);}return a(t.__originalMappings,n.compareByOriginalPositions),t},u.prototype._version=3,Object.defineProperty(u.prototype,"sources",{get:function(){return this._sources.toArray().map((function(e){return null!=this.sourceRoot?n.join(this.sourceRoot,e):e}),this)}}),u.prototype._parseMappings=function(e,t){for(var r,s,i,l,u,p=1,d=0,f=0,h=0,m=0,y=0,b=e.length,g=0,E={},v={},x=[],T=[];g<b;)if(";"===e.charAt(g))p++,g++,d=0;else if(","===e.charAt(g))g++;else {for((r=new c).generatedLine=p,l=g;l<b&&!this._charIsMappingSeparator(e,l);l++);if(i=E[s=e.slice(g,l)])g+=s.length;else {for(i=[];g<l;)o.decode(e,g,v),u=v.value,g=v.rest,i.push(u);if(2===i.length)throw new Error("Found a source, but no line and column");if(3===i.length)throw new Error("Found a source and line, but no column");E[s]=i;}r.generatedColumn=d+i[0],d=r.generatedColumn,i.length>1&&(r.source=m+i[1],m+=i[1],r.originalLine=f+i[2],f=r.originalLine,r.originalLine+=1,r.originalColumn=h+i[3],h=r.originalColumn,i.length>4&&(r.name=y+i[4],y+=i[4])),T.push(r),"number"==typeof r.originalLine&&x.push(r);}a(T,n.compareByGeneratedPositionsDeflated),this.__generatedMappings=T,a(x,n.compareByOriginalPositions),this.__originalMappings=x;},u.prototype._findMapping=function(e,t,r,n,i,o){if(e[r]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+e[r]);if(e[n]<0)throw new TypeError("Column must be greater than or equal to 0, got "+e[n]);return s.search(e,t,i,o)},u.prototype.computeColumnSpans=function(){for(var e=0;e<this._generatedMappings.length;++e){var t=this._generatedMappings[e];if(e+1<this._generatedMappings.length){var r=this._generatedMappings[e+1];if(t.generatedLine===r.generatedLine){t.lastGeneratedColumn=r.generatedColumn-1;continue}}t.lastGeneratedColumn=1/0;}},u.prototype.originalPositionFor=function(e){var t={generatedLine:n.getArg(e,"line"),generatedColumn:n.getArg(e,"column")},r=this._findMapping(t,this._generatedMappings,"generatedLine","generatedColumn",n.compareByGeneratedPositionsDeflated,n.getArg(e,"bias",l.GREATEST_LOWER_BOUND));if(r>=0){var s=this._generatedMappings[r];if(s.generatedLine===t.generatedLine){var i=n.getArg(s,"source",null);null!==i&&(i=this._sources.at(i),null!=this.sourceRoot&&(i=n.join(this.sourceRoot,i)));var o=n.getArg(s,"name",null);return null!==o&&(o=this._names.at(o)),{source:i,line:n.getArg(s,"originalLine",null),column:n.getArg(s,"originalColumn",null),name:o}}}return {source:null,line:null,column:null,name:null}},u.prototype.hasContentsOfAllSources=function(){return !!this.sourcesContent&&this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some((function(e){return null==e}))},u.prototype.sourceContentFor=function(e,t){if(!this.sourcesContent)return null;if(null!=this.sourceRoot&&(e=n.relative(this.sourceRoot,e)),this._sources.has(e))return this.sourcesContent[this._sources.indexOf(e)];var r;if(null!=this.sourceRoot&&(r=n.urlParse(this.sourceRoot))){var s=e.replace(/^file:\/\//,"");if("file"==r.scheme&&this._sources.has(s))return this.sourcesContent[this._sources.indexOf(s)];if((!r.path||"/"==r.path)&&this._sources.has("/"+e))return this.sourcesContent[this._sources.indexOf("/"+e)]}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},u.prototype.generatedPositionFor=function(e){var t=n.getArg(e,"source");if(null!=this.sourceRoot&&(t=n.relative(this.sourceRoot,t)),!this._sources.has(t))return {line:null,column:null,lastColumn:null};var r={source:t=this._sources.indexOf(t),originalLine:n.getArg(e,"line"),originalColumn:n.getArg(e,"column")},s=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",n.compareByOriginalPositions,n.getArg(e,"bias",l.GREATEST_LOWER_BOUND));if(s>=0){var i=this._originalMappings[s];if(i.source===r.source)return {line:n.getArg(i,"generatedLine",null),column:n.getArg(i,"generatedColumn",null),lastColumn:n.getArg(i,"lastGeneratedColumn",null)}}return {line:null,column:null,lastColumn:null}},p.prototype=Object.create(l.prototype),p.prototype.constructor=l,p.prototype._version=3,Object.defineProperty(p.prototype,"sources",{get:function(){for(var e=[],t=0;t<this._sections.length;t++)for(var r=0;r<this._sections[t].consumer.sources.length;r++)e.push(this._sections[t].consumer.sources[r]);return e}}),p.prototype.originalPositionFor=function(e){var t={generatedLine:n.getArg(e,"line"),generatedColumn:n.getArg(e,"column")},r=s.search(t,this._sections,(function(e,t){return e.generatedLine-t.generatedOffset.generatedLine||e.generatedColumn-t.generatedOffset.generatedColumn})),i=this._sections[r];return i?i.consumer.originalPositionFor({line:t.generatedLine-(i.generatedOffset.generatedLine-1),column:t.generatedColumn-(i.generatedOffset.generatedLine===t.generatedLine?i.generatedOffset.generatedColumn-1:0),bias:e.bias}):{source:null,line:null,column:null,name:null}},p.prototype.hasContentsOfAllSources=function(){return this._sections.every((function(e){return e.consumer.hasContentsOfAllSources()}))},p.prototype.sourceContentFor=function(e,t){for(var r=0;r<this._sections.length;r++){var n=this._sections[r].consumer.sourceContentFor(e,!0);if(n)return n}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},p.prototype.generatedPositionFor=function(e){for(var t=0;t<this._sections.length;t++){var r=this._sections[t];if(-1!==r.consumer.sources.indexOf(n.getArg(e,"source"))){var s=r.consumer.generatedPositionFor(e);if(s)return {line:s.line+(r.generatedOffset.generatedLine-1),column:s.column+(r.generatedOffset.generatedLine===s.line?r.generatedOffset.generatedColumn-1:0)}}}return {line:null,column:null}},p.prototype._parseMappings=function(e,t){this.__generatedMappings=[],this.__originalMappings=[];for(var r=0;r<this._sections.length;r++)for(var s=this._sections[r],i=s.consumer._generatedMappings,o=0;o<i.length;o++){var l=i[o],u=s.consumer._sources.at(l.source);null!==s.consumer.sourceRoot&&(u=n.join(s.consumer.sourceRoot,u)),this._sources.add(u),u=this._sources.indexOf(u);var c=s.consumer._names.at(l.name);this._names.add(c),c=this._names.indexOf(c);var p={source:u,generatedLine:l.generatedLine+(s.generatedOffset.generatedLine-1),generatedColumn:l.generatedColumn+(s.generatedOffset.generatedLine===l.generatedLine?s.generatedOffset.generatedColumn-1:0),originalLine:l.originalLine,originalColumn:l.originalColumn,name:c};this.__generatedMappings.push(p),"number"==typeof p.originalLine&&this.__originalMappings.push(p);}a(this.__generatedMappings,n.compareByGeneratedPositionsDeflated),a(this.__originalMappings,n.compareByOriginalPositions);};},"./node_modules/@babel/generator/node_modules/source-map/lib/source-map-generator.js":(e,t,r)=>{var n=r("./node_modules/@babel/generator/node_modules/source-map/lib/base64-vlq.js"),s=r("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"),i=r("./node_modules/@babel/generator/node_modules/source-map/lib/array-set.js").I,o=r("./node_modules/@babel/generator/node_modules/source-map/lib/mapping-list.js").H;function a(e){e||(e={}),this._file=s.getArg(e,"file",null),this._sourceRoot=s.getArg(e,"sourceRoot",null),this._skipValidation=s.getArg(e,"skipValidation",!1),this._sources=new i,this._names=new i,this._mappings=new o,this._sourcesContents=null;}a.prototype._version=3,a.fromSourceMap=function(e){var t=e.sourceRoot,r=new a({file:e.file,sourceRoot:t});return e.eachMapping((function(e){var n={generated:{line:e.generatedLine,column:e.generatedColumn}};null!=e.source&&(n.source=e.source,null!=t&&(n.source=s.relative(t,n.source)),n.original={line:e.originalLine,column:e.originalColumn},null!=e.name&&(n.name=e.name)),r.addMapping(n);})),e.sources.forEach((function(t){var n=e.sourceContentFor(t);null!=n&&r.setSourceContent(t,n);})),r},a.prototype.addMapping=function(e){var t=s.getArg(e,"generated"),r=s.getArg(e,"original",null),n=s.getArg(e,"source",null),i=s.getArg(e,"name",null);this._skipValidation||this._validateMapping(t,r,n,i),null!=n&&(n=String(n),this._sources.has(n)||this._sources.add(n)),null!=i&&(i=String(i),this._names.has(i)||this._names.add(i)),this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:null!=r&&r.line,originalColumn:null!=r&&r.column,source:n,name:i});},a.prototype.setSourceContent=function(e,t){var r=e;null!=this._sourceRoot&&(r=s.relative(this._sourceRoot,r)),null!=t?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[s.toSetString(r)]=t):this._sourcesContents&&(delete this._sourcesContents[s.toSetString(r)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null));},a.prototype.applySourceMap=function(e,t,r){var n=t;if(null==t){if(null==e.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');n=e.file;}var o=this._sourceRoot;null!=o&&(n=s.relative(o,n));var a=new i,l=new i;this._mappings.unsortedForEach((function(t){if(t.source===n&&null!=t.originalLine){var i=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});null!=i.source&&(t.source=i.source,null!=r&&(t.source=s.join(r,t.source)),null!=o&&(t.source=s.relative(o,t.source)),t.originalLine=i.line,t.originalColumn=i.column,null!=i.name&&(t.name=i.name));}var u=t.source;null==u||a.has(u)||a.add(u);var c=t.name;null==c||l.has(c)||l.add(c);}),this),this._sources=a,this._names=l,e.sources.forEach((function(t){var n=e.sourceContentFor(t);null!=n&&(null!=r&&(t=s.join(r,t)),null!=o&&(t=s.relative(o,t)),this.setSourceContent(t,n));}),this);},a.prototype._validateMapping=function(e,t,r,n){if(t&&"number"!=typeof t.line&&"number"!=typeof t.column)throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");if((!(e&&"line"in e&&"column"in e&&e.line>0&&e.column>=0)||t||r||n)&&!(e&&"line"in e&&"column"in e&&t&&"line"in t&&"column"in t&&e.line>0&&e.column>=0&&t.line>0&&t.column>=0&&r))throw new Error("Invalid mapping: "+JSON.stringify({generated:e,source:r,original:t,name:n}))},a.prototype._serializeMappings=function(){for(var e,t,r,i,o=0,a=1,l=0,u=0,c=0,p=0,d="",f=this._mappings.toArray(),h=0,m=f.length;h<m;h++){if(e="",(t=f[h]).generatedLine!==a)for(o=0;t.generatedLine!==a;)e+=";",a++;else if(h>0){if(!s.compareByGeneratedPositionsInflated(t,f[h-1]))continue;e+=",";}e+=n.encode(t.generatedColumn-o),o=t.generatedColumn,null!=t.source&&(i=this._sources.indexOf(t.source),e+=n.encode(i-p),p=i,e+=n.encode(t.originalLine-1-u),u=t.originalLine-1,e+=n.encode(t.originalColumn-l),l=t.originalColumn,null!=t.name&&(r=this._names.indexOf(t.name),e+=n.encode(r-c),c=r)),d+=e;}return d},a.prototype._generateSourcesContent=function(e,t){return e.map((function(e){if(!this._sourcesContents)return null;null!=t&&(e=s.relative(t,e));var r=s.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,r)?this._sourcesContents[r]:null}),this)},a.prototype.toJSON=function(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(e.file=this._file),null!=this._sourceRoot&&(e.sourceRoot=this._sourceRoot),this._sourcesContents&&(e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)),e},a.prototype.toString=function(){return JSON.stringify(this.toJSON())},t.SourceMapGenerator=a;},"./node_modules/@babel/generator/node_modules/source-map/lib/source-node.js":(e,t,r)=>{var n=r("./node_modules/@babel/generator/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator,s=r("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"),i=/(\r?\n)/,o="$$$isSourceNode$$$";function a(e,t,r,n,s){this.children=[],this.sourceContents={},this.line=null==e?null:e,this.column=null==t?null:t,this.source=null==r?null:r,this.name=null==s?null:s,this[o]=!0,null!=n&&this.add(n);}a.fromStringWithSourceMap=function(e,t,r){var n=new a,o=e.split(i),l=0,u=function(){return e()+(e()||"");function e(){return l<o.length?o[l++]:void 0}},c=1,p=0,d=null;return t.eachMapping((function(e){if(null!==d){if(!(c<e.generatedLine)){var t=(r=o[l]).substr(0,e.generatedColumn-p);return o[l]=r.substr(e.generatedColumn-p),p=e.generatedColumn,f(d,t),void(d=e)}f(d,u()),c++,p=0;}for(;c<e.generatedLine;)n.add(u()),c++;if(p<e.generatedColumn){var r=o[l];n.add(r.substr(0,e.generatedColumn)),o[l]=r.substr(e.generatedColumn),p=e.generatedColumn;}d=e;}),this),l<o.length&&(d&&f(d,u()),n.add(o.splice(l).join(""))),t.sources.forEach((function(e){var i=t.sourceContentFor(e);null!=i&&(null!=r&&(e=s.join(r,e)),n.setSourceContent(e,i));})),n;function f(e,t){if(null===e||void 0===e.source)n.add(t);else {var i=r?s.join(r,e.source):e.source;n.add(new a(e.originalLine,e.originalColumn,i,t,e.name));}}},a.prototype.add=function(e){if(Array.isArray(e))e.forEach((function(e){this.add(e);}),this);else {if(!e[o]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);e&&this.children.push(e);}return this},a.prototype.prepend=function(e){if(Array.isArray(e))for(var t=e.length-1;t>=0;t--)this.prepend(e[t]);else {if(!e[o]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);this.children.unshift(e);}return this},a.prototype.walk=function(e){for(var t,r=0,n=this.children.length;r<n;r++)(t=this.children[r])[o]?t.walk(e):""!==t&&e(t,{source:this.source,line:this.line,column:this.column,name:this.name});},a.prototype.join=function(e){var t,r,n=this.children.length;if(n>0){for(t=[],r=0;r<n-1;r++)t.push(this.children[r]),t.push(e);t.push(this.children[r]),this.children=t;}return this},a.prototype.replaceRight=function(e,t){var r=this.children[this.children.length-1];return r[o]?r.replaceRight(e,t):"string"==typeof r?this.children[this.children.length-1]=r.replace(e,t):this.children.push("".replace(e,t)),this},a.prototype.setSourceContent=function(e,t){this.sourceContents[s.toSetString(e)]=t;},a.prototype.walkSourceContents=function(e){for(var t=0,r=this.children.length;t<r;t++)this.children[t][o]&&this.children[t].walkSourceContents(e);var n=Object.keys(this.sourceContents);for(t=0,r=n.length;t<r;t++)e(s.fromSetString(n[t]),this.sourceContents[n[t]]);},a.prototype.toString=function(){var e="";return this.walk((function(t){e+=t;})),e},a.prototype.toStringWithSourceMap=function(e){var t={code:"",line:1,column:0},r=new n(e),s=!1,i=null,o=null,a=null,l=null;return this.walk((function(e,n){t.code+=e,null!==n.source&&null!==n.line&&null!==n.column?(i===n.source&&o===n.line&&a===n.column&&l===n.name||r.addMapping({source:n.source,original:{line:n.line,column:n.column},generated:{line:t.line,column:t.column},name:n.name}),i=n.source,o=n.line,a=n.column,l=n.name,s=!0):s&&(r.addMapping({generated:{line:t.line,column:t.column}}),i=null,s=!1);for(var u=0,c=e.length;u<c;u++)10===e.charCodeAt(u)?(t.line++,t.column=0,u+1===c?(i=null,s=!1):s&&r.addMapping({source:n.source,original:{line:n.line,column:n.column},generated:{line:t.line,column:t.column},name:n.name})):t.column++;})),this.walkSourceContents((function(e,t){r.setSourceContent(e,t);})),{code:t.code,map:r}},t.SourceNode=a;},"./node_modules/@babel/generator/node_modules/source-map/lib/util.js":(e,t)=>{t.getArg=function(e,t,r){if(t in e)return e[t];if(3===arguments.length)return r;throw new Error('"'+t+'" is a required argument.')};var r=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/,n=/^data:.+\,.+$/;function s(e){var t=e.match(r);return t?{scheme:t[1],auth:t[2],host:t[3],port:t[4],path:t[5]}:null}function i(e){var t="";return e.scheme&&(t+=e.scheme+":"),t+="//",e.auth&&(t+=e.auth+"@"),e.host&&(t+=e.host),e.port&&(t+=":"+e.port),e.path&&(t+=e.path),t}function o(e){var r=e,n=s(e);if(n){if(!n.path)return e;r=n.path;}for(var o,a=t.isAbsolute(r),l=r.split(/\/+/),u=0,c=l.length-1;c>=0;c--)"."===(o=l[c])?l.splice(c,1):".."===o?u++:u>0&&(""===o?(l.splice(c+1,u),u=0):(l.splice(c,2),u--));return ""===(r=l.join("/"))&&(r=a?"/":"."),n?(n.path=r,i(n)):r}t.urlParse=s,t.urlGenerate=i,t.normalize=o,t.join=function(e,t){""===e&&(e="."),""===t&&(t=".");var r=s(t),a=s(e);if(a&&(e=a.path||"/"),r&&!r.scheme)return a&&(r.scheme=a.scheme),i(r);if(r||t.match(n))return t;if(a&&!a.host&&!a.path)return a.host=t,i(a);var l="/"===t.charAt(0)?t:o(e.replace(/\/+$/,"")+"/"+t);return a?(a.path=l,i(a)):l},t.isAbsolute=function(e){return "/"===e.charAt(0)||!!e.match(r)},t.relative=function(e,t){""===e&&(e="."),e=e.replace(/\/$/,"");for(var r=0;0!==t.indexOf(e+"/");){var n=e.lastIndexOf("/");if(n<0)return t;if((e=e.slice(0,n)).match(/^([^\/]+:\/)?\/*$/))return t;++r;}return Array(r+1).join("../")+t.substr(e.length+1)};var a=!("__proto__"in Object.create(null));function l(e){return e}function u(e){if(!e)return !1;var t=e.length;if(t<9)return !1;if(95!==e.charCodeAt(t-1)||95!==e.charCodeAt(t-2)||111!==e.charCodeAt(t-3)||116!==e.charCodeAt(t-4)||111!==e.charCodeAt(t-5)||114!==e.charCodeAt(t-6)||112!==e.charCodeAt(t-7)||95!==e.charCodeAt(t-8)||95!==e.charCodeAt(t-9))return !1;for(var r=t-10;r>=0;r--)if(36!==e.charCodeAt(r))return !1;return !0}function c(e,t){return e===t?0:e>t?1:-1}t.toSetString=a?l:function(e){return u(e)?"$"+e:e},t.fromSetString=a?l:function(e){return u(e)?e.slice(1):e},t.compareByOriginalPositions=function(e,t,r){var n=e.source-t.source;return 0!==n||0!=(n=e.originalLine-t.originalLine)||0!=(n=e.originalColumn-t.originalColumn)||r||0!=(n=e.generatedColumn-t.generatedColumn)||0!=(n=e.generatedLine-t.generatedLine)?n:e.name-t.name},t.compareByGeneratedPositionsDeflated=function(e,t,r){var n=e.generatedLine-t.generatedLine;return 0!==n||0!=(n=e.generatedColumn-t.generatedColumn)||r||0!=(n=e.source-t.source)||0!=(n=e.originalLine-t.originalLine)||0!=(n=e.originalColumn-t.originalColumn)?n:e.name-t.name},t.compareByGeneratedPositionsInflated=function(e,t){var r=e.generatedLine-t.generatedLine;return 0!==r||0!=(r=e.generatedColumn-t.generatedColumn)||0!==(r=c(e.source,t.source))||0!=(r=e.originalLine-t.originalLine)||0!=(r=e.originalColumn-t.originalColumn)?r:c(e.name,t.name)};},"./node_modules/@babel/generator/node_modules/source-map/source-map.js":(e,t,r)=>{t.SourceMapGenerator=r("./node_modules/@babel/generator/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator,t.SourceMapConsumer=r("./node_modules/@babel/generator/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer,t.SourceNode=r("./node_modules/@babel/generator/node_modules/source-map/lib/source-node.js").SourceNode;},"./node_modules/@babel/helper-annotate-as-pure/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){const t=e.node||e;(({leadingComments:e})=>!!e&&e.some((e=>/[@#]__PURE__/.test(e.value))))(t)||n.addComment(t,"leading","#__PURE__");};var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}},"./node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.hasOwnDecorators=o,t.hasDecorators=function(e){return o(e)||e.body.body.some(o)},t.buildDecoratedClass=function(e,t,r,s){const{node:i,scope:o}=t,a=o.generateUidIdentifier("initialize"),u=i.id&&t.isDeclaration(),p=t.isInStrictMode(),{superClass:d}=i;let f;i.type="ClassDeclaration",i.id||(i.id=n.types.cloneNode(e)),d&&(f=o.generateUidIdentifierBasedOnNode(i.superClass,"super"),i.superClass=f);const h=l(i),m=n.types.arrayExpression(r.filter((e=>!e.node.abstract)).map(c.bind(s,i.id,f)));let y=n.template.expression.ast`
    ${function(e){try{return e.addHelper("decorate")}catch(e){throw "BABEL_HELPER_UNKNOWN"===e.code&&(e.message+="\n  '@babel/plugin-transform-decorators' in non-legacy mode requires '@babel/core' version ^7.0.2 and you appear to be using an older version."),e}}(s)}(
      ${h||n.types.nullLiteral()},
      function (${a}, ${d?n.types.cloneNode(f):null}) {
        ${i}
        return { F: ${n.types.cloneNode(i.id)}, d: ${m} };
      },
      ${d}
    )
  `,b="arguments.1.body.body.0";return p||y.arguments[1].body.directives.push(n.types.directive(n.types.directiveLiteral("use strict"))),u&&(y=n.template.ast`let ${e} = ${y}`,b="declarations.0.init."+b),{instanceNodes:[n.template.statement.ast`${n.types.cloneNode(a)}(this)`],wrapClass:e=>(e.replaceWith(y),e.get(b))}};var n=r("./node_modules/@babel/core/lib/index.js"),s=r("./node_modules/@babel/helper-replace-supers/lib/index.js"),i=r("./node_modules/@babel/helper-function-name/lib/index.js");function o(e){return !(!e.decorators||!e.decorators.length)}function a(e,t){return t?n.types.objectProperty(n.types.identifier(e),t):null}function l(e){let t;return e.decorators&&e.decorators.length>0&&(t=n.types.arrayExpression(e.decorators.map((e=>e.expression)))),e.decorators=void 0,t}function u(e){return e.computed?e.key:n.types.isIdentifier(e.key)?n.types.stringLiteral(e.key.name):n.types.stringLiteral(String(e.key.value))}function c(e,t,r){const{node:o,scope:c}=r,p=r.isClassMethod();if(r.isPrivate())throw r.buildCodeFrameError(`Private ${p?"methods":"fields"} in decorated classes are not supported yet.`);new s.default({methodPath:r,methodNode:o,objectRef:e,isStatic:o.static,superRef:t,scope:c,file:this,refToPreserve:e},!0).replace();const d=[a("kind",n.types.stringLiteral(p?o.kind:"field")),a("decorators",l(o)),a("static",o.static&&n.types.booleanLiteral(!0)),a("key",u(o))].filter(Boolean);if(p){const e=o.computed?null:o.key;n.types.toExpression(o),d.push(a("value",(0, i.default)({node:o,id:e,scope:c})||o));}else o.value?d.push((f=n.template.statements.ast`return ${o.value}`,n.types.objectMethod("method",n.types.identifier("value"),[],n.types.blockStatement(f)))):d.push(a("value",c.buildUndefinedNode()));var f;return r.remove(),n.types.objectExpression(d)}},"./node_modules/@babel/helper-create-class-features-plugin/lib/features.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.enableFeature=function(e,t,r){let n,s;u(e,t)&&!d(e,t)||(e.set(o,e.get(o)|t),"#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error"===r?(p(e,t,!0),e.set(l,e.get(l)|t)):"#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"===r?(p(e,t,!1),e.set(l,e.get(l)|t)):p(e,t,r));for(const[t,r]of i){if(!u(e,t))continue;const i=c(e,t);if(!d(e,t)){if(n===!i)throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled).");n=i,s=r;}}if(void 0!==n)for(const[t,r]of i)u(e,t)&&c(e,t)!==n&&(p(e,t,n),console.warn(`Though the "loose" option was set to "${!n}" in your @babel/preset-env config, it will not be used for ${r} since the "loose" mode option was set to "${n}" for ${s}.\nThe "loose" option must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding\n\t["${r}", { "loose": ${n} }]\nto the "plugins" section of your Babel config.`));},t.isLoose=c,t.verifyUsedFeatures=function(e,t){if((0, n.hasOwnDecorators)(e.node)){if(!u(t,s.decorators))throw e.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "legacy": true }], make sure it comes *before* "@babel/plugin-proposal-class-properties" and enable loose mode, like so:\n\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n\t["@babel/plugin-proposal-class-properties", { "loose": true }]');if(e.isPrivate())throw e.buildCodeFrameError(`Private ${e.isClassMethod()?"methods":"fields"} in decorated classes are not supported yet.`)}if(null!=e.isPrivateMethod&&e.isPrivateMethod()&&!u(t,s.privateMethods))throw e.buildCodeFrameError("Class private methods are not enabled.");if(e.isPrivateName()&&e.parentPath.isBinaryExpression({operator:"in",left:e.node})&&!u(t,s.privateIn))throw e.buildCodeFrameError("Private property in checks are not enabled.");if(e.isProperty()&&!u(t,s.fields))throw e.buildCodeFrameError("Class fields are not enabled.");if(null!=e.isStaticBlock&&e.isStaticBlock()&&!u(t,s.staticBlocks))throw e.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-proposal-class-static-block` to your configuration.")},t.FEATURES=void 0;var n=r("./node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js");const s=Object.freeze({fields:2,privateMethods:4,decorators:8,privateIn:16,staticBlocks:32});t.FEATURES=s;const i=new Map([[s.fields,"@babel/plugin-proposal-class-properties"],[s.privateMethods,"@babel/plugin-proposal-private-methods"],[s.privateIn,"@babel/plugin-proposal-private-property-in-object"]]),o="@babel/plugin-class-features/featuresKey",a="@babel/plugin-class-features/looseKey",l="@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";function u(e,t){return !!(e.get(o)&t)}function c(e,t){return !!(e.get(a)&t)}function p(e,t,r){r?e.set(a,e.get(a)|t):e.set(a,e.get(a)&~t),e.set(l,e.get(l)&~t);}function d(e,t){return !!(e.get(l)&t)}},"./node_modules/@babel/helper-create-class-features-plugin/lib/fields.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.buildPrivateNamesMap=function(e){const t=new Map;for(const r of e){const e=r.isPrivate(),n=!r.isProperty(),s=!r.node.static;if(e){const{name:e}=r.node.key.id,i=t.has(e)?t.get(e):{id:r.scope.generateUidIdentifier(e),static:!s,method:n};"get"===r.node.kind?i.getId=r.scope.generateUidIdentifier(`get_${e}`):"set"===r.node.kind?i.setId=r.scope.generateUidIdentifier(`set_${e}`):"method"===r.node.kind&&(i.methodId=r.scope.generateUidIdentifier(e)),t.set(e,i);}}return t},t.buildPrivateNamesNodes=function(e,t,r){const s=[];for(const[i,o]of e){const{static:e,method:l,getId:u,setId:c}=o,p=u||c,d=n.types.cloneNode(o.id);let f;t?f=n.types.callExpression(r.addHelper("classPrivateFieldLooseKey"),[n.types.stringLiteral(i)]):e||(f=n.types.newExpression(n.types.identifier(!l||p?"WeakMap":"WeakSet"),[])),f&&((0, a.default)(f),s.push(n.template.statement.ast`var ${d} = ${f}`));}return s},t.transformPrivateNamesUsage=function(e,t,r,{privateFieldsAsProperties:n,noDocumentAll:s},o){if(!r.size)return;const a=t.get("body"),l=n?f:d;(0, i.default)(a,c,Object.assign({privateNamesMap:r,classRef:e,file:o},l,{noDocumentAll:s})),a.traverse(p,{privateNamesMap:r,classRef:e,file:o,privateFieldsAsProperties:n});},t.buildFieldsInitNodes=function(e,t,r,s,i,o,a,u){let c,p=!1;const d=[],f=[],S=[],A=n.types.isIdentifier(t)?()=>t:()=>(null!=c||(c=r[0].scope.generateUidIdentifierBasedOnNode(t)),c);for(const t of r){l.assertFieldTransformed(t);const r=t.node.static,c=!r,w=t.isPrivate(),C=!w,D=t.isProperty(),_=!D,O=null==t.isStaticBlock?void 0:t.isStaticBlock();if(r||_&&w||O){const r=P(t,e,A,i,O,u);p=p||r;}switch(!0){case O:d.push(n.template.statement.ast`(() => ${n.types.blockStatement(t.node.body)})()`);break;case r&&w&&D&&a:p=!0,d.push(h(n.types.cloneNode(e),t,s));break;case r&&w&&D&&!a:p=!0,d.push(y(t,s));break;case r&&C&&D&&o:p=!0,d.push(E(n.types.cloneNode(e),t));break;case r&&C&&D&&!o:p=!0,d.push(v(n.types.cloneNode(e),t,i));break;case c&&w&&D&&a:f.push(h(n.types.thisExpression(),t,s));break;case c&&w&&D&&!a:f.push(m(n.types.thisExpression(),t,s));break;case c&&w&&_&&a:f.unshift(b(n.types.thisExpression(),t,s)),S.push(T(t,s,a));break;case c&&w&&_&&!a:f.unshift(g(n.types.thisExpression(),t,s)),S.push(T(t,s,a));break;case r&&w&&_&&!a:p=!0,d.unshift(y(t,s)),S.push(T(t,s,a));break;case r&&w&&_&&a:p=!0,d.unshift(x(n.types.cloneNode(e),t,0,s)),S.push(T(t,s,a));break;case c&&C&&D&&o:f.push(E(n.types.thisExpression(),t));break;case c&&C&&D&&!o:f.push(v(n.types.thisExpression(),t,i));break;default:throw new Error("Unreachable.")}}return {staticNodes:d.filter(Boolean),instanceNodes:f.filter(Boolean),pureStaticNodes:S.filter(Boolean),wrapClass(t){for(const e of r)e.remove();return c&&(t.scope.push({id:n.types.cloneNode(c)}),t.set("superClass",n.types.assignmentExpression("=",c,t.node.superClass))),p?(t.isClassExpression()?(t.scope.push({id:e}),t.replaceWith(n.types.assignmentExpression("=",n.types.cloneNode(e),t.node))):t.node.id||(t.node.id=e),t):t}}};var n=r("./node_modules/@babel/core/lib/index.js"),s=r("./node_modules/@babel/helper-replace-supers/lib/index.js"),i=r("./node_modules/@babel/helper-member-expression-to-functions/lib/index.js"),o=r("./node_modules/@babel/helper-optimise-call-expression/lib/index.js"),a=r("./node_modules/@babel/helper-annotate-as-pure/lib/index.js"),l=r("./node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");function u(e){const t=Object.assign({},e,{Class(e){const{privateNamesMap:n}=this,s=e.get("body.body"),i=new Map(n),o=[];for(const e of s){if(!e.isPrivate())continue;const{name:t}=e.node.key.id;i.delete(t),o.push(t);}o.length&&(e.get("body").traverse(r,Object.assign({},this,{redeclared:o})),e.traverse(t,Object.assign({},this,{privateNamesMap:i})),e.skipKey("body"));}}),r=n.traverse.visitors.merge([Object.assign({},e),s.environmentVisitor]);return t}const c=u({PrivateName(e,{noDocumentAll:t}){const{privateNamesMap:r,redeclared:n}=this,{node:s,parentPath:i}=e;if(!i.isMemberExpression({property:s})&&!i.isOptionalMemberExpression({property:s}))return;const{name:o}=s.id;r.has(o)&&(n&&n.includes(o)||this.handle(i,t));}}),p=u({BinaryExpression(e){const{operator:t,left:r,right:s}=e.node;if("in"!==t)return;if(!e.get("left").isPrivateName())return;const{privateFieldsAsProperties:i,privateNamesMap:o,redeclared:a}=this,{name:l}=r.id;if(!o.has(l))return;if(a&&a.includes(l))return;if(i){const{id:t}=o.get(l);return void e.replaceWith(n.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${s}, ${n.types.cloneNode(t)})
      `)}const{id:u,static:c}=o.get(l);c?e.replaceWith(n.template.expression.ast`${s} === ${this.classRef}`):e.replaceWith(n.template.expression.ast`${n.types.cloneNode(u)}.has(${s})`);}}),d={memoise(e,t){const{scope:r}=e,{object:n}=e.node,s=r.maybeGenerateMemoised(n);s&&this.memoiser.set(n,s,t);},receiver(e){const{object:t}=e.node;return this.memoiser.has(t)?n.types.cloneNode(this.memoiser.get(t)):n.types.cloneNode(t)},get(e){const{classRef:t,privateNamesMap:r,file:s}=this,{name:i}=e.node.property.id,{id:o,static:a,method:l,methodId:u,getId:c,setId:p}=r.get(i),d=c||p;if(a){const r=l&&!d?"classStaticPrivateMethodGet":"classStaticPrivateFieldSpecGet";return n.types.callExpression(s.addHelper(r),[this.receiver(e),n.types.cloneNode(t),n.types.cloneNode(o)])}if(l){if(d){if(!c&&p){if(s.availableHelper("writeOnlyError"))return n.types.sequenceExpression([this.receiver(e),n.types.callExpression(s.addHelper("writeOnlyError"),[n.types.stringLiteral(`#${i}`)])]);console.warn("@babel/helpers is outdated, update it to silence this warning.");}return n.types.callExpression(s.addHelper("classPrivateFieldGet"),[this.receiver(e),n.types.cloneNode(o)])}return n.types.callExpression(s.addHelper("classPrivateMethodGet"),[this.receiver(e),n.types.cloneNode(o),n.types.cloneNode(u)])}return n.types.callExpression(s.addHelper("classPrivateFieldGet"),[this.receiver(e),n.types.cloneNode(o)])},boundGet(e){return this.memoise(e,1),n.types.callExpression(n.types.memberExpression(this.get(e),n.types.identifier("bind")),[this.receiver(e)])},set(e,t){const{classRef:r,privateNamesMap:s,file:i}=this,{name:o}=e.node.property.id,{id:a,static:l,method:u,setId:c,getId:p}=s.get(o);if(l){const s=!u||p||c?"classStaticPrivateFieldSpecSet":"classStaticPrivateMethodSet";return n.types.callExpression(i.addHelper(s),[this.receiver(e),n.types.cloneNode(r),n.types.cloneNode(a),t])}return u?c?n.types.callExpression(i.addHelper("classPrivateFieldSet"),[this.receiver(e),n.types.cloneNode(a),t]):n.types.sequenceExpression([this.receiver(e),t,n.types.callExpression(i.addHelper("readOnlyError"),[n.types.stringLiteral(`#${o}`)])]):n.types.callExpression(i.addHelper("classPrivateFieldSet"),[this.receiver(e),n.types.cloneNode(a),t])},destructureSet(e){const{classRef:t,privateNamesMap:r,file:s}=this,{name:i}=e.node.property.id,{id:o,static:a}=r.get(i);if(a){try{var l=s.addHelper("classStaticPrivateFieldDestructureSet");}catch(e){throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.")}return n.types.memberExpression(n.types.callExpression(l,[this.receiver(e),n.types.cloneNode(t),n.types.cloneNode(o)]),n.types.identifier("value"))}return n.types.memberExpression(n.types.callExpression(s.addHelper("classPrivateFieldDestructureSet"),[this.receiver(e),n.types.cloneNode(o)]),n.types.identifier("value"))},call(e,t){return this.memoise(e,1),(0, o.default)(this.get(e),this.receiver(e),t,!1)},optionalCall(e,t){return this.memoise(e,1),(0, o.default)(this.get(e),this.receiver(e),t,!0)}},f={get(e){const{privateNamesMap:t,file:r}=this,{object:s}=e.node,{name:i}=e.node.property.id;return n.template.expression`BASE(REF, PROP)[PROP]`({BASE:r.addHelper("classPrivateFieldLooseBase"),REF:n.types.cloneNode(s),PROP:n.types.cloneNode(t.get(i).id)})},boundGet(e){return n.types.callExpression(n.types.memberExpression(this.get(e),n.types.identifier("bind")),[n.types.cloneNode(e.node.object)])},simpleSet(e){return this.get(e)},destructureSet(e){return this.get(e)},call(e,t){return n.types.callExpression(this.get(e),t)},optionalCall(e,t){return n.types.optionalCallExpression(this.get(e),t,!0)}};function h(e,t,r){const{id:s}=r.get(t.node.key.id.name),i=t.node.value||t.scope.buildUndefinedNode();return n.template.statement.ast`
    Object.defineProperty(${e}, ${n.types.cloneNode(s)}, {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${i}
    });
  `}function m(e,t,r){const{id:s}=r.get(t.node.key.id.name),i=t.node.value||t.scope.buildUndefinedNode();return n.template.statement.ast`${n.types.cloneNode(s)}.set(${e}, {
    // configurable is always false for private elements
    // enumerable is always false for private elements
    writable: true,
    value: ${i},
  })`}function y(e,t){const r=t.get(e.node.key.id.name),{id:s,getId:i,setId:o,initAdded:a}=r,l=i||o;if(!e.isProperty()&&(a||!l))return;if(l)return t.set(e.node.key.id.name,Object.assign({},r,{initAdded:!0})),n.template.statement.ast`
      var ${n.types.cloneNode(s)} = {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${i?i.name:e.scope.buildUndefinedNode()},
        set: ${o?o.name:e.scope.buildUndefinedNode()}
      }
    `;const u=e.node.value||e.scope.buildUndefinedNode();return n.template.statement.ast`
    var ${n.types.cloneNode(s)} = {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${u}
    };
  `}function b(e,t,r){const s=r.get(t.node.key.id.name),{methodId:i,id:o,getId:a,setId:l,initAdded:u}=s;if(!u)return i?n.template.statement.ast`
        Object.defineProperty(${e}, ${o}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${i.name}
        });
      `:a||l?(r.set(t.node.key.id.name,Object.assign({},s,{initAdded:!0})),n.template.statement.ast`
      Object.defineProperty(${e}, ${o}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${a?a.name:t.scope.buildUndefinedNode()},
        set: ${l?l.name:t.scope.buildUndefinedNode()}
      });
    `):void 0}function g(e,t,r){const s=r.get(t.node.key.id.name),{id:i,getId:o,setId:a,initAdded:l}=s;if(!l)return o||a?(r.set(t.node.key.id.name,Object.assign({},s,{initAdded:!0})),n.template.statement.ast`
      ${i}.set(${e}, {
        get: ${o?o.name:t.scope.buildUndefinedNode()},
        set: ${a?a.name:t.scope.buildUndefinedNode()}
      });
    `):n.template.statement.ast`${i}.add(${e})`}function E(e,t){const{key:r,computed:s}=t.node,i=t.node.value||t.scope.buildUndefinedNode();return n.types.expressionStatement(n.types.assignmentExpression("=",n.types.memberExpression(e,r,s||n.types.isLiteral(r)),i))}function v(e,t,r){const{key:s,computed:i}=t.node,o=t.node.value||t.scope.buildUndefinedNode();return n.types.expressionStatement(n.types.callExpression(r.addHelper("defineProperty"),[e,i||n.types.isLiteral(s)?s:n.types.stringLiteral(s.name),o]))}function x(e,t,r,s){const i=s.get(t.node.key.id.name),{id:o,methodId:a,getId:l,setId:u,initAdded:c}=i;if(!c)return l||u?(s.set(t.node.key.id.name,Object.assign({},i,{initAdded:!0})),n.template.statement.ast`
      Object.defineProperty(${e}, ${o}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${l?l.name:t.scope.buildUndefinedNode()},
        set: ${u?u.name:t.scope.buildUndefinedNode()}
      })
    `):n.template.statement.ast`
    Object.defineProperty(${e}, ${o}, {
      // configurable is false by default
      // enumerable is false by default
      // writable is false by default
      value: ${a.name}
    });
  `}function T(e,t,r=!1){const s=t.get(e.node.key.id.name),{id:i,methodId:o,getId:a,setId:l,getterDeclared:u,setterDeclared:c,static:p}=s,{params:d,body:f,generator:h,async:m}=e.node,y=a&&!u&&0===d.length,b=l&&!c&&d.length>0;let g=o;return y?(t.set(e.node.key.id.name,Object.assign({},s,{getterDeclared:!0})),g=a):b?(t.set(e.node.key.id.name,Object.assign({},s,{setterDeclared:!0})),g=l):p&&!r&&(g=i),n.types.functionDeclaration(n.types.cloneNode(g),d,f,h,m)}const S=n.traverse.visitors.merge([{ThisExpression(e,t){t.needsClassRef=!0,e.replaceWith(n.types.cloneNode(t.classRef));}},s.environmentVisitor]);function P(e,t,r,i,o,a){const l={classRef:t,needsClassRef:!1};return new s.default({methodPath:e,constantSuper:a,file:i,refToPreserve:t,getSuperRef:r,getObjectRef:()=>(l.needsClassRef=!0,o||e.node.static?t:n.types.memberExpression(t,n.types.identifier("prototype")))}).replace(),(o||e.isProperty())&&e.traverse(S,l),l.needsClassRef}},"./node_modules/@babel/helper-create-class-features-plugin/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createClassFeaturePlugin=function({name:e,feature:t,loose:r,manipulateOptions:d,api:f={assumption:()=>{}}}){const h=f.assumption("setPublicClassFields"),m=f.assumption("privateFieldsAsProperties"),y=f.assumption("constantSuper"),b=f.assumption("noDocumentAll");if(!0===r){const t=[];void 0!==h&&t.push('"setPublicClassFields"'),void 0!==m&&t.push('"privateFieldsAsProperties"'),0!==t.length&&console.warn(`[${e}]: You are using the "loose: true" option and you are explicitly setting a value for the ${t.join(" and ")} assumption${t.length>1?"s":""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:\n\t"assumptions": {\n\t\t"setPublicClassFields": true,\n\t\t"privateFieldsAsProperties": true\n\t}`);}return {name:e,manipulateOptions:d,pre(){(0, u.enableFeature)(this.file,t,r),(!this.file.get(p)||this.file.get(p)<c)&&this.file.set(p,c);},visitor:{Class(e,r){if(this.file.get(p)!==c)return;(0, u.verifyUsedFeatures)(e,this.file);const i=(0, u.isLoose)(this.file,t);let d,f=(0, a.hasOwnDecorators)(e.node);const g=[],E=[],v=[],x=new Set,T=e.get("body");for(const e of T.get("body")){if((0, u.verifyUsedFeatures)(e,this.file),e.node.computed&&v.push(e),e.isPrivate()){const{name:t}=e.node.key.id,r=`get ${t}`,n=`set ${t}`;if("get"===e.node.kind){if(x.has(r)||x.has(t)&&!x.has(n))throw e.buildCodeFrameError("Duplicate private field");x.add(r).add(t);}else if("set"===e.node.kind){if(x.has(n)||x.has(t)&&!x.has(r))throw e.buildCodeFrameError("Duplicate private field");x.add(n).add(t);}else {if(x.has(t)&&!x.has(r)&&!x.has(n)||x.has(t)&&(x.has(r)||x.has(n)))throw e.buildCodeFrameError("Duplicate private field");x.add(t);}}e.isClassMethod({kind:"constructor"})?d=e:(E.push(e),(e.isProperty()||e.isPrivate()||null!=e.isStaticBlock&&e.isStaticBlock())&&g.push(e)),f||(f=(0, a.hasOwnDecorators)(e.node));}if(!g.length&&!f)return;let S;e.isClassExpression()||!e.node.id?((0, s.default)(e),S=e.scope.generateUidIdentifier("class")):S=n.types.cloneNode(e.node.id);const P=(0, o.buildPrivateNamesMap)(g),A=(0, o.buildPrivateNamesNodes)(P,null!=m?m:i,r);let w,C,D,_,O;(0, o.transformPrivateNamesUsage)(S,e,P,{privateFieldsAsProperties:null!=m?m:i,noDocumentAll:b},r),f?(C=D=w=[],({instanceNodes:_,wrapClass:O}=(0, a.buildDecoratedClass)(S,e,E,this.file))):(w=(0, l.extractComputedKeys)(S,e,v,this.file),({staticNodes:C,pureStaticNodes:D,instanceNodes:_,wrapClass:O}=(0, o.buildFieldsInitNodes)(S,e.node.superClass,g,P,r,null!=h?h:i,null!=m?m:i,null!=y?y:i))),_.length>0&&(0, l.injectInitialization)(e,d,_,((e,t)=>{if(!f)for(const r of g)r.node.static||r.traverse(e,t);})),(e=O(e)).insertBefore([...A,...w]),C.length>0&&e.insertAfter(C),D.length>0&&e.find((e=>e.isStatement()||e.isDeclaration())).insertAfter(D);},PrivateName(e){if(this.file.get(p)===c&&!e.parentPath.isPrivate({key:e.node}))throw e.buildCodeFrameError(`Unknown PrivateName "${e}"`)},ExportDefaultDeclaration(e){if(this.file.get(p)!==c)return;const t=e.get("declaration");t.isClassDeclaration()&&(0, a.hasDecorators)(t.node)&&(t.node.id?(0, i.default)(e):t.node.type="ClassExpression");}}}},Object.defineProperty(t,"injectInitialization",{enumerable:!0,get:function(){return l.injectInitialization}}),Object.defineProperty(t,"enableFeature",{enumerable:!0,get:function(){return u.enableFeature}}),Object.defineProperty(t,"FEATURES",{enumerable:!0,get:function(){return u.FEATURES}});var n=r("./node_modules/@babel/core/lib/index.js"),s=r("./node_modules/@babel/helper-function-name/lib/index.js"),i=r("./node_modules/@babel/helper-split-export-declaration/lib/index.js"),o=r("./node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"),a=r("./node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"),l=r("./node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"),u=r("./node_modules/@babel/helper-create-class-features-plugin/lib/features.js");const c="7.14.3".split(".").reduce(((e,t)=>1e5*e+ +t),0),p="@babel/plugin-class-features/version";},"./node_modules/@babel/helper-create-class-features-plugin/lib/misc.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.injectInitialization=function(e,t,r,s){if(!r.length)return;const a=!!e.node.superClass;if(!t){const r=n.types.classMethod("constructor",n.types.identifier("constructor"),[],n.types.blockStatement([]));a&&(r.params=[n.types.restElement(n.types.identifier("args"))],r.body.body.push(n.template.statement.ast`super(...args)`)),[t]=e.get("body").unshiftContainer("body",r);}if(s&&s(o,{scope:t.scope}),a){const e=[];t.traverse(i,e);let s=!0;for(const t of e)s?(t.insertAfter(r),s=!1):t.insertAfter(r.map((e=>n.types.cloneNode(e))));}else t.get("body").unshiftContainer("body",r);},t.extractComputedKeys=function(e,t,r,s){const i=[],o={classBinding:t.node.id&&t.scope.getBinding(t.node.id.name),file:s};for(const e of r){const r=e.get("key");r.isReferencedIdentifier()?a(r,o):r.traverse(l,o);const s=e.node;if(!r.isConstantExpression()){const e=t.scope.generateUidIdentifierBasedOnNode(s.key);t.scope.push({id:e,kind:"let"}),i.push(n.types.expressionStatement(n.types.assignmentExpression("=",n.types.cloneNode(e),s.key))),s.key=n.types.cloneNode(e);}}return i};var n=r("./node_modules/@babel/core/lib/index.js"),s=r("./node_modules/@babel/helper-replace-supers/lib/index.js");const i=n.traverse.visitors.merge([{Super(e){const{node:t,parentPath:r}=e;r.isCallExpression({callee:t})&&this.push(r);}},s.environmentVisitor]),o={"TSTypeAnnotation|TypeAnnotation"(e){e.skip();},ReferencedIdentifier(e){this.scope.hasOwnBinding(e.node.name)&&(this.scope.rename(e.node.name),e.skip());}};function a(e,t){if(t.classBinding&&t.classBinding===e.scope.getBinding(e.node.name)){const r=t.file.addHelper("classNameTDZError"),s=n.types.callExpression(r,[n.types.stringLiteral(e.node.name)]);e.replaceWith(n.types.sequenceExpression([s,e.node])),e.skip();}}const l={ReferencedIdentifier:a};},"./node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.assertFieldTransformed=function(e){if(e.node.declare)throw e.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-proposal-class-properties\n - @babel/plugin-proposal-private-methods\n - @babel/plugin-proposal-decorators")};},"./node_modules/@babel/helper-function-name/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function({node:e,parent:t,scope:r,id:s},u=!1){if(e.id)return;if(!i.isObjectProperty(t)&&!i.isObjectMethod(t,{kind:"method"})||t.computed&&!i.isLiteral(t.key)){if(i.isVariableDeclarator(t)){if(s=t.id,i.isIdentifier(s)&&!u){const t=r.parent.getBinding(s.name);if(t&&t.constant&&r.getBinding(s.name)===t)return e.id=i.cloneNode(s),void(e.id[i.NOT_LOCAL_BINDING]=!0)}}else if(i.isAssignmentExpression(t,{operator:"="}))s=t.left;else if(!s)return}else s=t.key;let c;return s&&i.isLiteral(s)?c=function(e){return i.isNullLiteral(e)?"null":i.isRegExpLiteral(e)?`_${e.pattern}_${e.flags}`:i.isTemplateLiteral(e)?e.quasis.map((e=>e.value.raw)).join(""):void 0!==e.value?e.value+"":""}(s):s&&i.isIdentifier(s)&&(c=s.name),void 0!==c?(c=i.toBindingIdentifierName(c),(s=i.identifier(c))[i.NOT_LOCAL_BINDING]=!0,function(e,t,r,s){if(e.selfReference){if(!s.hasBinding(r.name)||s.hasGlobal(r.name)){if(!i.isFunction(t))return;let e=o;t.generator&&(e=a);const l=e({FUNCTION:t,FUNCTION_ID:r,FUNCTION_KEY:s.generateUidIdentifier(r.name)}).expression,u=l.callee.body.body[0].params;for(let e=0,r=(0, n.default)(t);e<r;e++)u.push(s.generateUidIdentifier("x"));return l}s.rename(r.name);}t.id=r,s.getProgramParent().references[r.name]=!0;}(function(e,t,r){const n={selfAssignment:!1,selfReference:!1,outerDeclar:r.getBindingIdentifier(t),references:[],name:t},s=r.getOwnBinding(t);return s?"param"===s.kind&&(n.selfReference=!0):(n.outerDeclar||r.hasGlobal(t))&&r.traverse(e,l,n),n}(e,c,r),e,s,r)||e):void 0};var n=r("./node_modules/@babel/helper-get-function-arity/lib/index.js"),s=r("./node_modules/@babel/template/lib/index.js"),i=r("./node_modules/@babel/types/lib/index.js");const o=(0, s.default)("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"),a=(0, s.default)("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"),l={"ReferencedIdentifier|BindingIdentifier"(e,t){e.node.name===t.name&&e.scope.getBindingIdentifier(t.name)===t.outerDeclar&&(t.selfReference=!0,e.stop());}};},"./node_modules/@babel/helper-get-function-arity/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){const t=e.params;for(let e=0;e<t.length;e++){const r=t[e];if(n.isAssignmentPattern(r)||n.isRestElement(r))return e}return t.length};var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}},"./node_modules/@babel/helper-member-expression-to-functions/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0});var n=r("./node_modules/@babel/types/lib/index.js");function s(e){const t=e,{node:r,parentPath:n}=t;if(n.isLogicalExpression()){const{operator:e,right:t}=n.node;if("&&"===e||"||"===e||"??"===e&&r===t)return s(n)}if(n.isSequenceExpression()){const{expressions:e}=n.node;return e[e.length-1]!==r||s(n)}return n.isConditional({test:r})||n.isUnaryExpression({operator:"!"})||n.isLoop({test:r})}class i{constructor(){this._map=void 0,this._map=new WeakMap;}has(e){return this._map.has(e)}get(e){if(!this.has(e))return;const t=this._map.get(e),{value:r}=t;return t.count--,0===t.count?n.assignmentExpression("=",r,e):r}set(e,t,r){return this._map.set(e,{count:r,value:t})}}function o(e,t){const{node:r}=e;if(e.isOptionalMemberExpression())return n.memberExpression(t,r.property,r.computed);if(e.isOptionalCallExpression()){const s=e.get("callee");if(e.node.optional&&s.isOptionalMemberExpression()){const{object:i}=s.node,o=e.scope.maybeGenerateMemoised(i)||i;return s.get("object").replaceWith(n.assignmentExpression("=",o,i)),n.callExpression(n.memberExpression(t,n.identifier("call")),[o,...r.arguments])}return n.callExpression(t,r.arguments)}return e.node}const a={memoise(){},handle(e,t){const{node:r,parent:i,parentPath:a,scope:l}=e;if(e.isOptionalMemberExpression()){if(function(e){for(;e&&!e.isProgram();){const{parentPath:t,container:r,listKey:n}=e,s=t.node;if(n){if(r!==s[n])return !0}else if(r!==s)return !0;e=t;}return !1}(e))return;const u=e.find((({node:t,parent:r,parentPath:n})=>n.isOptionalMemberExpression()?r.optional||r.object!==t:!n.isOptionalCallExpression()||t!==e.node&&r.optional||r.callee!==t));if(l.path.isPattern())return void u.replaceWith(n.callExpression(n.arrowFunctionExpression([],u.node),[]));const c=s(u),p=u.parentPath;if(p.isUpdateExpression({argument:r})||p.isAssignmentExpression({left:r}))throw e.buildCodeFrameError("can't handle assignment");const d=p.isUnaryExpression({operator:"delete"});if(d&&u.isOptionalMemberExpression()&&u.get("property").isPrivateName())throw e.buildCodeFrameError("can't delete a private class element");let f=e;for(;;)if(f.isOptionalMemberExpression()){if(f.node.optional)break;f=f.get("object");}else {if(!f.isOptionalCallExpression())throw new Error(`Internal error: unexpected ${f.node.type}`);if(f.node.optional)break;f=f.get("callee");}const h=f.isOptionalMemberExpression()?"object":"callee",m=f.node[h],y=l.maybeGenerateMemoised(m),b=null!=y?y:m,g=a.isOptionalCallExpression({callee:r}),E=a.isCallExpression({callee:r});f.replaceWith(o(f,b)),g?i.optional?a.replaceWith(this.optionalCall(e,i.arguments)):a.replaceWith(this.call(e,i.arguments)):E?e.replaceWith(this.boundGet(e)):e.replaceWith(this.get(e));let v,x=e.node;for(let t=e;t!==u;){const{parentPath:e}=t;if(e===u&&g&&i.optional){x=e.node;break}x=o(e,x),t=e;}const T=u.parentPath;if(n.isMemberExpression(x)&&T.isOptionalCallExpression({callee:u.node,optional:!0})){const{object:t}=x;v=e.scope.maybeGenerateMemoised(t),v&&(x.object=n.assignmentExpression("=",v,t));}let S=u;d&&(S=T,x=T.node);const P=y?n.assignmentExpression("=",n.cloneNode(b),n.cloneNode(m)):n.cloneNode(b);if(c){let e;e=t?n.binaryExpression("!=",P,n.nullLiteral()):n.logicalExpression("&&",n.binaryExpression("!==",P,n.nullLiteral()),n.binaryExpression("!==",n.cloneNode(b),l.buildUndefinedNode())),S.replaceWith(n.logicalExpression("&&",e,x));}else {let e;e=t?n.binaryExpression("==",P,n.nullLiteral()):n.logicalExpression("||",n.binaryExpression("===",P,n.nullLiteral()),n.binaryExpression("===",n.cloneNode(b),l.buildUndefinedNode())),S.replaceWith(n.conditionalExpression(e,d?n.booleanLiteral(!0):l.buildUndefinedNode(),x));}if(v){const e=T.node;T.replaceWith(n.optionalCallExpression(n.optionalMemberExpression(e.callee,n.identifier("call"),!1,!0),[n.cloneNode(v),...e.arguments],!1));}}else if(a.isUpdateExpression({argument:r})){if(this.simpleSet)return void e.replaceWith(this.simpleSet(e));const{operator:t,prefix:s}=i;this.memoise(e,2);const o=n.binaryExpression(t[0],n.unaryExpression("+",this.get(e)),n.numericLiteral(1));if(s)a.replaceWith(this.set(e,o));else {const{scope:t}=e,s=t.generateUidIdentifierBasedOnNode(r);t.push({id:s}),o.left=n.assignmentExpression("=",n.cloneNode(s),o.left),a.replaceWith(n.sequenceExpression([this.set(e,o),n.cloneNode(s)]));}}else if(a.isAssignmentExpression({left:r})){if(this.simpleSet)return void e.replaceWith(this.simpleSet(e));const{operator:t,right:r}=i;if("="===t)a.replaceWith(this.set(e,r));else {const s=t.slice(0,-1);n.LOGICAL_OPERATORS.includes(s)?(this.memoise(e,1),a.replaceWith(n.logicalExpression(s,this.get(e),this.set(e,r)))):(this.memoise(e,2),a.replaceWith(this.set(e,n.binaryExpression(s,this.get(e),r))));}}else {if(!a.isCallExpression({callee:r}))return a.isOptionalCallExpression({callee:r})?l.path.isPattern()?void a.replaceWith(n.callExpression(n.arrowFunctionExpression([],a.node),[])):void a.replaceWith(this.optionalCall(e,i.arguments)):void(a.isForXStatement({left:r})||a.isObjectProperty({value:r})&&a.parentPath.isObjectPattern()||a.isAssignmentPattern({left:r})&&a.parentPath.isObjectProperty({value:i})&&a.parentPath.parentPath.isObjectPattern()||a.isArrayPattern()||a.isAssignmentPattern({left:r})&&a.parentPath.isArrayPattern()||a.isRestElement()?e.replaceWith(this.destructureSet(e)):e.replaceWith(this.get(e)));a.replaceWith(this.call(e,i.arguments));}}};t.default=function(e,t,r){e.traverse(t,Object.assign({},a,r,{memoiser:new i}));};},"./node_modules/@babel/helper-module-imports/lib/import-builder.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}const i=r("assert");t.default=class{constructor(e,t,r){this._statements=[],this._resultName=null,this._scope=null,this._hub=null,this._importedSource=void 0,this._scope=t,this._hub=r,this._importedSource=e;}done(){return {statements:this._statements,resultName:this._resultName}}import(){return this._statements.push(n.importDeclaration([],n.stringLiteral(this._importedSource))),this}require(){return this._statements.push(n.expressionStatement(n.callExpression(n.identifier("require"),[n.stringLiteral(this._importedSource)]))),this}namespace(e="namespace"){const t=this._scope.generateUidIdentifier(e),r=this._statements[this._statements.length-1];return i("ImportDeclaration"===r.type),i(0===r.specifiers.length),r.specifiers=[n.importNamespaceSpecifier(t)],this._resultName=n.cloneNode(t),this}default(e){e=this._scope.generateUidIdentifier(e);const t=this._statements[this._statements.length-1];return i("ImportDeclaration"===t.type),i(0===t.specifiers.length),t.specifiers=[n.importDefaultSpecifier(e)],this._resultName=n.cloneNode(e),this}named(e,t){if("default"===t)return this.default(e);e=this._scope.generateUidIdentifier(e);const r=this._statements[this._statements.length-1];return i("ImportDeclaration"===r.type),i(0===r.specifiers.length),r.specifiers=[n.importSpecifier(e,n.identifier(t))],this._resultName=n.cloneNode(e),this}var(e){e=this._scope.generateUidIdentifier(e);let t=this._statements[this._statements.length-1];return "ExpressionStatement"!==t.type&&(i(this._resultName),t=n.expressionStatement(this._resultName),this._statements.push(t)),this._statements[this._statements.length-1]=n.variableDeclaration("var",[n.variableDeclarator(e,t.expression)]),this._resultName=n.cloneNode(e),this}defaultInterop(){return this._interop(this._hub.addHelper("interopRequireDefault"))}wildcardInterop(){return this._interop(this._hub.addHelper("interopRequireWildcard"))}_interop(e){const t=this._statements[this._statements.length-1];return "ExpressionStatement"===t.type?t.expression=n.callExpression(e,[t.expression]):"VariableDeclaration"===t.type?(i(1===t.declarations.length),t.declarations[0].init=n.callExpression(e,[t.declarations[0].init])):i.fail("Unexpected type."),this}prop(e){const t=this._statements[this._statements.length-1];return "ExpressionStatement"===t.type?t.expression=n.memberExpression(t.expression,n.identifier(e)):"VariableDeclaration"===t.type?(i(1===t.declarations.length),t.declarations[0].init=n.memberExpression(t.declarations[0].init,n.identifier(e))):i.fail("Unexpected type:"+t.type),this}read(e){this._resultName=n.memberExpression(this._resultName,n.identifier(e));}};},"./node_modules/@babel/helper-module-imports/lib/import-injector.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=a();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var i=n?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(r,s,i):r[s]=e[s];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js")),s=o(r("./node_modules/@babel/helper-module-imports/lib/import-builder.js")),i=o(r("./node_modules/@babel/helper-module-imports/lib/is-module.js"));function o(e){return e&&e.__esModule?e:{default:e}}function a(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return a=function(){return e},e}const l=r("assert");t.default=class{constructor(e,t,r){this._defaultOpts={importedSource:null,importedType:"commonjs",importedInterop:"babel",importingInterop:"babel",ensureLiveReference:!1,ensureNoContext:!1,importPosition:"before"};const n=e.find((e=>e.isProgram()));this._programPath=n,this._programScope=n.scope,this._hub=n.hub,this._defaultOpts=this._applyDefaults(t,r,!0);}addDefault(e,t){return this.addNamed("default",e,t)}addNamed(e,t,r){return l("string"==typeof e),this._generateImport(this._applyDefaults(t,r),e)}addNamespace(e,t){return this._generateImport(this._applyDefaults(e,t),null)}addSideEffect(e,t){return this._generateImport(this._applyDefaults(e,t),!1)}_applyDefaults(e,t,r=!1){const n=[];"string"==typeof e?(n.push({importedSource:e}),n.push(t)):(l(!t,"Unexpected secondary arguments."),n.push(e));const s=Object.assign({},this._defaultOpts);for(const e of n)e&&(Object.keys(s).forEach((t=>{void 0!==e[t]&&(s[t]=e[t]);})),r||(void 0!==e.nameHint&&(s.nameHint=e.nameHint),void 0!==e.blockHoist&&(s.blockHoist=e.blockHoist)));return s}_generateImport(e,t){const r="default"===t,o=!!t&&!r,a=null===t,{importedSource:l,importedType:u,importedInterop:c,importingInterop:p,ensureLiveReference:d,ensureNoContext:f,nameHint:h,importPosition:m,blockHoist:y}=e;let b=h||t;const g=(0, i.default)(this._programPath),E=g&&"node"===p,v=g&&"babel"===p;if("after"===m&&!g)throw new Error('"importPosition": "after" is only supported in modules');const x=new s.default(l,this._programScope,this._hub);if("es6"===u){if(!E&&!v)throw new Error("Cannot import an ES6 module from CommonJS");x.import(),a?x.namespace(h||l):(r||o)&&x.named(b,t);}else {if("commonjs"!==u)throw new Error(`Unexpected interopType "${u}"`);if("babel"===c)if(E){b="default"!==b?b:l;const e=`${l}$es6Default`;x.import(),a?x.default(e).var(b||l).wildcardInterop():r?d?x.default(e).var(b||l).defaultInterop().read("default"):x.default(e).var(b).defaultInterop().prop(t):o&&x.default(e).read(t);}else v?(x.import(),a?x.namespace(b||l):(r||o)&&x.named(b,t)):(x.require(),a?x.var(b||l).wildcardInterop():(r||o)&&d?r?(b="default"!==b?b:l,x.var(b).read(t),x.defaultInterop()):x.var(l).read(t):r?x.var(b).defaultInterop().prop(t):o&&x.var(b).prop(t));else if("compiled"===c)E?(x.import(),a?x.default(b||l):(r||o)&&x.default(l).read(b)):v?(x.import(),a?x.namespace(b||l):(r||o)&&x.named(b,t)):(x.require(),a?x.var(b||l):(r||o)&&(d?x.var(l).read(b):x.prop(t).var(b)));else {if("uncompiled"!==c)throw new Error(`Unknown importedInterop "${c}".`);if(r&&d)throw new Error("No live reference for commonjs default");E?(x.import(),a?x.default(b||l):r?x.default(b):o&&x.default(l).read(b)):v?(x.import(),a?x.default(b||l):r?x.default(b):o&&x.named(b,t)):(x.require(),a?x.var(b||l):r?x.var(b):o&&(d?x.var(l).read(b):x.var(b).prop(t)));}}const{statements:T,resultName:S}=x.done();return this._insertStatements(T,m,y),(r||o)&&f&&"Identifier"!==S.type?n.sequenceExpression([n.numericLiteral(0),S]):S}_insertStatements(e,t="before",r=3){const n=this._programPath.get("body");if("after"===t){for(let t=n.length-1;t>=0;t--)if(n[t].isImportDeclaration())return void n[t].insertAfter(e)}else {e.forEach((e=>{e._blockHoist=r;}));const t=n.find((e=>{const t=e.node._blockHoist;return Number.isFinite(t)&&t<4}));if(t)return void t.insertBefore(e)}this._programPath.unshiftContainer("body",e);}};},"./node_modules/@babel/helper-module-imports/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.addDefault=function(e,t,r){return new n.default(e).addDefault(t,r)},t.addNamed=function(e,t,r,s){return new n.default(e).addNamed(t,r,s)},t.addNamespace=function(e,t,r){return new n.default(e).addNamespace(t,r)},t.addSideEffect=function(e,t,r){return new n.default(e).addSideEffect(t,r)},Object.defineProperty(t,"ImportInjector",{enumerable:!0,get:function(){return n.default}}),Object.defineProperty(t,"isModule",{enumerable:!0,get:function(){return s.default}});var n=i(r("./node_modules/@babel/helper-module-imports/lib/import-injector.js")),s=i(r("./node_modules/@babel/helper-module-imports/lib/is-module.js"));function i(e){return e&&e.__esModule?e:{default:e}}},"./node_modules/@babel/helper-module-imports/lib/is-module.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){const{sourceType:t}=e.node;if("module"!==t&&"script"!==t)throw e.buildCodeFrameError(`Unknown sourceType "${t}", cannot transform.`);return "module"===e.node.sourceType};},"./node_modules/@babel/helper-module-transforms/lib/get-module-name.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;{const e=r;t.default=r=function(t,r){var n,s,i,o;return e(t,{moduleId:null!=(n=r.moduleId)?n:t.moduleId,moduleIds:null!=(s=r.moduleIds)?s:t.moduleIds,getModuleId:null!=(i=r.getModuleId)?i:t.getModuleId,moduleRoot:null!=(o=r.moduleRoot)?o:t.moduleRoot})};}function r(e,t){const{filename:r,filenameRelative:n=r,sourceRoot:s=t.moduleRoot}=e,{moduleId:i,moduleIds:o=!!i,getModuleId:a,moduleRoot:l=s}=t;if(!o)return null;if(null!=i&&!a)return i;let u=null!=l?l+"/":"";if(n){const e=null!=s?new RegExp("^"+s+"/?"):"";u+=n.replace(e,"").replace(/\.(\w*?)$/,"");}return u=u.replace(/\\/g,"/"),a&&a(u)||u}},"./node_modules/@babel/helper-module-transforms/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.rewriteModuleStatementsAndPrepareHeader=function(e,{loose:t,exportName:r,strict:c,allowTopLevelThis:p,strictMode:f,noInterop:m,importInterop:y=(m?"none":"babel"),lazy:b,esNamespaceOnly:g,constantReexports:E=t,enumerableModuleMeta:v=t}){(0, u.validateImportInteropOption)(y),n((0, o.isModule)(e),"Cannot process module statements in a script"),e.node.sourceType="script";const x=(0, u.default)(e,r,{importInterop:y,initializeReexports:E,lazy:b,esNamespaceOnly:g});p||(0, a.default)(e),(0, l.default)(e,x),!1!==f&&(e.node.directives.some((e=>"use strict"===e.value.value))||e.unshiftContainer("directives",s.directive(s.directiveLiteral("use strict"))));const T=[];(0, u.hasExports)(x)&&!c&&T.push(function(e,t=!1){return (t?i.default.statement`
        EXPORTS.__esModule = true;
      `:i.default.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({EXPORTS:e.exportName})}(x,v));const S=function(e,t){const r=Object.create(null);for(const e of t.local.values())for(const t of e.names)r[t]=!0;let n=!1;for(const e of t.source.values()){for(const t of e.reexports.keys())r[t]=!0;for(const t of e.reexportNamespace)r[t]=!0;n=n||!!e.reexportAll;}if(!n||0===Object.keys(r).length)return null;const i=e.scope.generateUidIdentifier("exportNames");return delete r.default,{name:i.name,statement:s.variableDeclaration("var",[s.variableDeclarator(i,s.valueToNode(r))])}}(e,x);return S&&(x.exportNameListName=S.name,T.push(S.statement)),T.push(...function(e,t,r=!1){const n=[],i=[];for(const[e,r]of t.local)"import"===r.kind||("hoisted"===r.kind?n.push(h(t,r.names,s.identifier(e))):i.push(...r.names));for(const e of t.source.values()){r||n.push(...d(t,e,!1));for(const t of e.reexportNamespace)i.push(t);}return n.push(...function(e,t){const r=[];for(let t=0;t<e.length;t+=100)r.push(e.slice(t,t+100));return r}(i).map((r=>h(t,r,e.scope.buildUndefinedNode())))),n}(e,x,E)),{meta:x,headers:T}},t.ensureStatementsHoisted=function(e){e.forEach((e=>{e._blockHoist=3;}));},t.wrapInterop=function(e,t,r){if("none"===r)return null;if("node-namespace"===r)return s.callExpression(e.hub.addHelper("interopRequireWildcard"),[t,s.booleanLiteral(!0)]);if("node-default"===r)return null;let n;if("default"===r)n="interopRequireDefault";else {if("namespace"!==r)throw new Error(`Unknown interop: ${r}`);n="interopRequireWildcard";}return s.callExpression(e.hub.addHelper(n),[t])},t.buildNamespaceInitStatements=function(e,t,r=!1){const n=[];let o=s.identifier(t.name);t.lazy&&(o=s.callExpression(o,[]));for(const e of t.importsNamespace)e!==t.name&&n.push(i.default.statement`var NAME = SOURCE;`({NAME:e,SOURCE:s.cloneNode(o)}));r&&n.push(...d(e,t,!0));for(const r of t.reexportNamespace)n.push((t.lazy?i.default.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `:i.default.statement`EXPORTS.NAME = NAMESPACE;`)({EXPORTS:e.exportName,NAME:r,NAMESPACE:s.cloneNode(o)}));if(t.reexportAll){const a=function(e,t,r){return (r?i.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      `:i.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({NAMESPACE:t,EXPORTS:e.exportName,VERIFY_NAME_LIST:e.exportNameListName?i.default`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({EXPORTS_LIST:e.exportNameListName}):null})}(e,s.cloneNode(o),r);a.loc=t.reexportAll.loc,n.push(a);}return n},Object.defineProperty(t,"isModule",{enumerable:!0,get:function(){return o.isModule}}),Object.defineProperty(t,"rewriteThis",{enumerable:!0,get:function(){return a.default}}),Object.defineProperty(t,"hasExports",{enumerable:!0,get:function(){return u.hasExports}}),Object.defineProperty(t,"isSideEffectImport",{enumerable:!0,get:function(){return u.isSideEffectImport}}),Object.defineProperty(t,"getModuleName",{enumerable:!0,get:function(){return c.default}});var n=r("assert"),s=r("./node_modules/@babel/types/lib/index.js"),i=r("./node_modules/@babel/template/lib/index.js"),o=r("./node_modules/@babel/helper-module-imports/lib/index.js"),a=r("./node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"),l=r("./node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"),u=r("./node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"),c=r("./node_modules/@babel/helper-module-transforms/lib/get-module-name.js");const p={constant:i.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,constantComputed:i.default.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`,spec:i.default`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    `},d=(e,t,r)=>{const n=t.lazy?s.callExpression(s.identifier(t.name),[]):s.identifier(t.name),{stringSpecifiers:i}=e;return Array.from(t.reexports,(([o,a])=>{let l=s.cloneNode(n);"default"===a&&"node-default"===t.interop||(l=i.has(a)?s.memberExpression(l,s.stringLiteral(a),!0):s.memberExpression(l,s.identifier(a)));const u={EXPORTS:e.exportName,EXPORT_NAME:o,NAMESPACE_IMPORT:l};return r||s.isIdentifier(l)?i.has(o)?p.constantComputed(u):p.constant(u):p.spec(u)}))},f={computed:i.default.expression`EXPORTS["NAME"] = VALUE`,default:i.default.expression`EXPORTS.NAME = VALUE`};function h(e,t,r){const{stringSpecifiers:n,exportName:i}=e;return s.expressionStatement(t.reduce(((e,t)=>{const r={EXPORTS:i,NAME:t,VALUE:e};return n.has(t)?f.computed(r):f.default(r)}),r))}},"./node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.hasExports=function(e){return e.hasExports},t.isSideEffectImport=o,t.validateImportInteropOption=a,t.default=function(e,t,{importInterop:r,initializeReexports:s=!1,lazy:a=!1,esNamespaceOnly:p=!1}){t||(t=e.scope.generateUidIdentifier("exports").name);const d=new Set;!function(e){e.get("body").forEach((e=>{e.isExportDefaultDeclaration()&&(0, i.default)(e);}));}(e);const{local:f,source:h,hasExports:m}=function(e,{lazy:t,initializeReexports:r},s){const i=function(e,t,r){const n=new Map;e.get("body").forEach((e=>{let r;if(e.isImportDeclaration())r="import";else {if(e.isExportDefaultDeclaration()&&(e=e.get("declaration")),e.isExportNamedDeclaration())if(e.node.declaration)e=e.get("declaration");else if(t&&e.node.source&&e.get("source").isStringLiteral())return void e.get("specifiers").forEach((e=>{c(e),n.set(e.get("local").node.name,"block");}));if(e.isFunctionDeclaration())r="hoisted";else if(e.isClassDeclaration())r="block";else if(e.isVariableDeclaration({kind:"var"}))r="var";else {if(!e.isVariableDeclaration())return;r="block";}}Object.keys(e.getOuterBindingIdentifiers()).forEach((e=>{n.set(e,r);}));}));const s=new Map,i=e=>{const t=e.node.name;let r=s.get(t);if(!r){const i=n.get(t);if(void 0===i)throw e.buildCodeFrameError(`Exporting local "${t}", which is not declared.`);r={names:[],kind:i},s.set(t,r);}return r};return e.get("body").forEach((e=>{if(!e.isExportNamedDeclaration()||!t&&e.node.source){if(e.isExportDefaultDeclaration()){const t=e.get("declaration");if(!t.isFunctionDeclaration()&&!t.isClassDeclaration())throw t.buildCodeFrameError("Unexpected default expression export.");i(t.get("id")).names.push("default");}}else if(e.node.declaration){const t=e.get("declaration"),r=t.getOuterBindingIdentifierPaths();Object.keys(r).forEach((e=>{if("__esModule"===e)throw t.buildCodeFrameError('Illegal export "__esModule".');i(r[e]).names.push(e);}));}else e.get("specifiers").forEach((e=>{const t=e.get("local"),n=e.get("exported"),s=i(t),o=u(n,r);if("__esModule"===o)throw n.buildCodeFrameError('Illegal export "__esModule".');s.names.push(o);}));})),s}(e,r,s),a=new Map,l=t=>{const r=t.value;let s=a.get(r);return s||(s={name:e.scope.generateUidIdentifier((0, n.basename)(r,(0, n.extname)(r))).name,interop:"none",loc:null,imports:new Map,importsNamespace:new Set,reexports:new Map,reexportNamespace:new Set,reexportAll:null,lazy:!1,source:r},a.set(r,s)),s};let p=!1;e.get("body").forEach((e=>{if(e.isImportDeclaration()){const t=l(e.node.source);t.loc||(t.loc=e.node.loc),e.get("specifiers").forEach((e=>{if(e.isImportDefaultSpecifier()){const r=e.get("local").node.name;t.imports.set(r,"default");const n=i.get(r);n&&(i.delete(r),n.names.forEach((e=>{t.reexports.set(e,"default");})));}else if(e.isImportNamespaceSpecifier()){const r=e.get("local").node.name;t.importsNamespace.add(r);const n=i.get(r);n&&(i.delete(r),n.names.forEach((e=>{t.reexportNamespace.add(e);})));}else if(e.isImportSpecifier()){const r=u(e.get("imported"),s),n=e.get("local").node.name;t.imports.set(n,r);const o=i.get(n);o&&(i.delete(n),o.names.forEach((e=>{t.reexports.set(e,r);})));}}));}else if(e.isExportAllDeclaration()){p=!0;const t=l(e.node.source);t.loc||(t.loc=e.node.loc),t.reexportAll={loc:e.node.loc};}else if(e.isExportNamedDeclaration()&&e.node.source){p=!0;const t=l(e.node.source);t.loc||(t.loc=e.node.loc),e.get("specifiers").forEach((e=>{c(e);const r=u(e.get("local"),s),n=u(e.get("exported"),s);if(t.reexports.set(n,r),"__esModule"===n)throw e.get("exported").buildCodeFrameError('Illegal export "__esModule".')}));}else (e.isExportNamedDeclaration()||e.isExportDefaultDeclaration())&&(p=!0);}));for(const e of a.values()){let t=!1,r=!1;e.importsNamespace.size>0&&(t=!0,r=!0),e.reexportAll&&(r=!0);for(const n of e.imports.values())"default"===n?t=!0:r=!0;for(const n of e.reexports.values())"default"===n?t=!0:r=!0;t&&r?e.interop="namespace":t&&(e.interop="default");}for(const[e,r]of a)if(!1!==t&&!o(r)&&!r.reexportAll)if(!0===t)r.lazy=!/\./.test(e);else if(Array.isArray(t))r.lazy=-1!==t.indexOf(e);else {if("function"!=typeof t)throw new Error(".lazy must be a boolean, string array, or function");r.lazy=t(e);}return {hasExports:p,local:i,source:a}}(e,{initializeReexports:s,lazy:a},d);!function(e){e.get("body").forEach((e=>{if(e.isImportDeclaration())e.remove();else if(e.isExportNamedDeclaration())e.node.declaration?(e.node.declaration._blockHoist=e.node._blockHoist,e.replaceWith(e.node.declaration)):e.remove();else if(e.isExportDefaultDeclaration()){const t=e.get("declaration");if(!t.isFunctionDeclaration()&&!t.isClassDeclaration())throw t.buildCodeFrameError("Unexpected default expression export.");t._blockHoist=e.node._blockHoist,e.replaceWith(t);}else e.isExportAllDeclaration()&&e.remove();}));}(e);for(const[,e]of h){e.importsNamespace.size>0&&(e.name=e.importsNamespace.values().next().value);const t=l(r,e.source);"none"===t?e.interop="none":"node"===t&&"namespace"===e.interop?e.interop="node-namespace":"node"===t&&"default"===e.interop?e.interop="node-default":p&&"namespace"===e.interop&&(e.interop="default");}return {exportName:t,exportNameListName:null,hasExports:m,local:f,source:h,stringSpecifiers:d}};var n=r("path"),s=r("./node_modules/@babel/helper-validator-identifier/lib/index.js"),i=r("./node_modules/@babel/helper-split-export-declaration/lib/index.js");function o(e){return 0===e.imports.size&&0===e.importsNamespace.size&&0===e.reexports.size&&0===e.reexportNamespace.size&&!e.reexportAll}function a(e){if("function"!=typeof e&&"none"!==e&&"babel"!==e&&"node"!==e)throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e}).`);return e}function l(e,t){return "function"==typeof e?a(e(t)):e}function u(e,t){if(e.isIdentifier())return e.node.name;if(e.isStringLiteral()){const r=e.node.value;return (0, s.isIdentifierName)(r)||t.add(r),r}throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e.node.type}`)}function c(e){if(!e.isExportSpecifier())throw e.isExportNamespaceSpecifier()?e.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`."):e.buildCodeFrameError("Unexpected export specifier type")}},"./node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){const r=new Map,n=new Map,i=t=>{e.requeue(t);};for(const[e,n]of t.source){for(const[t,s]of n.imports)r.set(t,[e,s,null]);for(const t of n.importsNamespace)r.set(t,[e,null,t]);}for(const[e,r]of t.local){let t=n.get(e);t||(t=[],n.set(e,t)),t.push(...r.names);}const l={metadata:t,requeueInParent:i,scope:e.scope,exported:n};e.traverse(a,l),(0, o.default)(e,new Set([...Array.from(r.keys()),...Array.from(n.keys())]));const u={seen:new WeakSet,metadata:t,requeueInParent:i,scope:e.scope,imported:r,exported:n,buildImportReference:([e,r,n],i)=>{const o=t.source.get(e);if(n)return o.lazy&&(i=s.callExpression(i,[])),i;let a=s.identifier(o.name);if(o.lazy&&(a=s.callExpression(a,[])),"default"===r&&"node-default"===o.interop)return a;const l=t.stringSpecifiers.has(r);return s.memberExpression(a,l?s.stringLiteral(r):s.identifier(r),l)}};e.traverse(c,u);};var n=r("assert"),s=r("./node_modules/@babel/types/lib/index.js"),i=r("./node_modules/@babel/template/lib/index.js"),o=r("./node_modules/@babel/helper-simple-access/lib/index.js");const a={Scope(e){e.skip();},ClassDeclaration(e){const{requeueInParent:t,exported:r,metadata:n}=this,{id:i}=e.node;if(!i)throw new Error("Expected class to have a name");const o=i.name,a=r.get(o)||[];if(a.length>0){const r=s.expressionStatement(l(n,a,s.identifier(o)));r._blockHoist=e.node._blockHoist,t(e.insertAfter(r)[0]);}},VariableDeclaration(e){const{requeueInParent:t,exported:r,metadata:n}=this;Object.keys(e.getOuterBindingIdentifiers()).forEach((i=>{const o=r.get(i)||[];if(o.length>0){const r=s.expressionStatement(l(n,o,s.identifier(i)));r._blockHoist=e.node._blockHoist,t(e.insertAfter(r)[0]);}}));}},l=(e,t,r)=>(t||[]).reduce(((t,r)=>{const{stringSpecifiers:n}=e,i=n.has(r);return s.assignmentExpression("=",s.memberExpression(s.identifier(e.exportName),i?s.stringLiteral(r):s.identifier(r),i),t)}),r),u=e=>i.default.expression.ast`
    (function() {
      throw new Error('"' + '${e}' + '" is read-only.');
    })()
  `,c={ReferencedIdentifier(e){const{seen:t,buildImportReference:r,scope:n,imported:i,requeueInParent:o}=this;if(t.has(e.node))return;t.add(e.node);const a=e.node.name,l=i.get(a);if(l){const t=e.scope.getBinding(a);if(n.getBinding(a)!==t)return;const i=r(l,e.node);if(i.loc=e.node.loc,(e.parentPath.isCallExpression({callee:e.node})||e.parentPath.isOptionalCallExpression({callee:e.node})||e.parentPath.isTaggedTemplateExpression({tag:e.node}))&&s.isMemberExpression(i))e.replaceWith(s.sequenceExpression([s.numericLiteral(0),i]));else if(e.isJSXIdentifier()&&s.isMemberExpression(i)){const{object:t,property:r}=i;e.replaceWith(s.jsxMemberExpression(s.jsxIdentifier(t.name),s.jsxIdentifier(r.name)));}else e.replaceWith(i);o(e),e.skip();}},AssignmentExpression:{exit(e){const{scope:t,seen:r,imported:i,exported:o,requeueInParent:a,buildImportReference:c}=this;if(r.has(e.node))return;r.add(e.node);const p=e.get("left");if(!p.isMemberExpression())if(p.isIdentifier()){const r=p.node.name;if(t.getBinding(r)!==e.scope.getBinding(r))return;const d=o.get(r),f=i.get(r);if((null==d?void 0:d.length)>0||f){n("="===e.node.operator,"Path was not simplified");const t=e.node;f&&(t.left=c(f,t.left),t.right=s.sequenceExpression([t.right,u(r)])),e.replaceWith(l(this.metadata,d,t)),a(e);}}else {const r=p.getOuterBindingIdentifiers(),n=Object.keys(r).filter((r=>t.getBinding(r)===e.scope.getBinding(r))),c=n.find((e=>i.has(e)));c&&(e.node.right=s.sequenceExpression([e.node.right,u(c)]));const d=[];if(n.forEach((e=>{const t=o.get(e)||[];t.length>0&&d.push(l(this.metadata,t,s.identifier(e)));})),d.length>0){let t=s.sequenceExpression(d);e.parentPath.isExpressionStatement()&&(t=s.expressionStatement(t),t._blockHoist=e.parentPath.node._blockHoist),a(e.insertAfter(t)[0]);}}}},"ForOfStatement|ForInStatement"(e){const{scope:t,node:r}=e,{left:n}=r,{exported:i,scope:o}=this;if(!s.isVariableDeclaration(n)){let r=!1;const a=e.get("body"),l=a.scope;for(const e of Object.keys(s.getOuterBindingIdentifiers(n)))i.get(e)&&o.getBinding(e)===t.getBinding(e)&&(r=!0,l.hasOwnBinding(e)&&l.rename(e));if(!r)return;const u=t.generateUidIdentifierBasedOnNode(n);a.unshiftContainer("body",s.expressionStatement(s.assignmentExpression("=",n,u))),e.get("left").replaceWith(s.variableDeclaration("let",[s.variableDeclarator(s.cloneNode(u))])),t.registerDeclaration(e.get("left"));}}};},"./node_modules/@babel/helper-module-transforms/lib/rewrite-this.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){(0, s.default)(e.node,Object.assign({},o,{noScope:!0}));};var n=r("./node_modules/@babel/helper-replace-supers/lib/index.js"),s=r("./node_modules/@babel/traverse/lib/index.js"),i=r("./node_modules/@babel/types/lib/index.js");const o=s.default.visitors.merge([n.environmentVisitor,{ThisExpression(e){e.replaceWith(i.unaryExpression("void",i.numericLiteral(0),!0));}}]);},"./node_modules/@babel/helper-optimise-call-expression/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r,s){return 1===r.length&&n.isSpreadElement(r[0])&&n.isIdentifier(r[0].argument,{name:"arguments"})?s?n.optionalCallExpression(n.optionalMemberExpression(e,n.identifier("apply"),!1,!0),[t,r[0].argument],!1):n.callExpression(n.memberExpression(e,n.identifier("apply")),[t,r[0].argument]):s?n.optionalCallExpression(n.optionalMemberExpression(e,n.identifier("call"),!1,!0),[t,...r],!1):n.callExpression(n.memberExpression(e,n.identifier("call")),[t,...r])};var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}},"./node_modules/@babel/helper-plugin-utils/lib/index.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.declare=function(e){return (t,s,i)=>{var o;let a;for(const e of Object.keys(r)){var l;t[e]||(a=null!=(l=a)?l:n(t),a[e]=r[e](a));}return e(null!=(o=a)?o:t,s||{},i)}};const r={assertVersion:e=>t=>{!function(e,t){if("number"==typeof e){if(!Number.isInteger(e))throw new Error("Expected string or integer value.");e=`^${e}.0.0-0`;}if("string"!=typeof e)throw new Error("Expected string or integer value.");const r=Error.stackTraceLimit;let n;throw "number"==typeof r&&r<25&&(Error.stackTraceLimit=25),n="7."===t.slice(0,2)?new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t}". You'll need to update your @babel/core version.`):new Error(`Requires Babel "${e}", but was loaded with "${t}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`),"number"==typeof r&&(Error.stackTraceLimit=r),Object.assign(n,{code:"BABEL_VERSION_UNSUPPORTED",version:t,range:e})}(t,e.version);},targets:()=>()=>({}),assumption:()=>()=>{}};function n(e){let t=null;return "string"==typeof e.version&&/^7\./.test(e.version)&&(t=Object.getPrototypeOf(e),!t||s(t,"version")&&s(t,"transform")&&s(t,"template")&&s(t,"types")||(t=null)),Object.assign({},t,e)}function s(e,t){return Object.prototype.hasOwnProperty.call(e,t)}},"./node_modules/@babel/helper-replace-supers/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.skipAllButComputedKey=l,t.default=t.environmentVisitor=void 0;var n=r("./node_modules/@babel/traverse/lib/index.js"),s=r("./node_modules/@babel/helper-member-expression-to-functions/lib/index.js"),i=r("./node_modules/@babel/helper-optimise-call-expression/lib/index.js"),o=r("./node_modules/@babel/types/lib/index.js");function a(e,t,r,n){e=o.cloneNode(e);const s=t||n?e:o.memberExpression(e,o.identifier("prototype"));return o.callExpression(r.addHelper("getPrototypeOf"),[s])}function l(e){if(!e.node.computed)return void e.skip();const t=o.VISITOR_KEYS[e.type];for(const r of t)"key"!==r&&e.skipKey(r);}const u={[(o.staticBlock?"StaticBlock|":"")+"ClassPrivateProperty|TypeAnnotation"](e){e.skip();},Function(e){e.isMethod()||e.isArrowFunctionExpression()||e.skip();},"Method|ClassProperty"(e){l(e);}};t.environmentVisitor=u;const c=n.default.visitors.merge([u,{Super(e,t){const{node:r,parentPath:n}=e;n.isMemberExpression({object:r})&&t.handle(n);}}]),p=n.default.visitors.merge([u,{Scopable(e,{refName:t}){const r=e.scope.getOwnBinding(t);r&&r.identifier.name===t&&e.scope.rename(t);}}]),d={memoise(e,t){const{scope:r,node:n}=e,{computed:s,property:i}=n;if(!s)return;const o=r.maybeGenerateMemoised(i);o&&this.memoiser.set(i,o,t);},prop(e){const{computed:t,property:r}=e.node;return this.memoiser.has(r)?o.cloneNode(this.memoiser.get(r)):t?o.cloneNode(r):o.stringLiteral(r.name)},get(e){return this._get(e,this._getThisRefs())},_get(e,t){const r=a(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return o.callExpression(this.file.addHelper("get"),[t.memo?o.sequenceExpression([t.memo,r]):r,this.prop(e),t.this])},_getThisRefs(){if(!this.isDerivedConstructor)return {this:o.thisExpression()};const e=this.scope.generateDeclaredUidIdentifier("thisSuper");return {memo:o.assignmentExpression("=",e,o.thisExpression()),this:o.cloneNode(e)}},set(e,t){const r=this._getThisRefs(),n=a(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return o.callExpression(this.file.addHelper("set"),[r.memo?o.sequenceExpression([r.memo,n]):n,this.prop(e),t,r.this,o.booleanLiteral(e.isInStrictMode())])},destructureSet(e){throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.")},call(e,t){const r=this._getThisRefs();return (0, i.default)(this._get(e,r),o.cloneNode(r.this),t,!1)},optionalCall(e,t){const r=this._getThisRefs();return (0, i.default)(this._get(e,r),o.cloneNode(r.this),t,!0)}},f=Object.assign({},d,{prop(e){const{property:t}=e.node;return this.memoiser.has(t)?o.cloneNode(this.memoiser.get(t)):o.cloneNode(t)},get(e){const{isStatic:t,getSuperRef:r}=this,{computed:n}=e.node,s=this.prop(e);let i;var a,l;return i=t?null!=(a=r())?a:o.memberExpression(o.identifier("Function"),o.identifier("prototype")):o.memberExpression(null!=(l=r())?l:o.identifier("Object"),o.identifier("prototype")),o.memberExpression(i,s,n)},set(e,t){const{computed:r}=e.node,n=this.prop(e);return o.assignmentExpression("=",o.memberExpression(o.thisExpression(),n,r),t)},destructureSet(e){const{computed:t}=e.node,r=this.prop(e);return o.memberExpression(o.thisExpression(),r,t)},call(e,t){return (0, i.default)(this.get(e),o.thisExpression(),t,!1)},optionalCall(e,t){return (0, i.default)(this.get(e),o.thisExpression(),t,!0)}});t.default=class{constructor(e){var t;const r=e.methodPath;this.methodPath=r,this.isDerivedConstructor=r.isClassMethod({kind:"constructor"})&&!!e.superRef,this.isStatic=r.isObjectMethod()||r.node.static||(null==r.isStaticBlock?void 0:r.isStaticBlock()),this.isPrivateMethod=r.isPrivate()&&r.isMethod(),this.file=e.file,this.constantSuper=null!=(t=e.constantSuper)?t:e.isLoose,this.opts=e;}getObjectRef(){return o.cloneNode(this.opts.objectRef||this.opts.getObjectRef())}getSuperRef(){return this.opts.superRef?o.cloneNode(this.opts.superRef):this.opts.getSuperRef?o.cloneNode(this.opts.getSuperRef()):void 0}replace(){this.opts.refToPreserve&&this.methodPath.traverse(p,{refName:this.opts.refToPreserve.name});const e=this.constantSuper?f:d;(0, s.default)(this.methodPath,c,Object.assign({file:this.file,scope:this.methodPath.scope,isDerivedConstructor:this.isDerivedConstructor,isStatic:this.isStatic,isPrivateMethod:this.isPrivateMethod,getObjectRef:this.getObjectRef.bind(this),getSuperRef:this.getSuperRef.bind(this)},e));}};},"./node_modules/@babel/helper-simple-access/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){e.traverse(i,{scope:e.scope,bindingNames:t,seen:new WeakSet});};var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}const i={UpdateExpression:{exit(e){const{scope:t,bindingNames:r}=this,s=e.get("argument");if(!s.isIdentifier())return;const i=s.node.name;if(r.has(i)&&t.getBinding(i)===e.scope.getBinding(i))if(e.parentPath.isExpressionStatement()&&!e.isCompletionRecord()){const t="++"==e.node.operator?"+=":"-=";e.replaceWith(n.assignmentExpression(t,s.node,n.numericLiteral(1)));}else if(e.node.prefix)e.replaceWith(n.assignmentExpression("=",n.identifier(i),n.binaryExpression(e.node.operator[0],n.unaryExpression("+",s.node),n.numericLiteral(1))));else {const t=e.scope.generateUidIdentifierBasedOnNode(s.node,"old"),r=t.name;e.scope.push({id:t});const i=n.binaryExpression(e.node.operator[0],n.identifier(r),n.numericLiteral(1));e.replaceWith(n.sequenceExpression([n.assignmentExpression("=",n.identifier(r),n.unaryExpression("+",s.node)),n.assignmentExpression("=",n.cloneNode(s.node),i),n.identifier(r)]));}}},AssignmentExpression:{exit(e){const{scope:t,seen:r,bindingNames:s}=this;if("="===e.node.operator)return;if(r.has(e.node))return;r.add(e.node);const i=e.get("left");if(!i.isIdentifier())return;const o=i.node.name;s.has(o)&&t.getBinding(o)===e.scope.getBinding(o)&&(e.node.right=n.binaryExpression(e.node.operator.slice(0,-1),n.cloneNode(e.node.left),e.node.right),e.node.operator="=");}}};},"./node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isTransparentExprWrapper=i,t.skipTransparentExprWrappers=function(e){for(;i(e.node);)e=e.get("expression");return e};var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}function i(e){return n.isTSAsExpression(e)||n.isTSTypeAssertion(e)||n.isTSNonNullExpression(e)||n.isTypeCastExpression(e)||n.isParenthesizedExpression(e)}},"./node_modules/@babel/helper-split-export-declaration/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){if(!e.isExportDeclaration())throw new Error("Only export declarations can be split.");const t=e.isExportDefaultDeclaration(),r=e.get("declaration"),s=r.isClassDeclaration();if(t){const t=r.isFunctionDeclaration()||s,i=r.isScope()?r.scope.parent:r.scope;let o=r.node.id,a=!1;o||(a=!0,o=i.generateUidIdentifier("default"),(t||r.isFunctionExpression()||r.isClassExpression())&&(r.node.id=n.cloneNode(o)));const l=t?r:n.variableDeclaration("var",[n.variableDeclarator(n.cloneNode(o),r.node)]),u=n.exportNamedDeclaration(null,[n.exportSpecifier(n.cloneNode(o),n.identifier("default"))]);return e.insertAfter(u),e.replaceWith(l),a&&i.registerDeclaration(e),e}if(e.get("specifiers").length>0)throw new Error("It doesn't make sense to split exported specifiers.");const i=r.getOuterBindingIdentifiers(),o=Object.keys(i).map((e=>n.exportSpecifier(n.identifier(e),n.identifier(e)))),a=n.exportNamedDeclaration(null,o);return e.insertAfter(a),e.replaceWith(r.node),e};var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}},"./node_modules/@babel/helper-validator-identifier/lib/identifier.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isIdentifierStart=u,t.isIdentifierChar=c,t.isIdentifierName=function(e){let t=!0;for(let r=0;r<e.length;r++){let n=e.charCodeAt(r);if(55296==(64512&n)&&r+1<e.length){const t=e.charCodeAt(++r);56320==(64512&t)&&(n=65536+((1023&n)<<10)+(1023&t));}if(t){if(t=!1,!u(n))return !1}else if(!c(n))return !1}return !t};let r="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",n="‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";const s=new RegExp("["+r+"]"),i=new RegExp("["+r+n+"]");r=n=null;const o=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938],a=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];function l(e,t){let r=65536;for(let n=0,s=t.length;n<s;n+=2){if(r+=t[n],r>e)return !1;if(r+=t[n+1],r>=e)return !0}return !1}function u(e){return e<65?36===e:e<=90||(e<97?95===e:e<=122||(e<=65535?e>=170&&s.test(String.fromCharCode(e)):l(e,o)))}function c(e){return e<48?36===e:e<58||!(e<65)&&(e<=90||(e<97?95===e:e<=122||(e<=65535?e>=170&&i.test(String.fromCharCode(e)):l(e,o)||l(e,a))))}},"./node_modules/@babel/helper-validator-identifier/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"isIdentifierName",{enumerable:!0,get:function(){return n.isIdentifierName}}),Object.defineProperty(t,"isIdentifierChar",{enumerable:!0,get:function(){return n.isIdentifierChar}}),Object.defineProperty(t,"isIdentifierStart",{enumerable:!0,get:function(){return n.isIdentifierStart}}),Object.defineProperty(t,"isReservedWord",{enumerable:!0,get:function(){return s.isReservedWord}}),Object.defineProperty(t,"isStrictBindOnlyReservedWord",{enumerable:!0,get:function(){return s.isStrictBindOnlyReservedWord}}),Object.defineProperty(t,"isStrictBindReservedWord",{enumerable:!0,get:function(){return s.isStrictBindReservedWord}}),Object.defineProperty(t,"isStrictReservedWord",{enumerable:!0,get:function(){return s.isStrictReservedWord}}),Object.defineProperty(t,"isKeyword",{enumerable:!0,get:function(){return s.isKeyword}});var n=r("./node_modules/@babel/helper-validator-identifier/lib/identifier.js"),s=r("./node_modules/@babel/helper-validator-identifier/lib/keyword.js");},"./node_modules/@babel/helper-validator-identifier/lib/keyword.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isReservedWord=i,t.isStrictReservedWord=o,t.isStrictBindOnlyReservedWord=a,t.isStrictBindReservedWord=function(e,t){return o(e,t)||a(e)},t.isKeyword=function(e){return r.has(e)};const r=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"]),n=new Set(["implements","interface","let","package","private","protected","public","static","yield"]),s=new Set(["eval","arguments"]);function i(e,t){return t&&"await"===e||"enum"===e}function o(e,t){return i(e,t)||n.has(e)}function a(e){return s.has(e)}},"./node_modules/@babel/helpers/lib/helpers-generated.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.wrapRegExp=t.typeof=t.objectSpread2=t.jsx=void 0;var n,s=(n=r("./node_modules/@babel/template/lib/index.js"))&&n.__esModule?n:{default:n};const i={minVersion:"7.0.0-beta.0",ast:()=>s.default.program.ast('\nvar REACT_ELEMENT_TYPE;\nexport default function _createRawReactElement(type, props, key, children) {\n  if (!REACT_ELEMENT_TYPE) {\n    REACT_ELEMENT_TYPE =\n      (typeof Symbol === "function" &&\n        \n        Symbol["for"] &&\n        Symbol["for"]("react.element")) ||\n      0xeac7;\n  }\n  var defaultProps = type && type.defaultProps;\n  var childrenLength = arguments.length - 3;\n  if (!props && childrenLength !== 0) {\n    \n    \n    props = { children: void 0 };\n  }\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = new Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 3];\n    }\n    props.children = childArray;\n  }\n  if (props && defaultProps) {\n    for (var propName in defaultProps) {\n      if (props[propName] === void 0) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  } else if (!props) {\n    props = defaultProps || {};\n  }\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key === undefined ? null : "" + key,\n    ref: null,\n    props: props,\n    _owner: null,\n  };\n}\n')};t.jsx=i;const o={minVersion:"7.5.0",ast:()=>s.default.program.ast('\nimport defineProperty from "defineProperty";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(\n          target,\n          key,\n          Object.getOwnPropertyDescriptor(source, key)\n        );\n      });\n    }\n  }\n  return target;\n}\n')};t.objectSpread2=o;const a={minVersion:"7.0.0-beta.0",ast:()=>s.default.program.ast('\nexport default function _typeof(obj) {\n  "@babel/helpers - typeof";\n  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj &&\n        typeof Symbol === "function" &&\n        obj.constructor === Symbol &&\n        obj !== Symbol.prototype\n        ? "symbol"\n        : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\n')};t.typeof=a;const l={minVersion:"7.2.6",ast:()=>s.default.program.ast('\nimport setPrototypeOf from "setPrototypeOf";\nimport inherits from "inherits";\nexport default function _wrapRegExp() {\n  _wrapRegExp = function (re, groups) {\n    return new BabelRegExp(re, undefined, groups);\n  };\n  var _super = RegExp.prototype;\n  var _groups = new WeakMap();\n  function BabelRegExp(re, flags, groups) {\n    var _this = new RegExp(re, flags);\n    \n    _groups.set(_this, groups || _groups.get(re));\n    return setPrototypeOf(_this, BabelRegExp.prototype);\n  }\n  inherits(BabelRegExp, RegExp);\n  BabelRegExp.prototype.exec = function (str) {\n    var result = _super.exec.call(this, str);\n    if (result) result.groups = buildGroups(result, this);\n    return result;\n  };\n  BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {\n    if (typeof substitution === "string") {\n      var groups = _groups.get(this);\n      return _super[Symbol.replace].call(\n        this,\n        str,\n        substitution.replace(/\\$<([^>]+)>/g, function (_, name) {\n          return "$" + groups[name];\n        })\n      );\n    } else if (typeof substitution === "function") {\n      var _this = this;\n      return _super[Symbol.replace].call(this, str, function () {\n        var args = arguments;\n        \n        if (typeof args[args.length - 1] !== "object") {\n          args = [].slice.call(args);\n          args.push(buildGroups(args, _this));\n        }\n        return substitution.apply(this, args);\n      });\n    } else {\n      return _super[Symbol.replace].call(this, str, substitution);\n    }\n  };\n  function buildGroups(result, re) {\n    \n    \n    var g = _groups.get(re);\n    return Object.keys(g).reduce(function (groups, name) {\n      groups[name] = result[g[name]];\n      return groups;\n    }, Object.create(null));\n  }\n  return _wrapRegExp.apply(this, arguments);\n}\n')};t.wrapRegExp=l;},"./node_modules/@babel/helpers/lib/helpers.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n,s=(n=r("./node_modules/@babel/template/lib/index.js"))&&n.__esModule?n:{default:n},i=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=o();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var i=n?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(r,s,i):r[s]=e[s];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/helpers/lib/helpers-generated.js"));function o(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return o=function(){return e},e}const a=Object.assign({__proto__:null},i);var l=a;t.default=l;const u=e=>t=>({minVersion:e,ast:()=>s.default.program.ast(t)});a.asyncIterator=u("7.0.0-beta.0")`
  export default function _asyncIterator(iterable) {
    var method;
    if (typeof Symbol !== "undefined") {
      if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator];
      if (method == null && Symbol.iterator) method = iterable[Symbol.iterator];
    }
    if (method == null) method = iterable["@@asyncIterator"];
    if (method == null) method = iterable["@@iterator"]
    if (method == null) throw new TypeError("Object is not async iterable");
    return method.call(iterable);
  }
`,a.AwaitValue=u("7.0.0-beta.0")`
  export default function _AwaitValue(value) {
    this.wrapped = value;
  }
`,a.AsyncGenerator=u("7.0.0-beta.0")`
  import AwaitValue from "AwaitValue";

  export default function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null,
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg)
        var value = result.value;
        var wrappedAwait = value instanceof AwaitValue;

        Promise.resolve(wrappedAwait ? value.wrapped : value).then(
          function (arg) {
            if (wrappedAwait) {
              resume(key === "return" ? "return" : "next", arg);
              return
            }

            settle(result.done ? "return" : "normal", arg);
          },
          function (err) { resume("throw", err); });
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({ value: value, done: true });
          break;
        case "throw":
          front.reject(value);
          break;
        default:
          front.resolve({ value: value, done: false });
          break;
      }

      front = front.next;
      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    // Hide "return" method if generator return is not supported
    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

  AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };
  AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };
  AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
`,a.wrapAsyncGenerator=u("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`,a.awaitAsyncGenerator=u("7.0.0-beta.0")`
  import AwaitValue from "AwaitValue";

  export default function _awaitAsyncGenerator(value) {
    return new AwaitValue(value);
  }
`,a.asyncGeneratorDelegate=u("7.0.0-beta.0")`
  export default function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {}, waiting = false;

    function pump(key, value) {
      waiting = true;
      value = new Promise(function (resolve) { resolve(inner[key](value)); });
      return { done: false, value: awaitWrap(value) };
    };

    iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () { return this; };

    iter.next = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }
      return pump("next", value);
    };

    if (typeof inner.throw === "function") {
      iter.throw = function (value) {
        if (waiting) {
          waiting = false;
          throw value;
        }
        return pump("throw", value);
      };
    }

    if (typeof inner.return === "function") {
      iter.return = function (value) {
        if (waiting) {
          waiting = false;
          return value;
        }
        return pump("return", value);
      };
    }

    return iter;
  }
`,a.asyncToGenerator=u("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`,a.classCallCheck=u("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`,a.createClass=u("7.0.0-beta.0")`
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
`,a.defineEnumerableProperties=u("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object's own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`,a.defaults=u("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`,a.defineProperty=u("7.0.0-beta.0")`
  export default function _defineProperty(obj, key, value) {
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`,a.extends=u("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`,a.objectSpread=u("7.0.0-beta.0")`
  import defineProperty from "defineProperty";

  export default function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = (arguments[i] != null) ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        defineProperty(target, key, source[key]);
      });
    }
    return target;
  }
`,a.inherits=u("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`,a.inheritsLoose=u("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`,a.getPrototypeOf=u("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`,a.setPrototypeOf=u("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
`,a.isNativeReflectConstruct=u("7.9.0")`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;

    // core-js@3
    if (Reflect.construct.sham) return false;

    // Proxy can't be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === "function") return true;

    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren't set, this throws an error similar to
      //   TypeError: this is not a Boolean object.

      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
`,a.construct=u("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";

  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn't
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`,a.isNativeFunction=u("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
`,a.wrapNativeSuper=u("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`,a.instanceof=u("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`,a.interopRequireDefault=u("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`,a.interopRequireWildcard=u("7.14.0")`
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  export default function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
      return { default: obj }
    }

    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
`,a.newArrowCheck=u("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`,a.objectDestructuringEmpty=u("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }
`,a.objectWithoutPropertiesLoose=u("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`,a.objectWithoutProperties=u("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`,a.assertThisInitialized=u("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`,a.possibleConstructorReturn=u("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }
    return assertThisInitialized(self);
  }
`,a.createSuper=u("7.9.0")`
  import getPrototypeOf from "getPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";
  import possibleConstructorReturn from "possibleConstructorReturn";

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    }
  }
 `,a.superPropBase=u("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`,a.get=u("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }
    return _get(target, property, receiver || target);
  }
`,a.set=u("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }
`,a.taggedTemplateLiteral=u("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`,a.taggedTemplateLiteralLoose=u("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`,a.readOnlyError=u("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`,a.writeOnlyError=u("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`,a.classNameTDZError=u("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new Error("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`,a.temporalUndefined=u("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`,a.tdz=u("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`,a.temporalRef=u("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`,a.slicedToArray=u("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`,a.slicedToArrayLoose=u("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`,a.toArray=u("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`,a.toConsumableArray=u("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`,a.arrayWithoutHoles=u("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`,a.arrayWithHoles=u("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`,a.maybeArrayLike=u("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`,a.iterableToArray=u("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`,a.iterableToArrayLimit=u("7.0.0-beta.0")`
  export default function _iterableToArrayLimit(arr, i) {
    // this is an expanded form of \`for...of\` that properly supports abrupt completions of
    // iterators etc. variable names have been minimised to reduce the size of this massive
    // helper. sometimes spec compliance is annoying :(
    //
    // _n = _iteratorNormalCompletion
    // _d = _didIteratorError
    // _e = _iteratorError
    // _i = _iterator
    // _s = _step

    var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;

    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
`,a.iterableToArrayLimitLoose=u("7.0.0-beta.0")`
  export default function _iterableToArrayLimitLoose(arr, i) {
    var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;

    var _arr = [];
    for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {
      _arr.push(_step.value);
      if (i && _arr.length === i) break;
    }
    return _arr;
  }
`,a.unsupportedIterableToArray=u("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`,a.arrayLikeToArray=u("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`,a.nonIterableSpread=u("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`,a.nonIterableRest=u("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`,a.createForOfIteratorHelper=u("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`,a.createForOfIteratorHelperLoose=u("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`,a.skipFirstGeneratorNext=u("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`,a.toPrimitive=u("7.1.5")`
  export default function _toPrimitive(
    input,
    hint /*: "default" | "string" | "number" | void */
  ) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
`,a.toPropertyKey=u("7.1.5")`
  import toPrimitive from "toPrimitive";

  export default function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
`,a.initializerWarningHelper=u("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'proposal-class-properties is enabled and runs after the decorators transform.'
        );
    }
`,a.initializerDefineProperty=u("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`,a.applyDecoratedDescriptor=u("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`,a.classPrivateFieldLooseKey=u("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`,a.classPrivateFieldLooseBase=u("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`,a.classPrivateFieldGet=u("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`,a.classPrivateFieldSet=u("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`,a.classPrivateFieldDestructureSet=u("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`,a.classExtractFieldDescriptor=u("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`,a.classStaticPrivateFieldSpecGet=u("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`,a.classStaticPrivateFieldSpecSet=u("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`,a.classStaticPrivateMethodGet=u("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`,a.classStaticPrivateMethodSet=u("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`,a.classApplyDescriptorGet=u("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`,a.classApplyDescriptorSet=u("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`,a.classApplyDescriptorDestructureSet=u("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`,a.classStaticPrivateFieldDestructureSet=u("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`,a.classCheckPrivateStaticAccess=u("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`,a.classCheckPrivateStaticFieldDescriptor=u("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`,a.decorate=u("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`,a.classPrivateMethodGet=u("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`,a.classPrivateMethodSet=u("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `;},"./node_modules/@babel/helpers/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.get=d,t.minVersion=function(e){return p(e).minVersion()},t.getDependencies=function(e){return Array.from(p(e).dependencies.values())},t.ensure=function(e,t){u||(u=t),p(e);},t.default=t.list=void 0;var n=a(r("./node_modules/@babel/traverse/lib/index.js")),s=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=o();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var i=n?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(r,s,i):r[s]=e[s];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js")),i=a(r("./node_modules/@babel/helpers/lib/helpers.js"));function o(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return o=function(){return e},e}function a(e){return e&&e.__esModule?e:{default:e}}function l(e){const t=[];for(;e.parentPath;e=e.parentPath)t.push(e.key),e.inList&&t.push(e.listKey);return t.reverse().join(".")}let u;const c=Object.create(null);function p(e){if(!c[e]){const t=i.default[e];if(!t)throw Object.assign(new ReferenceError(`Unknown helper ${e}`),{code:"BABEL_HELPER_UNKNOWN",helper:e});const r=()=>{const r={ast:s.file(t.ast())};return u?new u({filename:`babel-helper://${e}`},r):r},o=function(e){const t=new Set,r=new Set,s=new Map;let o,a;const u=[],c=[],p=[],d={ImportDeclaration(e){const t=e.node.source.value;if(!i.default[t])throw e.buildCodeFrameError(`Unknown helper ${t}`);if(1!==e.get("specifiers").length||!e.get("specifiers.0").isImportDefaultSpecifier())throw e.buildCodeFrameError("Helpers can only import a default value");const r=e.node.specifiers[0].local;s.set(r,t),c.push(l(e));},ExportDefaultDeclaration(e){const t=e.get("declaration");if(t.isFunctionDeclaration()){if(!t.node.id)throw t.buildCodeFrameError("Helpers should give names to their exported func declaration");o=t.node.id.name;}a=l(e);},ExportAllDeclaration(e){throw e.buildCodeFrameError("Helpers can only export default")},ExportNamedDeclaration(e){throw e.buildCodeFrameError("Helpers can only export default")},Statement(e){e.isModuleDeclaration()||e.skip();}},f={Program(e){const t=e.scope.getAllBindings();Object.keys(t).forEach((e=>{e!==o&&(s.has(t[e].identifier)||r.add(e));}));},ReferencedIdentifier(e){const r=e.node.name,n=e.scope.getBinding(r,!0);n?s.has(n.identifier)&&p.push(l(e)):t.add(r);},AssignmentExpression(e){const t=e.get("left");if(!(o in t.getBindingIdentifiers()))return;if(!t.isIdentifier())throw t.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");const r=e.scope.getBinding(o);null!=r&&r.scope.path.isProgram()&&u.push(l(e));}};if((0, n.default)(e.ast,d,e.scope),(0, n.default)(e.ast,f,e.scope),!a)throw new Error("Helpers must default-export something.");return u.reverse(),{globals:Array.from(t),localBindingNames:Array.from(r),dependencies:s,exportBindingAssignments:u,exportPath:a,exportName:o,importBindingsReferences:p,importPaths:c}}(r());c[e]={build(e,t,i){const a=r();return function(e,t,r,i,o){if(i&&!r)throw new Error("Unexpected local bindings for module-based helpers.");if(!r)return;const{localBindingNames:a,dependencies:l,exportBindingAssignments:u,exportPath:c,exportName:p,importBindingsReferences:d,importPaths:f}=t,h={};l.forEach(((e,t)=>{h[t.name]="function"==typeof o&&o(e)||t;}));const m={},y=new Set(i||[]);a.forEach((e=>{let t=e;for(;y.has(t);)t="_"+t;t!==e&&(m[e]=t);})),"Identifier"===r.type&&p!==r.name&&(m[p]=r.name);const b={Program(e){const t=e.get(c),n=f.map((t=>e.get(t))),i=d.map((t=>e.get(t))),o=t.get("declaration");if("Identifier"===r.type)o.isFunctionDeclaration()?t.replaceWith(o):t.replaceWith(s.variableDeclaration("var",[s.variableDeclarator(r,o.node)]));else {if("MemberExpression"!==r.type)throw new Error("Unexpected helper format.");o.isFunctionDeclaration()?(u.forEach((t=>{const n=e.get(t);n.replaceWith(s.assignmentExpression("=",r,n.node));})),t.replaceWith(o),e.pushContainer("body",s.expressionStatement(s.assignmentExpression("=",r,s.identifier(p))))):t.replaceWith(s.expressionStatement(s.assignmentExpression("=",r,o.node)));}Object.keys(m).forEach((t=>{e.scope.rename(t,m[t]);}));for(const e of n)e.remove();for(const e of i){const t=s.cloneNode(h[e.node.name]);e.replaceWith(t);}e.stop();}};(0, n.default)(e.ast,b,e.scope);}(a,o,t,i,e),{nodes:a.ast.program.body,globals:o.globals}},minVersion:()=>t.minVersion,dependencies:o.dependencies};}return c[e]}function d(e,t,r,n){return p(e).build(t,r,n)}const f=Object.keys(i.default).map((e=>e.replace(/^_/,""))).filter((e=>"__esModule"!==e));t.list=f;var h=d;t.default=h;},"./node_modules/@babel/parser/lib/index.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0});const r=!0,n=!0,s=!0,i=!0;class o{constructor(e,t={}){this.label=void 0,this.keyword=void 0,this.beforeExpr=void 0,this.startsExpr=void 0,this.rightAssociative=void 0,this.isLoop=void 0,this.isAssign=void 0,this.prefix=void 0,this.postfix=void 0,this.binop=void 0,this.updateContext=void 0,this.label=e,this.keyword=t.keyword,this.beforeExpr=!!t.beforeExpr,this.startsExpr=!!t.startsExpr,this.rightAssociative=!!t.rightAssociative,this.isLoop=!!t.isLoop,this.isAssign=!!t.isAssign,this.prefix=!!t.prefix,this.postfix=!!t.postfix,this.binop=null!=t.binop?t.binop:null,this.updateContext=null;}}const a=new Map;function l(e,t={}){t.keyword=e;const r=new o(e,t);return a.set(e,r),r}function u(e,t){return new o(e,{beforeExpr:r,binop:t})}const c={num:new o("num",{startsExpr:n}),bigint:new o("bigint",{startsExpr:n}),decimal:new o("decimal",{startsExpr:n}),regexp:new o("regexp",{startsExpr:n}),string:new o("string",{startsExpr:n}),name:new o("name",{startsExpr:n}),privateName:new o("#name",{startsExpr:n}),eof:new o("eof"),bracketL:new o("[",{beforeExpr:r,startsExpr:n}),bracketHashL:new o("#[",{beforeExpr:r,startsExpr:n}),bracketBarL:new o("[|",{beforeExpr:r,startsExpr:n}),bracketR:new o("]"),bracketBarR:new o("|]"),braceL:new o("{",{beforeExpr:r,startsExpr:n}),braceBarL:new o("{|",{beforeExpr:r,startsExpr:n}),braceHashL:new o("#{",{beforeExpr:r,startsExpr:n}),braceR:new o("}"),braceBarR:new o("|}"),parenL:new o("(",{beforeExpr:r,startsExpr:n}),parenR:new o(")"),comma:new o(",",{beforeExpr:r}),semi:new o(";",{beforeExpr:r}),colon:new o(":",{beforeExpr:r}),doubleColon:new o("::",{beforeExpr:r}),dot:new o("."),question:new o("?",{beforeExpr:r}),questionDot:new o("?."),arrow:new o("=>",{beforeExpr:r}),template:new o("template"),ellipsis:new o("...",{beforeExpr:r}),backQuote:new o("`",{startsExpr:n}),dollarBraceL:new o("${",{beforeExpr:r,startsExpr:n}),at:new o("@"),hash:new o("#",{startsExpr:n}),interpreterDirective:new o("#!..."),eq:new o("=",{beforeExpr:r,isAssign:!0}),assign:new o("_=",{beforeExpr:r,isAssign:!0}),incDec:new o("++/--",{prefix:i,postfix:!0,startsExpr:n}),bang:new o("!",{beforeExpr:r,prefix:i,startsExpr:n}),tilde:new o("~",{beforeExpr:r,prefix:i,startsExpr:n}),pipeline:u("|>",0),nullishCoalescing:u("??",1),logicalOR:u("||",1),logicalAND:u("&&",2),bitwiseOR:u("|",3),bitwiseXOR:u("^",4),bitwiseAND:u("&",5),equality:u("==/!=/===/!==",6),relational:u("</>/<=/>=",7),bitShift:u("<</>>/>>>",8),plusMin:new o("+/-",{beforeExpr:r,binop:9,prefix:i,startsExpr:n}),modulo:new o("%",{beforeExpr:r,binop:10,startsExpr:n}),star:new o("*",{binop:10}),slash:u("/",10),exponent:new o("**",{beforeExpr:r,binop:11,rightAssociative:!0}),_break:l("break"),_case:l("case",{beforeExpr:r}),_catch:l("catch"),_continue:l("continue"),_debugger:l("debugger"),_default:l("default",{beforeExpr:r}),_do:l("do",{isLoop:s,beforeExpr:r}),_else:l("else",{beforeExpr:r}),_finally:l("finally"),_for:l("for",{isLoop:s}),_function:l("function",{startsExpr:n}),_if:l("if"),_return:l("return",{beforeExpr:r}),_switch:l("switch"),_throw:l("throw",{beforeExpr:r,prefix:i,startsExpr:n}),_try:l("try"),_var:l("var"),_const:l("const"),_while:l("while",{isLoop:s}),_with:l("with"),_new:l("new",{beforeExpr:r,startsExpr:n}),_this:l("this",{startsExpr:n}),_super:l("super",{startsExpr:n}),_class:l("class",{startsExpr:n}),_extends:l("extends",{beforeExpr:r}),_export:l("export"),_import:l("import",{startsExpr:n}),_null:l("null",{startsExpr:n}),_true:l("true",{startsExpr:n}),_false:l("false",{startsExpr:n}),_in:l("in",{beforeExpr:r,binop:7}),_instanceof:l("instanceof",{beforeExpr:r,binop:7}),_typeof:l("typeof",{beforeExpr:r,prefix:i,startsExpr:n}),_void:l("void",{beforeExpr:r,prefix:i,startsExpr:n}),_delete:l("delete",{beforeExpr:r,prefix:i,startsExpr:n})},p=/\r\n?|[\n\u2028\u2029]/,d=new RegExp(p.source,"g");function f(e){switch(e){case 10:case 13:case 8232:case 8233:return !0;default:return !1}}const h=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;function m(e){switch(e){case 9:case 11:case 12:case 32:case 160:case 5760:case 8192:case 8193:case 8194:case 8195:case 8196:case 8197:case 8198:case 8199:case 8200:case 8201:case 8202:case 8239:case 8287:case 12288:case 65279:return !0;default:return !1}}class y{constructor(e,t){this.line=void 0,this.column=void 0,this.line=e,this.column=t;}}class b{constructor(e,t){this.start=void 0,this.end=void 0,this.filename=void 0,this.identifierName=void 0,this.start=e,this.end=t;}}function g(e){return e[e.length-1]}const E=Object.freeze({SyntaxError:"BABEL_PARSER_SYNTAX_ERROR",SourceTypeModuleError:"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"}),v=T({AccessorIsGenerator:"A %0ter cannot be a generator.",ArgumentsInClass:"'arguments' is only allowed in functions and class methods.",AsyncFunctionInSingleStatementContext:"Async functions can only be declared at the top level or inside a block.",AwaitBindingIdentifier:"Can not use 'await' as identifier inside an async function.",AwaitBindingIdentifierInStaticBlock:"Can not use 'await' as identifier inside a static block.",AwaitExpressionFormalParameter:"'await' is not allowed in async function parameters.",AwaitNotInAsyncContext:"'await' is only allowed within async functions and at the top levels of modules.",AwaitNotInAsyncFunction:"'await' is only allowed within async functions.",BadGetterArity:"A 'get' accesor must not have any formal parameters.",BadSetterArity:"A 'set' accesor must have exactly one formal parameter.",BadSetterRestParameter:"A 'set' accesor function argument must not be a rest parameter.",ConstructorClassField:"Classes may not have a field named 'constructor'.",ConstructorClassPrivateField:"Classes may not have a private field named '#constructor'.",ConstructorIsAccessor:"Class constructor may not be an accessor.",ConstructorIsAsync:"Constructor can't be an async function.",ConstructorIsGenerator:"Constructor can't be a generator.",DeclarationMissingInitializer:"'%0' require an initialization value.",DecoratorBeforeExport:"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",DecoratorConstructor:"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",DecoratorExportClass:"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",DecoratorSemicolon:"Decorators must not be followed by a semicolon.",DecoratorStaticBlock:"Decorators can't be used with a static block.",DeletePrivateField:"Deleting a private field is not allowed.",DestructureNamedImport:"ES2015 named imports do not destructure. Use another statement for destructuring after the import.",DuplicateConstructor:"Duplicate constructor in the same class.",DuplicateDefaultExport:"Only one default export allowed per module.",DuplicateExport:"`%0` has already been exported. Exported identifiers must be unique.",DuplicateProto:"Redefinition of __proto__ property.",DuplicateRegExpFlags:"Duplicate regular expression flag.",ElementAfterRest:"Rest element must be last element.",EscapedCharNotAnIdentifier:"Invalid Unicode escape.",ExportBindingIsString:"A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",ExportDefaultFromAsIdentifier:"'from' is not allowed as an identifier after 'export default'.",ForInOfLoopInitializer:"'%0' loop variable declaration may not have an initializer.",ForOfAsync:"The left-hand side of a for-of loop may not be 'async'.",ForOfLet:"The left-hand side of a for-of loop may not start with 'let'.",GeneratorInSingleStatementContext:"Generators can only be declared at the top level or inside a block.",IllegalBreakContinue:"Unsyntactic %0.",IllegalLanguageModeDirective:"Illegal 'use strict' directive in function with non-simple parameter list.",IllegalReturn:"'return' outside of function.",ImportBindingIsString:'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',ImportCallArgumentTrailingComma:"Trailing comma is disallowed inside import(...) arguments.",ImportCallArity:"`import()` requires exactly %0.",ImportCallNotNewExpression:"Cannot use new with import(...).",ImportCallSpreadArgument:"`...` is not allowed in `import()`.",InvalidBigIntLiteral:"Invalid BigIntLiteral.",InvalidCodePoint:"Code point out of bounds.",InvalidDecimal:"Invalid decimal.",InvalidDigit:"Expected number in radix %0.",InvalidEscapeSequence:"Bad character escape sequence.",InvalidEscapeSequenceTemplate:"Invalid escape sequence in template.",InvalidEscapedReservedWord:"Escape sequence in keyword %0.",InvalidIdentifier:"Invalid identifier %0.",InvalidLhs:"Invalid left-hand side in %0.",InvalidLhsBinding:"Binding invalid left-hand side in %0.",InvalidNumber:"Invalid number.",InvalidOrMissingExponent:"Floating-point numbers require a valid exponent after the 'e'.",InvalidOrUnexpectedToken:"Unexpected character '%0'.",InvalidParenthesizedAssignment:"Invalid parenthesized assignment pattern.",InvalidPrivateFieldResolution:"Private name #%0 is not defined.",InvalidPropertyBindingPattern:"Binding member expression.",InvalidRecordProperty:"Only properties and spread elements are allowed in record definitions.",InvalidRestAssignmentPattern:"Invalid rest operator's argument.",LabelRedeclaration:"Label '%0' is already declared.",LetInLexicalBinding:"'let' is not allowed to be used as a name in 'let' or 'const' declarations.",LineTerminatorBeforeArrow:"No line break is allowed before '=>'.",MalformedRegExpFlags:"Invalid regular expression flag.",MissingClassName:"A class name is required.",MissingEqInAssignment:"Only '=' operator can be used for specifying default value.",MissingSemicolon:"Missing semicolon.",MissingUnicodeEscape:"Expecting Unicode escape sequence \\uXXXX.",MixingCoalesceWithLogical:"Nullish coalescing operator(??) requires parens when mixing with logical operators.",ModuleAttributeDifferentFromType:"The only accepted module attribute is `type`.",ModuleAttributeInvalidValue:"Only string literals are allowed as module attribute values.",ModuleAttributesWithDuplicateKeys:'Duplicate key "%0" is not allowed in module attributes.',ModuleExportNameHasLoneSurrogate:"An export name cannot include a lone surrogate, found '\\u%0'.",ModuleExportUndefined:"Export '%0' is not defined.",MultipleDefaultsInSwitch:"Multiple default clauses.",NewlineAfterThrow:"Illegal newline after throw.",NoCatchOrFinally:"Missing catch or finally clause.",NumberIdentifier:"Identifier directly after number.",NumericSeparatorInEscapeSequence:"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",ObsoleteAwaitStar:"'await*' has been removed from the async functions proposal. Use Promise.all() instead.",OptionalChainingNoNew:"Constructors in/after an Optional Chain are not allowed.",OptionalChainingNoTemplate:"Tagged Template Literals are not allowed in optionalChain.",OverrideOnConstructor:"'override' modifier cannot appear on a constructor declaration.",ParamDupe:"Argument name clash.",PatternHasAccessor:"Object pattern can't contain getter or setter.",PatternHasMethod:"Object pattern can't contain methods.",PipelineBodyNoArrow:'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',PipelineBodySequenceExpression:"Pipeline body may not be a comma-separated sequence expression.",PipelineHeadSequenceExpression:"Pipeline head should not be a comma-separated sequence expression.",PipelineTopicUnused:"Pipeline is in topic style but does not use topic reference.",PrimaryTopicNotAllowed:"Topic reference was used in a lexical context without topic binding.",PrimaryTopicRequiresSmartPipeline:"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",PrivateInExpectedIn:"Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",PrivateNameRedeclaration:"Duplicate private name #%0.",RecordExpressionBarIncorrectEndSyntaxType:"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",RecordExpressionBarIncorrectStartSyntaxType:"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",RecordExpressionHashIncorrectStartSyntaxType:"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",RecordNoProto:"'__proto__' is not allowed in Record expressions.",RestTrailingComma:"Unexpected trailing comma after rest element.",SloppyFunction:"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",StaticPrototype:"Classes may not have static property named prototype.",StrictDelete:"Deleting local variable in strict mode.",StrictEvalArguments:"Assigning to '%0' in strict mode.",StrictEvalArgumentsBinding:"Binding '%0' in strict mode.",StrictFunction:"In strict mode code, functions can only be declared at top level or inside a block.",StrictNumericEscape:"The only valid numeric escape in strict mode is '\\0'.",StrictOctalLiteral:"Legacy octal literals are not allowed in strict mode.",StrictWith:"'with' in strict mode.",SuperNotAllowed:"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",SuperPrivateField:"Private fields can't be accessed on super.",TrailingDecorator:"Decorators must be attached to a class element.",TupleExpressionBarIncorrectEndSyntaxType:"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",TupleExpressionBarIncorrectStartSyntaxType:"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",TupleExpressionHashIncorrectStartSyntaxType:"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",UnexpectedArgumentPlaceholder:"Unexpected argument placeholder.",UnexpectedAwaitAfterPipelineBody:'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',UnexpectedDigitAfterHash:"Unexpected digit after hash token.",UnexpectedImportExport:"'import' and 'export' may only appear at the top level.",UnexpectedKeyword:"Unexpected keyword '%0'.",UnexpectedLeadingDecorator:"Leading decorators must be attached to a class declaration.",UnexpectedLexicalDeclaration:"Lexical declaration cannot appear in a single-statement context.",UnexpectedNewTarget:"`new.target` can only be used in functions or class properties.",UnexpectedNumericSeparator:"A numeric separator is only allowed between two digits.",UnexpectedPrivateField:"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",UnexpectedReservedWord:"Unexpected reserved word '%0'.",UnexpectedSuper:"'super' is only allowed in object methods and classes.",UnexpectedToken:"Unexpected token '%0'.",UnexpectedTokenUnaryExponentiation:"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",UnsupportedBind:"Binding should be performed on object property.",UnsupportedDecoratorExport:"A decorated export must export a class declaration.",UnsupportedDefaultExport:"Only expressions, functions or classes are allowed as the `default` export.",UnsupportedImport:"`import` can only be used in `import()` or `import.meta`.",UnsupportedMetaProperty:"The only valid meta property for %0 is %0.%1.",UnsupportedParameterDecorator:"Decorators cannot be used to decorate parameters.",UnsupportedPropertyDecorator:"Decorators cannot be used to decorate object literal properties.",UnsupportedSuper:"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",UnterminatedComment:"Unterminated comment.",UnterminatedRegExp:"Unterminated regular expression.",UnterminatedString:"Unterminated string constant.",UnterminatedTemplate:"Unterminated template.",VarRedeclaration:"Identifier '%0' has already been declared.",YieldBindingIdentifier:"Can not use 'yield' as identifier inside a generator.",YieldInParameter:"Yield expression is not allowed in formal parameters.",ZeroDigitNumericSeparator:"Numeric separator can not be used after leading 0."},E.SyntaxError),x=T({ImportMetaOutsideModule:"import.meta may appear only with 'sourceType: \"module\"'",ImportOutsideModule:"'import' and 'export' may appear only with 'sourceType: \"module\"'"},E.SourceTypeModuleError);function T(e,t){const r={};return Object.keys(e).forEach((n=>{r[n]=Object.freeze({code:t,reasonCode:n,template:e[n]});})),Object.freeze(r)}class S{constructor(e,t,r,n){this.token=void 0,this.isExpr=void 0,this.preserveSpace=void 0,this.override=void 0,this.token=e,this.isExpr=!!t,this.preserveSpace=!!r,this.override=n;}}const P={braceStatement:new S("{",!1),braceExpression:new S("{",!0),recordExpression:new S("#{",!0),templateQuasi:new S("${",!1),parenStatement:new S("(",!1),parenExpression:new S("(",!0),template:new S("`",!0,!0,(e=>e.readTmplToken())),functionExpression:new S("function",!0),functionStatement:new S("function",!1)};c.parenR.updateContext=c.braceR.updateContext=function(){if(1===this.state.context.length)return void(this.state.exprAllowed=!0);let e=this.state.context.pop();e===P.braceStatement&&"function"===this.curContext().token&&(e=this.state.context.pop()),this.state.exprAllowed=!e.isExpr;},c.name.updateContext=function(e){let t=!1;e!==c.dot&&("of"!==this.state.value||this.state.exprAllowed||e===c._function||e===c._class||(t=!0)),this.state.exprAllowed=t;},c.braceL.updateContext=function(e){this.state.context.push(this.braceIsBlock(e)?P.braceStatement:P.braceExpression),this.state.exprAllowed=!0;},c.dollarBraceL.updateContext=function(){this.state.context.push(P.templateQuasi),this.state.exprAllowed=!0;},c.parenL.updateContext=function(e){const t=e===c._if||e===c._for||e===c._with||e===c._while;this.state.context.push(t?P.parenStatement:P.parenExpression),this.state.exprAllowed=!0;},c.incDec.updateContext=function(){},c._function.updateContext=c._class.updateContext=function(e){!e.beforeExpr||e===c.semi||e===c._else||e===c._return&&this.hasPrecedingLineBreak()||(e===c.colon||e===c.braceL)&&this.curContext()===P.b_stat?this.state.context.push(P.functionStatement):this.state.context.push(P.functionExpression),this.state.exprAllowed=!1;},c.backQuote.updateContext=function(){this.curContext()===P.template?this.state.context.pop():this.state.context.push(P.template),this.state.exprAllowed=!1;},c.braceHashL.updateContext=function(){this.state.context.push(P.recordExpression),this.state.exprAllowed=!0;};let A="ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",w="‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";const C=new RegExp("["+A+"]"),D=new RegExp("["+A+w+"]");A=w=null;const _=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938],O=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];function j(e,t){let r=65536;for(let n=0,s=t.length;n<s;n+=2){if(r+=t[n],r>e)return !1;if(r+=t[n+1],r>=e)return !0}return !1}function I(e){return e<65?36===e:e<=90||(e<97?95===e:e<=122||(e<=65535?e>=170&&C.test(String.fromCharCode(e)):j(e,_)))}function N(e){return e<48?36===e:e<58||!(e<65)&&(e<=90||(e<97?95===e:e<=122||(e<=65535?e>=170&&D.test(String.fromCharCode(e)):j(e,_)||j(e,O))))}const k=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"]),F=new Set(["implements","interface","let","package","private","protected","public","static","yield"]),L=new Set(["eval","arguments"]);function M(e,t){return t&&"await"===e||"enum"===e}function B(e,t){return M(e,t)||F.has(e)}function R(e){return L.has(e)}function U(e,t){return B(e,t)||R(e)}function V(e){return k.has(e)}const W=/^in(stanceof)?$/;class ${constructor(e){this.flags=void 0,this.var=[],this.lexical=[],this.functions=[],this.flags=e;}}class K{constructor(e,t){this.scopeStack=[],this.undefinedExports=new Map,this.undefinedPrivateNames=new Map,this.raise=e,this.inModule=t;}get inFunction(){return (2&this.currentVarScope().flags)>0}get allowSuper(){return (16&this.currentThisScope().flags)>0}get allowDirectSuper(){return (32&this.currentThisScope().flags)>0}get inClass(){return (64&this.currentThisScope().flags)>0}get inStaticBlock(){return (128&this.currentThisScope().flags)>0}get inNonArrowFunction(){return (2&this.currentThisScope().flags)>0}get treatFunctionsAsVar(){return this.treatFunctionsAsVarInScope(this.currentScope())}createScope(e){return new $(e)}enter(e){this.scopeStack.push(this.createScope(e));}exit(){this.scopeStack.pop();}treatFunctionsAsVarInScope(e){return !!(2&e.flags||!this.inModule&&1&e.flags)}declareName(e,t,r){let n=this.currentScope();if(8&t||16&t)this.checkRedeclarationInScope(n,e,t,r),16&t?n.functions.push(e):n.lexical.push(e),8&t&&this.maybeExportDefined(n,e);else if(4&t)for(let s=this.scopeStack.length-1;s>=0&&(n=this.scopeStack[s],this.checkRedeclarationInScope(n,e,t,r),n.var.push(e),this.maybeExportDefined(n,e),!(259&n.flags));--s);this.inModule&&1&n.flags&&this.undefinedExports.delete(e);}maybeExportDefined(e,t){this.inModule&&1&e.flags&&this.undefinedExports.delete(t);}checkRedeclarationInScope(e,t,r,n){this.isRedeclaredInScope(e,t,r)&&this.raise(n,v.VarRedeclaration,t);}isRedeclaredInScope(e,t,r){return !!(1&r)&&(8&r?e.lexical.indexOf(t)>-1||e.functions.indexOf(t)>-1||e.var.indexOf(t)>-1:16&r?e.lexical.indexOf(t)>-1||!this.treatFunctionsAsVarInScope(e)&&e.var.indexOf(t)>-1:e.lexical.indexOf(t)>-1&&!(8&e.flags&&e.lexical[0]===t)||!this.treatFunctionsAsVarInScope(e)&&e.functions.indexOf(t)>-1)}checkLocalExport(e){-1===this.scopeStack[0].lexical.indexOf(e.name)&&-1===this.scopeStack[0].var.indexOf(e.name)&&-1===this.scopeStack[0].functions.indexOf(e.name)&&this.undefinedExports.set(e.name,e.start);}currentScope(){return this.scopeStack[this.scopeStack.length-1]}currentVarScope(){for(let e=this.scopeStack.length-1;;e--){const t=this.scopeStack[e];if(259&t.flags)return t}}currentThisScope(){for(let e=this.scopeStack.length-1;;e--){const t=this.scopeStack[e];if((259&t.flags||64&t.flags)&&!(4&t.flags))return t}}}class q extends ${constructor(...e){super(...e),this.declareFunctions=[];}}class G extends K{createScope(e){return new q(e)}declareName(e,t,r){const n=this.currentScope();if(2048&t)return this.checkRedeclarationInScope(n,e,t,r),this.maybeExportDefined(n,e),void n.declareFunctions.push(e);super.declareName(...arguments);}isRedeclaredInScope(e,t,r){return !!super.isRedeclaredInScope(...arguments)||!!(2048&r)&&!e.declareFunctions.includes(t)&&(e.lexical.includes(t)||e.functions.includes(t))}checkLocalExport(e){-1===this.scopeStack[0].declareFunctions.indexOf(e.name)&&super.checkLocalExport(e);}}const H=new Set(["_","any","bool","boolean","empty","extends","false","interface","mixed","null","number","static","string","true","typeof","void"]),J=T({AmbiguousConditionalArrow:"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",AmbiguousDeclareModuleKind:"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",AssignReservedType:"Cannot overwrite reserved type %0.",DeclareClassElement:"The `declare` modifier can only appear on class fields.",DeclareClassFieldInitializer:"Initializers are not allowed in fields with the `declare` modifier.",DuplicateDeclareModuleExports:"Duplicate `declare module.exports` statement.",EnumBooleanMemberNotInitialized:"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",EnumDuplicateMemberName:"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",EnumInconsistentMemberValues:"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",EnumInvalidExplicitType:"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",EnumInvalidExplicitTypeUnknownSupplied:"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",EnumInvalidMemberInitializerPrimaryType:"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",EnumInvalidMemberInitializerSymbolType:"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",EnumInvalidMemberInitializerUnknownType:"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",EnumInvalidMemberName:"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",EnumNumberMemberNotInitialized:"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",EnumStringMemberInconsistentlyInitailized:"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",GetterMayNotHaveThisParam:"A getter cannot have a `this` parameter.",ImportTypeShorthandOnlyInPureImport:"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",InexactInsideExact:"Explicit inexact syntax cannot appear inside an explicit exact object type.",InexactInsideNonObject:"Explicit inexact syntax cannot appear in class or interface definitions.",InexactVariance:"Explicit inexact syntax cannot have variance.",InvalidNonTypeImportInDeclareModule:"Imports within a `declare module` body must always be `import type` or `import typeof`.",MissingTypeParamDefault:"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",NestedDeclareModule:"`declare module` cannot be used inside another `declare module`.",NestedFlowComment:"Cannot have a flow comment inside another flow comment.",OptionalBindingPattern:"A binding pattern parameter cannot be optional in an implementation signature.",SetterMayNotHaveThisParam:"A setter cannot have a `this` parameter.",SpreadVariance:"Spread properties cannot have variance.",ThisParamAnnotationRequired:"A type annotation is required for the `this` parameter.",ThisParamBannedInConstructor:"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",ThisParamMayNotBeOptional:"The `this` parameter cannot be optional.",ThisParamMustBeFirst:"The `this` parameter must be the first function parameter.",ThisParamNoDefault:"The `this` parameter may not have a default value.",TypeBeforeInitializer:"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",TypeCastInPattern:"The type cast expression is expected to be wrapped with parenthesis.",UnexpectedExplicitInexactInObject:"Explicit inexact syntax must appear at the end of an inexact object.",UnexpectedReservedType:"Unexpected reserved type %0.",UnexpectedReservedUnderscore:"`_` is only allowed as a type argument to call or new.",UnexpectedSpaceBetweenModuloChecks:"Spaces between `%` and `checks` are not allowed here.",UnexpectedSpreadType:"Spread operator cannot appear in class or interface definitions.",UnexpectedSubtractionOperand:'Unexpected token, expected "number" or "bigint".',UnexpectedTokenAfterTypeParameter:"Expected an arrow function after this type parameter declaration.",UnexpectedTypeParameterBeforeAsyncArrowFunction:"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",UnsupportedDeclareExportKind:"`declare export %0` is not supported. Use `%1` instead.",UnsupportedStatementInDeclareModule:"Only declares and type imports are allowed inside declare module.",UnterminatedFlowComment:"Unterminated flow-comment."},E.SyntaxError);function Y(e){return "type"===e.importKind||"typeof"===e.importKind}function X(e){return (e.type===c.name||!!e.type.keyword)&&"from"!==e.value}const z={const:"declare export var",let:"declare export var",type:"export type",interface:"export interface"},Q=/\*?\s*@((?:no)?flow)\b/,Z={quot:'"',amp:"&",apos:"'",lt:"<",gt:">",nbsp:" ",iexcl:"¡",cent:"¢",pound:"£",curren:"¤",yen:"¥",brvbar:"¦",sect:"§",uml:"¨",copy:"©",ordf:"ª",laquo:"«",not:"¬",shy:"­",reg:"®",macr:"¯",deg:"°",plusmn:"±",sup2:"²",sup3:"³",acute:"´",micro:"µ",para:"¶",middot:"·",cedil:"¸",sup1:"¹",ordm:"º",raquo:"»",frac14:"¼",frac12:"½",frac34:"¾",iquest:"¿",Agrave:"À",Aacute:"Á",Acirc:"Â",Atilde:"Ã",Auml:"Ä",Aring:"Å",AElig:"Æ",Ccedil:"Ç",Egrave:"È",Eacute:"É",Ecirc:"Ê",Euml:"Ë",Igrave:"Ì",Iacute:"Í",Icirc:"Î",Iuml:"Ï",ETH:"Ð",Ntilde:"Ñ",Ograve:"Ò",Oacute:"Ó",Ocirc:"Ô",Otilde:"Õ",Ouml:"Ö",times:"×",Oslash:"Ø",Ugrave:"Ù",Uacute:"Ú",Ucirc:"Û",Uuml:"Ü",Yacute:"Ý",THORN:"Þ",szlig:"ß",agrave:"à",aacute:"á",acirc:"â",atilde:"ã",auml:"ä",aring:"å",aelig:"æ",ccedil:"ç",egrave:"è",eacute:"é",ecirc:"ê",euml:"ë",igrave:"ì",iacute:"í",icirc:"î",iuml:"ï",eth:"ð",ntilde:"ñ",ograve:"ò",oacute:"ó",ocirc:"ô",otilde:"õ",ouml:"ö",divide:"÷",oslash:"ø",ugrave:"ù",uacute:"ú",ucirc:"û",uuml:"ü",yacute:"ý",thorn:"þ",yuml:"ÿ",OElig:"Œ",oelig:"œ",Scaron:"Š",scaron:"š",Yuml:"Ÿ",fnof:"ƒ",circ:"ˆ",tilde:"˜",Alpha:"Α",Beta:"Β",Gamma:"Γ",Delta:"Δ",Epsilon:"Ε",Zeta:"Ζ",Eta:"Η",Theta:"Θ",Iota:"Ι",Kappa:"Κ",Lambda:"Λ",Mu:"Μ",Nu:"Ν",Xi:"Ξ",Omicron:"Ο",Pi:"Π",Rho:"Ρ",Sigma:"Σ",Tau:"Τ",Upsilon:"Υ",Phi:"Φ",Chi:"Χ",Psi:"Ψ",Omega:"Ω",alpha:"α",beta:"β",gamma:"γ",delta:"δ",epsilon:"ε",zeta:"ζ",eta:"η",theta:"θ",iota:"ι",kappa:"κ",lambda:"λ",mu:"μ",nu:"ν",xi:"ξ",omicron:"ο",pi:"π",rho:"ρ",sigmaf:"ς",sigma:"σ",tau:"τ",upsilon:"υ",phi:"φ",chi:"χ",psi:"ψ",omega:"ω",thetasym:"ϑ",upsih:"ϒ",piv:"ϖ",ensp:" ",emsp:" ",thinsp:" ",zwnj:"‌",zwj:"‍",lrm:"‎",rlm:"‏",ndash:"–",mdash:"—",lsquo:"‘",rsquo:"’",sbquo:"‚",ldquo:"“",rdquo:"”",bdquo:"„",dagger:"†",Dagger:"‡",bull:"•",hellip:"…",permil:"‰",prime:"′",Prime:"″",lsaquo:"‹",rsaquo:"›",oline:"‾",frasl:"⁄",euro:"€",image:"ℑ",weierp:"℘",real:"ℜ",trade:"™",alefsym:"ℵ",larr:"←",uarr:"↑",rarr:"→",darr:"↓",harr:"↔",crarr:"↵",lArr:"⇐",uArr:"⇑",rArr:"⇒",dArr:"⇓",hArr:"⇔",forall:"∀",part:"∂",exist:"∃",empty:"∅",nabla:"∇",isin:"∈",notin:"∉",ni:"∋",prod:"∏",sum:"∑",minus:"−",lowast:"∗",radic:"√",prop:"∝",infin:"∞",ang:"∠",and:"∧",or:"∨",cap:"∩",cup:"∪",int:"∫",there4:"∴",sim:"∼",cong:"≅",asymp:"≈",ne:"≠",equiv:"≡",le:"≤",ge:"≥",sub:"⊂",sup:"⊃",nsub:"⊄",sube:"⊆",supe:"⊇",oplus:"⊕",otimes:"⊗",perp:"⊥",sdot:"⋅",lceil:"⌈",rceil:"⌉",lfloor:"⌊",rfloor:"⌋",lang:"〈",rang:"〉",loz:"◊",spades:"♠",clubs:"♣",hearts:"♥",diams:"♦"},ee=/^[\da-fA-F]+$/,te=/^\d+$/,re=T({AttributeIsEmpty:"JSX attributes must only be assigned a non-empty expression.",MissingClosingTagElement:"Expected corresponding JSX closing tag for <%0>.",MissingClosingTagFragment:"Expected corresponding JSX closing tag for <>.",UnexpectedSequenceExpression:"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",UnsupportedJsxValue:"JSX value should be either an expression or a quoted JSX text.",UnterminatedJsxContent:"Unterminated JSX contents.",UnwrappedAdjacentJSXElements:"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"},E.SyntaxError);function ne(e){return !!e&&("JSXOpeningFragment"===e.type||"JSXClosingFragment"===e.type)}function se(e){if("JSXIdentifier"===e.type)return e.name;if("JSXNamespacedName"===e.type)return e.namespace.name+":"+e.name.name;if("JSXMemberExpression"===e.type)return se(e.object)+"."+se(e.property);throw new Error("Node had unexpected type: "+e.type)}P.j_oTag=new S("<tag",!1),P.j_cTag=new S("</tag",!1),P.j_expr=new S("<tag>...</tag>",!0,!0),c.jsxName=new o("jsxName"),c.jsxText=new o("jsxText",{beforeExpr:!0}),c.jsxTagStart=new o("jsxTagStart",{startsExpr:!0}),c.jsxTagEnd=new o("jsxTagEnd"),c.jsxTagStart.updateContext=function(){this.state.context.push(P.j_expr),this.state.context.push(P.j_oTag),this.state.exprAllowed=!1;},c.jsxTagEnd.updateContext=function(e){const t=this.state.context.pop();t===P.j_oTag&&e===c.slash||t===P.j_cTag?(this.state.context.pop(),this.state.exprAllowed=this.curContext()===P.j_expr):this.state.exprAllowed=!0;};class ie extends ${constructor(...e){super(...e),this.types=[],this.enums=[],this.constEnums=[],this.classes=[],this.exportOnlyBindings=[];}}class oe extends K{createScope(e){return new ie(e)}declareName(e,t,r){const n=this.currentScope();if(1024&t)return this.maybeExportDefined(n,e),void n.exportOnlyBindings.push(e);super.declareName(...arguments),2&t&&(1&t||(this.checkRedeclarationInScope(n,e,t,r),this.maybeExportDefined(n,e)),n.types.push(e)),256&t&&n.enums.push(e),512&t&&n.constEnums.push(e),128&t&&n.classes.push(e);}isRedeclaredInScope(e,t,r){return e.enums.indexOf(t)>-1?!(256&r)||!!(512&r)!=e.constEnums.indexOf(t)>-1:128&r&&e.classes.indexOf(t)>-1?e.lexical.indexOf(t)>-1&&!!(1&r):!!(2&r&&e.types.indexOf(t)>-1)||super.isRedeclaredInScope(...arguments)}checkLocalExport(e){-1===this.scopeStack[0].types.indexOf(e.name)&&-1===this.scopeStack[0].exportOnlyBindings.indexOf(e.name)&&super.checkLocalExport(e);}}class ae{constructor(){this.stacks=[];}enter(e){this.stacks.push(e);}exit(){this.stacks.pop();}currentFlags(){return this.stacks[this.stacks.length-1]}get hasAwait(){return (2&this.currentFlags())>0}get hasYield(){return (1&this.currentFlags())>0}get hasReturn(){return (4&this.currentFlags())>0}get hasIn(){return (8&this.currentFlags())>0}}function le(e,t){return (e?2:0)|(t?1:0)}function ue(e){if(null==e)throw new Error(`Unexpected ${e} value.`);return e}function ce(e){if(!e)throw new Error("Assert fail")}const pe=T({AbstractMethodHasImplementation:"Method '%0' cannot have an implementation because it is marked abstract.",AccesorCannotDeclareThisParameter:"'get' and 'set' accessors cannot declare 'this' parameters.",AccesorCannotHaveTypeParameters:"An accessor cannot have type parameters.",ClassMethodHasDeclare:"Class methods cannot have the 'declare' modifier.",ClassMethodHasReadonly:"Class methods cannot have the 'readonly' modifier.",ConstructorHasTypeParameters:"Type parameters cannot appear on a constructor declaration.",DeclareAccessor:"'declare' is not allowed in %0ters.",DeclareClassFieldHasInitializer:"Initializers are not allowed in ambient contexts.",DeclareFunctionHasImplementation:"An implementation cannot be declared in ambient contexts.",DuplicateAccessibilityModifier:"Accessibility modifier already seen.",DuplicateModifier:"Duplicate modifier: '%0'.",EmptyHeritageClauseType:"'%0' list cannot be empty.",EmptyTypeArguments:"Type argument list cannot be empty.",EmptyTypeParameters:"Type parameter list cannot be empty.",ExpectedAmbientAfterExportDeclare:"'export declare' must be followed by an ambient declaration.",ImportAliasHasImportType:"An import alias can not use 'import type'.",IncompatibleModifiers:"'%0' modifier cannot be used with '%1' modifier.",IndexSignatureHasAbstract:"Index signatures cannot have the 'abstract' modifier.",IndexSignatureHasAccessibility:"Index signatures cannot have an accessibility modifier ('%0').",IndexSignatureHasDeclare:"Index signatures cannot have the 'declare' modifier.",IndexSignatureHasOverride:"'override' modifier cannot appear on an index signature.",IndexSignatureHasStatic:"Index signatures cannot have the 'static' modifier.",InvalidModifierOnTypeMember:"'%0' modifier cannot appear on a type member.",InvalidModifiersOrder:"'%0' modifier must precede '%1' modifier.",InvalidTupleMemberLabel:"Tuple members must be labeled with a simple identifier.",MixedLabeledAndUnlabeledElements:"Tuple members must all have names or all not have names.",NonAbstractClassHasAbstractMethod:"Abstract methods can only appear within an abstract class.",NonClassMethodPropertyHasAbstractModifer:"'abstract' modifier can only appear on a class, method, or property declaration.",OptionalTypeBeforeRequired:"A required element cannot follow an optional element.",OverrideNotInSubClass:"This member cannot have an 'override' modifier because its containing class does not extend another class.",PatternIsOptional:"A binding pattern parameter cannot be optional in an implementation signature.",PrivateElementHasAbstract:"Private elements cannot have the 'abstract' modifier.",PrivateElementHasAccessibility:"Private elements cannot have an accessibility modifier ('%0').",ReadonlyForMethodSignature:"'readonly' modifier can only appear on a property declaration or index signature.",SetAccesorCannotHaveOptionalParameter:"A 'set' accessor cannot have an optional parameter.",SetAccesorCannotHaveRestParameter:"A 'set' accessor cannot have rest parameter.",SetAccesorCannotHaveReturnType:"A 'set' accessor cannot have a return type annotation.",StaticBlockCannotHaveModifier:"Static class blocks cannot have any modifier.",TypeAnnotationAfterAssign:"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",TypeImportCannotSpecifyDefaultAndNamed:"A type-only import can specify a default import or named bindings, but not both.",UnexpectedParameterModifier:"A parameter property is only allowed in a constructor implementation.",UnexpectedReadonly:"'readonly' type modifier is only permitted on array and tuple literal types.",UnexpectedTypeAnnotation:"Did not expect a type annotation here.",UnexpectedTypeCastInParameter:"Unexpected type cast in parameter position.",UnsupportedImportTypeArgument:"Argument in a type import must be a string literal.",UnsupportedParameterPropertyKind:"A parameter property may not be declared using a binding pattern.",UnsupportedSignatureParameterKind:"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."},E.SyntaxError);function de(e){return "private"===e||"public"===e||"protected"===e}c.placeholder=new o("%%",{startsExpr:!0});const fe=T({ClassNameIsRequired:"A class name is required."},E.SyntaxError);function he(e,t){return e.some((e=>Array.isArray(e)?e[0]===t:e===t))}function me(e,t,r){const n=e.find((e=>Array.isArray(e)?e[0]===t:e===t));return n&&Array.isArray(n)?n[1][r]:null}const ye=["minimal","smart","fsharp"],be=["hash","bar"],ge={estree:e=>class extends e{estreeParseRegExpLiteral({pattern:e,flags:t}){let r=null;try{r=new RegExp(e,t);}catch(e){}const n=this.estreeParseLiteral(r);return n.regex={pattern:e,flags:t},n}estreeParseBigIntLiteral(e){let t;try{t=BigInt(e);}catch(e){t=null;}const r=this.estreeParseLiteral(t);return r.bigint=String(r.value||e),r}estreeParseDecimalLiteral(e){const t=this.estreeParseLiteral(null);return t.decimal=String(t.value||e),t}estreeParseLiteral(e){return this.parseLiteral(e,"Literal")}directiveToStmt(e){const t=e.value,r=this.startNodeAt(e.start,e.loc.start),n=this.startNodeAt(t.start,t.loc.start);return n.value=t.extra.expressionValue,n.raw=t.extra.raw,r.expression=this.finishNodeAt(n,"Literal",t.end,t.loc.end),r.directive=t.extra.raw.slice(1,-1),this.finishNodeAt(r,"ExpressionStatement",e.end,e.loc.end)}initFunction(e,t){super.initFunction(e,t),e.expression=!1;}checkDeclaration(e){null!=e&&this.isObjectProperty(e)?this.checkDeclaration(e.value):super.checkDeclaration(e);}getObjectOrClassMethodParams(e){return e.value.params}isValidDirective(e){var t;return "ExpressionStatement"===e.type&&"Literal"===e.expression.type&&"string"==typeof e.expression.value&&!(null!=(t=e.expression.extra)&&t.parenthesized)}stmtToDirective(e){const t=super.stmtToDirective(e),r=e.expression.value;return this.addExtra(t.value,"expressionValue",r),t}parseBlockBody(e,...t){super.parseBlockBody(e,...t);const r=e.directives.map((e=>this.directiveToStmt(e)));e.body=r.concat(e.body),delete e.directives;}pushClassMethod(e,t,r,n,s,i){this.parseMethod(t,r,n,s,i,"ClassMethod",!0),t.typeParameters&&(t.value.typeParameters=t.typeParameters,delete t.typeParameters),e.body.push(t);}parseExprAtom(e){switch(this.state.type){case c.num:case c.string:return this.estreeParseLiteral(this.state.value);case c.regexp:return this.estreeParseRegExpLiteral(this.state.value);case c.bigint:return this.estreeParseBigIntLiteral(this.state.value);case c.decimal:return this.estreeParseDecimalLiteral(this.state.value);case c._null:return this.estreeParseLiteral(null);case c._true:return this.estreeParseLiteral(!0);case c._false:return this.estreeParseLiteral(!1);default:return super.parseExprAtom(e)}}parseMaybePrivateName(...e){const t=super.parseMaybePrivateName(...e);return "PrivateName"===t.type&&this.getPluginOption("estree","classFeatures")?this.convertPrivateNameToPrivateIdentifier(t):t}convertPrivateNameToPrivateIdentifier(e){const t=super.getPrivateNameSV(e);return delete(e=e).id,e.name=t,e.type="PrivateIdentifier",e}isPrivateName(e){return this.getPluginOption("estree","classFeatures")?"PrivateIdentifier"===e.type:super.isPrivateName(e)}getPrivateNameSV(e){return this.getPluginOption("estree","classFeatures")?e.name:super.getPrivateNameSV(e)}parseLiteral(e,t,r,n){const s=super.parseLiteral(e,t,r,n);return s.raw=s.extra.raw,delete s.extra,s}parseFunctionBody(e,t,r=!1){super.parseFunctionBody(e,t,r),e.expression="BlockStatement"!==e.body.type;}parseMethod(e,t,r,n,s,i,o=!1){let a=this.startNode();return a.kind=e.kind,a=super.parseMethod(a,t,r,n,s,i,o),a.type="FunctionExpression",delete a.kind,e.value=a,"ClassPrivateMethod"===i&&(e.computed=!1),i="MethodDefinition",this.finishNode(e,i)}parseClassProperty(...e){const t=super.parseClassProperty(...e);return this.getPluginOption("estree","classFeatures")&&(t.type="PropertyDefinition"),t}parseClassPrivateProperty(...e){const t=super.parseClassPrivateProperty(...e);return this.getPluginOption("estree","classFeatures")&&(t.type="PropertyDefinition",t.computed=!1),t}parseObjectMethod(e,t,r,n,s){const i=super.parseObjectMethod(e,t,r,n,s);return i&&(i.type="Property","method"===i.kind&&(i.kind="init"),i.shorthand=!1),i}parseObjectProperty(e,t,r,n,s){const i=super.parseObjectProperty(e,t,r,n,s);return i&&(i.kind="init",i.type="Property"),i}toAssignable(e,t=!1){return null!=e&&this.isObjectProperty(e)?(this.toAssignable(e.value,t),e):super.toAssignable(e,t)}toAssignableObjectExpressionProp(e,...t){"get"===e.kind||"set"===e.kind?this.raise(e.key.start,v.PatternHasAccessor):e.method?this.raise(e.key.start,v.PatternHasMethod):super.toAssignableObjectExpressionProp(e,...t);}finishCallExpression(e,t){var r;(super.finishCallExpression(e,t),"Import"===e.callee.type)&&(e.type="ImportExpression",e.source=e.arguments[0],this.hasPlugin("importAssertions")&&(e.attributes=null!=(r=e.arguments[1])?r:null),delete e.arguments,delete e.callee);return e}toReferencedArguments(e){"ImportExpression"!==e.type&&super.toReferencedArguments(e);}parseExport(e){switch(super.parseExport(e),e.type){case"ExportAllDeclaration":e.exported=null;break;case"ExportNamedDeclaration":1===e.specifiers.length&&"ExportNamespaceSpecifier"===e.specifiers[0].type&&(e.type="ExportAllDeclaration",e.exported=e.specifiers[0].exported,delete e.specifiers);}return e}parseSubscript(e,t,r,n,s){const i=super.parseSubscript(e,t,r,n,s);if(s.optionalChainMember){if("OptionalMemberExpression"!==i.type&&"OptionalCallExpression"!==i.type||(i.type=i.type.substring(8)),s.stop){const e=this.startNodeAtNode(i);return e.expression=i,this.finishNode(e,"ChainExpression")}}else "MemberExpression"!==i.type&&"CallExpression"!==i.type||(i.optional=!1);return i}hasPropertyAsPrivateName(e){return "ChainExpression"===e.type&&(e=e.expression),super.hasPropertyAsPrivateName(e)}isOptionalChain(e){return "ChainExpression"===e.type}isObjectProperty(e){return "Property"===e.type&&"init"===e.kind&&!e.method}isObjectMethod(e){return e.method||"get"===e.kind||"set"===e.kind}},jsx:e=>class extends e{jsxReadToken(){let e="",t=this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,re.UnterminatedJsxContent);const r=this.input.charCodeAt(this.state.pos);switch(r){case 60:case 123:return this.state.pos===this.state.start?60===r&&this.state.exprAllowed?(++this.state.pos,this.finishToken(c.jsxTagStart)):super.getTokenFromCode(r):(e+=this.input.slice(t,this.state.pos),this.finishToken(c.jsxText,e));case 38:e+=this.input.slice(t,this.state.pos),e+=this.jsxReadEntity(),t=this.state.pos;break;case 62:case 125:default:f(r)?(e+=this.input.slice(t,this.state.pos),e+=this.jsxReadNewLine(!0),t=this.state.pos):++this.state.pos;}}}jsxReadNewLine(e){const t=this.input.charCodeAt(this.state.pos);let r;return ++this.state.pos,13===t&&10===this.input.charCodeAt(this.state.pos)?(++this.state.pos,r=e?"\n":"\r\n"):r=String.fromCharCode(t),++this.state.curLine,this.state.lineStart=this.state.pos,r}jsxReadString(e){let t="",r=++this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,v.UnterminatedString);const n=this.input.charCodeAt(this.state.pos);if(n===e)break;38===n?(t+=this.input.slice(r,this.state.pos),t+=this.jsxReadEntity(),r=this.state.pos):f(n)?(t+=this.input.slice(r,this.state.pos),t+=this.jsxReadNewLine(!1),r=this.state.pos):++this.state.pos;}return t+=this.input.slice(r,this.state.pos++),this.finishToken(c.string,t)}jsxReadEntity(){let e,t="",r=0,n=this.input[this.state.pos];const s=++this.state.pos;for(;this.state.pos<this.length&&r++<10;){if(n=this.input[this.state.pos++],";"===n){"#"===t[0]?"x"===t[1]?(t=t.substr(2),ee.test(t)&&(e=String.fromCodePoint(parseInt(t,16)))):(t=t.substr(1),te.test(t)&&(e=String.fromCodePoint(parseInt(t,10)))):e=Z[t];break}t+=n;}return e||(this.state.pos=s,"&")}jsxReadWord(){let e;const t=this.state.pos;do{e=this.input.charCodeAt(++this.state.pos);}while(N(e)||45===e);return this.finishToken(c.jsxName,this.input.slice(t,this.state.pos))}jsxParseIdentifier(){const e=this.startNode();return this.match(c.jsxName)?e.name=this.state.value:this.state.type.keyword?e.name=this.state.type.keyword:this.unexpected(),this.next(),this.finishNode(e,"JSXIdentifier")}jsxParseNamespacedName(){const e=this.state.start,t=this.state.startLoc,r=this.jsxParseIdentifier();if(!this.eat(c.colon))return r;const n=this.startNodeAt(e,t);return n.namespace=r,n.name=this.jsxParseIdentifier(),this.finishNode(n,"JSXNamespacedName")}jsxParseElementName(){const e=this.state.start,t=this.state.startLoc;let r=this.jsxParseNamespacedName();if("JSXNamespacedName"===r.type)return r;for(;this.eat(c.dot);){const n=this.startNodeAt(e,t);n.object=r,n.property=this.jsxParseIdentifier(),r=this.finishNode(n,"JSXMemberExpression");}return r}jsxParseAttributeValue(){let e;switch(this.state.type){case c.braceL:return e=this.startNode(),this.next(),e=this.jsxParseExpressionContainer(e),"JSXEmptyExpression"===e.expression.type&&this.raise(e.start,re.AttributeIsEmpty),e;case c.jsxTagStart:case c.string:return this.parseExprAtom();default:throw this.raise(this.state.start,re.UnsupportedJsxValue)}}jsxParseEmptyExpression(){const e=this.startNodeAt(this.state.lastTokEnd,this.state.lastTokEndLoc);return this.finishNodeAt(e,"JSXEmptyExpression",this.state.start,this.state.startLoc)}jsxParseSpreadChild(e){return this.next(),e.expression=this.parseExpression(),this.expect(c.braceR),this.finishNode(e,"JSXSpreadChild")}jsxParseExpressionContainer(e){if(this.match(c.braceR))e.expression=this.jsxParseEmptyExpression();else {const t=this.parseExpression();e.expression=t;}return this.expect(c.braceR),this.finishNode(e,"JSXExpressionContainer")}jsxParseAttribute(){const e=this.startNode();return this.eat(c.braceL)?(this.expect(c.ellipsis),e.argument=this.parseMaybeAssignAllowIn(),this.expect(c.braceR),this.finishNode(e,"JSXSpreadAttribute")):(e.name=this.jsxParseNamespacedName(),e.value=this.eat(c.eq)?this.jsxParseAttributeValue():null,this.finishNode(e,"JSXAttribute"))}jsxParseOpeningElementAt(e,t){const r=this.startNodeAt(e,t);return this.match(c.jsxTagEnd)?(this.expect(c.jsxTagEnd),this.finishNode(r,"JSXOpeningFragment")):(r.name=this.jsxParseElementName(),this.jsxParseOpeningElementAfterName(r))}jsxParseOpeningElementAfterName(e){const t=[];for(;!this.match(c.slash)&&!this.match(c.jsxTagEnd);)t.push(this.jsxParseAttribute());return e.attributes=t,e.selfClosing=this.eat(c.slash),this.expect(c.jsxTagEnd),this.finishNode(e,"JSXOpeningElement")}jsxParseClosingElementAt(e,t){const r=this.startNodeAt(e,t);return this.match(c.jsxTagEnd)?(this.expect(c.jsxTagEnd),this.finishNode(r,"JSXClosingFragment")):(r.name=this.jsxParseElementName(),this.expect(c.jsxTagEnd),this.finishNode(r,"JSXClosingElement"))}jsxParseElementAt(e,t){const r=this.startNodeAt(e,t),n=[],s=this.jsxParseOpeningElementAt(e,t);let i=null;if(!s.selfClosing){e:for(;;)switch(this.state.type){case c.jsxTagStart:if(e=this.state.start,t=this.state.startLoc,this.next(),this.eat(c.slash)){i=this.jsxParseClosingElementAt(e,t);break e}n.push(this.jsxParseElementAt(e,t));break;case c.jsxText:n.push(this.parseExprAtom());break;case c.braceL:{const e=this.startNode();this.next(),this.match(c.ellipsis)?n.push(this.jsxParseSpreadChild(e)):n.push(this.jsxParseExpressionContainer(e));break}default:throw this.unexpected()}ne(s)&&!ne(i)?this.raise(i.start,re.MissingClosingTagFragment):!ne(s)&&ne(i)?this.raise(i.start,re.MissingClosingTagElement,se(s.name)):ne(s)||ne(i)||se(i.name)!==se(s.name)&&this.raise(i.start,re.MissingClosingTagElement,se(s.name));}if(ne(s)?(r.openingFragment=s,r.closingFragment=i):(r.openingElement=s,r.closingElement=i),r.children=n,this.isRelational("<"))throw this.raise(this.state.start,re.UnwrappedAdjacentJSXElements);return ne(s)?this.finishNode(r,"JSXFragment"):this.finishNode(r,"JSXElement")}jsxParseElement(){const e=this.state.start,t=this.state.startLoc;return this.next(),this.jsxParseElementAt(e,t)}parseExprAtom(e){return this.match(c.jsxText)?this.parseLiteral(this.state.value,"JSXText"):this.match(c.jsxTagStart)?this.jsxParseElement():this.isRelational("<")&&33!==this.input.charCodeAt(this.state.pos)?(this.finishToken(c.jsxTagStart),this.jsxParseElement()):super.parseExprAtom(e)}getTokenFromCode(e){if(this.state.inPropertyName)return super.getTokenFromCode(e);const t=this.curContext();if(t===P.j_expr)return this.jsxReadToken();if(t===P.j_oTag||t===P.j_cTag){if(I(e))return this.jsxReadWord();if(62===e)return ++this.state.pos,this.finishToken(c.jsxTagEnd);if((34===e||39===e)&&t===P.j_oTag)return this.jsxReadString(e)}return 60===e&&this.state.exprAllowed&&33!==this.input.charCodeAt(this.state.pos+1)?(++this.state.pos,this.finishToken(c.jsxTagStart)):super.getTokenFromCode(e)}updateContext(e){if(this.match(c.braceL)){const t=this.curContext();t===P.j_oTag?this.state.context.push(P.braceExpression):t===P.j_expr?this.state.context.push(P.templateQuasi):super.updateContext(e),this.state.exprAllowed=!0;}else {if(!this.match(c.slash)||e!==c.jsxTagStart)return super.updateContext(e);this.state.context.length-=2,this.state.context.push(P.j_cTag),this.state.exprAllowed=!1;}}},flow:e=>class extends e{constructor(...e){super(...e),this.flowPragma=void 0;}getScopeHandler(){return G}shouldParseTypes(){return this.getPluginOption("flow","all")||"flow"===this.flowPragma}shouldParseEnums(){return !!this.getPluginOption("flow","enums")}finishToken(e,t){return e!==c.string&&e!==c.semi&&e!==c.interpreterDirective&&void 0===this.flowPragma&&(this.flowPragma=null),super.finishToken(e,t)}addComment(e){if(void 0===this.flowPragma){const t=Q.exec(e.value);if(t)if("flow"===t[1])this.flowPragma="flow";else {if("noflow"!==t[1])throw new Error("Unexpected flow pragma");this.flowPragma="noflow";}}return super.addComment(e)}flowParseTypeInitialiser(e){const t=this.state.inType;this.state.inType=!0,this.expect(e||c.colon);const r=this.flowParseType();return this.state.inType=t,r}flowParsePredicate(){const e=this.startNode(),t=this.state.start;return this.next(),this.expectContextual("checks"),this.state.lastTokStart>t+1&&this.raise(t,J.UnexpectedSpaceBetweenModuloChecks),this.eat(c.parenL)?(e.value=this.parseExpression(),this.expect(c.parenR),this.finishNode(e,"DeclaredPredicate")):this.finishNode(e,"InferredPredicate")}flowParseTypeAndPredicateInitialiser(){const e=this.state.inType;this.state.inType=!0,this.expect(c.colon);let t=null,r=null;return this.match(c.modulo)?(this.state.inType=e,r=this.flowParsePredicate()):(t=this.flowParseType(),this.state.inType=e,this.match(c.modulo)&&(r=this.flowParsePredicate())),[t,r]}flowParseDeclareClass(e){return this.next(),this.flowParseInterfaceish(e,!0),this.finishNode(e,"DeclareClass")}flowParseDeclareFunction(e){this.next();const t=e.id=this.parseIdentifier(),r=this.startNode(),n=this.startNode();this.isRelational("<")?r.typeParameters=this.flowParseTypeParameterDeclaration():r.typeParameters=null,this.expect(c.parenL);const s=this.flowParseFunctionTypeParams();return r.params=s.params,r.rest=s.rest,r.this=s._this,this.expect(c.parenR),[r.returnType,e.predicate]=this.flowParseTypeAndPredicateInitialiser(),n.typeAnnotation=this.finishNode(r,"FunctionTypeAnnotation"),t.typeAnnotation=this.finishNode(n,"TypeAnnotation"),this.resetEndLocation(t),this.semicolon(),this.scope.declareName(e.id.name,2048,e.id.start),this.finishNode(e,"DeclareFunction")}flowParseDeclare(e,t){if(this.match(c._class))return this.flowParseDeclareClass(e);if(this.match(c._function))return this.flowParseDeclareFunction(e);if(this.match(c._var))return this.flowParseDeclareVariable(e);if(this.eatContextual("module"))return this.match(c.dot)?this.flowParseDeclareModuleExports(e):(t&&this.raise(this.state.lastTokStart,J.NestedDeclareModule),this.flowParseDeclareModule(e));if(this.isContextual("type"))return this.flowParseDeclareTypeAlias(e);if(this.isContextual("opaque"))return this.flowParseDeclareOpaqueType(e);if(this.isContextual("interface"))return this.flowParseDeclareInterface(e);if(this.match(c._export))return this.flowParseDeclareExportDeclaration(e,t);throw this.unexpected()}flowParseDeclareVariable(e){return this.next(),e.id=this.flowParseTypeAnnotatableIdentifier(!0),this.scope.declareName(e.id.name,5,e.id.start),this.semicolon(),this.finishNode(e,"DeclareVariable")}flowParseDeclareModule(e){this.scope.enter(0),this.match(c.string)?e.id=this.parseExprAtom():e.id=this.parseIdentifier();const t=e.body=this.startNode(),r=t.body=[];for(this.expect(c.braceL);!this.match(c.braceR);){let e=this.startNode();this.match(c._import)?(this.next(),this.isContextual("type")||this.match(c._typeof)||this.raise(this.state.lastTokStart,J.InvalidNonTypeImportInDeclareModule),this.parseImport(e)):(this.expectContextual("declare",J.UnsupportedStatementInDeclareModule),e=this.flowParseDeclare(e,!0)),r.push(e);}this.scope.exit(),this.expect(c.braceR),this.finishNode(t,"BlockStatement");let n=null,s=!1;return r.forEach((e=>{!function(e){return "DeclareExportAllDeclaration"===e.type||"DeclareExportDeclaration"===e.type&&(!e.declaration||"TypeAlias"!==e.declaration.type&&"InterfaceDeclaration"!==e.declaration.type)}(e)?"DeclareModuleExports"===e.type&&(s&&this.raise(e.start,J.DuplicateDeclareModuleExports),"ES"===n&&this.raise(e.start,J.AmbiguousDeclareModuleKind),n="CommonJS",s=!0):("CommonJS"===n&&this.raise(e.start,J.AmbiguousDeclareModuleKind),n="ES");})),e.kind=n||"CommonJS",this.finishNode(e,"DeclareModule")}flowParseDeclareExportDeclaration(e,t){if(this.expect(c._export),this.eat(c._default))return this.match(c._function)||this.match(c._class)?e.declaration=this.flowParseDeclare(this.startNode()):(e.declaration=this.flowParseType(),this.semicolon()),e.default=!0,this.finishNode(e,"DeclareExportDeclaration");if(this.match(c._const)||this.isLet()||(this.isContextual("type")||this.isContextual("interface"))&&!t){const e=this.state.value,t=z[e];throw this.raise(this.state.start,J.UnsupportedDeclareExportKind,e,t)}if(this.match(c._var)||this.match(c._function)||this.match(c._class)||this.isContextual("opaque"))return e.declaration=this.flowParseDeclare(this.startNode()),e.default=!1,this.finishNode(e,"DeclareExportDeclaration");if(this.match(c.star)||this.match(c.braceL)||this.isContextual("interface")||this.isContextual("type")||this.isContextual("opaque"))return "ExportNamedDeclaration"===(e=this.parseExport(e)).type&&(e.type="ExportDeclaration",e.default=!1,delete e.exportKind),e.type="Declare"+e.type,e;throw this.unexpected()}flowParseDeclareModuleExports(e){return this.next(),this.expectContextual("exports"),e.typeAnnotation=this.flowParseTypeAnnotation(),this.semicolon(),this.finishNode(e,"DeclareModuleExports")}flowParseDeclareTypeAlias(e){return this.next(),this.flowParseTypeAlias(e),e.type="DeclareTypeAlias",e}flowParseDeclareOpaqueType(e){return this.next(),this.flowParseOpaqueType(e,!0),e.type="DeclareOpaqueType",e}flowParseDeclareInterface(e){return this.next(),this.flowParseInterfaceish(e),this.finishNode(e,"DeclareInterface")}flowParseInterfaceish(e,t=!1){if(e.id=this.flowParseRestrictedIdentifier(!t,!0),this.scope.declareName(e.id.name,t?17:9,e.id.start),this.isRelational("<")?e.typeParameters=this.flowParseTypeParameterDeclaration():e.typeParameters=null,e.extends=[],e.implements=[],e.mixins=[],this.eat(c._extends))do{e.extends.push(this.flowParseInterfaceExtends());}while(!t&&this.eat(c.comma));if(this.isContextual("mixins")){this.next();do{e.mixins.push(this.flowParseInterfaceExtends());}while(this.eat(c.comma))}if(this.isContextual("implements")){this.next();do{e.implements.push(this.flowParseInterfaceExtends());}while(this.eat(c.comma))}e.body=this.flowParseObjectType({allowStatic:t,allowExact:!1,allowSpread:!1,allowProto:t,allowInexact:!1});}flowParseInterfaceExtends(){const e=this.startNode();return e.id=this.flowParseQualifiedTypeIdentifier(),this.isRelational("<")?e.typeParameters=this.flowParseTypeParameterInstantiation():e.typeParameters=null,this.finishNode(e,"InterfaceExtends")}flowParseInterface(e){return this.flowParseInterfaceish(e),this.finishNode(e,"InterfaceDeclaration")}checkNotUnderscore(e){"_"===e&&this.raise(this.state.start,J.UnexpectedReservedUnderscore);}checkReservedType(e,t,r){H.has(e)&&this.raise(t,r?J.AssignReservedType:J.UnexpectedReservedType,e);}flowParseRestrictedIdentifier(e,t){return this.checkReservedType(this.state.value,this.state.start,t),this.parseIdentifier(e)}flowParseTypeAlias(e){return e.id=this.flowParseRestrictedIdentifier(!1,!0),this.scope.declareName(e.id.name,9,e.id.start),this.isRelational("<")?e.typeParameters=this.flowParseTypeParameterDeclaration():e.typeParameters=null,e.right=this.flowParseTypeInitialiser(c.eq),this.semicolon(),this.finishNode(e,"TypeAlias")}flowParseOpaqueType(e,t){return this.expectContextual("type"),e.id=this.flowParseRestrictedIdentifier(!0,!0),this.scope.declareName(e.id.name,9,e.id.start),this.isRelational("<")?e.typeParameters=this.flowParseTypeParameterDeclaration():e.typeParameters=null,e.supertype=null,this.match(c.colon)&&(e.supertype=this.flowParseTypeInitialiser(c.colon)),e.impltype=null,t||(e.impltype=this.flowParseTypeInitialiser(c.eq)),this.semicolon(),this.finishNode(e,"OpaqueType")}flowParseTypeParameter(e=!1){const t=this.state.start,r=this.startNode(),n=this.flowParseVariance(),s=this.flowParseTypeAnnotatableIdentifier();return r.name=s.name,r.variance=n,r.bound=s.typeAnnotation,this.match(c.eq)?(this.eat(c.eq),r.default=this.flowParseType()):e&&this.raise(t,J.MissingTypeParamDefault),this.finishNode(r,"TypeParameter")}flowParseTypeParameterDeclaration(){const e=this.state.inType,t=this.startNode();t.params=[],this.state.inType=!0,this.isRelational("<")||this.match(c.jsxTagStart)?this.next():this.unexpected();let r=!1;do{const e=this.flowParseTypeParameter(r);t.params.push(e),e.default&&(r=!0),this.isRelational(">")||this.expect(c.comma);}while(!this.isRelational(">"));return this.expectRelational(">"),this.state.inType=e,this.finishNode(t,"TypeParameterDeclaration")}flowParseTypeParameterInstantiation(){const e=this.startNode(),t=this.state.inType;e.params=[],this.state.inType=!0,this.expectRelational("<");const r=this.state.noAnonFunctionType;for(this.state.noAnonFunctionType=!1;!this.isRelational(">");)e.params.push(this.flowParseType()),this.isRelational(">")||this.expect(c.comma);return this.state.noAnonFunctionType=r,this.expectRelational(">"),this.state.inType=t,this.finishNode(e,"TypeParameterInstantiation")}flowParseTypeParameterInstantiationCallOrNew(){const e=this.startNode(),t=this.state.inType;for(e.params=[],this.state.inType=!0,this.expectRelational("<");!this.isRelational(">");)e.params.push(this.flowParseTypeOrImplicitInstantiation()),this.isRelational(">")||this.expect(c.comma);return this.expectRelational(">"),this.state.inType=t,this.finishNode(e,"TypeParameterInstantiation")}flowParseInterfaceType(){const e=this.startNode();if(this.expectContextual("interface"),e.extends=[],this.eat(c._extends))do{e.extends.push(this.flowParseInterfaceExtends());}while(this.eat(c.comma));return e.body=this.flowParseObjectType({allowStatic:!1,allowExact:!1,allowSpread:!1,allowProto:!1,allowInexact:!1}),this.finishNode(e,"InterfaceTypeAnnotation")}flowParseObjectPropertyKey(){return this.match(c.num)||this.match(c.string)?this.parseExprAtom():this.parseIdentifier(!0)}flowParseObjectTypeIndexer(e,t,r){return e.static=t,this.lookahead().type===c.colon?(e.id=this.flowParseObjectPropertyKey(),e.key=this.flowParseTypeInitialiser()):(e.id=null,e.key=this.flowParseType()),this.expect(c.bracketR),e.value=this.flowParseTypeInitialiser(),e.variance=r,this.finishNode(e,"ObjectTypeIndexer")}flowParseObjectTypeInternalSlot(e,t){return e.static=t,e.id=this.flowParseObjectPropertyKey(),this.expect(c.bracketR),this.expect(c.bracketR),this.isRelational("<")||this.match(c.parenL)?(e.method=!0,e.optional=!1,e.value=this.flowParseObjectTypeMethodish(this.startNodeAt(e.start,e.loc.start))):(e.method=!1,this.eat(c.question)&&(e.optional=!0),e.value=this.flowParseTypeInitialiser()),this.finishNode(e,"ObjectTypeInternalSlot")}flowParseObjectTypeMethodish(e){for(e.params=[],e.rest=null,e.typeParameters=null,e.this=null,this.isRelational("<")&&(e.typeParameters=this.flowParseTypeParameterDeclaration()),this.expect(c.parenL),this.match(c._this)&&(e.this=this.flowParseFunctionTypeParam(!0),e.this.name=null,this.match(c.parenR)||this.expect(c.comma));!this.match(c.parenR)&&!this.match(c.ellipsis);)e.params.push(this.flowParseFunctionTypeParam(!1)),this.match(c.parenR)||this.expect(c.comma);return this.eat(c.ellipsis)&&(e.rest=this.flowParseFunctionTypeParam(!1)),this.expect(c.parenR),e.returnType=this.flowParseTypeInitialiser(),this.finishNode(e,"FunctionTypeAnnotation")}flowParseObjectTypeCallProperty(e,t){const r=this.startNode();return e.static=t,e.value=this.flowParseObjectTypeMethodish(r),this.finishNode(e,"ObjectTypeCallProperty")}flowParseObjectType({allowStatic:e,allowExact:t,allowSpread:r,allowProto:n,allowInexact:s}){const i=this.state.inType;this.state.inType=!0;const o=this.startNode();let a,l;o.callProperties=[],o.properties=[],o.indexers=[],o.internalSlots=[];let u=!1;for(t&&this.match(c.braceBarL)?(this.expect(c.braceBarL),a=c.braceBarR,l=!0):(this.expect(c.braceL),a=c.braceR,l=!1),o.exact=l;!this.match(a);){let t=!1,i=null,a=null;const p=this.startNode();if(n&&this.isContextual("proto")){const t=this.lookahead();t.type!==c.colon&&t.type!==c.question&&(this.next(),i=this.state.start,e=!1);}if(e&&this.isContextual("static")){const e=this.lookahead();e.type!==c.colon&&e.type!==c.question&&(this.next(),t=!0);}const d=this.flowParseVariance();if(this.eat(c.bracketL))null!=i&&this.unexpected(i),this.eat(c.bracketL)?(d&&this.unexpected(d.start),o.internalSlots.push(this.flowParseObjectTypeInternalSlot(p,t))):o.indexers.push(this.flowParseObjectTypeIndexer(p,t,d));else if(this.match(c.parenL)||this.isRelational("<"))null!=i&&this.unexpected(i),d&&this.unexpected(d.start),o.callProperties.push(this.flowParseObjectTypeCallProperty(p,t));else {let e="init";if(this.isContextual("get")||this.isContextual("set")){const t=this.lookahead();t.type!==c.name&&t.type!==c.string&&t.type!==c.num||(e=this.state.value,this.next());}const n=this.flowParseObjectTypeProperty(p,t,i,d,e,r,null!=s?s:!l);null===n?(u=!0,a=this.state.lastTokStart):o.properties.push(n);}this.flowObjectTypeSemicolon(),!a||this.match(c.braceR)||this.match(c.braceBarR)||this.raise(a,J.UnexpectedExplicitInexactInObject);}this.expect(a),r&&(o.inexact=u);const p=this.finishNode(o,"ObjectTypeAnnotation");return this.state.inType=i,p}flowParseObjectTypeProperty(e,t,r,n,s,i,o){if(this.eat(c.ellipsis))return this.match(c.comma)||this.match(c.semi)||this.match(c.braceR)||this.match(c.braceBarR)?(i?o||this.raise(this.state.lastTokStart,J.InexactInsideExact):this.raise(this.state.lastTokStart,J.InexactInsideNonObject),n&&this.raise(n.start,J.InexactVariance),null):(i||this.raise(this.state.lastTokStart,J.UnexpectedSpreadType),null!=r&&this.unexpected(r),n&&this.raise(n.start,J.SpreadVariance),e.argument=this.flowParseType(),this.finishNode(e,"ObjectTypeSpreadProperty"));{e.key=this.flowParseObjectPropertyKey(),e.static=t,e.proto=null!=r,e.kind=s;let o=!1;return this.isRelational("<")||this.match(c.parenL)?(e.method=!0,null!=r&&this.unexpected(r),n&&this.unexpected(n.start),e.value=this.flowParseObjectTypeMethodish(this.startNodeAt(e.start,e.loc.start)),"get"!==s&&"set"!==s||this.flowCheckGetterSetterParams(e),!i&&"constructor"===e.key.name&&e.value.this&&this.raise(e.value.this.start,J.ThisParamBannedInConstructor)):("init"!==s&&this.unexpected(),e.method=!1,this.eat(c.question)&&(o=!0),e.value=this.flowParseTypeInitialiser(),e.variance=n),e.optional=o,this.finishNode(e,"ObjectTypeProperty")}}flowCheckGetterSetterParams(e){const t="get"===e.kind?0:1,r=e.start,n=e.value.params.length+(e.value.rest?1:0);e.value.this&&this.raise(e.value.this.start,"get"===e.kind?J.GetterMayNotHaveThisParam:J.SetterMayNotHaveThisParam),n!==t&&("get"===e.kind?this.raise(r,v.BadGetterArity):this.raise(r,v.BadSetterArity)),"set"===e.kind&&e.value.rest&&this.raise(r,v.BadSetterRestParameter);}flowObjectTypeSemicolon(){this.eat(c.semi)||this.eat(c.comma)||this.match(c.braceR)||this.match(c.braceBarR)||this.unexpected();}flowParseQualifiedTypeIdentifier(e,t,r){e=e||this.state.start,t=t||this.state.startLoc;let n=r||this.flowParseRestrictedIdentifier(!0);for(;this.eat(c.dot);){const r=this.startNodeAt(e,t);r.qualification=n,r.id=this.flowParseRestrictedIdentifier(!0),n=this.finishNode(r,"QualifiedTypeIdentifier");}return n}flowParseGenericType(e,t,r){const n=this.startNodeAt(e,t);return n.typeParameters=null,n.id=this.flowParseQualifiedTypeIdentifier(e,t,r),this.isRelational("<")&&(n.typeParameters=this.flowParseTypeParameterInstantiation()),this.finishNode(n,"GenericTypeAnnotation")}flowParseTypeofType(){const e=this.startNode();return this.expect(c._typeof),e.argument=this.flowParsePrimaryType(),this.finishNode(e,"TypeofTypeAnnotation")}flowParseTupleType(){const e=this.startNode();for(e.types=[],this.expect(c.bracketL);this.state.pos<this.length&&!this.match(c.bracketR)&&(e.types.push(this.flowParseType()),!this.match(c.bracketR));)this.expect(c.comma);return this.expect(c.bracketR),this.finishNode(e,"TupleTypeAnnotation")}flowParseFunctionTypeParam(e){let t=null,r=!1,n=null;const s=this.startNode(),i=this.lookahead(),o=this.state.type===c._this;return i.type===c.colon||i.type===c.question?(o&&!e&&this.raise(s.start,J.ThisParamMustBeFirst),t=this.parseIdentifier(o),this.eat(c.question)&&(r=!0,o&&this.raise(s.start,J.ThisParamMayNotBeOptional)),n=this.flowParseTypeInitialiser()):n=this.flowParseType(),s.name=t,s.optional=r,s.typeAnnotation=n,this.finishNode(s,"FunctionTypeParam")}reinterpretTypeAsFunctionTypeParam(e){const t=this.startNodeAt(e.start,e.loc.start);return t.name=null,t.optional=!1,t.typeAnnotation=e,this.finishNode(t,"FunctionTypeParam")}flowParseFunctionTypeParams(e=[]){let t=null,r=null;for(this.match(c._this)&&(r=this.flowParseFunctionTypeParam(!0),r.name=null,this.match(c.parenR)||this.expect(c.comma));!this.match(c.parenR)&&!this.match(c.ellipsis);)e.push(this.flowParseFunctionTypeParam(!1)),this.match(c.parenR)||this.expect(c.comma);return this.eat(c.ellipsis)&&(t=this.flowParseFunctionTypeParam(!1)),{params:e,rest:t,_this:r}}flowIdentToTypeAnnotation(e,t,r,n){switch(n.name){case"any":return this.finishNode(r,"AnyTypeAnnotation");case"bool":case"boolean":return this.finishNode(r,"BooleanTypeAnnotation");case"mixed":return this.finishNode(r,"MixedTypeAnnotation");case"empty":return this.finishNode(r,"EmptyTypeAnnotation");case"number":return this.finishNode(r,"NumberTypeAnnotation");case"string":return this.finishNode(r,"StringTypeAnnotation");case"symbol":return this.finishNode(r,"SymbolTypeAnnotation");default:return this.checkNotUnderscore(n.name),this.flowParseGenericType(e,t,n)}}flowParsePrimaryType(){const e=this.state.start,t=this.state.startLoc,r=this.startNode();let n,s,i=!1;const o=this.state.noAnonFunctionType;switch(this.state.type){case c.name:return this.isContextual("interface")?this.flowParseInterfaceType():this.flowIdentToTypeAnnotation(e,t,r,this.parseIdentifier());case c.braceL:return this.flowParseObjectType({allowStatic:!1,allowExact:!1,allowSpread:!0,allowProto:!1,allowInexact:!0});case c.braceBarL:return this.flowParseObjectType({allowStatic:!1,allowExact:!0,allowSpread:!0,allowProto:!1,allowInexact:!1});case c.bracketL:return this.state.noAnonFunctionType=!1,s=this.flowParseTupleType(),this.state.noAnonFunctionType=o,s;case c.relational:if("<"===this.state.value)return r.typeParameters=this.flowParseTypeParameterDeclaration(),this.expect(c.parenL),n=this.flowParseFunctionTypeParams(),r.params=n.params,r.rest=n.rest,r.this=n._this,this.expect(c.parenR),this.expect(c.arrow),r.returnType=this.flowParseType(),this.finishNode(r,"FunctionTypeAnnotation");break;case c.parenL:if(this.next(),!this.match(c.parenR)&&!this.match(c.ellipsis))if(this.match(c.name)||this.match(c._this)){const e=this.lookahead().type;i=e!==c.question&&e!==c.colon;}else i=!0;if(i){if(this.state.noAnonFunctionType=!1,s=this.flowParseType(),this.state.noAnonFunctionType=o,this.state.noAnonFunctionType||!(this.match(c.comma)||this.match(c.parenR)&&this.lookahead().type===c.arrow))return this.expect(c.parenR),s;this.eat(c.comma);}return n=s?this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(s)]):this.flowParseFunctionTypeParams(),r.params=n.params,r.rest=n.rest,r.this=n._this,this.expect(c.parenR),this.expect(c.arrow),r.returnType=this.flowParseType(),r.typeParameters=null,this.finishNode(r,"FunctionTypeAnnotation");case c.string:return this.parseLiteral(this.state.value,"StringLiteralTypeAnnotation");case c._true:case c._false:return r.value=this.match(c._true),this.next(),this.finishNode(r,"BooleanLiteralTypeAnnotation");case c.plusMin:if("-"===this.state.value){if(this.next(),this.match(c.num))return this.parseLiteral(-this.state.value,"NumberLiteralTypeAnnotation",r.start,r.loc.start);if(this.match(c.bigint))return this.parseLiteral(-this.state.value,"BigIntLiteralTypeAnnotation",r.start,r.loc.start);throw this.raise(this.state.start,J.UnexpectedSubtractionOperand)}throw this.unexpected();case c.num:return this.parseLiteral(this.state.value,"NumberLiteralTypeAnnotation");case c.bigint:return this.parseLiteral(this.state.value,"BigIntLiteralTypeAnnotation");case c._void:return this.next(),this.finishNode(r,"VoidTypeAnnotation");case c._null:return this.next(),this.finishNode(r,"NullLiteralTypeAnnotation");case c._this:return this.next(),this.finishNode(r,"ThisTypeAnnotation");case c.star:return this.next(),this.finishNode(r,"ExistsTypeAnnotation");default:if("typeof"===this.state.type.keyword)return this.flowParseTypeofType();if(this.state.type.keyword){const e=this.state.type.label;return this.next(),super.createIdentifier(r,e)}}throw this.unexpected()}flowParsePostfixType(){const e=this.state.start,t=this.state.startLoc;let r=this.flowParsePrimaryType(),n=!1;for(;(this.match(c.bracketL)||this.match(c.questionDot))&&!this.canInsertSemicolon();){const s=this.startNodeAt(e,t),i=this.eat(c.questionDot);n=n||i,this.expect(c.bracketL),!i&&this.match(c.bracketR)?(s.elementType=r,this.next(),r=this.finishNode(s,"ArrayTypeAnnotation")):(s.objectType=r,s.indexType=this.flowParseType(),this.expect(c.bracketR),n?(s.optional=i,r=this.finishNode(s,"OptionalIndexedAccessType")):r=this.finishNode(s,"IndexedAccessType"));}return r}flowParsePrefixType(){const e=this.startNode();return this.eat(c.question)?(e.typeAnnotation=this.flowParsePrefixType(),this.finishNode(e,"NullableTypeAnnotation")):this.flowParsePostfixType()}flowParseAnonFunctionWithoutParens(){const e=this.flowParsePrefixType();if(!this.state.noAnonFunctionType&&this.eat(c.arrow)){const t=this.startNodeAt(e.start,e.loc.start);return t.params=[this.reinterpretTypeAsFunctionTypeParam(e)],t.rest=null,t.this=null,t.returnType=this.flowParseType(),t.typeParameters=null,this.finishNode(t,"FunctionTypeAnnotation")}return e}flowParseIntersectionType(){const e=this.startNode();this.eat(c.bitwiseAND);const t=this.flowParseAnonFunctionWithoutParens();for(e.types=[t];this.eat(c.bitwiseAND);)e.types.push(this.flowParseAnonFunctionWithoutParens());return 1===e.types.length?t:this.finishNode(e,"IntersectionTypeAnnotation")}flowParseUnionType(){const e=this.startNode();this.eat(c.bitwiseOR);const t=this.flowParseIntersectionType();for(e.types=[t];this.eat(c.bitwiseOR);)e.types.push(this.flowParseIntersectionType());return 1===e.types.length?t:this.finishNode(e,"UnionTypeAnnotation")}flowParseType(){const e=this.state.inType;this.state.inType=!0;const t=this.flowParseUnionType();return this.state.inType=e,this.state.exprAllowed=this.state.exprAllowed||this.state.noAnonFunctionType,t}flowParseTypeOrImplicitInstantiation(){if(this.state.type===c.name&&"_"===this.state.value){const e=this.state.start,t=this.state.startLoc,r=this.parseIdentifier();return this.flowParseGenericType(e,t,r)}return this.flowParseType()}flowParseTypeAnnotation(){const e=this.startNode();return e.typeAnnotation=this.flowParseTypeInitialiser(),this.finishNode(e,"TypeAnnotation")}flowParseTypeAnnotatableIdentifier(e){const t=e?this.parseIdentifier():this.flowParseRestrictedIdentifier();return this.match(c.colon)&&(t.typeAnnotation=this.flowParseTypeAnnotation(),this.resetEndLocation(t)),t}typeCastToParameter(e){return e.expression.typeAnnotation=e.typeAnnotation,this.resetEndLocation(e.expression,e.typeAnnotation.end,e.typeAnnotation.loc.end),e.expression}flowParseVariance(){let e=null;return this.match(c.plusMin)&&(e=this.startNode(),"+"===this.state.value?e.kind="plus":e.kind="minus",this.next(),this.finishNode(e,"Variance")),e}parseFunctionBody(e,t,r=!1){return t?this.forwardNoArrowParamsConversionAt(e,(()=>super.parseFunctionBody(e,!0,r))):super.parseFunctionBody(e,!1,r)}parseFunctionBodyAndFinish(e,t,r=!1){if(this.match(c.colon)){const t=this.startNode();[t.typeAnnotation,e.predicate]=this.flowParseTypeAndPredicateInitialiser(),e.returnType=t.typeAnnotation?this.finishNode(t,"TypeAnnotation"):null;}super.parseFunctionBodyAndFinish(e,t,r);}parseStatement(e,t){if(this.state.strict&&this.match(c.name)&&"interface"===this.state.value){const e=this.lookahead();if(e.type===c.name||V(e.value)){const e=this.startNode();return this.next(),this.flowParseInterface(e)}}else if(this.shouldParseEnums()&&this.isContextual("enum")){const e=this.startNode();return this.next(),this.flowParseEnumDeclaration(e)}const r=super.parseStatement(e,t);return void 0!==this.flowPragma||this.isValidDirective(r)||(this.flowPragma=null),r}parseExpressionStatement(e,t){if("Identifier"===t.type)if("declare"===t.name){if(this.match(c._class)||this.match(c.name)||this.match(c._function)||this.match(c._var)||this.match(c._export))return this.flowParseDeclare(e)}else if(this.match(c.name)){if("interface"===t.name)return this.flowParseInterface(e);if("type"===t.name)return this.flowParseTypeAlias(e);if("opaque"===t.name)return this.flowParseOpaqueType(e,!1)}return super.parseExpressionStatement(e,t)}shouldParseExportDeclaration(){return this.isContextual("type")||this.isContextual("interface")||this.isContextual("opaque")||this.shouldParseEnums()&&this.isContextual("enum")||super.shouldParseExportDeclaration()}isExportDefaultSpecifier(){return (!this.match(c.name)||!("type"===this.state.value||"interface"===this.state.value||"opaque"===this.state.value||this.shouldParseEnums()&&"enum"===this.state.value))&&super.isExportDefaultSpecifier()}parseExportDefaultExpression(){if(this.shouldParseEnums()&&this.isContextual("enum")){const e=this.startNode();return this.next(),this.flowParseEnumDeclaration(e)}return super.parseExportDefaultExpression()}parseConditional(e,t,r,n){if(!this.match(c.question))return e;if(n){const s=this.tryParse((()=>super.parseConditional(e,t,r)));return s.node?(s.error&&(this.state=s.failState),s.node):(n.start=s.error.pos||this.state.start,e)}this.expect(c.question);const s=this.state.clone(),i=this.state.noArrowAt,o=this.startNodeAt(t,r);let{consequent:a,failed:l}=this.tryParseConditionalConsequent(),[u,p]=this.getArrowLikeExpressions(a);if(l||p.length>0){const e=[...i];if(p.length>0){this.state=s,this.state.noArrowAt=e;for(let t=0;t<p.length;t++)e.push(p[t].start);(({consequent:a,failed:l}=this.tryParseConditionalConsequent())),[u,p]=this.getArrowLikeExpressions(a);}l&&u.length>1&&this.raise(s.start,J.AmbiguousConditionalArrow),l&&1===u.length&&(this.state=s,this.state.noArrowAt=e.concat(u[0].start),({consequent:a,failed:l}=this.tryParseConditionalConsequent()));}return this.getArrowLikeExpressions(a,!0),this.state.noArrowAt=i,this.expect(c.colon),o.test=e,o.consequent=a,o.alternate=this.forwardNoArrowParamsConversionAt(o,(()=>this.parseMaybeAssign(void 0,void 0,void 0))),this.finishNode(o,"ConditionalExpression")}tryParseConditionalConsequent(){this.state.noArrowParamsConversionAt.push(this.state.start);const e=this.parseMaybeAssignAllowIn(),t=!this.match(c.colon);return this.state.noArrowParamsConversionAt.pop(),{consequent:e,failed:t}}getArrowLikeExpressions(e,t){const r=[e],n=[];for(;0!==r.length;){const e=r.pop();"ArrowFunctionExpression"===e.type?(e.typeParameters||!e.returnType?this.finishArrowValidation(e):n.push(e),r.push(e.body)):"ConditionalExpression"===e.type&&(r.push(e.consequent),r.push(e.alternate));}return t?(n.forEach((e=>this.finishArrowValidation(e))),[n,[]]):function(e,t){const r=[],n=[];for(let s=0;s<e.length;s++)(t(e[s])?r:n).push(e[s]);return [r,n]}(n,(e=>e.params.every((e=>this.isAssignable(e,!0)))))}finishArrowValidation(e){var t;this.toAssignableList(e.params,null==(t=e.extra)?void 0:t.trailingComma,!1),this.scope.enter(6),super.checkParams(e,!1,!0),this.scope.exit();}forwardNoArrowParamsConversionAt(e,t){let r;return -1!==this.state.noArrowParamsConversionAt.indexOf(e.start)?(this.state.noArrowParamsConversionAt.push(this.state.start),r=t(),this.state.noArrowParamsConversionAt.pop()):r=t(),r}parseParenItem(e,t,r){if(e=super.parseParenItem(e,t,r),this.eat(c.question)&&(e.optional=!0,this.resetEndLocation(e)),this.match(c.colon)){const n=this.startNodeAt(t,r);return n.expression=e,n.typeAnnotation=this.flowParseTypeAnnotation(),this.finishNode(n,"TypeCastExpression")}return e}assertModuleNodeAllowed(e){"ImportDeclaration"===e.type&&("type"===e.importKind||"typeof"===e.importKind)||"ExportNamedDeclaration"===e.type&&"type"===e.exportKind||"ExportAllDeclaration"===e.type&&"type"===e.exportKind||super.assertModuleNodeAllowed(e);}parseExport(e){const t=super.parseExport(e);return "ExportNamedDeclaration"!==t.type&&"ExportAllDeclaration"!==t.type||(t.exportKind=t.exportKind||"value"),t}parseExportDeclaration(e){if(this.isContextual("type")){e.exportKind="type";const t=this.startNode();return this.next(),this.match(c.braceL)?(e.specifiers=this.parseExportSpecifiers(),this.parseExportFrom(e),null):this.flowParseTypeAlias(t)}if(this.isContextual("opaque")){e.exportKind="type";const t=this.startNode();return this.next(),this.flowParseOpaqueType(t,!1)}if(this.isContextual("interface")){e.exportKind="type";const t=this.startNode();return this.next(),this.flowParseInterface(t)}if(this.shouldParseEnums()&&this.isContextual("enum")){e.exportKind="value";const t=this.startNode();return this.next(),this.flowParseEnumDeclaration(t)}return super.parseExportDeclaration(e)}eatExportStar(e){return !!super.eatExportStar(...arguments)||!(!this.isContextual("type")||this.lookahead().type!==c.star)&&(e.exportKind="type",this.next(),this.next(),!0)}maybeParseExportNamespaceSpecifier(e){const t=this.state.start,r=super.maybeParseExportNamespaceSpecifier(e);return r&&"type"===e.exportKind&&this.unexpected(t),r}parseClassId(e,t,r){super.parseClassId(e,t,r),this.isRelational("<")&&(e.typeParameters=this.flowParseTypeParameterDeclaration());}parseClassMember(e,t,r){const n=this.state.start;if(this.isContextual("declare")){if(this.parseClassMemberFromModifier(e,t))return;t.declare=!0;}super.parseClassMember(e,t,r),t.declare&&("ClassProperty"!==t.type&&"ClassPrivateProperty"!==t.type&&"PropertyDefinition"!==t.type?this.raise(n,J.DeclareClassElement):t.value&&this.raise(t.value.start,J.DeclareClassFieldInitializer));}isIterator(e){return "iterator"===e||"asyncIterator"===e}readIterator(){const e=super.readWord1(),t="@@"+e;this.isIterator(e)&&this.state.inType||this.raise(this.state.pos,v.InvalidIdentifier,t),this.finishToken(c.name,t);}getTokenFromCode(e){const t=this.input.charCodeAt(this.state.pos+1);return 123===e&&124===t?this.finishOp(c.braceBarL,2):!this.state.inType||62!==e&&60!==e?this.state.inType&&63===e?46===t?this.finishOp(c.questionDot,2):this.finishOp(c.question,1):function(e,t){return 64===e&&64===t}(e,t)?(this.state.pos+=2,this.readIterator()):super.getTokenFromCode(e):this.finishOp(c.relational,1)}isAssignable(e,t){switch(e.type){case"Identifier":case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":return !0;case"ObjectExpression":{const t=e.properties.length-1;return e.properties.every(((e,r)=>"ObjectMethod"!==e.type&&(r===t||"SpreadElement"===e.type)&&this.isAssignable(e)))}case"ObjectProperty":return this.isAssignable(e.value);case"SpreadElement":return this.isAssignable(e.argument);case"ArrayExpression":return e.elements.every((e=>this.isAssignable(e)));case"AssignmentExpression":return "="===e.operator;case"ParenthesizedExpression":case"TypeCastExpression":return this.isAssignable(e.expression);case"MemberExpression":case"OptionalMemberExpression":return !t;default:return !1}}toAssignable(e,t=!1){return "TypeCastExpression"===e.type?super.toAssignable(this.typeCastToParameter(e),t):super.toAssignable(e,t)}toAssignableList(e,t,r){for(let t=0;t<e.length;t++){const r=e[t];"TypeCastExpression"===(null==r?void 0:r.type)&&(e[t]=this.typeCastToParameter(r));}return super.toAssignableList(e,t,r)}toReferencedList(e,t){for(let n=0;n<e.length;n++){var r;const s=e[n];!s||"TypeCastExpression"!==s.type||null!=(r=s.extra)&&r.parenthesized||!(e.length>1)&&t||this.raise(s.typeAnnotation.start,J.TypeCastInPattern);}return e}parseArrayLike(e,t,r,n){const s=super.parseArrayLike(e,t,r,n);return t&&!this.state.maybeInArrowParameters&&this.toReferencedList(s.elements),s}checkLVal(e,...t){if("TypeCastExpression"!==e.type)return super.checkLVal(e,...t)}parseClassProperty(e){return this.match(c.colon)&&(e.typeAnnotation=this.flowParseTypeAnnotation()),super.parseClassProperty(e)}parseClassPrivateProperty(e){return this.match(c.colon)&&(e.typeAnnotation=this.flowParseTypeAnnotation()),super.parseClassPrivateProperty(e)}isClassMethod(){return this.isRelational("<")||super.isClassMethod()}isClassProperty(){return this.match(c.colon)||super.isClassProperty()}isNonstaticConstructor(e){return !this.match(c.colon)&&super.isNonstaticConstructor(e)}pushClassMethod(e,t,r,n,s,i){if(t.variance&&this.unexpected(t.variance.start),delete t.variance,this.isRelational("<")&&(t.typeParameters=this.flowParseTypeParameterDeclaration()),super.pushClassMethod(e,t,r,n,s,i),t.params&&s){const e=t.params;e.length>0&&this.isThisParam(e[0])&&this.raise(t.start,J.ThisParamBannedInConstructor);}else if("MethodDefinition"===t.type&&s&&t.value.params){const e=t.value.params;e.length>0&&this.isThisParam(e[0])&&this.raise(t.start,J.ThisParamBannedInConstructor);}}pushClassPrivateMethod(e,t,r,n){t.variance&&this.unexpected(t.variance.start),delete t.variance,this.isRelational("<")&&(t.typeParameters=this.flowParseTypeParameterDeclaration()),super.pushClassPrivateMethod(e,t,r,n);}parseClassSuper(e){if(super.parseClassSuper(e),e.superClass&&this.isRelational("<")&&(e.superTypeParameters=this.flowParseTypeParameterInstantiation()),this.isContextual("implements")){this.next();const t=e.implements=[];do{const e=this.startNode();e.id=this.flowParseRestrictedIdentifier(!0),this.isRelational("<")?e.typeParameters=this.flowParseTypeParameterInstantiation():e.typeParameters=null,t.push(this.finishNode(e,"ClassImplements"));}while(this.eat(c.comma))}}checkGetterSetterParams(e){super.checkGetterSetterParams(e);const t=this.getObjectOrClassMethodParams(e);if(t.length>0){const r=t[0];this.isThisParam(r)&&"get"===e.kind?this.raise(r.start,J.GetterMayNotHaveThisParam):this.isThisParam(r)&&this.raise(r.start,J.SetterMayNotHaveThisParam);}}parsePropertyName(e,t){const r=this.flowParseVariance(),n=super.parsePropertyName(e,t);return e.variance=r,n}parseObjPropValue(e,t,r,n,s,i,o,a){let l;e.variance&&this.unexpected(e.variance.start),delete e.variance,this.isRelational("<")&&!o&&(l=this.flowParseTypeParameterDeclaration(),this.match(c.parenL)||this.unexpected()),super.parseObjPropValue(e,t,r,n,s,i,o,a),l&&((e.value||e).typeParameters=l);}parseAssignableListItemTypes(e){return this.eat(c.question)&&("Identifier"!==e.type&&this.raise(e.start,J.OptionalBindingPattern),this.isThisParam(e)&&this.raise(e.start,J.ThisParamMayNotBeOptional),e.optional=!0),this.match(c.colon)?e.typeAnnotation=this.flowParseTypeAnnotation():this.isThisParam(e)&&this.raise(e.start,J.ThisParamAnnotationRequired),this.match(c.eq)&&this.isThisParam(e)&&this.raise(e.start,J.ThisParamNoDefault),this.resetEndLocation(e),e}parseMaybeDefault(e,t,r){const n=super.parseMaybeDefault(e,t,r);return "AssignmentPattern"===n.type&&n.typeAnnotation&&n.right.start<n.typeAnnotation.start&&this.raise(n.typeAnnotation.start,J.TypeBeforeInitializer),n}shouldParseDefaultImport(e){return Y(e)?X(this.state):super.shouldParseDefaultImport(e)}parseImportSpecifierLocal(e,t,r,n){t.local=Y(e)?this.flowParseRestrictedIdentifier(!0,!0):this.parseIdentifier(),this.checkLVal(t.local,n,9),e.specifiers.push(this.finishNode(t,r));}maybeParseDefaultImportSpecifier(e){e.importKind="value";let t=null;if(this.match(c._typeof)?t="typeof":this.isContextual("type")&&(t="type"),t){const r=this.lookahead();"type"===t&&r.type===c.star&&this.unexpected(r.start),(X(r)||r.type===c.braceL||r.type===c.star)&&(this.next(),e.importKind=t);}return super.maybeParseDefaultImportSpecifier(e)}parseImportSpecifier(e){const t=this.startNode(),r=this.state.start,n=this.parseModuleExportName();let s=null;"Identifier"===n.type&&("type"===n.name?s="type":"typeof"===n.name&&(s="typeof"));let i=!1;if(this.isContextual("as")&&!this.isLookaheadContextual("as")){const e=this.parseIdentifier(!0);null===s||this.match(c.name)||this.state.type.keyword?(t.imported=n,t.importKind=null,t.local=this.parseIdentifier()):(t.imported=e,t.importKind=s,t.local=e.__clone());}else if(null!==s&&(this.match(c.name)||this.state.type.keyword))t.imported=this.parseIdentifier(!0),t.importKind=s,this.eatContextual("as")?t.local=this.parseIdentifier():(i=!0,t.local=t.imported.__clone());else {if("StringLiteral"===n.type)throw this.raise(t.start,v.ImportBindingIsString,n.value);i=!0,t.imported=n,t.importKind=null,t.local=t.imported.__clone();}const o=Y(e),a=Y(t);o&&a&&this.raise(r,J.ImportTypeShorthandOnlyInPureImport),(o||a)&&this.checkReservedType(t.local.name,t.local.start,!0),!i||o||a||this.checkReservedWord(t.local.name,t.start,!0,!0),this.checkLVal(t.local,"import specifier",9),e.specifiers.push(this.finishNode(t,"ImportSpecifier"));}parseBindingAtom(){switch(this.state.type){case c._this:return this.parseIdentifier(!0);default:return super.parseBindingAtom()}}parseFunctionParams(e,t){const r=e.kind;"get"!==r&&"set"!==r&&this.isRelational("<")&&(e.typeParameters=this.flowParseTypeParameterDeclaration()),super.parseFunctionParams(e,t);}parseVarId(e,t){super.parseVarId(e,t),this.match(c.colon)&&(e.id.typeAnnotation=this.flowParseTypeAnnotation(),this.resetEndLocation(e.id));}parseAsyncArrowFromCallExpression(e,t){if(this.match(c.colon)){const t=this.state.noAnonFunctionType;this.state.noAnonFunctionType=!0,e.returnType=this.flowParseTypeAnnotation(),this.state.noAnonFunctionType=t;}return super.parseAsyncArrowFromCallExpression(e,t)}shouldParseAsyncArrow(){return this.match(c.colon)||super.shouldParseAsyncArrow()}parseMaybeAssign(e,t,r){var n;let s,i=null;if(this.hasPlugin("jsx")&&(this.match(c.jsxTagStart)||this.isRelational("<"))){if(i=this.state.clone(),s=this.tryParse((()=>super.parseMaybeAssign(e,t,r)),i),!s.error)return s.node;const{context:n}=this.state;n[n.length-1]===P.j_oTag?n.length-=2:n[n.length-1]===P.j_expr&&(n.length-=1);}if(null!=(n=s)&&n.error||this.isRelational("<")){var o,a;let n;i=i||this.state.clone();const l=this.tryParse((s=>{var i;n=this.flowParseTypeParameterDeclaration();const o=this.forwardNoArrowParamsConversionAt(n,(()=>{const s=super.parseMaybeAssign(e,t,r);return this.resetStartLocationFromNode(s,n),s}));"ArrowFunctionExpression"!==o.type&&null!=(i=o.extra)&&i.parenthesized&&s();const a=this.maybeUnwrapTypeCastExpression(o);return a.typeParameters=n,this.resetStartLocationFromNode(a,n),o}),i);let u=null;if(l.node&&"ArrowFunctionExpression"===this.maybeUnwrapTypeCastExpression(l.node).type){if(!l.error&&!l.aborted)return l.node.async&&this.raise(n.start,J.UnexpectedTypeParameterBeforeAsyncArrowFunction),l.node;u=l.node;}if(null!=(o=s)&&o.node)return this.state=s.failState,s.node;if(u)return this.state=l.failState,u;if(null!=(a=s)&&a.thrown)throw s.error;if(l.thrown)throw l.error;throw this.raise(n.start,J.UnexpectedTokenAfterTypeParameter)}return super.parseMaybeAssign(e,t,r)}parseArrow(e){if(this.match(c.colon)){const t=this.tryParse((()=>{const t=this.state.noAnonFunctionType;this.state.noAnonFunctionType=!0;const r=this.startNode();return [r.typeAnnotation,e.predicate]=this.flowParseTypeAndPredicateInitialiser(),this.state.noAnonFunctionType=t,this.canInsertSemicolon()&&this.unexpected(),this.match(c.arrow)||this.unexpected(),r}));if(t.thrown)return null;t.error&&(this.state=t.failState),e.returnType=t.node.typeAnnotation?this.finishNode(t.node,"TypeAnnotation"):null;}return super.parseArrow(e)}shouldParseArrow(){return this.match(c.colon)||super.shouldParseArrow()}setArrowFunctionParameters(e,t){-1!==this.state.noArrowParamsConversionAt.indexOf(e.start)?e.params=t:super.setArrowFunctionParameters(e,t);}checkParams(e,t,r){if(!r||-1===this.state.noArrowParamsConversionAt.indexOf(e.start)){for(let t=0;t<e.params.length;t++)this.isThisParam(e.params[t])&&t>0&&this.raise(e.params[t].start,J.ThisParamMustBeFirst);return super.checkParams(...arguments)}}parseParenAndDistinguishExpression(e){return super.parseParenAndDistinguishExpression(e&&-1===this.state.noArrowAt.indexOf(this.state.start))}parseSubscripts(e,t,r,n){if("Identifier"===e.type&&"async"===e.name&&-1!==this.state.noArrowAt.indexOf(t)){this.next();const n=this.startNodeAt(t,r);n.callee=e,n.arguments=this.parseCallExpressionArguments(c.parenR,!1),e=this.finishNode(n,"CallExpression");}else if("Identifier"===e.type&&"async"===e.name&&this.isRelational("<")){const s=this.state.clone(),i=this.tryParse((e=>this.parseAsyncArrowWithTypeParameters(t,r)||e()),s);if(!i.error&&!i.aborted)return i.node;const o=this.tryParse((()=>super.parseSubscripts(e,t,r,n)),s);if(o.node&&!o.error)return o.node;if(i.node)return this.state=i.failState,i.node;if(o.node)return this.state=o.failState,o.node;throw i.error||o.error}return super.parseSubscripts(e,t,r,n)}parseSubscript(e,t,r,n,s){if(this.match(c.questionDot)&&this.isLookaheadToken_lt()){if(s.optionalChainMember=!0,n)return s.stop=!0,e;this.next();const i=this.startNodeAt(t,r);return i.callee=e,i.typeArguments=this.flowParseTypeParameterInstantiation(),this.expect(c.parenL),i.arguments=this.parseCallExpressionArguments(c.parenR,!1),i.optional=!0,this.finishCallExpression(i,!0)}if(!n&&this.shouldParseTypes()&&this.isRelational("<")){const n=this.startNodeAt(t,r);n.callee=e;const i=this.tryParse((()=>(n.typeArguments=this.flowParseTypeParameterInstantiationCallOrNew(),this.expect(c.parenL),n.arguments=this.parseCallExpressionArguments(c.parenR,!1),s.optionalChainMember&&(n.optional=!1),this.finishCallExpression(n,s.optionalChainMember))));if(i.node)return i.error&&(this.state=i.failState),i.node}return super.parseSubscript(e,t,r,n,s)}parseNewArguments(e){let t=null;this.shouldParseTypes()&&this.isRelational("<")&&(t=this.tryParse((()=>this.flowParseTypeParameterInstantiationCallOrNew())).node),e.typeArguments=t,super.parseNewArguments(e);}parseAsyncArrowWithTypeParameters(e,t){const r=this.startNodeAt(e,t);if(this.parseFunctionParams(r),this.parseArrow(r))return this.parseArrowExpression(r,void 0,!0)}readToken_mult_modulo(e){const t=this.input.charCodeAt(this.state.pos+1);if(42===e&&47===t&&this.state.hasFlowComment)return this.state.hasFlowComment=!1,this.state.pos+=2,void this.nextToken();super.readToken_mult_modulo(e);}readToken_pipe_amp(e){const t=this.input.charCodeAt(this.state.pos+1);124!==e||125!==t?super.readToken_pipe_amp(e):this.finishOp(c.braceBarR,2);}parseTopLevel(e,t){const r=super.parseTopLevel(e,t);return this.state.hasFlowComment&&this.raise(this.state.pos,J.UnterminatedFlowComment),r}skipBlockComment(){if(this.hasPlugin("flowComments")&&this.skipFlowComment())return this.state.hasFlowComment&&this.unexpected(null,J.NestedFlowComment),this.hasFlowCommentCompletion(),this.state.pos+=this.skipFlowComment(),void(this.state.hasFlowComment=!0);if(this.state.hasFlowComment){const e=this.input.indexOf("*-/",this.state.pos+=2);if(-1===e)throw this.raise(this.state.pos-2,v.UnterminatedComment);this.state.pos=e+3;}else super.skipBlockComment();}skipFlowComment(){const{pos:e}=this.state;let t=2;for(;[32,9].includes(this.input.charCodeAt(e+t));)t++;const r=this.input.charCodeAt(t+e),n=this.input.charCodeAt(t+e+1);return 58===r&&58===n?t+2:"flow-include"===this.input.slice(t+e,t+e+12)?t+12:58===r&&58!==n&&t}hasFlowCommentCompletion(){if(-1===this.input.indexOf("*/",this.state.pos))throw this.raise(this.state.pos,v.UnterminatedComment)}flowEnumErrorBooleanMemberNotInitialized(e,{enumName:t,memberName:r}){this.raise(e,J.EnumBooleanMemberNotInitialized,r,t);}flowEnumErrorInvalidMemberName(e,{enumName:t,memberName:r}){const n=r[0].toUpperCase()+r.slice(1);this.raise(e,J.EnumInvalidMemberName,r,n,t);}flowEnumErrorDuplicateMemberName(e,{enumName:t,memberName:r}){this.raise(e,J.EnumDuplicateMemberName,r,t);}flowEnumErrorInconsistentMemberValues(e,{enumName:t}){this.raise(e,J.EnumInconsistentMemberValues,t);}flowEnumErrorInvalidExplicitType(e,{enumName:t,suppliedType:r}){return this.raise(e,null===r?J.EnumInvalidExplicitTypeUnknownSupplied:J.EnumInvalidExplicitType,t,r)}flowEnumErrorInvalidMemberInitializer(e,{enumName:t,explicitType:r,memberName:n}){let s=null;switch(r){case"boolean":case"number":case"string":s=J.EnumInvalidMemberInitializerPrimaryType;break;case"symbol":s=J.EnumInvalidMemberInitializerSymbolType;break;default:s=J.EnumInvalidMemberInitializerUnknownType;}return this.raise(e,s,t,n,r)}flowEnumErrorNumberMemberNotInitialized(e,{enumName:t,memberName:r}){this.raise(e,J.EnumNumberMemberNotInitialized,t,r);}flowEnumErrorStringMemberInconsistentlyInitailized(e,{enumName:t}){this.raise(e,J.EnumStringMemberInconsistentlyInitailized,t);}flowEnumMemberInit(){const e=this.state.start,t=()=>this.match(c.comma)||this.match(c.braceR);switch(this.state.type){case c.num:{const r=this.parseLiteral(this.state.value,"NumericLiteral");return t()?{type:"number",pos:r.start,value:r}:{type:"invalid",pos:e}}case c.string:{const r=this.parseLiteral(this.state.value,"StringLiteral");return t()?{type:"string",pos:r.start,value:r}:{type:"invalid",pos:e}}case c._true:case c._false:{const r=this.parseBooleanLiteral();return t()?{type:"boolean",pos:r.start,value:r}:{type:"invalid",pos:e}}default:return {type:"invalid",pos:e}}}flowEnumMemberRaw(){const e=this.state.start;return {id:this.parseIdentifier(!0),init:this.eat(c.eq)?this.flowEnumMemberInit():{type:"none",pos:e}}}flowEnumCheckExplicitTypeMismatch(e,t,r){const{explicitType:n}=t;null!==n&&n!==r&&this.flowEnumErrorInvalidMemberInitializer(e,t);}flowEnumMembers({enumName:e,explicitType:t}){const r=new Set,n={booleanMembers:[],numberMembers:[],stringMembers:[],defaultedMembers:[]};let s=!1;for(;!this.match(c.braceR);){if(this.eat(c.ellipsis)){s=!0;break}const i=this.startNode(),{id:o,init:a}=this.flowEnumMemberRaw(),l=o.name;if(""===l)continue;/^[a-z]/.test(l)&&this.flowEnumErrorInvalidMemberName(o.start,{enumName:e,memberName:l}),r.has(l)&&this.flowEnumErrorDuplicateMemberName(o.start,{enumName:e,memberName:l}),r.add(l);const u={enumName:e,explicitType:t,memberName:l};switch(i.id=o,a.type){case"boolean":this.flowEnumCheckExplicitTypeMismatch(a.pos,u,"boolean"),i.init=a.value,n.booleanMembers.push(this.finishNode(i,"EnumBooleanMember"));break;case"number":this.flowEnumCheckExplicitTypeMismatch(a.pos,u,"number"),i.init=a.value,n.numberMembers.push(this.finishNode(i,"EnumNumberMember"));break;case"string":this.flowEnumCheckExplicitTypeMismatch(a.pos,u,"string"),i.init=a.value,n.stringMembers.push(this.finishNode(i,"EnumStringMember"));break;case"invalid":throw this.flowEnumErrorInvalidMemberInitializer(a.pos,u);case"none":switch(t){case"boolean":this.flowEnumErrorBooleanMemberNotInitialized(a.pos,u);break;case"number":this.flowEnumErrorNumberMemberNotInitialized(a.pos,u);break;default:n.defaultedMembers.push(this.finishNode(i,"EnumDefaultedMember"));}}this.match(c.braceR)||this.expect(c.comma);}return {members:n,hasUnknownMembers:s}}flowEnumStringMembers(e,t,{enumName:r}){if(0===e.length)return t;if(0===t.length)return e;if(t.length>e.length){for(const t of e)this.flowEnumErrorStringMemberInconsistentlyInitailized(t.start,{enumName:r});return t}for(const e of t)this.flowEnumErrorStringMemberInconsistentlyInitailized(e.start,{enumName:r});return e}flowEnumParseExplicitType({enumName:e}){if(this.eatContextual("of")){if(!this.match(c.name))throw this.flowEnumErrorInvalidExplicitType(this.state.start,{enumName:e,suppliedType:null});const{value:t}=this.state;return this.next(),"boolean"!==t&&"number"!==t&&"string"!==t&&"symbol"!==t&&this.flowEnumErrorInvalidExplicitType(this.state.start,{enumName:e,suppliedType:t}),t}return null}flowEnumBody(e,{enumName:t,nameLoc:r}){const n=this.flowEnumParseExplicitType({enumName:t});this.expect(c.braceL);const{members:s,hasUnknownMembers:i}=this.flowEnumMembers({enumName:t,explicitType:n});switch(e.hasUnknownMembers=i,n){case"boolean":return e.explicitType=!0,e.members=s.booleanMembers,this.expect(c.braceR),this.finishNode(e,"EnumBooleanBody");case"number":return e.explicitType=!0,e.members=s.numberMembers,this.expect(c.braceR),this.finishNode(e,"EnumNumberBody");case"string":return e.explicitType=!0,e.members=this.flowEnumStringMembers(s.stringMembers,s.defaultedMembers,{enumName:t}),this.expect(c.braceR),this.finishNode(e,"EnumStringBody");case"symbol":return e.members=s.defaultedMembers,this.expect(c.braceR),this.finishNode(e,"EnumSymbolBody");default:{const n=()=>(e.members=[],this.expect(c.braceR),this.finishNode(e,"EnumStringBody"));e.explicitType=!1;const i=s.booleanMembers.length,o=s.numberMembers.length,a=s.stringMembers.length,l=s.defaultedMembers.length;if(i||o||a||l){if(i||o){if(!o&&!a&&i>=l){for(const e of s.defaultedMembers)this.flowEnumErrorBooleanMemberNotInitialized(e.start,{enumName:t,memberName:e.id.name});return e.members=s.booleanMembers,this.expect(c.braceR),this.finishNode(e,"EnumBooleanBody")}if(!i&&!a&&o>=l){for(const e of s.defaultedMembers)this.flowEnumErrorNumberMemberNotInitialized(e.start,{enumName:t,memberName:e.id.name});return e.members=s.numberMembers,this.expect(c.braceR),this.finishNode(e,"EnumNumberBody")}return this.flowEnumErrorInconsistentMemberValues(r,{enumName:t}),n()}return e.members=this.flowEnumStringMembers(s.stringMembers,s.defaultedMembers,{enumName:t}),this.expect(c.braceR),this.finishNode(e,"EnumStringBody")}return n()}}}flowParseEnumDeclaration(e){const t=this.parseIdentifier();return e.id=t,e.body=this.flowEnumBody(this.startNode(),{enumName:t.name,nameLoc:t.start}),this.finishNode(e,"EnumDeclaration")}updateContext(e){this.match(c.name)&&"of"===this.state.value&&e===c.name&&"interface"===this.input.slice(this.state.lastTokStart,this.state.lastTokEnd)?this.state.exprAllowed=!1:super.updateContext(e);}isLookaheadToken_lt(){const e=this.nextTokenStart();if(60===this.input.charCodeAt(e)){const t=this.input.charCodeAt(e+1);return 60!==t&&61!==t}return !1}maybeUnwrapTypeCastExpression(e){return "TypeCastExpression"===e.type?e.expression:e}},typescript:e=>class extends e{getScopeHandler(){return oe}tsIsIdentifier(){return this.match(c.name)}tsTokenCanFollowModifier(){return (this.match(c.bracketL)||this.match(c.braceL)||this.match(c.star)||this.match(c.ellipsis)||this.match(c.privateName)||this.isLiteralPropertyName())&&!this.hasPrecedingLineBreak()}tsNextTokenCanFollowModifier(){return this.next(),this.tsTokenCanFollowModifier()}tsParseModifier(e){if(!this.match(c.name))return;const t=this.state.value;return -1!==e.indexOf(t)&&this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))?t:void 0}tsParseModifiers(e,t,r,n){const s=(t,r,n,s)=>{r===n&&e[s]&&this.raise(t,pe.InvalidModifiersOrder,n,s);},i=(t,r,n,s)=>{(e[n]&&r===s||e[s]&&r===n)&&this.raise(t,pe.IncompatibleModifiers,n,s);};for(;;){const o=this.state.start,a=this.tsParseModifier(t.concat(null!=r?r:[]));if(!a)break;de(a)?e.accessibility?this.raise(o,pe.DuplicateAccessibilityModifier):(s(o,a,a,"override"),s(o,a,a,"static"),e.accessibility=a):(Object.hasOwnProperty.call(e,a)?this.raise(o,pe.DuplicateModifier,a):(s(o,a,"static","readonly"),s(o,a,"static","override"),s(o,a,"override","readonly"),s(o,a,"abstract","override"),i(o,a,"declare","override"),i(o,a,"static","abstract")),e[a]=!0),null!=r&&r.includes(a)&&this.raise(o,n,a);}}tsIsListTerminator(e){switch(e){case"EnumMembers":case"TypeMembers":return this.match(c.braceR);case"HeritageClauseElement":return this.match(c.braceL);case"TupleElementTypes":return this.match(c.bracketR);case"TypeParametersOrArguments":return this.isRelational(">")}throw new Error("Unreachable")}tsParseList(e,t){const r=[];for(;!this.tsIsListTerminator(e);)r.push(t());return r}tsParseDelimitedList(e,t){return ue(this.tsParseDelimitedListWorker(e,t,!0))}tsParseDelimitedListWorker(e,t,r){const n=[];for(;!this.tsIsListTerminator(e);){const s=t();if(null==s)return;if(n.push(s),!this.eat(c.comma)){if(this.tsIsListTerminator(e))break;return void(r&&this.expect(c.comma))}}return n}tsParseBracketedList(e,t,r,n){n||(r?this.expect(c.bracketL):this.expectRelational("<"));const s=this.tsParseDelimitedList(e,t);return r?this.expect(c.bracketR):this.expectRelational(">"),s}tsParseImportType(){const e=this.startNode();return this.expect(c._import),this.expect(c.parenL),this.match(c.string)||this.raise(this.state.start,pe.UnsupportedImportTypeArgument),e.argument=this.parseExprAtom(),this.expect(c.parenR),this.eat(c.dot)&&(e.qualifier=this.tsParseEntityName(!0)),this.isRelational("<")&&(e.typeParameters=this.tsParseTypeArguments()),this.finishNode(e,"TSImportType")}tsParseEntityName(e){let t=this.parseIdentifier();for(;this.eat(c.dot);){const r=this.startNodeAtNode(t);r.left=t,r.right=this.parseIdentifier(e),t=this.finishNode(r,"TSQualifiedName");}return t}tsParseTypeReference(){const e=this.startNode();return e.typeName=this.tsParseEntityName(!1),!this.hasPrecedingLineBreak()&&this.isRelational("<")&&(e.typeParameters=this.tsParseTypeArguments()),this.finishNode(e,"TSTypeReference")}tsParseThisTypePredicate(e){this.next();const t=this.startNodeAtNode(e);return t.parameterName=e,t.typeAnnotation=this.tsParseTypeAnnotation(!1),t.asserts=!1,this.finishNode(t,"TSTypePredicate")}tsParseThisTypeNode(){const e=this.startNode();return this.next(),this.finishNode(e,"TSThisType")}tsParseTypeQuery(){const e=this.startNode();return this.expect(c._typeof),this.match(c._import)?e.exprName=this.tsParseImportType():e.exprName=this.tsParseEntityName(!0),this.finishNode(e,"TSTypeQuery")}tsParseTypeParameter(){const e=this.startNode();return e.name=this.parseIdentifierName(e.start),e.constraint=this.tsEatThenParseType(c._extends),e.default=this.tsEatThenParseType(c.eq),this.finishNode(e,"TSTypeParameter")}tsTryParseTypeParameters(){if(this.isRelational("<"))return this.tsParseTypeParameters()}tsParseTypeParameters(){const e=this.startNode();return this.isRelational("<")||this.match(c.jsxTagStart)?this.next():this.unexpected(),e.params=this.tsParseBracketedList("TypeParametersOrArguments",this.tsParseTypeParameter.bind(this),!1,!0),0===e.params.length&&this.raise(e.start,pe.EmptyTypeParameters),this.finishNode(e,"TSTypeParameterDeclaration")}tsTryNextParseConstantContext(){return this.lookahead().type===c._const?(this.next(),this.tsParseTypeReference()):null}tsFillSignature(e,t){const r=e===c.arrow;t.typeParameters=this.tsTryParseTypeParameters(),this.expect(c.parenL),t.parameters=this.tsParseBindingListForSignature(),(r||this.match(e))&&(t.typeAnnotation=this.tsParseTypeOrTypePredicateAnnotation(e));}tsParseBindingListForSignature(){return this.parseBindingList(c.parenR,41).map((e=>("Identifier"!==e.type&&"RestElement"!==e.type&&"ObjectPattern"!==e.type&&"ArrayPattern"!==e.type&&this.raise(e.start,pe.UnsupportedSignatureParameterKind,e.type),e)))}tsParseTypeMemberSemicolon(){this.eat(c.comma)||this.isLineTerminator()||this.expect(c.semi);}tsParseSignatureMember(e,t){return this.tsFillSignature(c.colon,t),this.tsParseTypeMemberSemicolon(),this.finishNode(t,e)}tsIsUnambiguouslyIndexSignature(){return this.next(),this.eat(c.name)&&this.match(c.colon)}tsTryParseIndexSignature(e){if(!this.match(c.bracketL)||!this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))return;this.expect(c.bracketL);const t=this.parseIdentifier();t.typeAnnotation=this.tsParseTypeAnnotation(),this.resetEndLocation(t),this.expect(c.bracketR),e.parameters=[t];const r=this.tsTryParseTypeAnnotation();return r&&(e.typeAnnotation=r),this.tsParseTypeMemberSemicolon(),this.finishNode(e,"TSIndexSignature")}tsParsePropertyOrMethodSignature(e,t){this.eat(c.question)&&(e.optional=!0);const r=e;if(this.match(c.parenL)||this.isRelational("<")){t&&this.raise(e.start,pe.ReadonlyForMethodSignature);const n=r;if(n.kind&&this.isRelational("<")&&this.raise(this.state.pos,pe.AccesorCannotHaveTypeParameters),this.tsFillSignature(c.colon,n),this.tsParseTypeMemberSemicolon(),"get"===n.kind)n.parameters.length>0&&(this.raise(this.state.pos,v.BadGetterArity),this.isThisParam(n.parameters[0])&&this.raise(this.state.pos,pe.AccesorCannotDeclareThisParameter));else if("set"===n.kind){if(1!==n.parameters.length)this.raise(this.state.pos,v.BadSetterArity);else {const e=n.parameters[0];this.isThisParam(e)&&this.raise(this.state.pos,pe.AccesorCannotDeclareThisParameter),"Identifier"===e.type&&e.optional&&this.raise(this.state.pos,pe.SetAccesorCannotHaveOptionalParameter),"RestElement"===e.type&&this.raise(this.state.pos,pe.SetAccesorCannotHaveRestParameter);}n.typeAnnotation&&this.raise(n.typeAnnotation.start,pe.SetAccesorCannotHaveReturnType);}else n.kind="method";return this.finishNode(n,"TSMethodSignature")}{const e=r;t&&(e.readonly=!0);const n=this.tsTryParseTypeAnnotation();return n&&(e.typeAnnotation=n),this.tsParseTypeMemberSemicolon(),this.finishNode(e,"TSPropertySignature")}}tsParseTypeMember(){const e=this.startNode();if(this.match(c.parenL)||this.isRelational("<"))return this.tsParseSignatureMember("TSCallSignatureDeclaration",e);if(this.match(c._new)){const t=this.startNode();return this.next(),this.match(c.parenL)||this.isRelational("<")?this.tsParseSignatureMember("TSConstructSignatureDeclaration",e):(e.key=this.createIdentifier(t,"new"),this.tsParsePropertyOrMethodSignature(e,!1))}this.tsParseModifiers(e,["readonly"],["declare","abstract","private","protected","public","static","override"],pe.InvalidModifierOnTypeMember);return this.tsTryParseIndexSignature(e)||(this.parsePropertyName(e,!1),e.computed||"Identifier"!==e.key.type||"get"!==e.key.name&&"set"!==e.key.name||!this.tsTokenCanFollowModifier()||(e.kind=e.key.name,this.parsePropertyName(e,!1)),this.tsParsePropertyOrMethodSignature(e,!!e.readonly))}tsParseTypeLiteral(){const e=this.startNode();return e.members=this.tsParseObjectTypeMembers(),this.finishNode(e,"TSTypeLiteral")}tsParseObjectTypeMembers(){this.expect(c.braceL);const e=this.tsParseList("TypeMembers",this.tsParseTypeMember.bind(this));return this.expect(c.braceR),e}tsIsStartOfMappedType(){return this.next(),this.eat(c.plusMin)?this.isContextual("readonly"):(this.isContextual("readonly")&&this.next(),!!this.match(c.bracketL)&&(this.next(),!!this.tsIsIdentifier()&&(this.next(),this.match(c._in))))}tsParseMappedTypeParameter(){const e=this.startNode();return e.name=this.parseIdentifierName(e.start),e.constraint=this.tsExpectThenParseType(c._in),this.finishNode(e,"TSTypeParameter")}tsParseMappedType(){const e=this.startNode();return this.expect(c.braceL),this.match(c.plusMin)?(e.readonly=this.state.value,this.next(),this.expectContextual("readonly")):this.eatContextual("readonly")&&(e.readonly=!0),this.expect(c.bracketL),e.typeParameter=this.tsParseMappedTypeParameter(),e.nameType=this.eatContextual("as")?this.tsParseType():null,this.expect(c.bracketR),this.match(c.plusMin)?(e.optional=this.state.value,this.next(),this.expect(c.question)):this.eat(c.question)&&(e.optional=!0),e.typeAnnotation=this.tsTryParseType(),this.semicolon(),this.expect(c.braceR),this.finishNode(e,"TSMappedType")}tsParseTupleType(){const e=this.startNode();e.elementTypes=this.tsParseBracketedList("TupleElementTypes",this.tsParseTupleElementType.bind(this),!0,!1);let t=!1,r=null;return e.elementTypes.forEach((e=>{var n;let{type:s}=e;!t||"TSRestType"===s||"TSOptionalType"===s||"TSNamedTupleMember"===s&&e.optional||this.raise(e.start,pe.OptionalTypeBeforeRequired),t=t||"TSNamedTupleMember"===s&&e.optional||"TSOptionalType"===s,"TSRestType"===s&&(s=(e=e.typeAnnotation).type);const i="TSNamedTupleMember"===s;r=null!=(n=r)?n:i,r!==i&&this.raise(e.start,pe.MixedLabeledAndUnlabeledElements);})),this.finishNode(e,"TSTupleType")}tsParseTupleElementType(){const{start:e,startLoc:t}=this.state,r=this.eat(c.ellipsis);let n=this.tsParseType();const s=this.eat(c.question);if(this.eat(c.colon)){const e=this.startNodeAtNode(n);e.optional=s,"TSTypeReference"!==n.type||n.typeParameters||"Identifier"!==n.typeName.type?(this.raise(n.start,pe.InvalidTupleMemberLabel),e.label=n):e.label=n.typeName,e.elementType=this.tsParseType(),n=this.finishNode(e,"TSNamedTupleMember");}else if(s){const e=this.startNodeAtNode(n);e.typeAnnotation=n,n=this.finishNode(e,"TSOptionalType");}if(r){const r=this.startNodeAt(e,t);r.typeAnnotation=n,n=this.finishNode(r,"TSRestType");}return n}tsParseParenthesizedType(){const e=this.startNode();return this.expect(c.parenL),e.typeAnnotation=this.tsParseType(),this.expect(c.parenR),this.finishNode(e,"TSParenthesizedType")}tsParseFunctionOrConstructorType(e,t){const r=this.startNode();return "TSConstructorType"===e&&(r.abstract=!!t,t&&this.next(),this.next()),this.tsFillSignature(c.arrow,r),this.finishNode(r,e)}tsParseLiteralTypeNode(){const e=this.startNode();return e.literal=(()=>{switch(this.state.type){case c.num:case c.bigint:case c.string:case c._true:case c._false:return this.parseExprAtom();default:throw this.unexpected()}})(),this.finishNode(e,"TSLiteralType")}tsParseTemplateLiteralType(){const e=this.startNode();return e.literal=this.parseTemplate(!1),this.finishNode(e,"TSLiteralType")}parseTemplateSubstitution(){return this.state.inType?this.tsParseType():super.parseTemplateSubstitution()}tsParseThisTypeOrThisTypePredicate(){const e=this.tsParseThisTypeNode();return this.isContextual("is")&&!this.hasPrecedingLineBreak()?this.tsParseThisTypePredicate(e):e}tsParseNonArrayType(){switch(this.state.type){case c.name:case c._void:case c._null:{const e=this.match(c._void)?"TSVoidKeyword":this.match(c._null)?"TSNullKeyword":function(e){switch(e){case"any":return "TSAnyKeyword";case"boolean":return "TSBooleanKeyword";case"bigint":return "TSBigIntKeyword";case"never":return "TSNeverKeyword";case"number":return "TSNumberKeyword";case"object":return "TSObjectKeyword";case"string":return "TSStringKeyword";case"symbol":return "TSSymbolKeyword";case"undefined":return "TSUndefinedKeyword";case"unknown":return "TSUnknownKeyword";default:return}}(this.state.value);if(void 0!==e&&46!==this.lookaheadCharCode()){const t=this.startNode();return this.next(),this.finishNode(t,e)}return this.tsParseTypeReference()}case c.string:case c.num:case c.bigint:case c._true:case c._false:return this.tsParseLiteralTypeNode();case c.plusMin:if("-"===this.state.value){const e=this.startNode(),t=this.lookahead();if(t.type!==c.num&&t.type!==c.bigint)throw this.unexpected();return e.literal=this.parseMaybeUnary(),this.finishNode(e,"TSLiteralType")}break;case c._this:return this.tsParseThisTypeOrThisTypePredicate();case c._typeof:return this.tsParseTypeQuery();case c._import:return this.tsParseImportType();case c.braceL:return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))?this.tsParseMappedType():this.tsParseTypeLiteral();case c.bracketL:return this.tsParseTupleType();case c.parenL:return this.tsParseParenthesizedType();case c.backQuote:return this.tsParseTemplateLiteralType()}throw this.unexpected()}tsParseArrayTypeOrHigher(){let e=this.tsParseNonArrayType();for(;!this.hasPrecedingLineBreak()&&this.eat(c.bracketL);)if(this.match(c.bracketR)){const t=this.startNodeAtNode(e);t.elementType=e,this.expect(c.bracketR),e=this.finishNode(t,"TSArrayType");}else {const t=this.startNodeAtNode(e);t.objectType=e,t.indexType=this.tsParseType(),this.expect(c.bracketR),e=this.finishNode(t,"TSIndexedAccessType");}return e}tsParseTypeOperator(e){const t=this.startNode();return this.expectContextual(e),t.operator=e,t.typeAnnotation=this.tsParseTypeOperatorOrHigher(),"readonly"===e&&this.tsCheckTypeAnnotationForReadOnly(t),this.finishNode(t,"TSTypeOperator")}tsCheckTypeAnnotationForReadOnly(e){switch(e.typeAnnotation.type){case"TSTupleType":case"TSArrayType":return;default:this.raise(e.start,pe.UnexpectedReadonly);}}tsParseInferType(){const e=this.startNode();this.expectContextual("infer");const t=this.startNode();return t.name=this.parseIdentifierName(t.start),e.typeParameter=this.finishNode(t,"TSTypeParameter"),this.finishNode(e,"TSInferType")}tsParseTypeOperatorOrHigher(){const e=["keyof","unique","readonly"].find((e=>this.isContextual(e)));return e?this.tsParseTypeOperator(e):this.isContextual("infer")?this.tsParseInferType():this.tsParseArrayTypeOrHigher()}tsParseUnionOrIntersectionType(e,t,r){const n=this.startNode(),s=this.eat(r),i=[];do{i.push(t());}while(this.eat(r));return 1!==i.length||s?(n.types=i,this.finishNode(n,e)):i[0]}tsParseIntersectionTypeOrHigher(){return this.tsParseUnionOrIntersectionType("TSIntersectionType",this.tsParseTypeOperatorOrHigher.bind(this),c.bitwiseAND)}tsParseUnionTypeOrHigher(){return this.tsParseUnionOrIntersectionType("TSUnionType",this.tsParseIntersectionTypeOrHigher.bind(this),c.bitwiseOR)}tsIsStartOfFunctionType(){return !!this.isRelational("<")||this.match(c.parenL)&&this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))}tsSkipParameterStart(){if(this.match(c.name)||this.match(c._this))return this.next(),!0;if(this.match(c.braceL)){let e=1;for(this.next();e>0;)this.match(c.braceL)?++e:this.match(c.braceR)&&--e,this.next();return !0}if(this.match(c.bracketL)){let e=1;for(this.next();e>0;)this.match(c.bracketL)?++e:this.match(c.bracketR)&&--e,this.next();return !0}return !1}tsIsUnambiguouslyStartOfFunctionType(){if(this.next(),this.match(c.parenR)||this.match(c.ellipsis))return !0;if(this.tsSkipParameterStart()){if(this.match(c.colon)||this.match(c.comma)||this.match(c.question)||this.match(c.eq))return !0;if(this.match(c.parenR)&&(this.next(),this.match(c.arrow)))return !0}return !1}tsParseTypeOrTypePredicateAnnotation(e){return this.tsInType((()=>{const t=this.startNode();this.expect(e);const r=this.startNode(),n=!!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));if(n&&this.match(c._this)){let e=this.tsParseThisTypeOrThisTypePredicate();return "TSThisType"===e.type?(r.parameterName=e,r.asserts=!0,e=this.finishNode(r,"TSTypePredicate")):(this.resetStartLocationFromNode(e,r),e.asserts=!0),t.typeAnnotation=e,this.finishNode(t,"TSTypeAnnotation")}const s=this.tsIsIdentifier()&&this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));if(!s)return n?(r.parameterName=this.parseIdentifier(),r.asserts=n,t.typeAnnotation=this.finishNode(r,"TSTypePredicate"),this.finishNode(t,"TSTypeAnnotation")):this.tsParseTypeAnnotation(!1,t);const i=this.tsParseTypeAnnotation(!1);return r.parameterName=s,r.typeAnnotation=i,r.asserts=n,t.typeAnnotation=this.finishNode(r,"TSTypePredicate"),this.finishNode(t,"TSTypeAnnotation")}))}tsTryParseTypeOrTypePredicateAnnotation(){return this.match(c.colon)?this.tsParseTypeOrTypePredicateAnnotation(c.colon):void 0}tsTryParseTypeAnnotation(){return this.match(c.colon)?this.tsParseTypeAnnotation():void 0}tsTryParseType(){return this.tsEatThenParseType(c.colon)}tsParseTypePredicatePrefix(){const e=this.parseIdentifier();if(this.isContextual("is")&&!this.hasPrecedingLineBreak())return this.next(),e}tsParseTypePredicateAsserts(){if(!this.match(c.name)||"asserts"!==this.state.value||this.hasPrecedingLineBreak())return !1;const e=this.state.containsEsc;return this.next(),!(!this.match(c.name)&&!this.match(c._this)||(e&&this.raise(this.state.lastTokStart,v.InvalidEscapedReservedWord,"asserts"),0))}tsParseTypeAnnotation(e=!0,t=this.startNode()){return this.tsInType((()=>{e&&this.expect(c.colon),t.typeAnnotation=this.tsParseType();})),this.finishNode(t,"TSTypeAnnotation")}tsParseType(){ce(this.state.inType);const e=this.tsParseNonConditionalType();if(this.hasPrecedingLineBreak()||!this.eat(c._extends))return e;const t=this.startNodeAtNode(e);return t.checkType=e,t.extendsType=this.tsParseNonConditionalType(),this.expect(c.question),t.trueType=this.tsParseType(),this.expect(c.colon),t.falseType=this.tsParseType(),this.finishNode(t,"TSConditionalType")}isAbstractConstructorSignature(){return this.isContextual("abstract")&&this.lookahead().type===c._new}tsParseNonConditionalType(){return this.tsIsStartOfFunctionType()?this.tsParseFunctionOrConstructorType("TSFunctionType"):this.match(c._new)?this.tsParseFunctionOrConstructorType("TSConstructorType"):this.isAbstractConstructorSignature()?this.tsParseFunctionOrConstructorType("TSConstructorType",!0):this.tsParseUnionTypeOrHigher()}tsParseTypeAssertion(){const e=this.startNode(),t=this.tsTryNextParseConstantContext();return e.typeAnnotation=t||this.tsNextThenParseType(),this.expectRelational(">"),e.expression=this.parseMaybeUnary(),this.finishNode(e,"TSTypeAssertion")}tsParseHeritageClause(e){const t=this.state.start,r=this.tsParseDelimitedList("HeritageClauseElement",this.tsParseExpressionWithTypeArguments.bind(this));return r.length||this.raise(t,pe.EmptyHeritageClauseType,e),r}tsParseExpressionWithTypeArguments(){const e=this.startNode();return e.expression=this.tsParseEntityName(!1),this.isRelational("<")&&(e.typeParameters=this.tsParseTypeArguments()),this.finishNode(e,"TSExpressionWithTypeArguments")}tsParseInterfaceDeclaration(e){e.id=this.parseIdentifier(),this.checkLVal(e.id,"typescript interface declaration",130),e.typeParameters=this.tsTryParseTypeParameters(),this.eat(c._extends)&&(e.extends=this.tsParseHeritageClause("extends"));const t=this.startNode();return t.body=this.tsInType(this.tsParseObjectTypeMembers.bind(this)),e.body=this.finishNode(t,"TSInterfaceBody"),this.finishNode(e,"TSInterfaceDeclaration")}tsParseTypeAliasDeclaration(e){return e.id=this.parseIdentifier(),this.checkLVal(e.id,"typescript type alias",2),e.typeParameters=this.tsTryParseTypeParameters(),e.typeAnnotation=this.tsInType((()=>{if(this.expect(c.eq),this.isContextual("intrinsic")&&this.lookahead().type!==c.dot){const e=this.startNode();return this.next(),this.finishNode(e,"TSIntrinsicKeyword")}return this.tsParseType()})),this.semicolon(),this.finishNode(e,"TSTypeAliasDeclaration")}tsInNoContext(e){const t=this.state.context;this.state.context=[t[0]];try{return e()}finally{this.state.context=t;}}tsInType(e){const t=this.state.inType;this.state.inType=!0;try{return e()}finally{this.state.inType=t;}}tsEatThenParseType(e){return this.match(e)?this.tsNextThenParseType():void 0}tsExpectThenParseType(e){return this.tsDoThenParseType((()=>this.expect(e)))}tsNextThenParseType(){return this.tsDoThenParseType((()=>this.next()))}tsDoThenParseType(e){return this.tsInType((()=>(e(),this.tsParseType())))}tsParseEnumMember(){const e=this.startNode();return e.id=this.match(c.string)?this.parseExprAtom():this.parseIdentifier(!0),this.eat(c.eq)&&(e.initializer=this.parseMaybeAssignAllowIn()),this.finishNode(e,"TSEnumMember")}tsParseEnumDeclaration(e,t){return t&&(e.const=!0),e.id=this.parseIdentifier(),this.checkLVal(e.id,"typescript enum declaration",t?779:267),this.expect(c.braceL),e.members=this.tsParseDelimitedList("EnumMembers",this.tsParseEnumMember.bind(this)),this.expect(c.braceR),this.finishNode(e,"TSEnumDeclaration")}tsParseModuleBlock(){const e=this.startNode();return this.scope.enter(0),this.expect(c.braceL),this.parseBlockOrModuleBlockBody(e.body=[],void 0,!0,c.braceR),this.scope.exit(),this.finishNode(e,"TSModuleBlock")}tsParseModuleOrNamespaceDeclaration(e,t=!1){if(e.id=this.parseIdentifier(),t||this.checkLVal(e.id,"module or namespace declaration",1024),this.eat(c.dot)){const t=this.startNode();this.tsParseModuleOrNamespaceDeclaration(t,!0),e.body=t;}else this.scope.enter(256),this.prodParam.enter(0),e.body=this.tsParseModuleBlock(),this.prodParam.exit(),this.scope.exit();return this.finishNode(e,"TSModuleDeclaration")}tsParseAmbientExternalModuleDeclaration(e){return this.isContextual("global")?(e.global=!0,e.id=this.parseIdentifier()):this.match(c.string)?e.id=this.parseExprAtom():this.unexpected(),this.match(c.braceL)?(this.scope.enter(256),this.prodParam.enter(0),e.body=this.tsParseModuleBlock(),this.prodParam.exit(),this.scope.exit()):this.semicolon(),this.finishNode(e,"TSModuleDeclaration")}tsParseImportEqualsDeclaration(e,t){e.isExport=t||!1,e.id=this.parseIdentifier(),this.checkLVal(e.id,"import equals declaration",9),this.expect(c.eq);const r=this.tsParseModuleReference();return "type"===e.importKind&&"TSExternalModuleReference"!==r.type&&this.raise(r.start,pe.ImportAliasHasImportType),e.moduleReference=r,this.semicolon(),this.finishNode(e,"TSImportEqualsDeclaration")}tsIsExternalModuleReference(){return this.isContextual("require")&&40===this.lookaheadCharCode()}tsParseModuleReference(){return this.tsIsExternalModuleReference()?this.tsParseExternalModuleReference():this.tsParseEntityName(!1)}tsParseExternalModuleReference(){const e=this.startNode();if(this.expectContextual("require"),this.expect(c.parenL),!this.match(c.string))throw this.unexpected();return e.expression=this.parseExprAtom(),this.expect(c.parenR),this.finishNode(e,"TSExternalModuleReference")}tsLookAhead(e){const t=this.state.clone(),r=e();return this.state=t,r}tsTryParseAndCatch(e){const t=this.tryParse((t=>e()||t()));if(!t.aborted&&t.node)return t.error&&(this.state=t.failState),t.node}tsTryParse(e){const t=this.state.clone(),r=e();return void 0!==r&&!1!==r?r:void(this.state=t)}tsTryParseDeclare(e){if(this.isLineTerminator())return;let t,r=this.state.type;return this.isContextual("let")&&(r=c._var,t="let"),this.tsInAmbientContext((()=>{switch(r){case c._function:return e.declare=!0,this.parseFunctionStatement(e,!1,!0);case c._class:return e.declare=!0,this.parseClass(e,!0,!1);case c._const:if(this.match(c._const)&&this.isLookaheadContextual("enum"))return this.expect(c._const),this.expectContextual("enum"),this.tsParseEnumDeclaration(e,!0);case c._var:return t=t||this.state.value,this.parseVarStatement(e,t);case c.name:{const t=this.state.value;return "global"===t?this.tsParseAmbientExternalModuleDeclaration(e):this.tsParseDeclaration(e,t,!0)}}}))}tsTryParseExportDeclaration(){return this.tsParseDeclaration(this.startNode(),this.state.value,!0)}tsParseExpressionStatement(e,t){switch(t.name){case"declare":{const t=this.tsTryParseDeclare(e);if(t)return t.declare=!0,t;break}case"global":if(this.match(c.braceL)){this.scope.enter(256),this.prodParam.enter(0);const r=e;return r.global=!0,r.id=t,r.body=this.tsParseModuleBlock(),this.scope.exit(),this.prodParam.exit(),this.finishNode(r,"TSModuleDeclaration")}break;default:return this.tsParseDeclaration(e,t.name,!1)}}tsParseDeclaration(e,t,r){switch(t){case"abstract":if(this.tsCheckLineTerminator(r)&&(this.match(c._class)||this.match(c.name)))return this.tsParseAbstractDeclaration(e);break;case"enum":if(r||this.match(c.name))return r&&this.next(),this.tsParseEnumDeclaration(e,!1);break;case"interface":if(this.tsCheckLineTerminator(r)&&this.match(c.name))return this.tsParseInterfaceDeclaration(e);break;case"module":if(this.tsCheckLineTerminator(r)){if(this.match(c.string))return this.tsParseAmbientExternalModuleDeclaration(e);if(this.match(c.name))return this.tsParseModuleOrNamespaceDeclaration(e)}break;case"namespace":if(this.tsCheckLineTerminator(r)&&this.match(c.name))return this.tsParseModuleOrNamespaceDeclaration(e);break;case"type":if(this.tsCheckLineTerminator(r)&&this.match(c.name))return this.tsParseTypeAliasDeclaration(e)}}tsCheckLineTerminator(e){return e?!this.hasFollowingLineBreak()&&(this.next(),!0):!this.isLineTerminator()}tsTryParseGenericAsyncArrowFunction(e,t){if(!this.isRelational("<"))return;const r=this.state.maybeInArrowParameters;this.state.maybeInArrowParameters=!0;const n=this.tsTryParseAndCatch((()=>{const r=this.startNodeAt(e,t);return r.typeParameters=this.tsParseTypeParameters(),super.parseFunctionParams(r),r.returnType=this.tsTryParseTypeOrTypePredicateAnnotation(),this.expect(c.arrow),r}));return this.state.maybeInArrowParameters=r,n?this.parseArrowExpression(n,null,!0):void 0}tsParseTypeArguments(){const e=this.startNode();return e.params=this.tsInType((()=>this.tsInNoContext((()=>(this.expectRelational("<"),this.tsParseDelimitedList("TypeParametersOrArguments",this.tsParseType.bind(this))))))),0===e.params.length&&this.raise(e.start,pe.EmptyTypeArguments),this.state.exprAllowed=!1,this.expectRelational(">"),this.finishNode(e,"TSTypeParameterInstantiation")}tsIsDeclarationStart(){if(this.match(c.name))switch(this.state.value){case"abstract":case"declare":case"enum":case"interface":case"module":case"namespace":case"type":return !0}return !1}isExportDefaultSpecifier(){return !this.tsIsDeclarationStart()&&super.isExportDefaultSpecifier()}parseAssignableListItem(e,t){const r=this.state.start,n=this.state.startLoc;let s,i=!1;void 0!==e&&(s=this.parseAccessModifier(),i=!!this.tsParseModifier(["readonly"]),!1===e&&(s||i)&&this.raise(r,pe.UnexpectedParameterModifier));const o=this.parseMaybeDefault();this.parseAssignableListItemTypes(o);const a=this.parseMaybeDefault(o.start,o.loc.start,o);if(s||i){const e=this.startNodeAt(r,n);return t.length&&(e.decorators=t),s&&(e.accessibility=s),i&&(e.readonly=i),"Identifier"!==a.type&&"AssignmentPattern"!==a.type&&this.raise(e.start,pe.UnsupportedParameterPropertyKind),e.parameter=a,this.finishNode(e,"TSParameterProperty")}return t.length&&(o.decorators=t),a}parseFunctionBodyAndFinish(e,t,r=!1){this.match(c.colon)&&(e.returnType=this.tsParseTypeOrTypePredicateAnnotation(c.colon));const n="FunctionDeclaration"===t?"TSDeclareFunction":"ClassMethod"===t?"TSDeclareMethod":void 0;n&&!this.match(c.braceL)&&this.isLineTerminator()?this.finishNode(e,n):"TSDeclareFunction"===n&&this.state.isAmbientContext&&(this.raise(e.start,pe.DeclareFunctionHasImplementation),e.declare)?super.parseFunctionBodyAndFinish(e,n,r):super.parseFunctionBodyAndFinish(e,t,r);}registerFunctionStatementId(e){!e.body&&e.id?this.checkLVal(e.id,"function name",1024):super.registerFunctionStatementId(...arguments);}tsCheckForInvalidTypeCasts(e){e.forEach((e=>{"TSTypeCastExpression"===(null==e?void 0:e.type)&&this.raise(e.typeAnnotation.start,pe.UnexpectedTypeAnnotation);}));}toReferencedList(e,t){return this.tsCheckForInvalidTypeCasts(e),e}parseArrayLike(...e){const t=super.parseArrayLike(...e);return "ArrayExpression"===t.type&&this.tsCheckForInvalidTypeCasts(t.elements),t}parseSubscript(e,t,r,n,s){if(!this.hasPrecedingLineBreak()&&this.match(c.bang)){this.state.exprAllowed=!1,this.next();const n=this.startNodeAt(t,r);return n.expression=e,this.finishNode(n,"TSNonNullExpression")}if(this.isRelational("<")){const i=this.tsTryParseAndCatch((()=>{if(!n&&this.atPossibleAsyncArrow(e)){const e=this.tsTryParseGenericAsyncArrowFunction(t,r);if(e)return e}const i=this.startNodeAt(t,r);i.callee=e;const o=this.tsParseTypeArguments();if(o){if(!n&&this.eat(c.parenL))return i.arguments=this.parseCallExpressionArguments(c.parenR,!1),this.tsCheckForInvalidTypeCasts(i.arguments),i.typeParameters=o,s.optionalChainMember&&(i.optional=!1),this.finishCallExpression(i,s.optionalChainMember);if(this.match(c.backQuote)){const n=this.parseTaggedTemplateExpression(e,t,r,s);return n.typeParameters=o,n}}this.unexpected();}));if(i)return i}return super.parseSubscript(e,t,r,n,s)}parseNewArguments(e){if(this.isRelational("<")){const t=this.tsTryParseAndCatch((()=>{const e=this.tsParseTypeArguments();return this.match(c.parenL)||this.unexpected(),e}));t&&(e.typeParameters=t);}super.parseNewArguments(e);}parseExprOp(e,t,r,n){if(ue(c._in.binop)>n&&!this.hasPrecedingLineBreak()&&this.isContextual("as")){const s=this.startNodeAt(t,r);s.expression=e;const i=this.tsTryNextParseConstantContext();return s.typeAnnotation=i||this.tsNextThenParseType(),this.finishNode(s,"TSAsExpression"),this.reScan_lt_gt(),this.parseExprOp(s,t,r,n)}return super.parseExprOp(e,t,r,n)}checkReservedWord(e,t,r,n){}checkDuplicateExports(){}parseImport(e){if(e.importKind="value",this.match(c.name)||this.match(c.star)||this.match(c.braceL)){let t=this.lookahead();if(!this.isContextual("type")||t.type===c.comma||t.type===c.name&&"from"===t.value||t.type===c.eq||(e.importKind="type",this.next(),t=this.lookahead()),this.match(c.name)&&t.type===c.eq)return this.tsParseImportEqualsDeclaration(e)}const t=super.parseImport(e);return "type"===t.importKind&&t.specifiers.length>1&&"ImportDefaultSpecifier"===t.specifiers[0].type&&this.raise(t.start,pe.TypeImportCannotSpecifyDefaultAndNamed),t}parseExport(e){if(this.match(c._import))return this.next(),this.isContextual("type")&&61!==this.lookaheadCharCode()?(e.importKind="type",this.next()):e.importKind="value",this.tsParseImportEqualsDeclaration(e,!0);if(this.eat(c.eq)){const t=e;return t.expression=this.parseExpression(),this.semicolon(),this.finishNode(t,"TSExportAssignment")}if(this.eatContextual("as")){const t=e;return this.expectContextual("namespace"),t.id=this.parseIdentifier(),this.semicolon(),this.finishNode(t,"TSNamespaceExportDeclaration")}return this.isContextual("type")&&this.lookahead().type===c.braceL?(this.next(),e.exportKind="type"):e.exportKind="value",super.parseExport(e)}isAbstractClass(){return this.isContextual("abstract")&&this.lookahead().type===c._class}parseExportDefaultExpression(){if(this.isAbstractClass()){const e=this.startNode();return this.next(),e.abstract=!0,this.parseClass(e,!0,!0),e}if("interface"===this.state.value){const e=this.tsParseDeclaration(this.startNode(),this.state.value,!0);if(e)return e}return super.parseExportDefaultExpression()}parseStatementContent(e,t){if(this.state.type===c._const){const e=this.lookahead();if(e.type===c.name&&"enum"===e.value){const e=this.startNode();return this.expect(c._const),this.expectContextual("enum"),this.tsParseEnumDeclaration(e,!0)}}return super.parseStatementContent(e,t)}parseAccessModifier(){return this.tsParseModifier(["public","protected","private"])}tsHasSomeModifiers(e,t){return t.some((t=>de(t)?e.accessibility===t:!!e[t]))}parseClassMember(e,t,r){const n=["declare","private","public","protected","override","abstract","readonly"];this.tsParseModifiers(t,n.concat(["static"]));const s=()=>{const s=!!t.static;s&&this.eat(c.braceL)?(this.tsHasSomeModifiers(t,n)&&this.raise(this.state.pos,pe.StaticBlockCannotHaveModifier),this.parseClassStaticBlock(e,t)):this.parseClassMemberWithIsStatic(e,t,r,s);};t.declare?this.tsInAmbientContext(s):s();}parseClassMemberWithIsStatic(e,t,r,n){const s=this.tsTryParseIndexSignature(t);if(s)return e.body.push(s),t.abstract&&this.raise(t.start,pe.IndexSignatureHasAbstract),t.accessibility&&this.raise(t.start,pe.IndexSignatureHasAccessibility,t.accessibility),t.declare&&this.raise(t.start,pe.IndexSignatureHasDeclare),void(t.override&&this.raise(t.start,pe.IndexSignatureHasOverride));!this.state.inAbstractClass&&t.abstract&&this.raise(t.start,pe.NonAbstractClassHasAbstractMethod),t.override&&(r.hadSuperClass||this.raise(t.start,pe.OverrideNotInSubClass)),super.parseClassMemberWithIsStatic(e,t,r,n);}parsePostMemberNameModifiers(e){this.eat(c.question)&&(e.optional=!0),e.readonly&&this.match(c.parenL)&&this.raise(e.start,pe.ClassMethodHasReadonly),e.declare&&this.match(c.parenL)&&this.raise(e.start,pe.ClassMethodHasDeclare);}parseExpressionStatement(e,t){return ("Identifier"===t.type?this.tsParseExpressionStatement(e,t):void 0)||super.parseExpressionStatement(e,t)}shouldParseExportDeclaration(){return !!this.tsIsDeclarationStart()||super.shouldParseExportDeclaration()}parseConditional(e,t,r,n){if(!n||!this.match(c.question))return super.parseConditional(e,t,r,n);const s=this.tryParse((()=>super.parseConditional(e,t,r)));return s.node?(s.error&&(this.state=s.failState),s.node):(n.start=s.error.pos||this.state.start,e)}parseParenItem(e,t,r){if(e=super.parseParenItem(e,t,r),this.eat(c.question)&&(e.optional=!0,this.resetEndLocation(e)),this.match(c.colon)){const n=this.startNodeAt(t,r);return n.expression=e,n.typeAnnotation=this.tsParseTypeAnnotation(),this.finishNode(n,"TSTypeCastExpression")}return e}parseExportDeclaration(e){const t=this.state.start,r=this.state.startLoc,n=this.eatContextual("declare");if(n&&(this.isContextual("declare")||!this.shouldParseExportDeclaration()))throw this.raise(this.state.start,pe.ExpectedAmbientAfterExportDeclare);let s;return this.match(c.name)&&(s=this.tsTryParseExportDeclaration()),s||(s=super.parseExportDeclaration(e)),s&&("TSInterfaceDeclaration"===s.type||"TSTypeAliasDeclaration"===s.type||n)&&(e.exportKind="type"),s&&n&&(this.resetStartLocation(s,t,r),s.declare=!0),s}parseClassId(e,t,r){if((!t||r)&&this.isContextual("implements"))return;super.parseClassId(e,t,r,e.declare?1024:139);const n=this.tsTryParseTypeParameters();n&&(e.typeParameters=n);}parseClassPropertyAnnotation(e){!e.optional&&this.eat(c.bang)&&(e.definite=!0);const t=this.tsTryParseTypeAnnotation();t&&(e.typeAnnotation=t);}parseClassProperty(e){return this.parseClassPropertyAnnotation(e),this.state.isAmbientContext&&this.match(c.eq)&&this.raise(this.state.start,pe.DeclareClassFieldHasInitializer),super.parseClassProperty(e)}parseClassPrivateProperty(e){return e.abstract&&this.raise(e.start,pe.PrivateElementHasAbstract),e.accessibility&&this.raise(e.start,pe.PrivateElementHasAccessibility,e.accessibility),this.parseClassPropertyAnnotation(e),super.parseClassPrivateProperty(e)}pushClassMethod(e,t,r,n,s,i){const o=this.tsTryParseTypeParameters();o&&s&&this.raise(o.start,pe.ConstructorHasTypeParameters),!t.declare||"get"!==t.kind&&"set"!==t.kind||this.raise(t.start,pe.DeclareAccessor,t.kind),o&&(t.typeParameters=o),super.pushClassMethod(e,t,r,n,s,i);}pushClassPrivateMethod(e,t,r,n){const s=this.tsTryParseTypeParameters();s&&(t.typeParameters=s),super.pushClassPrivateMethod(e,t,r,n);}parseClassSuper(e){super.parseClassSuper(e),e.superClass&&this.isRelational("<")&&(e.superTypeParameters=this.tsParseTypeArguments()),this.eatContextual("implements")&&(e.implements=this.tsParseHeritageClause("implements"));}parseObjPropValue(e,...t){const r=this.tsTryParseTypeParameters();r&&(e.typeParameters=r),super.parseObjPropValue(e,...t);}parseFunctionParams(e,t){const r=this.tsTryParseTypeParameters();r&&(e.typeParameters=r),super.parseFunctionParams(e,t);}parseVarId(e,t){super.parseVarId(e,t),"Identifier"===e.id.type&&this.eat(c.bang)&&(e.definite=!0);const r=this.tsTryParseTypeAnnotation();r&&(e.id.typeAnnotation=r,this.resetEndLocation(e.id));}parseAsyncArrowFromCallExpression(e,t){return this.match(c.colon)&&(e.returnType=this.tsParseTypeAnnotation()),super.parseAsyncArrowFromCallExpression(e,t)}parseMaybeAssign(...e){var t,r,n,s,i,o,a;let l,u,p,d;if(this.hasPlugin("jsx")&&(this.match(c.jsxTagStart)||this.isRelational("<"))){if(l=this.state.clone(),u=this.tryParse((()=>super.parseMaybeAssign(...e)),l),!u.error)return u.node;const{context:t}=this.state;t[t.length-1]===P.j_oTag?t.length-=2:t[t.length-1]===P.j_expr&&(t.length-=1);}if(!(null!=(t=u)&&t.error||this.isRelational("<")))return super.parseMaybeAssign(...e);l=l||this.state.clone();const f=this.tryParse((t=>{var r,n;d=this.tsParseTypeParameters();const s=super.parseMaybeAssign(...e);return ("ArrowFunctionExpression"!==s.type||null!=(r=s.extra)&&r.parenthesized)&&t(),0!==(null==(n=d)?void 0:n.params.length)&&this.resetStartLocationFromNode(s,d),s.typeParameters=d,s}),l);if(!f.error&&!f.aborted)return f.node;if(!u&&(ce(!this.hasPlugin("jsx")),p=this.tryParse((()=>super.parseMaybeAssign(...e)),l),!p.error))return p.node;if(null!=(r=u)&&r.node)return this.state=u.failState,u.node;if(f.node)return this.state=f.failState,f.node;if(null!=(n=p)&&n.node)return this.state=p.failState,p.node;if(null!=(s=u)&&s.thrown)throw u.error;if(f.thrown)throw f.error;if(null!=(i=p)&&i.thrown)throw p.error;throw (null==(o=u)?void 0:o.error)||f.error||(null==(a=p)?void 0:a.error)}parseMaybeUnary(e){return !this.hasPlugin("jsx")&&this.isRelational("<")?this.tsParseTypeAssertion():super.parseMaybeUnary(e)}parseArrow(e){if(this.match(c.colon)){const t=this.tryParse((e=>{const t=this.tsParseTypeOrTypePredicateAnnotation(c.colon);return !this.canInsertSemicolon()&&this.match(c.arrow)||e(),t}));if(t.aborted)return;t.thrown||(t.error&&(this.state=t.failState),e.returnType=t.node);}return super.parseArrow(e)}parseAssignableListItemTypes(e){this.eat(c.question)&&("Identifier"===e.type||this.state.isAmbientContext||this.state.inType||this.raise(e.start,pe.PatternIsOptional),e.optional=!0);const t=this.tsTryParseTypeAnnotation();return t&&(e.typeAnnotation=t),this.resetEndLocation(e),e}toAssignable(e,t=!1){switch(e.type){case"TSTypeCastExpression":return super.toAssignable(this.typeCastToParameter(e),t);case"TSParameterProperty":return super.toAssignable(e,t);case"ParenthesizedExpression":return this.toAssignableParenthesizedExpression(e,t);case"TSAsExpression":case"TSNonNullExpression":case"TSTypeAssertion":return e.expression=this.toAssignable(e.expression,t),e;default:return super.toAssignable(e,t)}}toAssignableParenthesizedExpression(e,t){switch(e.expression.type){case"TSAsExpression":case"TSNonNullExpression":case"TSTypeAssertion":case"ParenthesizedExpression":return e.expression=this.toAssignable(e.expression,t),e;default:return super.toAssignable(e,t)}}checkLVal(e,t,...r){var n;switch(e.type){case"TSTypeCastExpression":return;case"TSParameterProperty":return void this.checkLVal(e.parameter,"parameter property",...r);case"TSAsExpression":case"TSTypeAssertion":if(!(r[0]||"parenthesized expression"===t||null!=(n=e.extra)&&n.parenthesized)){this.raise(e.start,v.InvalidLhs,t);break}return void this.checkLVal(e.expression,"parenthesized expression",...r);case"TSNonNullExpression":return void this.checkLVal(e.expression,t,...r);default:return void super.checkLVal(e,t,...r)}}parseBindingAtom(){switch(this.state.type){case c._this:return this.parseIdentifier(!0);default:return super.parseBindingAtom()}}parseMaybeDecoratorArguments(e){if(this.isRelational("<")){const t=this.tsParseTypeArguments();if(this.match(c.parenL)){const r=super.parseMaybeDecoratorArguments(e);return r.typeParameters=t,r}this.unexpected(this.state.start,c.parenL);}return super.parseMaybeDecoratorArguments(e)}checkCommaAfterRest(e){this.state.isAmbientContext&&this.match(c.comma)&&this.lookaheadCharCode()===e?this.next():super.checkCommaAfterRest(e);}isClassMethod(){return this.isRelational("<")||super.isClassMethod()}isClassProperty(){return this.match(c.bang)||this.match(c.colon)||super.isClassProperty()}parseMaybeDefault(...e){const t=super.parseMaybeDefault(...e);return "AssignmentPattern"===t.type&&t.typeAnnotation&&t.right.start<t.typeAnnotation.start&&this.raise(t.typeAnnotation.start,pe.TypeAnnotationAfterAssign),t}getTokenFromCode(e){return !this.state.inType||62!==e&&60!==e?super.getTokenFromCode(e):this.finishOp(c.relational,1)}reScan_lt_gt(){if(this.match(c.relational)){const e=this.input.charCodeAt(this.state.start);60!==e&&62!==e||(this.state.pos-=1,this.readToken_lt_gt(e));}}toAssignableList(e){for(let t=0;t<e.length;t++){const r=e[t];if(r)switch(r.type){case"TSTypeCastExpression":e[t]=this.typeCastToParameter(r);break;case"TSAsExpression":case"TSTypeAssertion":this.state.maybeInArrowParameters?this.raise(r.start,pe.UnexpectedTypeCastInParameter):e[t]=this.typeCastToParameter(r);}}return super.toAssignableList(...arguments)}typeCastToParameter(e){return e.expression.typeAnnotation=e.typeAnnotation,this.resetEndLocation(e.expression,e.typeAnnotation.end,e.typeAnnotation.loc.end),e.expression}shouldParseArrow(){return this.match(c.colon)||super.shouldParseArrow()}shouldParseAsyncArrow(){return this.match(c.colon)||super.shouldParseAsyncArrow()}canHaveLeadingDecorator(){return super.canHaveLeadingDecorator()||this.isAbstractClass()}jsxParseOpeningElementAfterName(e){if(this.isRelational("<")){const t=this.tsTryParseAndCatch((()=>this.tsParseTypeArguments()));t&&(e.typeParameters=t);}return super.jsxParseOpeningElementAfterName(e)}getGetterSetterExpectedParamCount(e){const t=super.getGetterSetterExpectedParamCount(e),r=this.getObjectOrClassMethodParams(e)[0];return r&&this.isThisParam(r)?t+1:t}parseCatchClauseParam(){const e=super.parseCatchClauseParam(),t=this.tsTryParseTypeAnnotation();return t&&(e.typeAnnotation=t,this.resetEndLocation(e)),e}tsInAmbientContext(e){const t=this.state.isAmbientContext;this.state.isAmbientContext=!0;try{return e()}finally{this.state.isAmbientContext=t;}}parseClass(e,...t){const r=this.state.inAbstractClass;this.state.inAbstractClass=!!e.abstract;try{return super.parseClass(e,...t)}finally{this.state.inAbstractClass=r;}}tsParseAbstractDeclaration(e){if(this.match(c._class))return e.abstract=!0,this.parseClass(e,!0,!1);if(this.isContextual("interface")){if(!this.hasFollowingLineBreak())return e.abstract=!0,this.raise(e.start,pe.NonClassMethodPropertyHasAbstractModifer),this.next(),this.tsParseInterfaceDeclaration(e)}else this.unexpected(null,c._class);}parseMethod(...e){const t=super.parseMethod(...e);if(t.abstract&&(this.hasPlugin("estree")?t.value.body:t.body)){const{key:e}=t;this.raise(t.start,pe.AbstractMethodHasImplementation,"Identifier"===e.type?e.name:`[${this.input.slice(e.start,e.end)}]`);}return t}shouldParseAsAmbientContext(){return !!this.getPluginOption("typescript","dts")}parse(){return this.shouldParseAsAmbientContext()&&(this.state.isAmbientContext=!0),super.parse()}getExpression(){return this.shouldParseAsAmbientContext()&&(this.state.isAmbientContext=!0),super.getExpression()}},v8intrinsic:e=>class extends e{parseV8Intrinsic(){if(this.match(c.modulo)){const e=this.state.start,t=this.startNode();if(this.eat(c.modulo),this.match(c.name)){const e=this.parseIdentifierName(this.state.start),r=this.createIdentifier(t,e);if(r.type="V8IntrinsicIdentifier",this.match(c.parenL))return r}this.unexpected(e);}}parseExprAtom(){return this.parseV8Intrinsic()||super.parseExprAtom(...arguments)}},placeholders:e=>class extends e{parsePlaceholder(e){if(this.match(c.placeholder)){const t=this.startNode();return this.next(),this.assertNoSpace("Unexpected space in placeholder."),t.name=super.parseIdentifier(!0),this.assertNoSpace("Unexpected space in placeholder."),this.expect(c.placeholder),this.finishPlaceholder(t,e)}}finishPlaceholder(e,t){const r=!(!e.expectedNode||"Placeholder"!==e.type);return e.expectedNode=t,r?e:this.finishNode(e,"Placeholder")}getTokenFromCode(e){return 37===e&&37===this.input.charCodeAt(this.state.pos+1)?this.finishOp(c.placeholder,2):super.getTokenFromCode(...arguments)}parseExprAtom(){return this.parsePlaceholder("Expression")||super.parseExprAtom(...arguments)}parseIdentifier(){return this.parsePlaceholder("Identifier")||super.parseIdentifier(...arguments)}checkReservedWord(e){void 0!==e&&super.checkReservedWord(...arguments);}parseBindingAtom(){return this.parsePlaceholder("Pattern")||super.parseBindingAtom(...arguments)}checkLVal(e){"Placeholder"!==e.type&&super.checkLVal(...arguments);}toAssignable(e){return e&&"Placeholder"===e.type&&"Expression"===e.expectedNode?(e.expectedNode="Pattern",e):super.toAssignable(...arguments)}isLet(e){return !!super.isLet(e)||!!this.isContextual("let")&&(!e&&this.lookahead().type===c.placeholder)}verifyBreakContinue(e){e.label&&"Placeholder"===e.label.type||super.verifyBreakContinue(...arguments);}parseExpressionStatement(e,t){if("Placeholder"!==t.type||t.extra&&t.extra.parenthesized)return super.parseExpressionStatement(...arguments);if(this.match(c.colon)){const r=e;return r.label=this.finishPlaceholder(t,"Identifier"),this.next(),r.body=this.parseStatement("label"),this.finishNode(r,"LabeledStatement")}return this.semicolon(),e.name=t.name,this.finishPlaceholder(e,"Statement")}parseBlock(){return this.parsePlaceholder("BlockStatement")||super.parseBlock(...arguments)}parseFunctionId(){return this.parsePlaceholder("Identifier")||super.parseFunctionId(...arguments)}parseClass(e,t,r){const n=t?"ClassDeclaration":"ClassExpression";this.next(),this.takeDecorators(e);const s=this.state.strict,i=this.parsePlaceholder("Identifier");if(i)if(this.match(c._extends)||this.match(c.placeholder)||this.match(c.braceL))e.id=i;else {if(r||!t)return e.id=null,e.body=this.finishPlaceholder(i,"ClassBody"),this.finishNode(e,n);this.unexpected(null,fe.ClassNameIsRequired);}else this.parseClassId(e,t,r);return this.parseClassSuper(e),e.body=this.parsePlaceholder("ClassBody")||this.parseClassBody(!!e.superClass,s),this.finishNode(e,n)}parseExport(e){const t=this.parsePlaceholder("Identifier");if(!t)return super.parseExport(...arguments);if(!this.isContextual("from")&&!this.match(c.comma))return e.specifiers=[],e.source=null,e.declaration=this.finishPlaceholder(t,"Declaration"),this.finishNode(e,"ExportNamedDeclaration");this.expectPlugin("exportDefaultFrom");const r=this.startNode();return r.exported=t,e.specifiers=[this.finishNode(r,"ExportDefaultSpecifier")],super.parseExport(e)}isExportDefaultSpecifier(){if(this.match(c._default)){const e=this.nextTokenStart();if(this.isUnparsedContextual(e,"from")&&this.input.startsWith(c.placeholder.label,this.nextTokenStartSince(e+4)))return !0}return super.isExportDefaultSpecifier()}maybeParseExportDefaultSpecifier(e){return !!(e.specifiers&&e.specifiers.length>0)||super.maybeParseExportDefaultSpecifier(...arguments)}checkExport(e){const{specifiers:t}=e;null!=t&&t.length&&(e.specifiers=t.filter((e=>"Placeholder"===e.exported.type))),super.checkExport(e),e.specifiers=t;}parseImport(e){const t=this.parsePlaceholder("Identifier");if(!t)return super.parseImport(...arguments);if(e.specifiers=[],!this.isContextual("from")&&!this.match(c.comma))return e.source=this.finishPlaceholder(t,"StringLiteral"),this.semicolon(),this.finishNode(e,"ImportDeclaration");const r=this.startNodeAtNode(t);return r.local=t,this.finishNode(r,"ImportDefaultSpecifier"),e.specifiers.push(r),this.eat(c.comma)&&(this.maybeParseStarImportSpecifier(e)||this.parseNamedImportSpecifiers(e)),this.expectContextual("from"),e.source=this.parseImportSource(),this.semicolon(),this.finishNode(e,"ImportDeclaration")}parseImportSource(){return this.parsePlaceholder("StringLiteral")||super.parseImportSource(...arguments)}}},Ee=Object.keys(ge),ve={sourceType:"script",sourceFilename:void 0,startLine:1,allowAwaitOutsideFunction:!1,allowReturnOutsideFunction:!1,allowImportExportEverywhere:!1,allowSuperOutsideMethod:!1,allowUndeclaredExports:!1,plugins:[],strictMode:null,ranges:!1,tokens:!1,createParenthesizedExpressions:!1,errorRecovery:!1};class xe{constructor(){this.strict=void 0,this.curLine=void 0,this.startLoc=void 0,this.endLoc=void 0,this.errors=[],this.potentialArrowAt=-1,this.noArrowAt=[],this.noArrowParamsConversionAt=[],this.maybeInArrowParameters=!1,this.inPipeline=!1,this.inType=!1,this.noAnonFunctionType=!1,this.inPropertyName=!1,this.hasFlowComment=!1,this.isAmbientContext=!1,this.inAbstractClass=!1,this.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null},this.soloAwait=!1,this.inFSharpPipelineDirectBody=!1,this.labels=[],this.decoratorStack=[[]],this.comments=[],this.trailingComments=[],this.leadingComments=[],this.commentStack=[],this.commentPreviousNode=null,this.pos=0,this.lineStart=0,this.type=c.eof,this.value=null,this.start=0,this.end=0,this.lastTokEndLoc=null,this.lastTokStartLoc=null,this.lastTokStart=0,this.lastTokEnd=0,this.context=[P.braceStatement],this.exprAllowed=!0,this.containsEsc=!1,this.strictErrors=new Map,this.exportedIdentifiers=[],this.tokensLength=0;}init(e){this.strict=!1!==e.strictMode&&"module"===e.sourceType,this.curLine=e.startLine,this.startLoc=this.endLoc=this.curPosition();}curPosition(){return new y(this.curLine,this.pos-this.lineStart)}clone(e){const t=new xe,r=Object.keys(this);for(let n=0,s=r.length;n<s;n++){const s=r[n];let i=this[s];!e&&Array.isArray(i)&&(i=i.slice()),t[s]=i;}return t}}var Te=function(e){return e>=48&&e<=57};const Se=new Set(["g","m","s","i","y","u"]),Pe={decBinOct:[46,66,69,79,95,98,101,111],hex:[46,88,95,120]},Ae={bin:[48,49]};Ae.oct=[...Ae.bin,50,51,52,53,54,55],Ae.dec=[...Ae.oct,56,57],Ae.hex=[...Ae.dec,65,66,67,68,69,70,97,98,99,100,101,102];class we{constructor(e){this.type=e.type,this.value=e.value,this.start=e.start,this.end=e.end,this.loc=new b(e.startLoc,e.endLoc);}}class Ce{constructor(){this.privateNames=new Set,this.loneAccessors=new Map,this.undefinedPrivateNames=new Map;}}class De{constructor(e){this.stack=[],this.undefinedPrivateNames=new Map,this.raise=e;}current(){return this.stack[this.stack.length-1]}enter(){this.stack.push(new Ce);}exit(){const e=this.stack.pop(),t=this.current();for(const[r,n]of Array.from(e.undefinedPrivateNames))t?t.undefinedPrivateNames.has(r)||t.undefinedPrivateNames.set(r,n):this.raise(n,v.InvalidPrivateFieldResolution,r);}declarePrivateName(e,t,r){const n=this.current();let s=n.privateNames.has(e);if(3&t){const r=s&&n.loneAccessors.get(e);if(r){const i=4&r,o=4&t;s=(3&r)==(3&t)||i!==o,s||n.loneAccessors.delete(e);}else s||n.loneAccessors.set(e,t);}s&&this.raise(r,v.PrivateNameRedeclaration,e),n.privateNames.add(e),n.undefinedPrivateNames.delete(e);}usePrivateName(e,t){let r;for(r of this.stack)if(r.privateNames.has(e))return;r?r.undefinedPrivateNames.set(e,t):this.raise(t,v.InvalidPrivateFieldResolution,e);}}class _e{constructor(e=0){this.type=void 0,this.type=e;}canBeArrowParameterDeclaration(){return 2===this.type||1===this.type}isCertainlyParameterDeclaration(){return 3===this.type}}class Oe extends _e{constructor(e){super(e),this.errors=new Map;}recordDeclarationError(e,t){this.errors.set(e,t);}clearDeclarationError(e){this.errors.delete(e);}iterateErrors(e){this.errors.forEach(e);}}class je{constructor(e){this.stack=[new _e],this.raise=e;}enter(e){this.stack.push(e);}exit(){this.stack.pop();}recordParameterInitializerError(e,t){const{stack:r}=this;let n=r.length-1,s=r[n];for(;!s.isCertainlyParameterDeclaration();){if(!s.canBeArrowParameterDeclaration())return;s.recordDeclarationError(e,t),s=r[--n];}this.raise(e,t);}recordParenthesizedIdentifierError(e,t){const{stack:r}=this,n=r[r.length-1];if(n.isCertainlyParameterDeclaration())this.raise(e,t);else {if(!n.canBeArrowParameterDeclaration())return;n.recordDeclarationError(e,t);}}recordAsyncArrowParametersError(e,t){const{stack:r}=this;let n=r.length-1,s=r[n];for(;s.canBeArrowParameterDeclaration();)2===s.type&&s.recordDeclarationError(e,t),s=r[--n];}validateAsPattern(){const{stack:e}=this,t=e[e.length-1];t.canBeArrowParameterDeclaration()&&t.iterateErrors(((t,r)=>{this.raise(r,t);let n=e.length-2,s=e[n];for(;s.canBeArrowParameterDeclaration();)s.clearDeclarationError(r),s=e[--n];}));}}function Ie(){return new _e}class Ne{constructor(){this.shorthandAssign=-1,this.doubleProto=-1;}}class ke{constructor(e,t,r){this.type=void 0,this.start=void 0,this.end=void 0,this.loc=void 0,this.range=void 0,this.leadingComments=void 0,this.trailingComments=void 0,this.innerComments=void 0,this.extra=void 0,this.type="",this.start=t,this.end=0,this.loc=new b(r),null!=e&&e.options.ranges&&(this.range=[t,0]),null!=e&&e.filename&&(this.loc.filename=e.filename);}__clone(){const e=new ke,t=Object.keys(this);for(let r=0,n=t.length;r<n;r++){const n=t[r];"leadingComments"!==n&&"trailingComments"!==n&&"innerComments"!==n&&(e[n]=this[n]);}return e}}const Fe=e=>"ParenthesizedExpression"===e.type?Fe(e.expression):e,Le={kind:"loop"},Me={kind:"switch"},Be=/[\uD800-\uDFFF]/u;class Re extends class extends class extends class extends class extends class extends class extends class extends class extends class{constructor(){this.sawUnambiguousESM=!1,this.ambiguousScriptDifferentAst=!1;}hasPlugin(e){return this.plugins.has(e)}getPluginOption(e,t){if(this.hasPlugin(e))return this.plugins.get(e)[t]}}{addComment(e){this.filename&&(e.loc.filename=this.filename),this.state.trailingComments.push(e),this.state.leadingComments.push(e);}adjustCommentsAfterTrailingComma(e,t,r){if(0===this.state.leadingComments.length)return;let n=null,s=t.length;for(;null===n&&s>0;)n=t[--s];if(null===n)return;for(let e=0;e<this.state.leadingComments.length;e++)this.state.leadingComments[e].end<this.state.commentPreviousNode.end&&(this.state.leadingComments.splice(e,1),e--);const i=[];for(let t=0;t<this.state.leadingComments.length;t++){const n=this.state.leadingComments[t];n.end<e.end?(i.push(n),r||(this.state.leadingComments.splice(t,1),t--)):(void 0===e.trailingComments&&(e.trailingComments=[]),e.trailingComments.push(n));}r&&(this.state.leadingComments=[]),i.length>0?n.trailingComments=i:void 0!==n.trailingComments&&(n.trailingComments=[]);}processComment(e){if("Program"===e.type&&e.body.length>0)return;const t=this.state.commentStack;let r,n,s,i,o;if(this.state.trailingComments.length>0)this.state.trailingComments[0].start>=e.end?(s=this.state.trailingComments,this.state.trailingComments=[]):this.state.trailingComments.length=0;else if(t.length>0){const r=g(t);r.trailingComments&&r.trailingComments[0].start>=e.end&&(s=r.trailingComments,delete r.trailingComments);}for(t.length>0&&g(t).start>=e.start&&(r=t.pop());t.length>0&&g(t).start>=e.start;)n=t.pop();if(!n&&r&&(n=r),r)switch(e.type){case"ObjectExpression":this.adjustCommentsAfterTrailingComma(e,e.properties);break;case"ObjectPattern":this.adjustCommentsAfterTrailingComma(e,e.properties,!0);break;case"CallExpression":this.adjustCommentsAfterTrailingComma(e,e.arguments);break;case"ArrayExpression":this.adjustCommentsAfterTrailingComma(e,e.elements);break;case"ArrayPattern":this.adjustCommentsAfterTrailingComma(e,e.elements,!0);}else this.state.commentPreviousNode&&("ImportSpecifier"===this.state.commentPreviousNode.type&&"ImportSpecifier"!==e.type||"ExportSpecifier"===this.state.commentPreviousNode.type&&"ExportSpecifier"!==e.type)&&this.adjustCommentsAfterTrailingComma(e,[this.state.commentPreviousNode]);if(n){if(n.leadingComments)if(n!==e&&n.leadingComments.length>0&&g(n.leadingComments).end<=e.start)e.leadingComments=n.leadingComments,delete n.leadingComments;else for(i=n.leadingComments.length-2;i>=0;--i)if(n.leadingComments[i].end<=e.start){e.leadingComments=n.leadingComments.splice(0,i+1);break}}else if(this.state.leadingComments.length>0)if(g(this.state.leadingComments).end<=e.start){if(this.state.commentPreviousNode)for(o=0;o<this.state.leadingComments.length;o++)this.state.leadingComments[o].end<this.state.commentPreviousNode.end&&(this.state.leadingComments.splice(o,1),o--);this.state.leadingComments.length>0&&(e.leadingComments=this.state.leadingComments,this.state.leadingComments=[]);}else {for(i=0;i<this.state.leadingComments.length&&!(this.state.leadingComments[i].end>e.start);i++);const t=this.state.leadingComments.slice(0,i);t.length&&(e.leadingComments=t),s=this.state.leadingComments.slice(i),0===s.length&&(s=null);}if(this.state.commentPreviousNode=e,s)if(s.length&&s[0].start>=e.start&&g(s).end<=e.end)e.innerComments=s;else {const t=s.findIndex((t=>t.end>=e.end));t>0?(e.innerComments=s.slice(0,t),e.trailingComments=s.slice(t)):e.trailingComments=s;}t.push(e);}}{getLocationForPosition(e){let t;return t=e===this.state.start?this.state.startLoc:e===this.state.lastTokStart?this.state.lastTokStartLoc:e===this.state.end?this.state.endLoc:e===this.state.lastTokEnd?this.state.lastTokEndLoc:function(e,t){let r,n=1,s=0;for(d.lastIndex=0;(r=d.exec(e))&&r.index<t;)n++,s=d.lastIndex;return new y(n,t-s)}(this.input,e),t}raise(e,{code:t,reasonCode:r,template:n},...s){return this.raiseWithData(e,{code:t,reasonCode:r},n,...s)}raiseOverwrite(e,{code:t,template:r},...n){const s=this.getLocationForPosition(e),i=r.replace(/%(\d+)/g,((e,t)=>n[t]))+` (${s.line}:${s.column})`;if(this.options.errorRecovery){const t=this.state.errors;for(let r=t.length-1;r>=0;r--){const n=t[r];if(n.pos===e)return Object.assign(n,{message:i});if(n.pos<e)break}}return this._raise({code:t,loc:s,pos:e},i)}raiseWithData(e,t,r,...n){const s=this.getLocationForPosition(e),i=r.replace(/%(\d+)/g,((e,t)=>n[t]))+` (${s.line}:${s.column})`;return this._raise(Object.assign({loc:s,pos:e},t),i)}_raise(e,t){const r=new SyntaxError(t);if(Object.assign(r,e),this.options.errorRecovery)return this.isLookahead||this.state.errors.push(r),r;throw r}}{constructor(e,t){super(),this.isLookahead=void 0,this.tokens=[],this.state=new xe,this.state.init(e),this.input=t,this.length=t.length,this.isLookahead=!1;}pushToken(e){this.tokens.length=this.state.tokensLength,this.tokens.push(e),++this.state.tokensLength;}next(){this.isLookahead||(this.checkKeywordEscapes(),this.options.tokens&&this.pushToken(new we(this.state))),this.state.lastTokEnd=this.state.end,this.state.lastTokStart=this.state.start,this.state.lastTokEndLoc=this.state.endLoc,this.state.lastTokStartLoc=this.state.startLoc,this.nextToken();}eat(e){return !!this.match(e)&&(this.next(),!0)}match(e){return this.state.type===e}lookahead(){const e=this.state;this.state=e.clone(!0),this.isLookahead=!0,this.next(),this.isLookahead=!1;const t=this.state;return this.state=e,t}nextTokenStart(){return this.nextTokenStartSince(this.state.pos)}nextTokenStartSince(e){return h.lastIndex=e,e+h.exec(this.input)[0].length}lookaheadCharCode(){return this.input.charCodeAt(this.nextTokenStart())}codePointAtPos(e){let t=this.input.charCodeAt(e);if(55296==(64512&t)&&++e<this.input.length){const r=this.input.charCodeAt(e);56320==(64512&r)&&(t=65536+((1023&t)<<10)+(1023&r));}return t}setStrict(e){this.state.strict=e,e&&(this.state.strictErrors.forEach(((e,t)=>this.raise(t,e))),this.state.strictErrors.clear());}curContext(){return this.state.context[this.state.context.length-1]}nextToken(){const e=this.curContext();if(null!=e&&e.preserveSpace||this.skipSpace(),this.state.start=this.state.pos,this.state.startLoc=this.state.curPosition(),this.state.pos>=this.length)return void this.finishToken(c.eof);const t=null==e?void 0:e.override;t?t(this):this.getTokenFromCode(this.codePointAtPos(this.state.pos));}pushComment(e,t,r,n,s,i){const o={type:e?"CommentBlock":"CommentLine",value:t,start:r,end:n,loc:new b(s,i)};this.options.tokens&&this.pushToken(o),this.state.comments.push(o),this.addComment(o);}skipBlockComment(){const e=this.state.curPosition(),t=this.state.pos,r=this.input.indexOf("*/",this.state.pos+2);if(-1===r)throw this.raise(t,v.UnterminatedComment);let n;for(this.state.pos=r+2,d.lastIndex=t;(n=d.exec(this.input))&&n.index<this.state.pos;)++this.state.curLine,this.state.lineStart=n.index+n[0].length;this.isLookahead||this.pushComment(!0,this.input.slice(t+2,r),t,this.state.pos,e,this.state.curPosition());}skipLineComment(e){const t=this.state.pos,r=this.state.curPosition();let n=this.input.charCodeAt(this.state.pos+=e);if(this.state.pos<this.length)for(;!f(n)&&++this.state.pos<this.length;)n=this.input.charCodeAt(this.state.pos);this.isLookahead||this.pushComment(!1,this.input.slice(t+e,this.state.pos),t,this.state.pos,r,this.state.curPosition());}skipSpace(){e:for(;this.state.pos<this.length;){const e=this.input.charCodeAt(this.state.pos);switch(e){case 32:case 160:case 9:++this.state.pos;break;case 13:10===this.input.charCodeAt(this.state.pos+1)&&++this.state.pos;case 10:case 8232:case 8233:++this.state.pos,++this.state.curLine,this.state.lineStart=this.state.pos;break;case 47:switch(this.input.charCodeAt(this.state.pos+1)){case 42:this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break e}break;default:if(!m(e))break e;++this.state.pos;}}}finishToken(e,t){this.state.end=this.state.pos,this.state.endLoc=this.state.curPosition();const r=this.state.type;this.state.type=e,this.state.value=t,this.isLookahead||this.updateContext(r);}readToken_numberSign(){if(0===this.state.pos&&this.readToken_interpreter())return;const e=this.state.pos+1,t=this.codePointAtPos(e);if(t>=48&&t<=57)throw this.raise(this.state.pos,v.UnexpectedDigitAfterHash);if(123===t||91===t&&this.hasPlugin("recordAndTuple")){if(this.expectPlugin("recordAndTuple"),"hash"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(this.state.pos,123===t?v.RecordExpressionHashIncorrectStartSyntaxType:v.TupleExpressionHashIncorrectStartSyntaxType);123===t?this.finishToken(c.braceHashL):this.finishToken(c.bracketHashL),this.state.pos+=2;}else I(t)?(++this.state.pos,this.finishToken(c.privateName,this.readWord1(t))):92===t?(++this.state.pos,this.finishToken(c.privateName,this.readWord1())):this.finishOp(c.hash,1);}readToken_dot(){const e=this.input.charCodeAt(this.state.pos+1);e>=48&&e<=57?this.readNumber(!0):46===e&&46===this.input.charCodeAt(this.state.pos+2)?(this.state.pos+=3,this.finishToken(c.ellipsis)):(++this.state.pos,this.finishToken(c.dot));}readToken_slash(){if(this.state.exprAllowed&&!this.state.inType)return ++this.state.pos,void this.readRegexp();61===this.input.charCodeAt(this.state.pos+1)?this.finishOp(c.assign,2):this.finishOp(c.slash,1);}readToken_interpreter(){if(0!==this.state.pos||this.length<2)return !1;let e=this.input.charCodeAt(this.state.pos+1);if(33!==e)return !1;const t=this.state.pos;for(this.state.pos+=1;!f(e)&&++this.state.pos<this.length;)e=this.input.charCodeAt(this.state.pos);const r=this.input.slice(t+2,this.state.pos);return this.finishToken(c.interpreterDirective,r),!0}readToken_mult_modulo(e){let t=42===e?c.star:c.modulo,r=1,n=this.input.charCodeAt(this.state.pos+1);const s=this.state.exprAllowed;42===e&&42===n&&(r++,n=this.input.charCodeAt(this.state.pos+2),t=c.exponent),61!==n||s||(r++,t=c.assign),this.finishOp(t,r);}readToken_pipe_amp(e){const t=this.input.charCodeAt(this.state.pos+1);if(t!==e){if(124===e){if(62===t)return void this.finishOp(c.pipeline,2);if(this.hasPlugin("recordAndTuple")&&125===t){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(this.state.pos,v.RecordExpressionBarIncorrectEndSyntaxType);return void this.finishOp(c.braceBarR,2)}if(this.hasPlugin("recordAndTuple")&&93===t){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(this.state.pos,v.TupleExpressionBarIncorrectEndSyntaxType);return void this.finishOp(c.bracketBarR,2)}}61!==t?this.finishOp(124===e?c.bitwiseOR:c.bitwiseAND,1):this.finishOp(c.assign,2);}else 61===this.input.charCodeAt(this.state.pos+2)?this.finishOp(c.assign,3):this.finishOp(124===e?c.logicalOR:c.logicalAND,2);}readToken_caret(){61===this.input.charCodeAt(this.state.pos+1)?this.finishOp(c.assign,2):this.finishOp(c.bitwiseXOR,1);}readToken_plus_min(e){const t=this.input.charCodeAt(this.state.pos+1);if(t===e)return 45!==t||this.inModule||62!==this.input.charCodeAt(this.state.pos+2)||0!==this.state.lastTokEnd&&!this.hasPrecedingLineBreak()?void this.finishOp(c.incDec,2):(this.skipLineComment(3),this.skipSpace(),void this.nextToken());61===t?this.finishOp(c.assign,2):this.finishOp(c.plusMin,1);}readToken_lt_gt(e){const t=this.input.charCodeAt(this.state.pos+1);let r=1;return t===e?(r=62===e&&62===this.input.charCodeAt(this.state.pos+2)?3:2,61===this.input.charCodeAt(this.state.pos+r)?void this.finishOp(c.assign,r+1):void this.finishOp(c.bitShift,r)):33!==t||60!==e||this.inModule||45!==this.input.charCodeAt(this.state.pos+2)||45!==this.input.charCodeAt(this.state.pos+3)?(61===t&&(r=2),void this.finishOp(c.relational,r)):(this.skipLineComment(4),this.skipSpace(),void this.nextToken())}readToken_eq_excl(e){const t=this.input.charCodeAt(this.state.pos+1);if(61!==t)return 61===e&&62===t?(this.state.pos+=2,void this.finishToken(c.arrow)):void this.finishOp(61===e?c.eq:c.bang,1);this.finishOp(c.equality,61===this.input.charCodeAt(this.state.pos+2)?3:2);}readToken_question(){const e=this.input.charCodeAt(this.state.pos+1),t=this.input.charCodeAt(this.state.pos+2);63===e?61===t?this.finishOp(c.assign,3):this.finishOp(c.nullishCoalescing,2):46!==e||t>=48&&t<=57?(++this.state.pos,this.finishToken(c.question)):(this.state.pos+=2,this.finishToken(c.questionDot));}getTokenFromCode(e){switch(e){case 46:return void this.readToken_dot();case 40:return ++this.state.pos,void this.finishToken(c.parenL);case 41:return ++this.state.pos,void this.finishToken(c.parenR);case 59:return ++this.state.pos,void this.finishToken(c.semi);case 44:return ++this.state.pos,void this.finishToken(c.comma);case 91:if(this.hasPlugin("recordAndTuple")&&124===this.input.charCodeAt(this.state.pos+1)){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(this.state.pos,v.TupleExpressionBarIncorrectStartSyntaxType);this.finishToken(c.bracketBarL),this.state.pos+=2;}else ++this.state.pos,this.finishToken(c.bracketL);return;case 93:return ++this.state.pos,void this.finishToken(c.bracketR);case 123:if(this.hasPlugin("recordAndTuple")&&124===this.input.charCodeAt(this.state.pos+1)){if("bar"!==this.getPluginOption("recordAndTuple","syntaxType"))throw this.raise(this.state.pos,v.RecordExpressionBarIncorrectStartSyntaxType);this.finishToken(c.braceBarL),this.state.pos+=2;}else ++this.state.pos,this.finishToken(c.braceL);return;case 125:return ++this.state.pos,void this.finishToken(c.braceR);case 58:return void(this.hasPlugin("functionBind")&&58===this.input.charCodeAt(this.state.pos+1)?this.finishOp(c.doubleColon,2):(++this.state.pos,this.finishToken(c.colon)));case 63:return void this.readToken_question();case 96:return ++this.state.pos,void this.finishToken(c.backQuote);case 48:{const e=this.input.charCodeAt(this.state.pos+1);if(120===e||88===e)return void this.readRadixNumber(16);if(111===e||79===e)return void this.readRadixNumber(8);if(98===e||66===e)return void this.readRadixNumber(2)}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return void this.readNumber(!1);case 34:case 39:return void this.readString(e);case 47:return void this.readToken_slash();case 37:case 42:return void this.readToken_mult_modulo(e);case 124:case 38:return void this.readToken_pipe_amp(e);case 94:return void this.readToken_caret();case 43:case 45:return void this.readToken_plus_min(e);case 60:case 62:return void this.readToken_lt_gt(e);case 61:case 33:return void this.readToken_eq_excl(e);case 126:return void this.finishOp(c.tilde,1);case 64:return ++this.state.pos,void this.finishToken(c.at);case 35:return void this.readToken_numberSign();case 92:return void this.readWord();default:if(I(e))return void this.readWord(e)}throw this.raise(this.state.pos,v.InvalidOrUnexpectedToken,String.fromCodePoint(e))}finishOp(e,t){const r=this.input.slice(this.state.pos,this.state.pos+t);this.state.pos+=t,this.finishToken(e,r);}readRegexp(){const e=this.state.pos;let t,r;for(;;){if(this.state.pos>=this.length)throw this.raise(e,v.UnterminatedRegExp);const n=this.input.charAt(this.state.pos);if(p.test(n))throw this.raise(e,v.UnterminatedRegExp);if(t)t=!1;else {if("["===n)r=!0;else if("]"===n&&r)r=!1;else if("/"===n&&!r)break;t="\\"===n;}++this.state.pos;}const n=this.input.slice(e,this.state.pos);++this.state.pos;let s="";for(;this.state.pos<this.length;){const e=this.input[this.state.pos],t=this.codePointAtPos(this.state.pos);if(Se.has(e))s.indexOf(e)>-1&&this.raise(this.state.pos+1,v.DuplicateRegExpFlags);else {if(!N(t)&&92!==t)break;this.raise(this.state.pos+1,v.MalformedRegExpFlags);}++this.state.pos,s+=e;}this.finishToken(c.regexp,{pattern:n,flags:s});}readInt(e,t,r,n=!0){const s=this.state.pos,i=16===e?Pe.hex:Pe.decBinOct,o=16===e?Ae.hex:10===e?Ae.dec:8===e?Ae.oct:Ae.bin;let a=!1,l=0;for(let s=0,u=null==t?1/0:t;s<u;++s){const t=this.input.charCodeAt(this.state.pos);let u;if(95!==t){if(u=t>=97?t-97+10:t>=65?t-65+10:Te(t)?t-48:1/0,u>=e)if(this.options.errorRecovery&&u<=9)u=0,this.raise(this.state.start+s+2,v.InvalidDigit,e);else {if(!r)break;u=0,a=!0;}++this.state.pos,l=l*e+u;}else {const e=this.input.charCodeAt(this.state.pos-1),t=this.input.charCodeAt(this.state.pos+1);(-1===o.indexOf(t)||i.indexOf(e)>-1||i.indexOf(t)>-1||Number.isNaN(t))&&this.raise(this.state.pos,v.UnexpectedNumericSeparator),n||this.raise(this.state.pos,v.NumericSeparatorInEscapeSequence),++this.state.pos;}}return this.state.pos===s||null!=t&&this.state.pos-s!==t||a?null:l}readRadixNumber(e){const t=this.state.pos;let r=!1;this.state.pos+=2;const n=this.readInt(e);null==n&&this.raise(this.state.start+2,v.InvalidDigit,e);const s=this.input.charCodeAt(this.state.pos);if(110===s)++this.state.pos,r=!0;else if(109===s)throw this.raise(t,v.InvalidDecimal);if(I(this.codePointAtPos(this.state.pos)))throw this.raise(this.state.pos,v.NumberIdentifier);if(r){const e=this.input.slice(t,this.state.pos).replace(/[_n]/g,"");this.finishToken(c.bigint,e);}else this.finishToken(c.num,n);}readNumber(e){const t=this.state.pos;let r=!1,n=!1,s=!1,i=!1,o=!1;e||null!==this.readInt(10)||this.raise(t,v.InvalidNumber);const a=this.state.pos-t>=2&&48===this.input.charCodeAt(t);if(a){const e=this.input.slice(t,this.state.pos);if(this.recordStrictModeErrors(t,v.StrictOctalLiteral),!this.state.strict){const r=e.indexOf("_");r>0&&this.raise(r+t,v.ZeroDigitNumericSeparator);}o=a&&!/[89]/.test(e);}let l=this.input.charCodeAt(this.state.pos);if(46!==l||o||(++this.state.pos,this.readInt(10),r=!0,l=this.input.charCodeAt(this.state.pos)),69!==l&&101!==l||o||(l=this.input.charCodeAt(++this.state.pos),43!==l&&45!==l||++this.state.pos,null===this.readInt(10)&&this.raise(t,v.InvalidOrMissingExponent),r=!0,i=!0,l=this.input.charCodeAt(this.state.pos)),110===l&&((r||a)&&this.raise(t,v.InvalidBigIntLiteral),++this.state.pos,n=!0),109===l&&(this.expectPlugin("decimal",this.state.pos),(i||a)&&this.raise(t,v.InvalidDecimal),++this.state.pos,s=!0),I(this.codePointAtPos(this.state.pos)))throw this.raise(this.state.pos,v.NumberIdentifier);const u=this.input.slice(t,this.state.pos).replace(/[_mn]/g,"");if(n)return void this.finishToken(c.bigint,u);if(s)return void this.finishToken(c.decimal,u);const p=o?parseInt(u,8):parseFloat(u);this.finishToken(c.num,p);}readCodePoint(e){let t;if(123===this.input.charCodeAt(this.state.pos)){const r=++this.state.pos;if(t=this.readHexChar(this.input.indexOf("}",this.state.pos)-this.state.pos,!0,e),++this.state.pos,null!==t&&t>1114111){if(!e)return null;this.raise(r,v.InvalidCodePoint);}}else t=this.readHexChar(4,!1,e);return t}readString(e){let t="",r=++this.state.pos;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,v.UnterminatedString);const n=this.input.charCodeAt(this.state.pos);if(n===e)break;if(92===n)t+=this.input.slice(r,this.state.pos),t+=this.readEscapedChar(!1),r=this.state.pos;else if(8232===n||8233===n)++this.state.pos,++this.state.curLine,this.state.lineStart=this.state.pos;else {if(f(n))throw this.raise(this.state.start,v.UnterminatedString);++this.state.pos;}}t+=this.input.slice(r,this.state.pos++),this.finishToken(c.string,t);}readTmplToken(){let e="",t=this.state.pos,r=!1;for(;;){if(this.state.pos>=this.length)throw this.raise(this.state.start,v.UnterminatedTemplate);const n=this.input.charCodeAt(this.state.pos);if(96===n||36===n&&123===this.input.charCodeAt(this.state.pos+1))return this.state.pos===this.state.start&&this.match(c.template)?36===n?(this.state.pos+=2,void this.finishToken(c.dollarBraceL)):(++this.state.pos,void this.finishToken(c.backQuote)):(e+=this.input.slice(t,this.state.pos),void this.finishToken(c.template,r?null:e));if(92===n){e+=this.input.slice(t,this.state.pos);const n=this.readEscapedChar(!0);null===n?r=!0:e+=n,t=this.state.pos;}else if(f(n)){switch(e+=this.input.slice(t,this.state.pos),++this.state.pos,n){case 13:10===this.input.charCodeAt(this.state.pos)&&++this.state.pos;case 10:e+="\n";break;default:e+=String.fromCharCode(n);}++this.state.curLine,this.state.lineStart=this.state.pos,t=this.state.pos;}else ++this.state.pos;}}recordStrictModeErrors(e,t){this.state.strict&&!this.state.strictErrors.has(e)?this.raise(e,t):this.state.strictErrors.set(e,t);}readEscapedChar(e){const t=!e,r=this.input.charCodeAt(++this.state.pos);switch(++this.state.pos,r){case 110:return "\n";case 114:return "\r";case 120:{const e=this.readHexChar(2,!1,t);return null===e?null:String.fromCharCode(e)}case 117:{const e=this.readCodePoint(t);return null===e?null:String.fromCodePoint(e)}case 116:return "\t";case 98:return "\b";case 118:return "\v";case 102:return "\f";case 13:10===this.input.charCodeAt(this.state.pos)&&++this.state.pos;case 10:this.state.lineStart=this.state.pos,++this.state.curLine;case 8232:case 8233:return "";case 56:case 57:if(e)return null;this.recordStrictModeErrors(this.state.pos-1,v.StrictNumericEscape);default:if(r>=48&&r<=55){const t=this.state.pos-1;let r=this.input.substr(this.state.pos-1,3).match(/^[0-7]+/)[0],n=parseInt(r,8);n>255&&(r=r.slice(0,-1),n=parseInt(r,8)),this.state.pos+=r.length-1;const s=this.input.charCodeAt(this.state.pos);if("0"!==r||56===s||57===s){if(e)return null;this.recordStrictModeErrors(t,v.StrictNumericEscape);}return String.fromCharCode(n)}return String.fromCharCode(r)}}readHexChar(e,t,r){const n=this.state.pos,s=this.readInt(16,e,t,!1);return null===s&&(r?this.raise(n,v.InvalidEscapeSequence):this.state.pos=n-1),s}readWord1(e){this.state.containsEsc=!1;let t="";const r=this.state.pos;let n=this.state.pos;for(void 0!==e&&(this.state.pos+=e<=65535?1:2);this.state.pos<this.length;){const e=this.codePointAtPos(this.state.pos);if(N(e))this.state.pos+=e<=65535?1:2;else {if(92!==e)break;{this.state.containsEsc=!0,t+=this.input.slice(n,this.state.pos);const e=this.state.pos,s=this.state.pos===r?I:N;if(117!==this.input.charCodeAt(++this.state.pos)){this.raise(this.state.pos,v.MissingUnicodeEscape),n=this.state.pos-1;continue}++this.state.pos;const i=this.readCodePoint(!0);null!==i&&(s(i)||this.raise(e,v.EscapedCharNotAnIdentifier),t+=String.fromCodePoint(i)),n=this.state.pos;}}}return t+this.input.slice(n,this.state.pos)}readWord(e){const t=this.readWord1(e),r=a.get(t)||c.name;this.finishToken(r,t);}checkKeywordEscapes(){const e=this.state.type.keyword;e&&this.state.containsEsc&&this.raise(this.state.start,v.InvalidEscapedReservedWord,e);}braceIsBlock(e){const t=this.curContext();return t===P.functionExpression||t===P.functionStatement||(e!==c.colon||t!==P.braceStatement&&t!==P.braceExpression?e===c._return||e===c.name&&this.state.exprAllowed?this.hasPrecedingLineBreak():e===c._else||e===c.semi||e===c.eof||e===c.parenR||e===c.arrow||(e===c.braceL?t===P.braceStatement:e!==c._var&&e!==c._const&&e!==c.name&&(e===c.relational||!this.state.exprAllowed)):!t.isExpr)}updateContext(e){const t=this.state.type;let r;!t.keyword||e!==c.dot&&e!==c.questionDot?(r=t.updateContext)?r.call(this,e):this.state.exprAllowed=t.beforeExpr:this.state.exprAllowed=!1;}}{addExtra(e,t,r){e&&((e.extra=e.extra||{})[t]=r);}isRelational(e){return this.match(c.relational)&&this.state.value===e}expectRelational(e){this.isRelational(e)?this.next():this.unexpected(null,c.relational);}isContextual(e){return this.match(c.name)&&this.state.value===e&&!this.state.containsEsc}isUnparsedContextual(e,t){const r=e+t.length;return this.input.slice(e,r)===t&&(r===this.input.length||!N(this.input.charCodeAt(r)))}isLookaheadContextual(e){const t=this.nextTokenStart();return this.isUnparsedContextual(t,e)}eatContextual(e){return this.isContextual(e)&&this.eat(c.name)}expectContextual(e,t){this.eatContextual(e)||this.unexpected(null,t);}canInsertSemicolon(){return this.match(c.eof)||this.match(c.braceR)||this.hasPrecedingLineBreak()}hasPrecedingLineBreak(){return p.test(this.input.slice(this.state.lastTokEnd,this.state.start))}hasFollowingLineBreak(){return p.test(this.input.slice(this.state.end,this.nextTokenStart()))}isLineTerminator(){return this.eat(c.semi)||this.canInsertSemicolon()}semicolon(e=!0){(e?this.isLineTerminator():this.eat(c.semi))||this.raise(this.state.lastTokEnd,v.MissingSemicolon);}expect(e,t){this.eat(e)||this.unexpected(t,e);}assertNoSpace(e="Unexpected space."){this.state.start>this.state.lastTokEnd&&this.raise(this.state.lastTokEnd,{code:E.SyntaxError,reasonCode:"UnexpectedSpace",template:e});}unexpected(e,t={code:E.SyntaxError,reasonCode:"UnexpectedToken",template:"Unexpected token"}){throw t instanceof o&&(t={code:E.SyntaxError,reasonCode:"UnexpectedToken",template:`Unexpected token, expected "${t.label}"`}),this.raise(null!=e?e:this.state.start,t)}expectPlugin(e,t){if(!this.hasPlugin(e))throw this.raiseWithData(null!=t?t:this.state.start,{missingPlugin:[e]},`This experimental syntax requires enabling the parser plugin: '${e}'`);return !0}expectOnePlugin(e,t){if(!e.some((e=>this.hasPlugin(e))))throw this.raiseWithData(null!=t?t:this.state.start,{missingPlugin:e},`This experimental syntax requires enabling one of the following parser plugin(s): '${e.join(", ")}'`)}tryParse(e,t=this.state.clone()){const r={node:null};try{const n=e(((e=null)=>{throw r.node=e,r}));if(this.state.errors.length>t.errors.length){const e=this.state;return this.state=t,this.state.tokensLength=e.tokensLength,{node:n,error:e.errors[t.errors.length],thrown:!1,aborted:!1,failState:e}}return {node:n,error:null,thrown:!1,aborted:!1,failState:null}}catch(e){const n=this.state;if(this.state=t,e instanceof SyntaxError)return {node:null,error:e,thrown:!0,aborted:!1,failState:n};if(e===r)return {node:r.node,error:null,thrown:!1,aborted:!0,failState:n};throw e}}checkExpressionErrors(e,t){if(!e)return !1;const{shorthandAssign:r,doubleProto:n}=e;if(!t)return r>=0||n>=0;r>=0&&this.unexpected(r),n>=0&&this.raise(n,v.DuplicateProto);}isLiteralPropertyName(){return this.match(c.name)||!!this.state.type.keyword||this.match(c.string)||this.match(c.num)||this.match(c.bigint)||this.match(c.decimal)}isPrivateName(e){return "PrivateName"===e.type}getPrivateNameSV(e){return e.id.name}hasPropertyAsPrivateName(e){return ("MemberExpression"===e.type||"OptionalMemberExpression"===e.type)&&this.isPrivateName(e.property)}isOptionalChain(e){return "OptionalMemberExpression"===e.type||"OptionalCallExpression"===e.type}isObjectProperty(e){return "ObjectProperty"===e.type}isObjectMethod(e){return "ObjectMethod"===e.type}initializeScopes(e="module"===this.options.sourceType){const t=this.state.labels;this.state.labels=[];const r=this.state.exportedIdentifiers;this.state.exportedIdentifiers=[];const n=this.inModule;this.inModule=e;const s=this.scope,i=this.getScopeHandler();this.scope=new i(this.raise.bind(this),this.inModule);const o=this.prodParam;this.prodParam=new ae;const a=this.classScope;this.classScope=new De(this.raise.bind(this));const l=this.expressionScope;return this.expressionScope=new je(this.raise.bind(this)),()=>{this.state.labels=t,this.state.exportedIdentifiers=r,this.inModule=n,this.scope=s,this.prodParam=o,this.classScope=a,this.expressionScope=l;}}enterInitialScopes(){let e=0;this.hasPlugin("topLevelAwait")&&this.inModule&&(e|=2),this.scope.enter(1),this.prodParam.enter(e);}}{startNode(){return new ke(this,this.state.start,this.state.startLoc)}startNodeAt(e,t){return new ke(this,e,t)}startNodeAtNode(e){return this.startNodeAt(e.start,e.loc.start)}finishNode(e,t){return this.finishNodeAt(e,t,this.state.lastTokEnd,this.state.lastTokEndLoc)}finishNodeAt(e,t,r,n){return e.type=t,e.end=r,e.loc.end=n,this.options.ranges&&(e.range[1]=r),this.processComment(e),e}resetStartLocation(e,t,r){e.start=t,e.loc.start=r,this.options.ranges&&(e.range[0]=t);}resetEndLocation(e,t=this.state.lastTokEnd,r=this.state.lastTokEndLoc){e.end=t,e.loc.end=r,this.options.ranges&&(e.range[1]=t);}resetStartLocationFromNode(e,t){this.resetStartLocation(e,t.start,t.loc.start);}}{toAssignable(e,t=!1){var r,n;let s;switch(("ParenthesizedExpression"===e.type||null!=(r=e.extra)&&r.parenthesized)&&(s=Fe(e),t?"Identifier"===s.type?this.expressionScope.recordParenthesizedIdentifierError(e.start,v.InvalidParenthesizedAssignment):"MemberExpression"!==s.type&&this.raise(e.start,v.InvalidParenthesizedAssignment):this.raise(e.start,v.InvalidParenthesizedAssignment)),e.type){case"Identifier":case"ObjectPattern":case"ArrayPattern":case"AssignmentPattern":break;case"ObjectExpression":e.type="ObjectPattern";for(let r=0,n=e.properties.length,s=n-1;r<n;r++){var i;const n=e.properties[r],o=r===s;this.toAssignableObjectExpressionProp(n,o,t),o&&"RestElement"===n.type&&null!=(i=e.extra)&&i.trailingComma&&this.raiseRestNotLast(e.extra.trailingComma);}break;case"ObjectProperty":this.toAssignable(e.value,t);break;case"SpreadElement":{this.checkToRestConversion(e),e.type="RestElement";const r=e.argument;this.toAssignable(r,t);break}case"ArrayExpression":e.type="ArrayPattern",this.toAssignableList(e.elements,null==(n=e.extra)?void 0:n.trailingComma,t);break;case"AssignmentExpression":"="!==e.operator&&this.raise(e.left.end,v.MissingEqInAssignment),e.type="AssignmentPattern",delete e.operator,this.toAssignable(e.left,t);break;case"ParenthesizedExpression":this.toAssignable(s,t);}return e}toAssignableObjectExpressionProp(e,t,r){if("ObjectMethod"===e.type){const t="get"===e.kind||"set"===e.kind?v.PatternHasAccessor:v.PatternHasMethod;this.raise(e.key.start,t);}else "SpreadElement"!==e.type||t?this.toAssignable(e,r):this.raiseRestNotLast(e.start);}toAssignableList(e,t,r){let n=e.length;if(n){const s=e[n-1];if("RestElement"===(null==s?void 0:s.type))--n;else if("SpreadElement"===(null==s?void 0:s.type)){s.type="RestElement";let e=s.argument;this.toAssignable(e,r),e=Fe(e),"Identifier"!==e.type&&"MemberExpression"!==e.type&&"ArrayPattern"!==e.type&&"ObjectPattern"!==e.type&&this.unexpected(e.start),t&&this.raiseTrailingCommaAfterRest(t),--n;}}for(let t=0;t<n;t++){const n=e[t];n&&(this.toAssignable(n,r),"RestElement"===n.type&&this.raiseRestNotLast(n.start));}return e}toReferencedList(e,t){return e}toReferencedListDeep(e,t){this.toReferencedList(e,t);for(const t of e)"ArrayExpression"===(null==t?void 0:t.type)&&this.toReferencedListDeep(t.elements);}parseSpread(e,t){const r=this.startNode();return this.next(),r.argument=this.parseMaybeAssignAllowIn(e,void 0,t),this.finishNode(r,"SpreadElement")}parseRestBinding(){const e=this.startNode();return this.next(),e.argument=this.parseBindingAtom(),this.finishNode(e,"RestElement")}parseBindingAtom(){switch(this.state.type){case c.bracketL:{const e=this.startNode();return this.next(),e.elements=this.parseBindingList(c.bracketR,93,!0),this.finishNode(e,"ArrayPattern")}case c.braceL:return this.parseObjectLike(c.braceR,!0)}return this.parseIdentifier()}parseBindingList(e,t,r,n){const s=[];let i=!0;for(;!this.eat(e);)if(i?i=!1:this.expect(c.comma),r&&this.match(c.comma))s.push(null);else {if(this.eat(e))break;if(this.match(c.ellipsis)){s.push(this.parseAssignableListItemTypes(this.parseRestBinding())),this.checkCommaAfterRest(t),this.expect(e);break}{const e=[];for(this.match(c.at)&&this.hasPlugin("decorators")&&this.raise(this.state.start,v.UnsupportedParameterDecorator);this.match(c.at);)e.push(this.parseDecorator());s.push(this.parseAssignableListItem(n,e));}}return s}parseAssignableListItem(e,t){const r=this.parseMaybeDefault();this.parseAssignableListItemTypes(r);const n=this.parseMaybeDefault(r.start,r.loc.start,r);return t.length&&(r.decorators=t),n}parseAssignableListItemTypes(e){return e}parseMaybeDefault(e,t,r){var n,s,i;if(t=null!=(n=t)?n:this.state.startLoc,e=null!=(s=e)?s:this.state.start,r=null!=(i=r)?i:this.parseBindingAtom(),!this.eat(c.eq))return r;const o=this.startNodeAt(e,t);return o.left=r,o.right=this.parseMaybeAssignAllowIn(),this.finishNode(o,"AssignmentPattern")}checkLVal(e,t,r=64,n,s,i=!1){switch(e.type){case"Identifier":{const{name:t}=e;this.state.strict&&(i?U(t,this.inModule):R(t))&&this.raise(e.start,64===r?v.StrictEvalArguments:v.StrictEvalArgumentsBinding,t),n&&(n.has(t)?this.raise(e.start,v.ParamDupe):n.add(t)),s&&"let"===t&&this.raise(e.start,v.LetInLexicalBinding),64&r||this.scope.declareName(t,r,e.start);break}case"MemberExpression":64!==r&&this.raise(e.start,v.InvalidPropertyBindingPattern);break;case"ObjectPattern":for(let t of e.properties){if(this.isObjectProperty(t))t=t.value;else if(this.isObjectMethod(t))continue;this.checkLVal(t,"object destructuring pattern",r,n,s);}break;case"ArrayPattern":for(const t of e.elements)t&&this.checkLVal(t,"array destructuring pattern",r,n,s);break;case"AssignmentPattern":this.checkLVal(e.left,"assignment pattern",r,n);break;case"RestElement":this.checkLVal(e.argument,"rest element",r,n);break;case"ParenthesizedExpression":this.checkLVal(e.expression,"parenthesized expression",r,n);break;default:this.raise(e.start,64===r?v.InvalidLhs:v.InvalidLhsBinding,t);}}checkToRestConversion(e){"Identifier"!==e.argument.type&&"MemberExpression"!==e.argument.type&&this.raise(e.argument.start,v.InvalidRestAssignmentPattern);}checkCommaAfterRest(e){this.match(c.comma)&&(this.lookaheadCharCode()===e?this.raiseTrailingCommaAfterRest(this.state.start):this.raiseRestNotLast(this.state.start));}raiseRestNotLast(e){throw this.raise(e,v.ElementAfterRest)}raiseTrailingCommaAfterRest(e){this.raise(e,v.RestTrailingComma);}}{checkProto(e,t,r,n){if("SpreadElement"===e.type||this.isObjectMethod(e)||e.computed||e.shorthand)return;const s=e.key;if("__proto__"===("Identifier"===s.type?s.name:s.value)){if(t)return void this.raise(s.start,v.RecordNoProto);r.used&&(n?-1===n.doubleProto&&(n.doubleProto=s.start):this.raise(s.start,v.DuplicateProto)),r.used=!0;}}shouldExitDescending(e,t){return "ArrowFunctionExpression"===e.type&&e.start===t}getExpression(){let e=0;this.hasPlugin("topLevelAwait")&&this.inModule&&(e|=2),this.scope.enter(1),this.prodParam.enter(e),this.nextToken();const t=this.parseExpression();return this.match(c.eof)||this.unexpected(),t.comments=this.state.comments,t.errors=this.state.errors,this.options.tokens&&(t.tokens=this.tokens),t}parseExpression(e,t){return e?this.disallowInAnd((()=>this.parseExpressionBase(t))):this.allowInAnd((()=>this.parseExpressionBase(t)))}parseExpressionBase(e){const t=this.state.start,r=this.state.startLoc,n=this.parseMaybeAssign(e);if(this.match(c.comma)){const s=this.startNodeAt(t,r);for(s.expressions=[n];this.eat(c.comma);)s.expressions.push(this.parseMaybeAssign(e));return this.toReferencedList(s.expressions),this.finishNode(s,"SequenceExpression")}return n}parseMaybeAssignDisallowIn(e,t,r){return this.disallowInAnd((()=>this.parseMaybeAssign(e,t,r)))}parseMaybeAssignAllowIn(e,t,r){return this.allowInAnd((()=>this.parseMaybeAssign(e,t,r)))}parseMaybeAssign(e,t,r){const n=this.state.start,s=this.state.startLoc;if(this.isContextual("yield")&&this.prodParam.hasYield){this.state.exprAllowed=!0;let e=this.parseYield();return t&&(e=t.call(this,e,n,s)),e}let i;e?i=!1:(e=new Ne,i=!0),(this.match(c.parenL)||this.match(c.name))&&(this.state.potentialArrowAt=this.state.start);let o=this.parseMaybeConditional(e,r);if(t&&(o=t.call(this,o,n,s)),this.state.type.isAssign){const t=this.startNodeAt(n,s),r=this.state.value;return t.operator=r,this.match(c.eq)?(t.left=this.toAssignable(o,!0),e.doubleProto=-1):t.left=o,e.shorthandAssign>=t.left.start&&(e.shorthandAssign=-1),this.checkLVal(o,"assignment expression"),this.next(),t.right=this.parseMaybeAssign(),this.finishNode(t,"AssignmentExpression")}return i&&this.checkExpressionErrors(e,!0),o}parseMaybeConditional(e,t){const r=this.state.start,n=this.state.startLoc,s=this.state.potentialArrowAt,i=this.parseExprOps(e);return this.shouldExitDescending(i,s)?i:this.parseConditional(i,r,n,t)}parseConditional(e,t,r,n){if(this.eat(c.question)){const n=this.startNodeAt(t,r);return n.test=e,n.consequent=this.parseMaybeAssignAllowIn(),this.expect(c.colon),n.alternate=this.parseMaybeAssign(),this.finishNode(n,"ConditionalExpression")}return e}parseExprOps(e){const t=this.state.start,r=this.state.startLoc,n=this.state.potentialArrowAt,s=this.parseMaybeUnary(e);return this.shouldExitDescending(s,n)?s:this.parseExprOp(s,t,r,-1)}parseExprOp(e,t,r,n){let s=this.state.type.binop;if(null!=s&&(this.prodParam.hasIn||!this.match(c._in))&&s>n){const i=this.state.type;if(i===c.pipeline){if(this.expectPlugin("pipelineOperator"),this.state.inFSharpPipelineDirectBody)return e;this.state.inPipeline=!0,this.checkPipelineAtInfixOperator(e,t);}const o=this.startNodeAt(t,r);o.left=e,o.operator=this.state.value;const a=i===c.logicalOR||i===c.logicalAND,l=i===c.nullishCoalescing;if(l&&(s=c.logicalAND.binop),this.next(),i===c.pipeline&&"minimal"===this.getPluginOption("pipelineOperator","proposal")&&this.match(c.name)&&"await"===this.state.value&&this.prodParam.hasAwait)throw this.raise(this.state.start,v.UnexpectedAwaitAfterPipelineBody);o.right=this.parseExprOpRightExpr(i,s),this.finishNode(o,a||l?"LogicalExpression":"BinaryExpression");const u=this.state.type;if(l&&(u===c.logicalOR||u===c.logicalAND)||a&&u===c.nullishCoalescing)throw this.raise(this.state.start,v.MixingCoalesceWithLogical);return this.parseExprOp(o,t,r,n)}return e}parseExprOpRightExpr(e,t){const r=this.state.start,n=this.state.startLoc;switch(e){case c.pipeline:switch(this.getPluginOption("pipelineOperator","proposal")){case"smart":return this.withTopicPermittingContext((()=>this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(e,t),r,n)));case"fsharp":return this.withSoloAwaitPermittingContext((()=>this.parseFSharpPipelineBody(t)))}default:return this.parseExprOpBaseRightExpr(e,t)}}parseExprOpBaseRightExpr(e,t){const r=this.state.start,n=this.state.startLoc;return this.parseExprOp(this.parseMaybeUnary(),r,n,e.rightAssociative?t-1:t)}checkExponentialAfterUnary(e){this.match(c.exponent)&&this.raise(e.argument.start,v.UnexpectedTokenUnaryExponentiation);}parseMaybeUnary(e,t){const r=this.state.start,n=this.state.startLoc,s=this.isContextual("await");if(s&&this.isAwaitAllowed()){this.next();const e=this.parseAwait(r,n);return t||this.checkExponentialAfterUnary(e),e}if(this.isContextual("module")&&123===this.lookaheadCharCode()&&!this.hasFollowingLineBreak())return this.parseModuleExpression();const i=this.match(c.incDec),o=this.startNode();if(this.state.type.prefix){o.operator=this.state.value,o.prefix=!0,this.match(c._throw)&&this.expectPlugin("throwExpressions");const r=this.match(c._delete);if(this.next(),o.argument=this.parseMaybeUnary(null,!0),this.checkExpressionErrors(e,!0),this.state.strict&&r){const e=o.argument;"Identifier"===e.type?this.raise(o.start,v.StrictDelete):this.hasPropertyAsPrivateName(e)&&this.raise(o.start,v.DeletePrivateField);}if(!i)return t||this.checkExponentialAfterUnary(o),this.finishNode(o,"UnaryExpression")}const a=this.parseUpdate(o,i,e);return s&&(this.hasPlugin("v8intrinsic")?this.state.type.startsExpr:this.state.type.startsExpr&&!this.match(c.modulo))&&!this.isAmbiguousAwait()?(this.raiseOverwrite(r,this.hasPlugin("topLevelAwait")?v.AwaitNotInAsyncContext:v.AwaitNotInAsyncFunction),this.parseAwait(r,n)):a}parseUpdate(e,t,r){if(t)return this.checkLVal(e.argument,"prefix operation"),this.finishNode(e,"UpdateExpression");const n=this.state.start,s=this.state.startLoc;let i=this.parseExprSubscripts(r);if(this.checkExpressionErrors(r,!1))return i;for(;this.state.type.postfix&&!this.canInsertSemicolon();){const e=this.startNodeAt(n,s);e.operator=this.state.value,e.prefix=!1,e.argument=i,this.checkLVal(i,"postfix operation"),this.next(),i=this.finishNode(e,"UpdateExpression");}return i}parseExprSubscripts(e){const t=this.state.start,r=this.state.startLoc,n=this.state.potentialArrowAt,s=this.parseExprAtom(e);return this.shouldExitDescending(s,n)?s:this.parseSubscripts(s,t,r)}parseSubscripts(e,t,r,n){const s={optionalChainMember:!1,maybeAsyncArrow:this.atPossibleAsyncArrow(e),stop:!1};do{e=this.parseSubscript(e,t,r,n,s),s.maybeAsyncArrow=!1;}while(!s.stop);return e}parseSubscript(e,t,r,n,s){if(!n&&this.eat(c.doubleColon))return this.parseBind(e,t,r,n,s);if(this.match(c.backQuote))return this.parseTaggedTemplateExpression(e,t,r,s);let i=!1;if(this.match(c.questionDot)){if(n&&40===this.lookaheadCharCode())return s.stop=!0,e;s.optionalChainMember=i=!0,this.next();}return !n&&this.match(c.parenL)?this.parseCoverCallAndAsyncArrowHead(e,t,r,s,i):i||this.match(c.bracketL)||this.eat(c.dot)?this.parseMember(e,t,r,s,i):(s.stop=!0,e)}parseMember(e,t,r,n,s){const i=this.startNodeAt(t,r),o=this.eat(c.bracketL);i.object=e,i.computed=o;const a=!o&&this.match(c.privateName)&&this.state.value,l=o?this.parseExpression():a?this.parsePrivateName():this.parseIdentifier(!0);return !1!==a&&("Super"===i.object.type&&this.raise(t,v.SuperPrivateField),this.classScope.usePrivateName(a,l.start)),i.property=l,o&&this.expect(c.bracketR),n.optionalChainMember?(i.optional=s,this.finishNode(i,"OptionalMemberExpression")):this.finishNode(i,"MemberExpression")}parseBind(e,t,r,n,s){const i=this.startNodeAt(t,r);return i.object=e,i.callee=this.parseNoCallExpr(),s.stop=!0,this.parseSubscripts(this.finishNode(i,"BindExpression"),t,r,n)}parseCoverCallAndAsyncArrowHead(e,t,r,n,s){const i=this.state.maybeInArrowParameters;this.state.maybeInArrowParameters=!0,this.next();let o=this.startNodeAt(t,r);return o.callee=e,n.maybeAsyncArrow&&this.expressionScope.enter(new Oe(2)),n.optionalChainMember&&(o.optional=s),o.arguments=s?this.parseCallExpressionArguments(c.parenR,!1):this.parseCallExpressionArguments(c.parenR,n.maybeAsyncArrow,"Import"===e.type,"Super"!==e.type,o),this.finishCallExpression(o,n.optionalChainMember),n.maybeAsyncArrow&&this.shouldParseAsyncArrow()&&!s?(n.stop=!0,this.expressionScope.validateAsPattern(),this.expressionScope.exit(),o=this.parseAsyncArrowFromCallExpression(this.startNodeAt(t,r),o)):(n.maybeAsyncArrow&&this.expressionScope.exit(),this.toReferencedArguments(o)),this.state.maybeInArrowParameters=i,o}toReferencedArguments(e,t){this.toReferencedListDeep(e.arguments,t);}parseTaggedTemplateExpression(e,t,r,n){const s=this.startNodeAt(t,r);return s.tag=e,s.quasi=this.parseTemplate(!0),n.optionalChainMember&&this.raise(t,v.OptionalChainingNoTemplate),this.finishNode(s,"TaggedTemplateExpression")}atPossibleAsyncArrow(e){return "Identifier"===e.type&&"async"===e.name&&this.state.lastTokEnd===e.end&&!this.canInsertSemicolon()&&e.end-e.start==5&&e.start===this.state.potentialArrowAt}finishCallExpression(e,t){if("Import"===e.callee.type)if(2===e.arguments.length&&(this.hasPlugin("moduleAttributes")||this.expectPlugin("importAssertions")),0===e.arguments.length||e.arguments.length>2)this.raise(e.start,v.ImportCallArity,this.hasPlugin("importAssertions")||this.hasPlugin("moduleAttributes")?"one or two arguments":"one argument");else for(const t of e.arguments)"SpreadElement"===t.type&&this.raise(t.start,v.ImportCallSpreadArgument);return this.finishNode(e,t?"OptionalCallExpression":"CallExpression")}parseCallExpressionArguments(e,t,r,n,s){const i=[];let o=!0;const a=this.state.inFSharpPipelineDirectBody;for(this.state.inFSharpPipelineDirectBody=!1;!this.eat(e);){if(o)o=!1;else if(this.expect(c.comma),this.match(e)){!r||this.hasPlugin("importAssertions")||this.hasPlugin("moduleAttributes")||this.raise(this.state.lastTokStart,v.ImportCallArgumentTrailingComma),s&&this.addExtra(s,"trailingComma",this.state.lastTokStart),this.next();break}i.push(this.parseExprListItem(!1,t?new Ne:void 0,t?{start:0}:void 0,n));}return this.state.inFSharpPipelineDirectBody=a,i}shouldParseAsyncArrow(){return this.match(c.arrow)&&!this.canInsertSemicolon()}parseAsyncArrowFromCallExpression(e,t){var r;return this.expect(c.arrow),this.parseArrowExpression(e,t.arguments,!0,null==(r=t.extra)?void 0:r.trailingComma),e}parseNoCallExpr(){const e=this.state.start,t=this.state.startLoc;return this.parseSubscripts(this.parseExprAtom(),e,t,!0)}parseExprAtom(e){this.state.type===c.slash&&this.readRegexp();const t=this.state.potentialArrowAt===this.state.start;let r;switch(this.state.type){case c._super:return this.parseSuper();case c._import:return r=this.startNode(),this.next(),this.match(c.dot)?this.parseImportMetaProperty(r):(this.match(c.parenL)||this.raise(this.state.lastTokStart,v.UnsupportedImport),this.finishNode(r,"Import"));case c._this:return r=this.startNode(),this.next(),this.finishNode(r,"ThisExpression");case c.name:{const e=this.state.containsEsc,r=this.parseIdentifier();if(!e&&"async"===r.name&&!this.canInsertSemicolon()){if(this.match(c._function)){const e=this.state.context.length-1;if(this.state.context[e]!==P.functionStatement)throw new Error("Internal error");return this.state.context[e]=P.functionExpression,this.next(),this.parseFunction(this.startNodeAtNode(r),void 0,!0)}if(this.match(c.name))return 61===this.lookaheadCharCode()?this.parseAsyncArrowUnaryFunction(r):r;if(this.match(c._do))return this.parseDo(!0)}return t&&this.match(c.arrow)&&!this.canInsertSemicolon()?(this.next(),this.parseArrowExpression(this.startNodeAtNode(r),[r],!1)):r}case c._do:return this.parseDo(!1);case c.regexp:{const e=this.state.value;return r=this.parseLiteral(e.value,"RegExpLiteral"),r.pattern=e.pattern,r.flags=e.flags,r}case c.num:return this.parseLiteral(this.state.value,"NumericLiteral");case c.bigint:return this.parseLiteral(this.state.value,"BigIntLiteral");case c.decimal:return this.parseLiteral(this.state.value,"DecimalLiteral");case c.string:return this.parseLiteral(this.state.value,"StringLiteral");case c._null:return r=this.startNode(),this.next(),this.finishNode(r,"NullLiteral");case c._true:case c._false:return this.parseBooleanLiteral();case c.parenL:return this.parseParenAndDistinguishExpression(t);case c.bracketBarL:case c.bracketHashL:return this.parseArrayLike(this.state.type===c.bracketBarL?c.bracketBarR:c.bracketR,!1,!0,e);case c.bracketL:return this.parseArrayLike(c.bracketR,!0,!1,e);case c.braceBarL:case c.braceHashL:return this.parseObjectLike(this.state.type===c.braceBarL?c.braceBarR:c.braceR,!1,!0,e);case c.braceL:return this.parseObjectLike(c.braceR,!1,!1,e);case c._function:return this.parseFunctionOrFunctionSent();case c.at:this.parseDecorators();case c._class:return r=this.startNode(),this.takeDecorators(r),this.parseClass(r,!1);case c._new:return this.parseNewOrNewTarget();case c.backQuote:return this.parseTemplate(!1);case c.doubleColon:{r=this.startNode(),this.next(),r.object=null;const e=r.callee=this.parseNoCallExpr();if("MemberExpression"===e.type)return this.finishNode(r,"BindExpression");throw this.raise(e.start,v.UnsupportedBind)}case c.privateName:{const e=this.state.start,t=this.state.value;if(r=this.parsePrivateName(),this.match(c._in))this.expectPlugin("privateIn"),this.classScope.usePrivateName(t,r.start);else {if(!this.hasPlugin("privateIn"))throw this.unexpected(e);this.raise(this.state.start,v.PrivateInExpectedIn,t);}return r}case c.hash:if(this.state.inPipeline)return r=this.startNode(),"smart"!==this.getPluginOption("pipelineOperator","proposal")&&this.raise(r.start,v.PrimaryTopicRequiresSmartPipeline),this.next(),this.primaryTopicReferenceIsAllowedInCurrentTopicContext()||this.raise(r.start,v.PrimaryTopicNotAllowed),this.registerTopicReference(),this.finishNode(r,"PipelinePrimaryTopicReference");case c.relational:if("<"===this.state.value){const e=this.input.codePointAt(this.nextTokenStart());(I(e)||62===e)&&this.expectOnePlugin(["jsx","flow","typescript"]);}default:throw this.unexpected()}}parseAsyncArrowUnaryFunction(e){const t=this.startNodeAtNode(e);this.prodParam.enter(le(!0,this.prodParam.hasYield));const r=[this.parseIdentifier()];return this.prodParam.exit(),this.hasPrecedingLineBreak()&&this.raise(this.state.pos,v.LineTerminatorBeforeArrow),this.expect(c.arrow),this.parseArrowExpression(t,r,!0),t}parseDo(e){this.expectPlugin("doExpressions"),e&&this.expectPlugin("asyncDoExpressions");const t=this.startNode();t.async=e,this.next();const r=this.state.labels;return this.state.labels=[],e?(this.prodParam.enter(2),t.body=this.parseBlock(),this.prodParam.exit()):t.body=this.parseBlock(),this.state.labels=r,this.finishNode(t,"DoExpression")}parseSuper(){const e=this.startNode();return this.next(),!this.match(c.parenL)||this.scope.allowDirectSuper||this.options.allowSuperOutsideMethod?this.scope.allowSuper||this.options.allowSuperOutsideMethod||this.raise(e.start,v.UnexpectedSuper):this.raise(e.start,v.SuperNotAllowed),this.match(c.parenL)||this.match(c.bracketL)||this.match(c.dot)||this.raise(e.start,v.UnsupportedSuper),this.finishNode(e,"Super")}parseBooleanLiteral(){const e=this.startNode();return e.value=this.match(c._true),this.next(),this.finishNode(e,"BooleanLiteral")}parseMaybePrivateName(e){return this.match(c.privateName)?(e||this.raise(this.state.start+1,v.UnexpectedPrivateField),this.parsePrivateName()):this.parseIdentifier(!0)}parsePrivateName(){const e=this.startNode(),t=this.startNodeAt(this.state.start+1,new y(this.state.curLine,this.state.start+1-this.state.lineStart)),r=this.state.value;return this.next(),e.id=this.createIdentifier(t,r),this.finishNode(e,"PrivateName")}parseFunctionOrFunctionSent(){const e=this.startNode();if(this.next(),this.prodParam.hasYield&&this.match(c.dot)){const t=this.createIdentifier(this.startNodeAtNode(e),"function");return this.next(),this.parseMetaProperty(e,t,"sent")}return this.parseFunction(e)}parseMetaProperty(e,t,r){e.meta=t,"function"===t.name&&"sent"===r&&(this.isContextual(r)?this.expectPlugin("functionSent"):this.hasPlugin("functionSent")||this.unexpected());const n=this.state.containsEsc;return e.property=this.parseIdentifier(!0),(e.property.name!==r||n)&&this.raise(e.property.start,v.UnsupportedMetaProperty,t.name,r),this.finishNode(e,"MetaProperty")}parseImportMetaProperty(e){const t=this.createIdentifier(this.startNodeAtNode(e),"import");return this.next(),this.isContextual("meta")&&(this.inModule||this.raise(t.start,x.ImportMetaOutsideModule),this.sawUnambiguousESM=!0),this.parseMetaProperty(e,t,"meta")}parseLiteral(e,t,r,n){r=r||this.state.start,n=n||this.state.startLoc;const s=this.startNodeAt(r,n);return this.addExtra(s,"rawValue",e),this.addExtra(s,"raw",this.input.slice(r,this.state.end)),s.value=e,this.next(),this.finishNode(s,t)}parseParenAndDistinguishExpression(e){const t=this.state.start,r=this.state.startLoc;let n;this.next(),this.expressionScope.enter(new Oe(1));const s=this.state.maybeInArrowParameters,i=this.state.inFSharpPipelineDirectBody;this.state.maybeInArrowParameters=!0,this.state.inFSharpPipelineDirectBody=!1;const o=this.state.start,a=this.state.startLoc,l=[],u=new Ne,p={start:0};let d,f,h=!0;for(;!this.match(c.parenR);){if(h)h=!1;else if(this.expect(c.comma,p.start||null),this.match(c.parenR)){f=this.state.start;break}if(this.match(c.ellipsis)){const e=this.state.start,t=this.state.startLoc;d=this.state.start,l.push(this.parseParenItem(this.parseRestBinding(),e,t)),this.checkCommaAfterRest(41);break}l.push(this.parseMaybeAssignAllowIn(u,this.parseParenItem,p));}const m=this.state.lastTokEnd,y=this.state.lastTokEndLoc;this.expect(c.parenR),this.state.maybeInArrowParameters=s,this.state.inFSharpPipelineDirectBody=i;let b=this.startNodeAt(t,r);if(e&&this.shouldParseArrow()&&(b=this.parseArrow(b)))return this.expressionScope.validateAsPattern(),this.expressionScope.exit(),this.parseArrowExpression(b,l,!1),b;if(this.expressionScope.exit(),l.length||this.unexpected(this.state.lastTokStart),f&&this.unexpected(f),d&&this.unexpected(d),this.checkExpressionErrors(u,!0),p.start&&this.unexpected(p.start),this.toReferencedListDeep(l,!0),l.length>1?(n=this.startNodeAt(o,a),n.expressions=l,this.finishNodeAt(n,"SequenceExpression",m,y)):n=l[0],!this.options.createParenthesizedExpressions)return this.addExtra(n,"parenthesized",!0),this.addExtra(n,"parenStart",t),n;const g=this.startNodeAt(t,r);return g.expression=n,this.finishNode(g,"ParenthesizedExpression"),g}shouldParseArrow(){return !this.canInsertSemicolon()}parseArrow(e){if(this.eat(c.arrow))return e}parseParenItem(e,t,r){return e}parseNewOrNewTarget(){const e=this.startNode();if(this.next(),this.match(c.dot)){const t=this.createIdentifier(this.startNodeAtNode(e),"new");this.next();const r=this.parseMetaProperty(e,t,"target");return this.scope.inNonArrowFunction||this.scope.inClass||this.raise(r.start,v.UnexpectedNewTarget),r}return this.parseNew(e)}parseNew(e){return e.callee=this.parseNoCallExpr(),"Import"===e.callee.type?this.raise(e.callee.start,v.ImportCallNotNewExpression):this.isOptionalChain(e.callee)?this.raise(this.state.lastTokEnd,v.OptionalChainingNoNew):this.eat(c.questionDot)&&this.raise(this.state.start,v.OptionalChainingNoNew),this.parseNewArguments(e),this.finishNode(e,"NewExpression")}parseNewArguments(e){if(this.eat(c.parenL)){const t=this.parseExprList(c.parenR);this.toReferencedList(t),e.arguments=t;}else e.arguments=[];}parseTemplateElement(e){const t=this.startNode();return null===this.state.value&&(e||this.raise(this.state.start+1,v.InvalidEscapeSequenceTemplate)),t.value={raw:this.input.slice(this.state.start,this.state.end).replace(/\r\n?/g,"\n"),cooked:this.state.value},this.next(),t.tail=this.match(c.backQuote),this.finishNode(t,"TemplateElement")}parseTemplate(e){const t=this.startNode();this.next(),t.expressions=[];let r=this.parseTemplateElement(e);for(t.quasis=[r];!r.tail;)this.expect(c.dollarBraceL),t.expressions.push(this.parseTemplateSubstitution()),this.expect(c.braceR),t.quasis.push(r=this.parseTemplateElement(e));return this.next(),this.finishNode(t,"TemplateLiteral")}parseTemplateSubstitution(){return this.parseExpression()}parseObjectLike(e,t,r,n){r&&this.expectPlugin("recordAndTuple");const s=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!1;const i=Object.create(null);let o=!0;const a=this.startNode();for(a.properties=[],this.next();!this.match(e);){if(o)o=!1;else if(this.expect(c.comma),this.match(e)){this.addExtra(a,"trailingComma",this.state.lastTokStart);break}const s=this.parsePropertyDefinition(t,n);t||this.checkProto(s,r,i,n),r&&!this.isObjectProperty(s)&&"SpreadElement"!==s.type&&this.raise(s.start,v.InvalidRecordProperty),s.shorthand&&this.addExtra(s,"shorthand",!0),a.properties.push(s);}this.state.exprAllowed=!1,this.next(),this.state.inFSharpPipelineDirectBody=s;let l="ObjectExpression";return t?l="ObjectPattern":r&&(l="RecordExpression"),this.finishNode(a,l)}maybeAsyncOrAccessorProp(e){return !e.computed&&"Identifier"===e.key.type&&(this.isLiteralPropertyName()||this.match(c.bracketL)||this.match(c.star))}parsePropertyDefinition(e,t){let r=[];if(this.match(c.at))for(this.hasPlugin("decorators")&&this.raise(this.state.start,v.UnsupportedPropertyDecorator);this.match(c.at);)r.push(this.parseDecorator());const n=this.startNode();let s,i,o=!1,a=!1,l=!1;if(this.match(c.ellipsis))return r.length&&this.unexpected(),e?(this.next(),n.argument=this.parseIdentifier(),this.checkCommaAfterRest(125),this.finishNode(n,"RestElement")):this.parseSpread();r.length&&(n.decorators=r,r=[]),n.method=!1,(e||t)&&(s=this.state.start,i=this.state.startLoc),e||(o=this.eat(c.star));const u=this.state.containsEsc,p=this.parsePropertyName(n,!1);if(!e&&!o&&!u&&this.maybeAsyncOrAccessorProp(n)){const e=p.name;"async"!==e||this.hasPrecedingLineBreak()||(a=!0,o=this.eat(c.star),this.parsePropertyName(n,!1)),"get"!==e&&"set"!==e||(l=!0,n.kind=e,this.match(c.star)&&(o=!0,this.raise(this.state.pos,v.AccessorIsGenerator,e),this.next()),this.parsePropertyName(n,!1));}return this.parseObjPropValue(n,s,i,o,a,e,l,t),n}getGetterSetterExpectedParamCount(e){return "get"===e.kind?0:1}getObjectOrClassMethodParams(e){return e.params}checkGetterSetterParams(e){var t;const r=this.getGetterSetterExpectedParamCount(e),n=this.getObjectOrClassMethodParams(e),s=e.start;n.length!==r&&("get"===e.kind?this.raise(s,v.BadGetterArity):this.raise(s,v.BadSetterArity)),"set"===e.kind&&"RestElement"===(null==(t=n[n.length-1])?void 0:t.type)&&this.raise(s,v.BadSetterRestParameter);}parseObjectMethod(e,t,r,n,s){return s?(this.parseMethod(e,t,!1,!1,!1,"ObjectMethod"),this.checkGetterSetterParams(e),e):r||t||this.match(c.parenL)?(n&&this.unexpected(),e.kind="method",e.method=!0,this.parseMethod(e,t,r,!1,!1,"ObjectMethod")):void 0}parseObjectProperty(e,t,r,n,s){return e.shorthand=!1,this.eat(c.colon)?(e.value=n?this.parseMaybeDefault(this.state.start,this.state.startLoc):this.parseMaybeAssignAllowIn(s),this.finishNode(e,"ObjectProperty")):e.computed||"Identifier"!==e.key.type?void 0:(this.checkReservedWord(e.key.name,e.key.start,!0,!1),n?e.value=this.parseMaybeDefault(t,r,e.key.__clone()):this.match(c.eq)&&s?(-1===s.shorthandAssign&&(s.shorthandAssign=this.state.start),e.value=this.parseMaybeDefault(t,r,e.key.__clone())):e.value=e.key.__clone(),e.shorthand=!0,this.finishNode(e,"ObjectProperty"))}parseObjPropValue(e,t,r,n,s,i,o,a){const l=this.parseObjectMethod(e,n,s,i,o)||this.parseObjectProperty(e,t,r,i,a);return l||this.unexpected(),l}parsePropertyName(e,t){if(this.eat(c.bracketL))e.computed=!0,e.key=this.parseMaybeAssignAllowIn(),this.expect(c.bracketR);else {const r=this.state.inPropertyName;this.state.inPropertyName=!0;const n=this.state.type;e.key=n===c.num||n===c.string||n===c.bigint||n===c.decimal?this.parseExprAtom():this.parseMaybePrivateName(t),n!==c.privateName&&(e.computed=!1),this.state.inPropertyName=r;}return e.key}initFunction(e,t){e.id=null,e.generator=!1,e.async=!!t;}parseMethod(e,t,r,n,s,i,o=!1){this.initFunction(e,r),e.generator=!!t;const a=n;return this.scope.enter(18|(o?64:0)|(s?32:0)),this.prodParam.enter(le(r,e.generator)),this.parseFunctionParams(e,a),this.parseFunctionBodyAndFinish(e,i,!0),this.prodParam.exit(),this.scope.exit(),e}parseArrayLike(e,t,r,n){r&&this.expectPlugin("recordAndTuple");const s=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!1;const i=this.startNode();return this.next(),i.elements=this.parseExprList(e,!r,n,i),this.state.inFSharpPipelineDirectBody=s,this.finishNode(i,r?"TupleExpression":"ArrayExpression")}parseArrowExpression(e,t,r,n){this.scope.enter(6);let s=le(r,!1);!this.match(c.bracketL)&&this.prodParam.hasIn&&(s|=8),this.prodParam.enter(s),this.initFunction(e,r);const i=this.state.maybeInArrowParameters;return t&&(this.state.maybeInArrowParameters=!0,this.setArrowFunctionParameters(e,t,n)),this.state.maybeInArrowParameters=!1,this.parseFunctionBody(e,!0),this.prodParam.exit(),this.scope.exit(),this.state.maybeInArrowParameters=i,this.finishNode(e,"ArrowFunctionExpression")}setArrowFunctionParameters(e,t,r){e.params=this.toAssignableList(t,r,!1);}parseFunctionBodyAndFinish(e,t,r=!1){this.parseFunctionBody(e,!1,r),this.finishNode(e,t);}parseFunctionBody(e,t,r=!1){const n=t&&!this.match(c.braceL);if(this.expressionScope.enter(Ie()),n)e.body=this.parseMaybeAssign(),this.checkParams(e,!1,t,!1);else {const n=this.state.strict,s=this.state.labels;this.state.labels=[],this.prodParam.enter(4|this.prodParam.currentFlags()),e.body=this.parseBlock(!0,!1,(s=>{const i=!this.isSimpleParamList(e.params);if(s&&i){const t="method"!==e.kind&&"constructor"!==e.kind||!e.key?e.start:e.key.end;this.raise(t,v.IllegalLanguageModeDirective);}const o=!n&&this.state.strict;this.checkParams(e,!(this.state.strict||t||r||i),t,o),this.state.strict&&e.id&&this.checkLVal(e.id,"function name",65,void 0,void 0,o);})),this.prodParam.exit(),this.expressionScope.exit(),this.state.labels=s;}}isSimpleParamList(e){for(let t=0,r=e.length;t<r;t++)if("Identifier"!==e[t].type)return !1;return !0}checkParams(e,t,r,n=!0){const s=new Set;for(const r of e.params)this.checkLVal(r,"function parameter list",5,t?null:s,void 0,n);}parseExprList(e,t,r,n){const s=[];let i=!0;for(;!this.eat(e);){if(i)i=!1;else if(this.expect(c.comma),this.match(e)){n&&this.addExtra(n,"trailingComma",this.state.lastTokStart),this.next();break}s.push(this.parseExprListItem(t,r));}return s}parseExprListItem(e,t,r,n){let s;if(this.match(c.comma))e||this.raise(this.state.pos,v.UnexpectedToken,","),s=null;else if(this.match(c.ellipsis)){const e=this.state.start,n=this.state.startLoc;s=this.parseParenItem(this.parseSpread(t,r),e,n);}else if(this.match(c.question)){this.expectPlugin("partialApplication"),n||this.raise(this.state.start,v.UnexpectedArgumentPlaceholder);const e=this.startNode();this.next(),s=this.finishNode(e,"ArgumentPlaceholder");}else s=this.parseMaybeAssignAllowIn(t,this.parseParenItem,r);return s}parseIdentifier(e){const t=this.startNode(),r=this.parseIdentifierName(t.start,e);return this.createIdentifier(t,r)}createIdentifier(e,t){return e.name=t,e.loc.identifierName=t,this.finishNode(e,"Identifier")}parseIdentifierName(e,t){let r;const{start:n,type:s}=this.state;if(s===c.name)r=this.state.value;else {if(!s.keyword)throw this.unexpected();{r=s.keyword;const e=this.curContext();s!==c._class&&s!==c._function||e!==P.functionStatement&&e!==P.functionExpression||this.state.context.pop();}}return t?this.state.type=c.name:this.checkReservedWord(r,n,!!s.keyword,!1),this.next(),r}checkReservedWord(e,t,r,n){if(this.prodParam.hasYield&&"yield"===e)this.raise(t,v.YieldBindingIdentifier);else {if("await"===e){if(this.prodParam.hasAwait)return void this.raise(t,v.AwaitBindingIdentifier);if(this.scope.inStaticBlock&&!this.scope.inNonArrowFunction)return void this.raise(t,v.AwaitBindingIdentifierInStaticBlock);this.expressionScope.recordAsyncArrowParametersError(t,v.AwaitBindingIdentifier);}!this.scope.inClass||this.scope.inNonArrowFunction||"arguments"!==e?r&&V(e)?this.raise(t,v.UnexpectedKeyword,e):(this.state.strict?n?U:B:M)(e,this.inModule)&&this.raise(t,v.UnexpectedReservedWord,e):this.raise(t,v.ArgumentsInClass);}}isAwaitAllowed(){return !!this.prodParam.hasAwait||!(!this.options.allowAwaitOutsideFunction||this.scope.inFunction)}parseAwait(e,t){const r=this.startNodeAt(e,t);return this.expressionScope.recordParameterInitializerError(r.start,v.AwaitExpressionFormalParameter),this.eat(c.star)&&this.raise(r.start,v.ObsoleteAwaitStar),this.scope.inFunction||this.options.allowAwaitOutsideFunction||(this.isAmbiguousAwait()?this.ambiguousScriptDifferentAst=!0:this.sawUnambiguousESM=!0),this.state.soloAwait||(r.argument=this.parseMaybeUnary(null,!0)),this.finishNode(r,"AwaitExpression")}isAmbiguousAwait(){return this.hasPrecedingLineBreak()||this.match(c.plusMin)||this.match(c.parenL)||this.match(c.bracketL)||this.match(c.backQuote)||this.match(c.regexp)||this.match(c.slash)||this.hasPlugin("v8intrinsic")&&this.match(c.modulo)}parseYield(){const e=this.startNode();return this.expressionScope.recordParameterInitializerError(e.start,v.YieldInParameter),this.next(),this.match(c.semi)||!this.match(c.star)&&!this.state.type.startsExpr||this.hasPrecedingLineBreak()?(e.delegate=!1,e.argument=null):(e.delegate=this.eat(c.star),e.argument=this.parseMaybeAssign()),this.finishNode(e,"YieldExpression")}checkPipelineAtInfixOperator(e,t){"smart"===this.getPluginOption("pipelineOperator","proposal")&&"SequenceExpression"===e.type&&this.raise(t,v.PipelineHeadSequenceExpression);}parseSmartPipelineBody(e,t,r){return this.checkSmartPipelineBodyEarlyErrors(e,t),this.parseSmartPipelineBodyInStyle(e,t,r)}checkSmartPipelineBodyEarlyErrors(e,t){if(this.match(c.arrow))throw this.raise(this.state.start,v.PipelineBodyNoArrow);"SequenceExpression"===e.type&&this.raise(t,v.PipelineBodySequenceExpression);}parseSmartPipelineBodyInStyle(e,t,r){const n=this.startNodeAt(t,r),s=this.isSimpleReference(e);return s?n.callee=e:(this.topicReferenceWasUsedInCurrentTopicContext()||this.raise(t,v.PipelineTopicUnused),n.expression=e),this.finishNode(n,s?"PipelineBareFunction":"PipelineTopicExpression")}isSimpleReference(e){switch(e.type){case"MemberExpression":return !e.computed&&this.isSimpleReference(e.object);case"Identifier":return !0;default:return !1}}withTopicPermittingContext(e){const t=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:1,maxTopicIndex:null};try{return e()}finally{this.state.topicContext=t;}}withTopicForbiddingContext(e){const t=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null};try{return e()}finally{this.state.topicContext=t;}}withSoloAwaitPermittingContext(e){const t=this.state.soloAwait;this.state.soloAwait=!0;try{return e()}finally{this.state.soloAwait=t;}}allowInAnd(e){const t=this.prodParam.currentFlags();if(8&~t){this.prodParam.enter(8|t);try{return e()}finally{this.prodParam.exit();}}return e()}disallowInAnd(e){const t=this.prodParam.currentFlags();if(8&t){this.prodParam.enter(-9&t);try{return e()}finally{this.prodParam.exit();}}return e()}registerTopicReference(){this.state.topicContext.maxTopicIndex=0;}primaryTopicReferenceIsAllowedInCurrentTopicContext(){return this.state.topicContext.maxNumOfResolvableTopics>=1}topicReferenceWasUsedInCurrentTopicContext(){return null!=this.state.topicContext.maxTopicIndex&&this.state.topicContext.maxTopicIndex>=0}parseFSharpPipelineBody(e){const t=this.state.start,r=this.state.startLoc;this.state.potentialArrowAt=this.state.start;const n=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=!0;const s=this.parseExprOp(this.parseMaybeUnary(),t,r,e);return this.state.inFSharpPipelineDirectBody=n,s}parseModuleExpression(){this.expectPlugin("moduleBlocks");const e=this.startNode();this.next(),this.eat(c.braceL);const t=this.initializeScopes(!0);this.enterInitialScopes();const r=this.startNode();try{e.body=this.parseProgram(r,c.braceR,"module");}finally{t();}return this.eat(c.braceR),this.finishNode(e,"ModuleExpression")}}{parseTopLevel(e,t){return e.program=this.parseProgram(t),e.comments=this.state.comments,this.options.tokens&&(e.tokens=function(e){for(let t=0;t<e.length;t++){const r=e[t];if(r.type===c.privateName){const{loc:n,start:s,value:i,end:o}=r,a=s+1,l=new y(n.start.line,n.start.column+1);e.splice(t,1,new we({type:c.hash,value:"#",start:s,end:a,startLoc:n.start,endLoc:l}),new we({type:c.name,value:i,start:a,end:o,startLoc:l,endLoc:n.end}));}}return e}(this.tokens)),this.finishNode(e,"File")}parseProgram(e,t=c.eof,r=this.options.sourceType){if(e.sourceType=r,e.interpreter=this.parseInterpreterDirective(),this.parseBlockBody(e,!0,!0,t),this.inModule&&!this.options.allowUndeclaredExports&&this.scope.undefinedExports.size>0)for(const[e]of Array.from(this.scope.undefinedExports)){const t=this.scope.undefinedExports.get(e);this.raise(t,v.ModuleExportUndefined,e);}return this.finishNode(e,"Program")}stmtToDirective(e){const t=e.expression,r=this.startNodeAt(t.start,t.loc.start),n=this.startNodeAt(e.start,e.loc.start),s=this.input.slice(t.start,t.end),i=r.value=s.slice(1,-1);return this.addExtra(r,"raw",s),this.addExtra(r,"rawValue",i),n.value=this.finishNodeAt(r,"DirectiveLiteral",t.end,t.loc.end),this.finishNodeAt(n,"Directive",e.end,e.loc.end)}parseInterpreterDirective(){if(!this.match(c.interpreterDirective))return null;const e=this.startNode();return e.value=this.state.value,this.next(),this.finishNode(e,"InterpreterDirective")}isLet(e){return !!this.isContextual("let")&&this.isLetKeyword(e)}isLetKeyword(e){const t=this.nextTokenStart(),r=this.input.charCodeAt(t);if(92===r||91===r)return !0;if(e)return !1;if(123===r)return !0;if(I(r)){let e=t+1;for(;N(this.input.charCodeAt(e));)++e;const r=this.input.slice(t,e);if(!W.test(r))return !0}return !1}parseStatement(e,t){return this.match(c.at)&&this.parseDecorators(!0),this.parseStatementContent(e,t)}parseStatementContent(e,t){let r=this.state.type;const n=this.startNode();let s;switch(this.isLet(e)&&(r=c._var,s="let"),r){case c._break:case c._continue:return this.parseBreakContinueStatement(n,r.keyword);case c._debugger:return this.parseDebuggerStatement(n);case c._do:return this.parseDoStatement(n);case c._for:return this.parseForStatement(n);case c._function:if(46===this.lookaheadCharCode())break;return e&&(this.state.strict?this.raise(this.state.start,v.StrictFunction):"if"!==e&&"label"!==e&&this.raise(this.state.start,v.SloppyFunction)),this.parseFunctionStatement(n,!1,!e);case c._class:return e&&this.unexpected(),this.parseClass(n,!0);case c._if:return this.parseIfStatement(n);case c._return:return this.parseReturnStatement(n);case c._switch:return this.parseSwitchStatement(n);case c._throw:return this.parseThrowStatement(n);case c._try:return this.parseTryStatement(n);case c._const:case c._var:return s=s||this.state.value,e&&"var"!==s&&this.raise(this.state.start,v.UnexpectedLexicalDeclaration),this.parseVarStatement(n,s);case c._while:return this.parseWhileStatement(n);case c._with:return this.parseWithStatement(n);case c.braceL:return this.parseBlock();case c.semi:return this.parseEmptyStatement(n);case c._import:{const e=this.lookaheadCharCode();if(40===e||46===e)break}case c._export:{let e;return this.options.allowImportExportEverywhere||t||this.raise(this.state.start,v.UnexpectedImportExport),this.next(),r===c._import?(e=this.parseImport(n),"ImportDeclaration"!==e.type||e.importKind&&"value"!==e.importKind||(this.sawUnambiguousESM=!0)):(e=this.parseExport(n),("ExportNamedDeclaration"!==e.type||e.exportKind&&"value"!==e.exportKind)&&("ExportAllDeclaration"!==e.type||e.exportKind&&"value"!==e.exportKind)&&"ExportDefaultDeclaration"!==e.type||(this.sawUnambiguousESM=!0)),this.assertModuleNodeAllowed(n),e}default:if(this.isAsyncFunction())return e&&this.raise(this.state.start,v.AsyncFunctionInSingleStatementContext),this.next(),this.parseFunctionStatement(n,!0,!e)}const i=this.state.value,o=this.parseExpression();return r===c.name&&"Identifier"===o.type&&this.eat(c.colon)?this.parseLabeledStatement(n,i,o,e):this.parseExpressionStatement(n,o)}assertModuleNodeAllowed(e){this.options.allowImportExportEverywhere||this.inModule||this.raise(e.start,x.ImportOutsideModule);}takeDecorators(e){const t=this.state.decoratorStack[this.state.decoratorStack.length-1];t.length&&(e.decorators=t,this.resetStartLocationFromNode(e,t[0]),this.state.decoratorStack[this.state.decoratorStack.length-1]=[]);}canHaveLeadingDecorator(){return this.match(c._class)}parseDecorators(e){const t=this.state.decoratorStack[this.state.decoratorStack.length-1];for(;this.match(c.at);){const e=this.parseDecorator();t.push(e);}if(this.match(c._export))e||this.unexpected(),this.hasPlugin("decorators")&&!this.getPluginOption("decorators","decoratorsBeforeExport")&&this.raise(this.state.start,v.DecoratorExportClass);else if(!this.canHaveLeadingDecorator())throw this.raise(this.state.start,v.UnexpectedLeadingDecorator)}parseDecorator(){this.expectOnePlugin(["decorators-legacy","decorators"]);const e=this.startNode();if(this.next(),this.hasPlugin("decorators")){this.state.decoratorStack.push([]);const t=this.state.start,r=this.state.startLoc;let n;if(this.eat(c.parenL))n=this.parseExpression(),this.expect(c.parenR);else for(n=this.parseIdentifier(!1);this.eat(c.dot);){const e=this.startNodeAt(t,r);e.object=n,e.property=this.parseIdentifier(!0),e.computed=!1,n=this.finishNode(e,"MemberExpression");}e.expression=this.parseMaybeDecoratorArguments(n),this.state.decoratorStack.pop();}else e.expression=this.parseExprSubscripts();return this.finishNode(e,"Decorator")}parseMaybeDecoratorArguments(e){if(this.eat(c.parenL)){const t=this.startNodeAtNode(e);return t.callee=e,t.arguments=this.parseCallExpressionArguments(c.parenR,!1),this.toReferencedList(t.arguments),this.finishNode(t,"CallExpression")}return e}parseBreakContinueStatement(e,t){const r="break"===t;return this.next(),this.isLineTerminator()?e.label=null:(e.label=this.parseIdentifier(),this.semicolon()),this.verifyBreakContinue(e,t),this.finishNode(e,r?"BreakStatement":"ContinueStatement")}verifyBreakContinue(e,t){const r="break"===t;let n;for(n=0;n<this.state.labels.length;++n){const t=this.state.labels[n];if(null==e.label||t.name===e.label.name){if(null!=t.kind&&(r||"loop"===t.kind))break;if(e.label&&r)break}}n===this.state.labels.length&&this.raise(e.start,v.IllegalBreakContinue,t);}parseDebuggerStatement(e){return this.next(),this.semicolon(),this.finishNode(e,"DebuggerStatement")}parseHeaderExpression(){this.expect(c.parenL);const e=this.parseExpression();return this.expect(c.parenR),e}parseDoStatement(e){return this.next(),this.state.labels.push(Le),e.body=this.withTopicForbiddingContext((()=>this.parseStatement("do"))),this.state.labels.pop(),this.expect(c._while),e.test=this.parseHeaderExpression(),this.eat(c.semi),this.finishNode(e,"DoWhileStatement")}parseForStatement(e){this.next(),this.state.labels.push(Le);let t=-1;if(this.isAwaitAllowed()&&this.eatContextual("await")&&(t=this.state.lastTokStart),this.scope.enter(0),this.expect(c.parenL),this.match(c.semi))return t>-1&&this.unexpected(t),this.parseFor(e,null);const r=this.isContextual("let"),n=r&&this.isLetKeyword();if(this.match(c._var)||this.match(c._const)||n){const r=this.startNode(),s=n?"let":this.state.value;return this.next(),this.parseVar(r,!0,s),this.finishNode(r,"VariableDeclaration"),(this.match(c._in)||this.isContextual("of"))&&1===r.declarations.length?this.parseForIn(e,r,t):(t>-1&&this.unexpected(t),this.parseFor(e,r))}const s=this.match(c.name)&&!this.state.containsEsc,i=new Ne,o=this.parseExpression(!0,i),a=this.isContextual("of");if(a&&(r?this.raise(o.start,v.ForOfLet):-1===t&&s&&"Identifier"===o.type&&"async"===o.name&&this.raise(o.start,v.ForOfAsync)),a||this.match(c._in)){this.toAssignable(o,!0);const r=a?"for-of statement":"for-in statement";return this.checkLVal(o,r),this.parseForIn(e,o,t)}return this.checkExpressionErrors(i,!0),t>-1&&this.unexpected(t),this.parseFor(e,o)}parseFunctionStatement(e,t,r){return this.next(),this.parseFunction(e,1|(r?0:2),t)}parseIfStatement(e){return this.next(),e.test=this.parseHeaderExpression(),e.consequent=this.parseStatement("if"),e.alternate=this.eat(c._else)?this.parseStatement("if"):null,this.finishNode(e,"IfStatement")}parseReturnStatement(e){return this.prodParam.hasReturn||this.options.allowReturnOutsideFunction||this.raise(this.state.start,v.IllegalReturn),this.next(),this.isLineTerminator()?e.argument=null:(e.argument=this.parseExpression(),this.semicolon()),this.finishNode(e,"ReturnStatement")}parseSwitchStatement(e){this.next(),e.discriminant=this.parseHeaderExpression();const t=e.cases=[];let r,n;for(this.expect(c.braceL),this.state.labels.push(Me),this.scope.enter(0);!this.match(c.braceR);)if(this.match(c._case)||this.match(c._default)){const e=this.match(c._case);r&&this.finishNode(r,"SwitchCase"),t.push(r=this.startNode()),r.consequent=[],this.next(),e?r.test=this.parseExpression():(n&&this.raise(this.state.lastTokStart,v.MultipleDefaultsInSwitch),n=!0,r.test=null),this.expect(c.colon);}else r?r.consequent.push(this.parseStatement(null)):this.unexpected();return this.scope.exit(),r&&this.finishNode(r,"SwitchCase"),this.next(),this.state.labels.pop(),this.finishNode(e,"SwitchStatement")}parseThrowStatement(e){return this.next(),this.hasPrecedingLineBreak()&&this.raise(this.state.lastTokEnd,v.NewlineAfterThrow),e.argument=this.parseExpression(),this.semicolon(),this.finishNode(e,"ThrowStatement")}parseCatchClauseParam(){const e=this.parseBindingAtom(),t="Identifier"===e.type;return this.scope.enter(t?8:0),this.checkLVal(e,"catch clause",9),e}parseTryStatement(e){if(this.next(),e.block=this.parseBlock(),e.handler=null,this.match(c._catch)){const t=this.startNode();this.next(),this.match(c.parenL)?(this.expect(c.parenL),t.param=this.parseCatchClauseParam(),this.expect(c.parenR)):(t.param=null,this.scope.enter(0)),t.body=this.withTopicForbiddingContext((()=>this.parseBlock(!1,!1))),this.scope.exit(),e.handler=this.finishNode(t,"CatchClause");}return e.finalizer=this.eat(c._finally)?this.parseBlock():null,e.handler||e.finalizer||this.raise(e.start,v.NoCatchOrFinally),this.finishNode(e,"TryStatement")}parseVarStatement(e,t){return this.next(),this.parseVar(e,!1,t),this.semicolon(),this.finishNode(e,"VariableDeclaration")}parseWhileStatement(e){return this.next(),e.test=this.parseHeaderExpression(),this.state.labels.push(Le),e.body=this.withTopicForbiddingContext((()=>this.parseStatement("while"))),this.state.labels.pop(),this.finishNode(e,"WhileStatement")}parseWithStatement(e){return this.state.strict&&this.raise(this.state.start,v.StrictWith),this.next(),e.object=this.parseHeaderExpression(),e.body=this.withTopicForbiddingContext((()=>this.parseStatement("with"))),this.finishNode(e,"WithStatement")}parseEmptyStatement(e){return this.next(),this.finishNode(e,"EmptyStatement")}parseLabeledStatement(e,t,r,n){for(const e of this.state.labels)e.name===t&&this.raise(r.start,v.LabelRedeclaration,t);const s=this.state.type.isLoop?"loop":this.match(c._switch)?"switch":null;for(let t=this.state.labels.length-1;t>=0;t--){const r=this.state.labels[t];if(r.statementStart!==e.start)break;r.statementStart=this.state.start,r.kind=s;}return this.state.labels.push({name:t,kind:s,statementStart:this.state.start}),e.body=this.parseStatement(n?-1===n.indexOf("label")?n+"label":n:"label"),this.state.labels.pop(),e.label=r,this.finishNode(e,"LabeledStatement")}parseExpressionStatement(e,t){return e.expression=t,this.semicolon(),this.finishNode(e,"ExpressionStatement")}parseBlock(e=!1,t=!0,r){const n=this.startNode();return e&&this.state.strictErrors.clear(),this.expect(c.braceL),t&&this.scope.enter(0),this.parseBlockBody(n,e,!1,c.braceR,r),t&&this.scope.exit(),this.finishNode(n,"BlockStatement")}isValidDirective(e){return "ExpressionStatement"===e.type&&"StringLiteral"===e.expression.type&&!e.expression.extra.parenthesized}parseBlockBody(e,t,r,n,s){const i=e.body=[],o=e.directives=[];this.parseBlockOrModuleBlockBody(i,t?o:void 0,r,n,s);}parseBlockOrModuleBlockBody(e,t,r,n,s){const i=this.state.strict;let o=!1,a=!1;for(;!this.match(n);){const n=this.parseStatement(null,r);if(t&&!a){if(this.isValidDirective(n)){const e=this.stmtToDirective(n);t.push(e),o||"use strict"!==e.value.value||(o=!0,this.setStrict(!0));continue}a=!0,this.state.strictErrors.clear();}e.push(n);}s&&s.call(this,o),i||this.setStrict(!1),this.next();}parseFor(e,t){return e.init=t,this.semicolon(!1),e.test=this.match(c.semi)?null:this.parseExpression(),this.semicolon(!1),e.update=this.match(c.parenR)?null:this.parseExpression(),this.expect(c.parenR),e.body=this.withTopicForbiddingContext((()=>this.parseStatement("for"))),this.scope.exit(),this.state.labels.pop(),this.finishNode(e,"ForStatement")}parseForIn(e,t,r){const n=this.match(c._in);return this.next(),n?r>-1&&this.unexpected(r):e.await=r>-1,"VariableDeclaration"!==t.type||null==t.declarations[0].init||n&&!this.state.strict&&"var"===t.kind&&"Identifier"===t.declarations[0].id.type?"AssignmentPattern"===t.type&&this.raise(t.start,v.InvalidLhs,"for-loop"):this.raise(t.start,v.ForInOfLoopInitializer,n?"for-in":"for-of"),e.left=t,e.right=n?this.parseExpression():this.parseMaybeAssignAllowIn(),this.expect(c.parenR),e.body=this.withTopicForbiddingContext((()=>this.parseStatement("for"))),this.scope.exit(),this.state.labels.pop(),this.finishNode(e,n?"ForInStatement":"ForOfStatement")}parseVar(e,t,r){const n=e.declarations=[],s=this.hasPlugin("typescript");for(e.kind=r;;){const e=this.startNode();if(this.parseVarId(e,r),this.eat(c.eq)?e.init=t?this.parseMaybeAssignDisallowIn():this.parseMaybeAssignAllowIn():("const"!==r||this.match(c._in)||this.isContextual("of")?"Identifier"===e.id.type||t&&(this.match(c._in)||this.isContextual("of"))||this.raise(this.state.lastTokEnd,v.DeclarationMissingInitializer,"Complex binding patterns"):s||this.raise(this.state.lastTokEnd,v.DeclarationMissingInitializer,"Const declarations"),e.init=null),n.push(this.finishNode(e,"VariableDeclarator")),!this.eat(c.comma))break}return e}parseVarId(e,t){e.id=this.parseBindingAtom(),this.checkLVal(e.id,"variable declaration","var"===t?5:9,void 0,"var"!==t);}parseFunction(e,t=0,r=!1){const n=1&t,s=2&t,i=!(!n||4&t);this.initFunction(e,r),this.match(c.star)&&s&&this.raise(this.state.start,v.GeneratorInSingleStatementContext),e.generator=this.eat(c.star),n&&(e.id=this.parseFunctionId(i));const o=this.state.maybeInArrowParameters;return this.state.maybeInArrowParameters=!1,this.scope.enter(2),this.prodParam.enter(le(r,e.generator)),n||(e.id=this.parseFunctionId()),this.parseFunctionParams(e,!1),this.withTopicForbiddingContext((()=>{this.parseFunctionBodyAndFinish(e,n?"FunctionDeclaration":"FunctionExpression");})),this.prodParam.exit(),this.scope.exit(),n&&!s&&this.registerFunctionStatementId(e),this.state.maybeInArrowParameters=o,e}parseFunctionId(e){return e||this.match(c.name)?this.parseIdentifier():null}parseFunctionParams(e,t){this.expect(c.parenL),this.expressionScope.enter(new _e(3)),e.params=this.parseBindingList(c.parenR,41,!1,t),this.expressionScope.exit();}registerFunctionStatementId(e){e.id&&this.scope.declareName(e.id.name,this.state.strict||e.generator||e.async?this.scope.treatFunctionsAsVar?5:9:17,e.id.start);}parseClass(e,t,r){this.next(),this.takeDecorators(e);const n=this.state.strict;return this.state.strict=!0,this.parseClassId(e,t,r),this.parseClassSuper(e),e.body=this.parseClassBody(!!e.superClass,n),this.finishNode(e,t?"ClassDeclaration":"ClassExpression")}isClassProperty(){return this.match(c.eq)||this.match(c.semi)||this.match(c.braceR)}isClassMethod(){return this.match(c.parenL)}isNonstaticConstructor(e){return !(e.computed||e.static||"constructor"!==e.key.name&&"constructor"!==e.key.value)}parseClassBody(e,t){this.classScope.enter();const r={hadConstructor:!1,hadSuperClass:e};let n=[];const s=this.startNode();if(s.body=[],this.expect(c.braceL),this.withTopicForbiddingContext((()=>{for(;!this.match(c.braceR);){if(this.eat(c.semi)){if(n.length>0)throw this.raise(this.state.lastTokEnd,v.DecoratorSemicolon);continue}if(this.match(c.at)){n.push(this.parseDecorator());continue}const e=this.startNode();n.length&&(e.decorators=n,this.resetStartLocationFromNode(e,n[0]),n=[]),this.parseClassMember(s,e,r),"constructor"===e.kind&&e.decorators&&e.decorators.length>0&&this.raise(e.start,v.DecoratorConstructor);}})),this.state.strict=t,this.next(),n.length)throw this.raise(this.state.start,v.TrailingDecorator);return this.classScope.exit(),this.finishNode(s,"ClassBody")}parseClassMemberFromModifier(e,t){const r=this.parseIdentifier(!0);if(this.isClassMethod()){const n=t;return n.kind="method",n.computed=!1,n.key=r,n.static=!1,this.pushClassMethod(e,n,!1,!1,!1,!1),!0}if(this.isClassProperty()){const n=t;return n.computed=!1,n.key=r,n.static=!1,e.body.push(this.parseClassProperty(n)),!0}return !1}parseClassMember(e,t,r){const n=this.isContextual("static");if(n){if(this.parseClassMemberFromModifier(e,t))return;if(this.eat(c.braceL))return void this.parseClassStaticBlock(e,t)}this.parseClassMemberWithIsStatic(e,t,r,n);}parseClassMemberWithIsStatic(e,t,r,n){const s=t,i=t,o=t,a=t,l=s,u=s;if(t.static=n,this.eat(c.star)){l.kind="method";const t=this.match(c.privateName);return this.parseClassElementName(l),t?void this.pushClassPrivateMethod(e,i,!0,!1):(this.isNonstaticConstructor(s)&&this.raise(s.key.start,v.ConstructorIsGenerator),void this.pushClassMethod(e,s,!0,!1,!1,!1))}const p=this.state.containsEsc,d=this.match(c.privateName),f=this.parseClassElementName(t),h="Identifier"===f.type,m=this.state.start;if(this.parsePostMemberNameModifiers(u),this.isClassMethod()){if(l.kind="method",d)return void this.pushClassPrivateMethod(e,i,!1,!1);const n=this.isNonstaticConstructor(s);let o=!1;n&&(s.kind="constructor",r.hadConstructor&&!this.hasPlugin("typescript")&&this.raise(f.start,v.DuplicateConstructor),n&&this.hasPlugin("typescript")&&t.override&&this.raise(f.start,v.OverrideOnConstructor),r.hadConstructor=!0,o=r.hadSuperClass),this.pushClassMethod(e,s,!1,!1,n,o);}else if(this.isClassProperty())d?this.pushClassPrivateProperty(e,a):this.pushClassProperty(e,o);else if(!h||"async"!==f.name||p||this.isLineTerminator())if(!h||"get"!==f.name&&"set"!==f.name||p||this.match(c.star)&&this.isLineTerminator())this.isLineTerminator()?d?this.pushClassPrivateProperty(e,a):this.pushClassProperty(e,o):this.unexpected();else {l.kind=f.name;const t=this.match(c.privateName);this.parseClassElementName(s),t?this.pushClassPrivateMethod(e,i,!1,!1):(this.isNonstaticConstructor(s)&&this.raise(s.key.start,v.ConstructorIsAccessor),this.pushClassMethod(e,s,!1,!1,!1,!1)),this.checkGetterSetterParams(s);}else {const t=this.eat(c.star);u.optional&&this.unexpected(m),l.kind="method";const r=this.match(c.privateName);this.parseClassElementName(l),this.parsePostMemberNameModifiers(u),r?this.pushClassPrivateMethod(e,i,t,!0):(this.isNonstaticConstructor(s)&&this.raise(s.key.start,v.ConstructorIsAsync),this.pushClassMethod(e,s,t,!0,!1,!1));}}parseClassElementName(e){const{type:t,value:r,start:n}=this.state;return t!==c.name&&t!==c.string||!e.static||"prototype"!==r||this.raise(n,v.StaticPrototype),t===c.privateName&&"constructor"===r&&this.raise(n,v.ConstructorClassPrivateField),this.parsePropertyName(e,!0)}parseClassStaticBlock(e,t){var r;this.expectPlugin("classStaticBlock",t.start),this.scope.enter(208);const n=this.state.labels;this.state.labels=[],this.prodParam.enter(0);const s=t.body=[];this.parseBlockOrModuleBlockBody(s,void 0,!1,c.braceR),this.prodParam.exit(),this.scope.exit(),this.state.labels=n,e.body.push(this.finishNode(t,"StaticBlock")),null!=(r=t.decorators)&&r.length&&this.raise(t.start,v.DecoratorStaticBlock);}pushClassProperty(e,t){t.computed||"constructor"!==t.key.name&&"constructor"!==t.key.value||this.raise(t.key.start,v.ConstructorClassField),e.body.push(this.parseClassProperty(t));}pushClassPrivateProperty(e,t){const r=this.parseClassPrivateProperty(t);e.body.push(r),this.classScope.declarePrivateName(this.getPrivateNameSV(r.key),0,r.key.start);}pushClassMethod(e,t,r,n,s,i){e.body.push(this.parseMethod(t,r,n,s,i,"ClassMethod",!0));}pushClassPrivateMethod(e,t,r,n){const s=this.parseMethod(t,r,n,!1,!1,"ClassPrivateMethod",!0);e.body.push(s);const i="get"===s.kind?s.static?6:2:"set"===s.kind?s.static?5:1:0;this.classScope.declarePrivateName(this.getPrivateNameSV(s.key),i,s.key.start);}parsePostMemberNameModifiers(e){}parseClassPrivateProperty(e){return this.parseInitializer(e),this.semicolon(),this.finishNode(e,"ClassPrivateProperty")}parseClassProperty(e){return this.parseInitializer(e),this.semicolon(),this.finishNode(e,"ClassProperty")}parseInitializer(e){this.scope.enter(80),this.expressionScope.enter(Ie()),this.prodParam.enter(0),e.value=this.eat(c.eq)?this.parseMaybeAssignAllowIn():null,this.expressionScope.exit(),this.prodParam.exit(),this.scope.exit();}parseClassId(e,t,r,n=139){this.match(c.name)?(e.id=this.parseIdentifier(),t&&this.checkLVal(e.id,"class name",n)):r||!t?e.id=null:this.unexpected(null,v.MissingClassName);}parseClassSuper(e){e.superClass=this.eat(c._extends)?this.parseExprSubscripts():null;}parseExport(e){const t=this.maybeParseExportDefaultSpecifier(e),r=!t||this.eat(c.comma),n=r&&this.eatExportStar(e),s=n&&this.maybeParseExportNamespaceSpecifier(e),i=r&&(!s||this.eat(c.comma)),o=t||n;if(n&&!s)return t&&this.unexpected(),this.parseExportFrom(e,!0),this.finishNode(e,"ExportAllDeclaration");const a=this.maybeParseExportNamedSpecifiers(e);if(t&&r&&!n&&!a||s&&i&&!a)throw this.unexpected(null,c.braceL);let l;if(o||a?(l=!1,this.parseExportFrom(e,o)):l=this.maybeParseExportDeclaration(e),o||a||l)return this.checkExport(e,!0,!1,!!e.source),this.finishNode(e,"ExportNamedDeclaration");if(this.eat(c._default))return e.declaration=this.parseExportDefaultExpression(),this.checkExport(e,!0,!0),this.finishNode(e,"ExportDefaultDeclaration");throw this.unexpected(null,c.braceL)}eatExportStar(e){return this.eat(c.star)}maybeParseExportDefaultSpecifier(e){if(this.isExportDefaultSpecifier()){this.expectPlugin("exportDefaultFrom");const t=this.startNode();return t.exported=this.parseIdentifier(!0),e.specifiers=[this.finishNode(t,"ExportDefaultSpecifier")],!0}return !1}maybeParseExportNamespaceSpecifier(e){if(this.isContextual("as")){e.specifiers||(e.specifiers=[]);const t=this.startNodeAt(this.state.lastTokStart,this.state.lastTokStartLoc);return this.next(),t.exported=this.parseModuleExportName(),e.specifiers.push(this.finishNode(t,"ExportNamespaceSpecifier")),!0}return !1}maybeParseExportNamedSpecifiers(e){return !!this.match(c.braceL)&&(e.specifiers||(e.specifiers=[]),e.specifiers.push(...this.parseExportSpecifiers()),e.source=null,e.declaration=null,!0)}maybeParseExportDeclaration(e){return !!this.shouldParseExportDeclaration()&&(e.specifiers=[],e.source=null,e.declaration=this.parseExportDeclaration(e),!0)}isAsyncFunction(){if(!this.isContextual("async"))return !1;const e=this.nextTokenStart();return !p.test(this.input.slice(this.state.pos,e))&&this.isUnparsedContextual(e,"function")}parseExportDefaultExpression(){const e=this.startNode(),t=this.isAsyncFunction();if(this.match(c._function)||t)return this.next(),t&&this.next(),this.parseFunction(e,5,t);if(this.match(c._class))return this.parseClass(e,!0,!0);if(this.match(c.at))return this.hasPlugin("decorators")&&this.getPluginOption("decorators","decoratorsBeforeExport")&&this.raise(this.state.start,v.DecoratorBeforeExport),this.parseDecorators(!1),this.parseClass(e,!0,!0);if(this.match(c._const)||this.match(c._var)||this.isLet())throw this.raise(this.state.start,v.UnsupportedDefaultExport);{const e=this.parseMaybeAssignAllowIn();return this.semicolon(),e}}parseExportDeclaration(e){return this.parseStatement(null)}isExportDefaultSpecifier(){if(this.match(c.name)){const e=this.state.value;if("async"===e&&!this.state.containsEsc||"let"===e)return !1;if(("type"===e||"interface"===e)&&!this.state.containsEsc){const e=this.lookahead();if(e.type===c.name&&"from"!==e.value||e.type===c.braceL)return this.expectOnePlugin(["flow","typescript"]),!1}}else if(!this.match(c._default))return !1;const e=this.nextTokenStart(),t=this.isUnparsedContextual(e,"from");if(44===this.input.charCodeAt(e)||this.match(c.name)&&t)return !0;if(this.match(c._default)&&t){const t=this.input.charCodeAt(this.nextTokenStartSince(e+4));return 34===t||39===t}return !1}parseExportFrom(e,t){if(this.eatContextual("from")){e.source=this.parseImportSource(),this.checkExport(e);const t=this.maybeParseImportAssertions();t&&(e.assertions=t);}else t?this.unexpected():e.source=null;this.semicolon();}shouldParseExportDeclaration(){if(this.match(c.at)&&(this.expectOnePlugin(["decorators","decorators-legacy"]),this.hasPlugin("decorators"))){if(!this.getPluginOption("decorators","decoratorsBeforeExport"))return !0;this.unexpected(this.state.start,v.DecoratorBeforeExport);}return "var"===this.state.type.keyword||"const"===this.state.type.keyword||"function"===this.state.type.keyword||"class"===this.state.type.keyword||this.isLet()||this.isAsyncFunction()}checkExport(e,t,r,n){if(t)if(r){if(this.checkDuplicateExports(e,"default"),this.hasPlugin("exportDefaultFrom")){var s;const t=e.declaration;"Identifier"!==t.type||"from"!==t.name||t.end-t.start!=4||null!=(s=t.extra)&&s.parenthesized||this.raise(t.start,v.ExportDefaultFromAsIdentifier);}}else if(e.specifiers&&e.specifiers.length)for(const t of e.specifiers){const{exported:e}=t,r="Identifier"===e.type?e.name:e.value;if(this.checkDuplicateExports(t,r),!n&&t.local){const{local:e}=t;"StringLiteral"===e.type?this.raise(t.start,v.ExportBindingIsString,e.value,r):(this.checkReservedWord(e.name,e.start,!0,!1),this.scope.checkLocalExport(e));}}else if(e.declaration)if("FunctionDeclaration"===e.declaration.type||"ClassDeclaration"===e.declaration.type){const t=e.declaration.id;if(!t)throw new Error("Assertion failure");this.checkDuplicateExports(e,t.name);}else if("VariableDeclaration"===e.declaration.type)for(const t of e.declaration.declarations)this.checkDeclaration(t.id);if(this.state.decoratorStack[this.state.decoratorStack.length-1].length)throw this.raise(e.start,v.UnsupportedDecoratorExport)}checkDeclaration(e){if("Identifier"===e.type)this.checkDuplicateExports(e,e.name);else if("ObjectPattern"===e.type)for(const t of e.properties)this.checkDeclaration(t);else if("ArrayPattern"===e.type)for(const t of e.elements)t&&this.checkDeclaration(t);else "ObjectProperty"===e.type?this.checkDeclaration(e.value):"RestElement"===e.type?this.checkDeclaration(e.argument):"AssignmentPattern"===e.type&&this.checkDeclaration(e.left);}checkDuplicateExports(e,t){this.state.exportedIdentifiers.indexOf(t)>-1&&this.raise(e.start,"default"===t?v.DuplicateDefaultExport:v.DuplicateExport,t),this.state.exportedIdentifiers.push(t);}parseExportSpecifiers(){const e=[];let t=!0;for(this.expect(c.braceL);!this.eat(c.braceR);){if(t)t=!1;else if(this.expect(c.comma),this.eat(c.braceR))break;const r=this.startNode();r.local=this.parseModuleExportName(),r.exported=this.eatContextual("as")?this.parseModuleExportName():r.local.__clone(),e.push(this.finishNode(r,"ExportSpecifier"));}return e}parseModuleExportName(){if(this.match(c.string)){const e=this.parseLiteral(this.state.value,"StringLiteral"),t=e.value.match(Be);return t&&this.raise(e.start,v.ModuleExportNameHasLoneSurrogate,t[0].charCodeAt(0).toString(16)),e}return this.parseIdentifier(!0)}parseImport(e){if(e.specifiers=[],!this.match(c.string)){const t=!this.maybeParseDefaultImportSpecifier(e)||this.eat(c.comma),r=t&&this.maybeParseStarImportSpecifier(e);t&&!r&&this.parseNamedImportSpecifiers(e),this.expectContextual("from");}e.source=this.parseImportSource();const t=this.maybeParseImportAssertions();if(t)e.assertions=t;else {const t=this.maybeParseModuleAttributes();t&&(e.attributes=t);}return this.semicolon(),this.finishNode(e,"ImportDeclaration")}parseImportSource(){return this.match(c.string)||this.unexpected(),this.parseExprAtom()}shouldParseDefaultImport(e){return this.match(c.name)}parseImportSpecifierLocal(e,t,r,n){t.local=this.parseIdentifier(),this.checkLVal(t.local,n,9),e.specifiers.push(this.finishNode(t,r));}parseAssertEntries(){const e=[],t=new Set;do{if(this.match(c.braceR))break;const r=this.startNode(),n=this.state.value;if(this.match(c.string)?r.key=this.parseLiteral(n,"StringLiteral"):r.key=this.parseIdentifier(!0),this.expect(c.colon),"type"!==n&&this.raise(r.key.start,v.ModuleAttributeDifferentFromType,n),t.has(n)&&this.raise(r.key.start,v.ModuleAttributesWithDuplicateKeys,n),t.add(n),!this.match(c.string))throw this.unexpected(this.state.start,v.ModuleAttributeInvalidValue);r.value=this.parseLiteral(this.state.value,"StringLiteral"),this.finishNode(r,"ImportAttribute"),e.push(r);}while(this.eat(c.comma));return e}maybeParseModuleAttributes(){if(!this.match(c._with)||this.hasPrecedingLineBreak())return this.hasPlugin("moduleAttributes")?[]:null;this.expectPlugin("moduleAttributes"),this.next();const e=[],t=new Set;do{const r=this.startNode();if(r.key=this.parseIdentifier(!0),"type"!==r.key.name&&this.raise(r.key.start,v.ModuleAttributeDifferentFromType,r.key.name),t.has(r.key.name)&&this.raise(r.key.start,v.ModuleAttributesWithDuplicateKeys,r.key.name),t.add(r.key.name),this.expect(c.colon),!this.match(c.string))throw this.unexpected(this.state.start,v.ModuleAttributeInvalidValue);r.value=this.parseLiteral(this.state.value,"StringLiteral"),this.finishNode(r,"ImportAttribute"),e.push(r);}while(this.eat(c.comma));return e}maybeParseImportAssertions(){if(!this.isContextual("assert")||this.hasPrecedingLineBreak())return this.hasPlugin("importAssertions")?[]:null;this.expectPlugin("importAssertions"),this.next(),this.eat(c.braceL);const e=this.parseAssertEntries();return this.eat(c.braceR),e}maybeParseDefaultImportSpecifier(e){return !!this.shouldParseDefaultImport(e)&&(this.parseImportSpecifierLocal(e,this.startNode(),"ImportDefaultSpecifier","default import specifier"),!0)}maybeParseStarImportSpecifier(e){if(this.match(c.star)){const t=this.startNode();return this.next(),this.expectContextual("as"),this.parseImportSpecifierLocal(e,t,"ImportNamespaceSpecifier","import namespace specifier"),!0}return !1}parseNamedImportSpecifiers(e){let t=!0;for(this.expect(c.braceL);!this.eat(c.braceR);){if(t)t=!1;else {if(this.eat(c.colon))throw this.raise(this.state.start,v.DestructureNamedImport);if(this.expect(c.comma),this.eat(c.braceR))break}this.parseImportSpecifier(e);}}parseImportSpecifier(e){const t=this.startNode();if(t.imported=this.parseModuleExportName(),this.eatContextual("as"))t.local=this.parseIdentifier();else {const{imported:e}=t;if("StringLiteral"===e.type)throw this.raise(t.start,v.ImportBindingIsString,e.value);this.checkReservedWord(e.name,t.start,!0,!0),t.local=e.__clone();}this.checkLVal(t.local,"import specifier",9),e.specifiers.push(this.finishNode(t,"ImportSpecifier"));}isThisParam(e){return "Identifier"===e.type&&"this"===e.name}}{constructor(e,t){super(e=function(e){const t={};for(const r of Object.keys(ve))t[r]=e&&null!=e[r]?e[r]:ve[r];return t}(e),t),this.options=e,this.initializeScopes(),this.plugins=function(e){const t=new Map;for(const r of e){const[e,n]=Array.isArray(r)?r:[r,{}];t.has(e)||t.set(e,n||{});}return t}(this.options.plugins),this.filename=e.sourceFilename;}getScopeHandler(){return K}parse(){this.enterInitialScopes();const e=this.startNode(),t=this.startNode();return this.nextToken(),e.errors=null,this.parseTopLevel(e,t),e.errors=this.state.errors,e}}function Ue(e,t){let r=Re;return null!=e&&e.plugins&&(function(e){if(he(e,"decorators")){if(he(e,"decorators-legacy"))throw new Error("Cannot use the decorators and decorators-legacy plugin together");const t=me(e,"decorators","decoratorsBeforeExport");if(null==t)throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");if("boolean"!=typeof t)throw new Error("'decoratorsBeforeExport' must be a boolean.")}if(he(e,"flow")&&he(e,"typescript"))throw new Error("Cannot combine flow and typescript plugins.");if(he(e,"placeholders")&&he(e,"v8intrinsic"))throw new Error("Cannot combine placeholders and v8intrinsic plugins.");if(he(e,"pipelineOperator")&&!ye.includes(me(e,"pipelineOperator","proposal")))throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: "+ye.map((e=>`'${e}'`)).join(", "));if(he(e,"moduleAttributes")){if(he(e,"importAssertions"))throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");if("may-2020"!==me(e,"moduleAttributes","version"))throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.")}if(he(e,"recordAndTuple")&&!be.includes(me(e,"recordAndTuple","syntaxType")))throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: "+be.map((e=>`'${e}'`)).join(", "));if(he(e,"asyncDoExpressions")&&!he(e,"doExpressions")){const e=new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");throw e.missingPlugins="doExpressions",e}}(e.plugins),r=function(e){const t=Ee.filter((t=>he(e,t))),r=t.join("/");let n=Ve[r];if(!n){n=Re;for(const e of t)n=ge[e](n);Ve[r]=n;}return n}(e.plugins)),new r(e,t)}const Ve={};t.parse=function(e,t){var r;if("unambiguous"!==(null==(r=t)?void 0:r.sourceType))return Ue(t,e).parse();t=Object.assign({},t);try{t.sourceType="module";const r=Ue(t,e),n=r.parse();if(r.sawUnambiguousESM)return n;if(r.ambiguousScriptDifferentAst)try{return t.sourceType="script",Ue(t,e).parse()}catch(e){}else n.program.sourceType="script";return n}catch(r){try{return t.sourceType="script",Ue(t,e).parse()}catch(e){}throw r}},t.parseExpression=function(e,t){const r=Ue(t,e);return r.options.strictMode&&(r.state.strict=!0),r.getExpression()},t.tokTypes=c;},"./node_modules/@babel/plugin-proposal-decorators/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/helper-plugin-utils/lib/index.js"),s=r("./node_modules/@babel/plugin-syntax-decorators/lib/index.js"),i=r("./node_modules/@babel/helper-create-class-features-plugin/lib/index.js"),o=r("./node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js"),a=(0, n.declare)(((e,t)=>{e.assertVersion(7);const{legacy:r=!1}=t;if("boolean"!=typeof r)throw new Error("'legacy' must be a boolean.");const{decoratorsBeforeExport:n}=t;if(void 0===n){if(!r)throw new Error("The decorators plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you want to use the legacy decorators semantics, you can set the 'legacy: true' option.")}else {if(r)throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");if("boolean"!=typeof n)throw new Error("'decoratorsBeforeExport' must be a boolean.")}return r?{name:"proposal-decorators",inherits:s.default,manipulateOptions({generatorOpts:e}){e.decoratorsBeforeExport=n;},visitor:o.default}:(0, i.createClassFeaturePlugin)({name:"proposal-decorators",api:e,feature:i.FEATURES.decorators,manipulateOptions({generatorOpts:e,parserOpts:t}){t.plugins.push(["decorators",{decoratorsBeforeExport:n}]),e.decoratorsBeforeExport=n;}})}));t.default=a;},"./node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/core/lib/index.js");const s=(0, n.template)("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n"),i=(0, n.template)("\n  CLASS_REF.prototype;\n"),o=(0, n.template)("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n"),a=(0, n.template)("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n"),l=new WeakSet;function u(e){const t=(e.isClass()?[e].concat(e.get("body.body")):e.get("properties")).reduce(((e,t)=>e.concat(t.node.decorators||[])),[]).filter((e=>!n.types.isIdentifier(e.expression)));if(0!==t.length)return n.types.sequenceExpression(t.map((t=>{const r=t.expression,s=t.expression=e.scope.generateDeclaredUidIdentifier("dec");return n.types.assignmentExpression("=",s,r)})).concat([e.node]))}function c(e){return !(!e.decorators||!e.decorators.length)}function p(e){return e.some((e=>{var t;return null==(t=e.decorators)?void 0:t.length}))}function d(e,t,r){const s=e.scope.generateDeclaredUidIdentifier(e.isClass()?"class":"obj"),u=r.reduce((function(r,u){const c=u.decorators||[];if(u.decorators=null,0===c.length)return r;if(u.computed)throw e.buildCodeFrameError("Computed method/property decorators are not yet supported.");const p=n.types.isLiteral(u.key)?u.key:n.types.stringLiteral(u.key.name),d=e.isClass()&&!u.static?i({CLASS_REF:s}).expression:s;if(n.types.isClassProperty(u,{static:!1})){const s=e.scope.generateDeclaredUidIdentifier("descriptor"),i=u.value?n.types.functionExpression(null,[],n.types.blockStatement([n.types.returnStatement(u.value)])):n.types.nullLiteral();u.value=n.types.callExpression(t.addHelper("initializerWarningHelper"),[s,n.types.thisExpression()]),l.add(u.value),r=r.concat([n.types.assignmentExpression("=",n.types.cloneNode(s),n.types.callExpression(t.addHelper("applyDecoratedDescriptor"),[n.types.cloneNode(d),n.types.cloneNode(p),n.types.arrayExpression(c.map((e=>n.types.cloneNode(e.expression)))),n.types.objectExpression([n.types.objectProperty(n.types.identifier("configurable"),n.types.booleanLiteral(!0)),n.types.objectProperty(n.types.identifier("enumerable"),n.types.booleanLiteral(!0)),n.types.objectProperty(n.types.identifier("writable"),n.types.booleanLiteral(!0)),n.types.objectProperty(n.types.identifier("initializer"),i)])]))]);}else r=r.concat(n.types.callExpression(t.addHelper("applyDecoratedDescriptor"),[n.types.cloneNode(d),n.types.cloneNode(p),n.types.arrayExpression(c.map((e=>n.types.cloneNode(e.expression)))),n.types.isObjectProperty(u)||n.types.isClassProperty(u,{static:!0})?a({TEMP:e.scope.generateDeclaredUidIdentifier("init"),TARGET:n.types.cloneNode(d),PROPERTY:n.types.cloneNode(p)}).expression:o({TARGET:n.types.cloneNode(d),PROPERTY:n.types.cloneNode(p)}).expression,n.types.cloneNode(d)]));return r}),[]);return n.types.sequenceExpression([n.types.assignmentExpression("=",n.types.cloneNode(s),e.node),n.types.sequenceExpression(u),n.types.cloneNode(s)])}function f({node:e,scope:t}){if(!c(e)&&!p(e.body.body))return;const r=e.id?n.types.cloneNode(e.id):t.generateUidIdentifier("class");return n.types.variableDeclaration("let",[n.types.variableDeclarator(r,n.types.toExpression(e))])}var h={ExportDefaultDeclaration(e){const t=e.get("declaration");if(!t.isClassDeclaration())return;const r=f(t);if(r){const[s]=e.replaceWithMultiple([r,n.types.exportNamedDeclaration(null,[n.types.exportSpecifier(n.types.cloneNode(r.declarations[0].id),n.types.identifier("default"))])]);t.node.id||e.scope.registerDeclaration(s);}},ClassDeclaration(e){const t=f(e);t&&e.replaceWith(t);},ClassExpression(e,t){const r=u(e)||function(e){if(!c(e.node))return;const t=e.node.decorators||[];e.node.decorators=null;const r=e.scope.generateDeclaredUidIdentifier("class");return t.map((e=>e.expression)).reverse().reduce((function(e,t){return s({CLASS_REF:n.types.cloneNode(r),DECORATOR:n.types.cloneNode(t),INNER:e}).expression}),e.node)}(e)||function(e,t){if(p(e.node.body.body))return d(e,t,e.node.body.body)}(e,t);r&&e.replaceWith(r);},ObjectExpression(e,t){const r=u(e)||function(e,t){if(p(e.node.properties))return d(e,t,e.node.properties)}(e,t);r&&e.replaceWith(r);},AssignmentExpression(e,t){l.has(e.node.right)&&e.replaceWith(n.types.callExpression(t.addHelper("initializerDefineProperty"),[n.types.cloneNode(e.get("left.object").node),n.types.stringLiteral(e.get("left.property").node.name||e.get("left.property").node.value),n.types.cloneNode(e.get("right.arguments")[0].node),n.types.cloneNode(e.get("right.arguments")[1].node)]));},CallExpression(e,t){3===e.node.arguments.length&&l.has(e.node.arguments[2])&&e.node.callee.name===t.addHelper("defineProperty").name&&e.replaceWith(n.types.callExpression(t.addHelper("initializerDefineProperty"),[n.types.cloneNode(e.get("arguments")[0].node),n.types.cloneNode(e.get("arguments")[1].node),n.types.cloneNode(e.get("arguments.2.arguments")[0].node),n.types.cloneNode(e.get("arguments.2.arguments")[1].node)]));}};t.default=h;},"./node_modules/@babel/plugin-proposal-nullish-coalescing-operator/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/helper-plugin-utils/lib/index.js"),s=r("./node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js"),i=r("./node_modules/@babel/core/lib/index.js"),o=(0, n.declare)(((e,{loose:t=!1})=>{var r;e.assertVersion(7);const n=null!=(r=e.assumption("noDocumentAll"))?r:t;return {name:"proposal-nullish-coalescing-operator",inherits:s.default,visitor:{LogicalExpression(e){const{node:t,scope:r}=e;if("??"!==t.operator)return;let s,o;if(r.isStatic(t.left))s=t.left,o=i.types.cloneNode(t.left);else {if(r.path.isPattern())return void e.replaceWith(i.template.ast`(() => ${e.node})()`);s=r.generateUidIdentifierBasedOnNode(t.left),r.push({id:i.types.cloneNode(s)}),o=i.types.assignmentExpression("=",s,t.left);}e.replaceWith(i.types.conditionalExpression(n?i.types.binaryExpression("!=",o,i.types.nullLiteral()):i.types.logicalExpression("&&",i.types.binaryExpression("!==",o,i.types.nullLiteral()),i.types.binaryExpression("!==",i.types.cloneNode(s),r.buildUndefinedNode())),i.types.cloneNode(s),t.right));}}}}));t.default=o;},"./node_modules/@babel/plugin-proposal-optional-chaining/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0});var n=r("./node_modules/@babel/helper-plugin-utils/lib/index.js"),s=r("./node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js"),i=r("./node_modules/@babel/core/lib/index.js"),o=r("./node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js");function a(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var l=a(s);function u(e){const t=c(e),{node:r,parentPath:n}=t;if(n.isLogicalExpression()){const{operator:e,right:t}=n.node;if("&&"===e||"||"===e||"??"===e&&r===t)return u(n)}if(n.isSequenceExpression()){const{expressions:e}=n.node;return e[e.length-1]!==r||u(n)}return n.isConditional({test:r})||n.isUnaryExpression({operator:"!"})||n.isLoop({test:r})}function c(e){let t=e;return e.findParent((e=>{if(!o.isTransparentExprWrapper(e))return !0;t=e;})),t}const{ast:p}=i.template.expression;function d(e){return e=o.skipTransparentExprWrappers(e),i.types.isIdentifier(e)||i.types.isSuper(e)||i.types.isMemberExpression(e)&&!e.computed&&d(e.object)}function f(e,{pureGetters:t,noDocumentAll:r}){const{scope:n}=e,s=c(e),{parentPath:a}=s,l=u(s);let f=!1;const h=a.isCallExpression({callee:s.node})&&e.isOptionalMemberExpression(),m=[];let y=e;if(n.path.isPattern()&&function(e){let t=e;const{scope:r}=e;for(;t.isOptionalMemberExpression()||t.isOptionalCallExpression();){const{node:e}=t,n=t.isOptionalMemberExpression()?"object":"callee",s=o.skipTransparentExprWrappers(t.get(n));if(e.optional)return !r.isStatic(s.node);t=s;}}(y))return void e.replaceWith(i.template.ast`(() => ${e.node})()`);for(;y.isOptionalMemberExpression()||y.isOptionalCallExpression();){const{node:e}=y;e.optional&&m.push(e),y.isOptionalMemberExpression()?(y.node.type="MemberExpression",y=o.skipTransparentExprWrappers(y.get("object"))):y.isOptionalCallExpression()&&(y.node.type="CallExpression",y=o.skipTransparentExprWrappers(y.get("callee")));}let b=e;a.isUnaryExpression({operator:"delete"})&&(b=a,f=!0);for(let e=m.length-1;e>=0;e--){const s=m[e],a=i.types.isCallExpression(s),u=a?"callee":"object",c=s[u];let y,E,v=c;for(;o.isTransparentExprWrapper(v);)v=v.expression;if(a&&i.types.isIdentifier(v,{name:"eval"})?(E=y=v,s[u]=i.types.sequenceExpression([i.types.numericLiteral(0),y])):t&&a&&d(v)?E=y=c:(y=n.maybeGenerateMemoised(v),y?(E=i.types.assignmentExpression("=",i.types.cloneNode(y),c),s[u]=y):E=y=c),a&&i.types.isMemberExpression(v))if(t&&d(v))s.callee=c;else {const{object:e}=v;let t=n.maybeGenerateMemoised(e);t?v.object=i.types.assignmentExpression("=",t,e):t=i.types.isSuper(e)?i.types.thisExpression():e,s.arguments.unshift(i.types.cloneNode(t)),s.callee=i.types.memberExpression(s.callee,i.types.identifier("call"));}let x=b.node;if(0===e&&h){var g;const e=o.skipTransparentExprWrappers(b.get("object")).node;let r;t&&d(e)||(r=n.maybeGenerateMemoised(e),r&&(x.object=i.types.assignmentExpression("=",r,e))),x=i.types.callExpression(i.types.memberExpression(x,i.types.identifier("bind")),[i.types.cloneNode(null!=(g=r)?g:e)]);}if(l){const e=r?p`${i.types.cloneNode(E)} != null`:p`
            ${i.types.cloneNode(E)} !== null && ${i.types.cloneNode(y)} !== void 0`;b.replaceWith(i.types.logicalExpression("&&",e,x)),b=o.skipTransparentExprWrappers(b.get("right"));}else {const e=r?p`${i.types.cloneNode(E)} == null`:p`
            ${i.types.cloneNode(E)} === null || ${i.types.cloneNode(y)} === void 0`,t=f?p`true`:p`void 0`;b.replaceWith(i.types.conditionalExpression(e,t,x)),b=o.skipTransparentExprWrappers(b.get("alternate"));}}}var h=n.declare(((e,t)=>{var r,n;e.assertVersion(7);const{loose:s=!1}=t,i=null!=(r=e.assumption("noDocumentAll"))?r:s,o=null!=(n=e.assumption("pureGetters"))?n:s;return {name:"proposal-optional-chaining",inherits:l.default.default,visitor:{"OptionalCallExpression|OptionalMemberExpression"(e){f(e,{noDocumentAll:i,pureGetters:o});}}}}));t.default=h,t.transform=f;},"./node_modules/@babel/plugin-syntax-class-properties/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=(0, r("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((e=>(e.assertVersion(7),{name:"syntax-class-properties",manipulateOptions(e,t){t.plugins.push("classProperties","classPrivateProperties","classPrivateMethods");}})));t.default=n;},"./node_modules/@babel/plugin-syntax-decorators/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=(0, r("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)(((e,t)=>{e.assertVersion(7);const{legacy:r=!1}=t;if("boolean"!=typeof r)throw new Error("'legacy' must be a boolean.");const{decoratorsBeforeExport:n}=t;if(void 0===n){if(!r)throw new Error("The '@babel/plugin-syntax-decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you want to use the legacy decorators semantics, you can set the 'legacy: true' option.")}else {if(r)throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");if("boolean"!=typeof n)throw new Error("'decoratorsBeforeExport' must be a boolean.")}return {name:"syntax-decorators",manipulateOptions(e,t){t.plugins.push(r?"decorators-legacy":["decorators",{decoratorsBeforeExport:n}]);}}}));t.default=n;},"./node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=(0, r("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((e=>(e.assertVersion(7),{name:"syntax-nullish-coalescing-operator",manipulateOptions(e,t){t.plugins.push("nullishCoalescingOperator");}})));t.default=n;},"./node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=(0, r("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((e=>(e.assertVersion(7),{name:"syntax-optional-chaining",manipulateOptions(e,t){t.plugins.push("optionalChaining");}})));t.default=n;},"./node_modules/@babel/plugin-syntax-typescript/lib/index.js":(e,t,r)=>{function n(e,t){const r=[];e.forEach(((e,n)=>{(Array.isArray(e)?e[0]:e)===t&&r.unshift(n);}));for(const t of r)e.splice(t,1);}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var s=(0, r("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)(((e,{isTSX:t})=>(e.assertVersion(7),{name:"syntax-typescript",manipulateOptions(e,r){const{plugins:s}=r;n(s,"flow"),n(s,"jsx"),r.plugins.push("typescript","classProperties"),r.plugins.push("objectRestSpread"),t&&r.plugins.push("jsx");}})));t.default=s;},"./node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n,s=r("./node_modules/@babel/helper-plugin-utils/lib/index.js"),i=r("./node_modules/@babel/helper-module-transforms/lib/index.js"),o=(n=r("./node_modules/@babel/helper-simple-access/lib/index.js"))&&n.__esModule?n:{default:n},a=r("./node_modules/@babel/core/lib/index.js"),l=r("./node_modules/babel-plugin-dynamic-import-node/utils.js"),u=(0, s.declare)(((e,t)=>{var r,n;e.assertVersion(7);const s=(0, l.createDynamicImportTransform)(e),{strictNamespace:u=!1,mjsStrictNamespace:c=!0,allowTopLevelThis:p,strict:d,strictMode:f,noInterop:h,importInterop:m,lazy:y=!1,allowCommonJSExports:b=!0}=t,g=null!=(r=e.assumption("constantReexports"))?r:t.loose,E=null!=(n=e.assumption("enumerableModuleMeta"))?n:t.loose;if(!("boolean"==typeof y||"function"==typeof y||Array.isArray(y)&&y.every((e=>"string"==typeof e))))throw new Error(".lazy must be a boolean, array of strings, or a function");if("boolean"!=typeof u)throw new Error(".strictNamespace must be a boolean, or undefined");if("boolean"!=typeof c)throw new Error(".mjsStrictNamespace must be a boolean, or undefined");const v=e=>a.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${e}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `,x={ReferencedIdentifier(e){const t=e.node.name;if("module"!==t&&"exports"!==t)return;const r=e.scope.getBinding(t);this.scope.getBinding(t)!==r||e.parentPath.isObjectProperty({value:e.node})&&e.parentPath.parentPath.isObjectPattern()||e.parentPath.isAssignmentExpression({left:e.node})||e.isAssignmentExpression({left:e.node})||e.replaceWith(v(t));},AssignmentExpression(e){const t=e.get("left");if(t.isIdentifier()){const t=e.node.name;if("module"!==t&&"exports"!==t)return;const r=e.scope.getBinding(t);if(this.scope.getBinding(t)!==r)return;const n=e.get("right");n.replaceWith(a.types.sequenceExpression([n.node,v(t)]));}else if(t.isPattern()){const r=t.getOuterBindingIdentifiers(),n=Object.keys(r).filter((t=>("module"===t||"exports"===t)&&this.scope.getBinding(t)===e.scope.getBinding(t)))[0];if(n){const t=e.get("right");t.replaceWith(a.types.sequenceExpression([t.node,v(n)]));}}}};return {name:"transform-modules-commonjs",pre(){this.file.set("@babel/plugin-transform-modules-*","commonjs");},visitor:{CallExpression(e){if(!this.file.has("@babel/plugin-proposal-dynamic-import"))return;if(!e.get("callee").isImport())return;let{scope:t}=e;do{t.rename("require");}while(t=t.parent);s(this,e.get("callee"));},Program:{exit(e,r){if(!(0, i.isModule)(e))return;e.scope.rename("exports"),e.scope.rename("module"),e.scope.rename("require"),e.scope.rename("__filename"),e.scope.rename("__dirname"),b||((0, o.default)(e,new Set(["module","exports"])),e.traverse(x,{scope:e.scope}));let n=(0, i.getModuleName)(this.file.opts,t);n&&(n=a.types.stringLiteral(n));const{meta:s,headers:l}=(0, i.rewriteModuleStatementsAndPrepareHeader)(e,{exportName:"exports",constantReexports:g,enumerableModuleMeta:E,strict:d,strictMode:f,allowTopLevelThis:p,noInterop:h,importInterop:m,lazy:y,esNamespaceOnly:"string"==typeof r.filename&&/\.mjs$/.test(r.filename)?c:u});for(const[t,r]of s.source){const n=a.types.callExpression(a.types.identifier("require"),[a.types.stringLiteral(t)]);let o;if((0, i.isSideEffectImport)(r)){if(r.lazy)throw new Error("Assertion failure");o=a.types.expressionStatement(n);}else {const t=(0, i.wrapInterop)(e,n,r.interop)||n;o=r.lazy?a.template.ast`
                  function ${r.name}() {
                    const data = ${t};
                    ${r.name} = function(){ return data; };
                    return data;
                  }
                `:a.template.ast`
                  var ${r.name} = ${t};
                `;}o.loc=r.loc,l.push(o),l.push(...(0, i.buildNamespaceInitStatements)(s,r,g));}(0, i.ensureStatementsHoisted)(l),e.unshiftContainer("body",l);}}}}}));t.default=u;},"./node_modules/@babel/plugin-transform-typescript/lib/enum.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){const{node:r}=e;if(r.const)throw e.buildCodeFrameError("'const' enums are not supported.");if(r.declare)return void e.remove();const s=r.id.name,l=function(e,t,r){const s=function(e,t){const r=Object.create(null);let s=-1;return e.node.members.map((i=>{const o=t.isIdentifier(i.id)?i.id.name:i.id.value,a=i.initializer;let l;if(a){const e=function(e,t){return r(e);function r(e){switch(e.type){case"StringLiteral":return e.value;case"UnaryExpression":return function({argument:e,operator:t}){const n=r(e);if(void 0!==n)switch(t){case"+":return n;case"-":return -n;case"~":return ~n;default:return}}(e);case"BinaryExpression":return function(e){const t=r(e.left);if(void 0===t)return;const n=r(e.right);if(void 0!==n)switch(e.operator){case"|":return t|n;case"&":return t&n;case">>":return t>>n;case">>>":return t>>>n;case"<<":return t<<n;case"^":return t^n;case"*":return t*n;case"/":return t/n;case"+":return t+n;case"-":return t-n;case"%":return t%n;default:return}}(e);case"NumericLiteral":return e.value;case"ParenthesizedExpression":return r(e.expression);case"Identifier":return t[e.name];case"TemplateLiteral":if(1===e.quasis.length)return e.quasis[0].value.cooked;default:return}}}(a,r);void 0!==e?(r[o]=e,"number"==typeof e?(l=t.numericLiteral(e),s=e):(n("string"==typeof e),l=t.stringLiteral(e),s=void 0)):(l=a,s=void 0);}else {if(void 0===s)throw e.buildCodeFrameError("Enum member must have initializer.");s++,l=t.numericLiteral(s),r[o]=s;}return [o,l]}))}(e,t).map((([e,n])=>{return s=t.isStringLiteral(n),i={ENUM:t.cloneNode(r),NAME:e,VALUE:n},(s?o:a)(i);var s,i;}));return i({ID:t.cloneNode(r),ASSIGNMENTS:s})}(e,t,r.id);switch(e.parent.type){case"BlockStatement":case"ExportNamedDeclaration":case"Program":if(e.insertAfter(l),function e(t){return t.isExportDeclaration()?e(t.parentPath):!!t.getData(s)||(t.setData(s,!0),!1)}(e.parentPath))e.remove();else {const n=t.isProgram(e.parent);e.scope.registerDeclaration(e.replaceWith(function(e,t,r){return t.variableDeclaration(r,[t.variableDeclarator(e)])}(r.id,t,n?"var":"let"))[0]);}break;default:throw new Error(`Unexpected enum parent '${e.parent.type}`)}};var n=r("assert"),s=r("./node_modules/@babel/core/lib/index.js");const i=(0, s.template)("\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n"),o=(0, s.template)('\n  ENUM["NAME"] = VALUE;\n'),a=(0, s.template)('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n');},"./node_modules/@babel/plugin-transform-typescript/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/helper-plugin-utils/lib/index.js"),s=r("./node_modules/@babel/plugin-syntax-typescript/lib/index.js"),i=r("./node_modules/@babel/core/lib/index.js"),o=r("./node_modules/@babel/helper-create-class-features-plugin/lib/index.js"),a=r("./node_modules/@babel/plugin-transform-typescript/lib/enum.js"),l=r("./node_modules/@babel/plugin-transform-typescript/lib/namespace.js");function u(e){switch(e.parent.type){case"TSTypeReference":case"TSQualifiedName":case"TSExpressionWithTypeArguments":case"TSTypeQuery":return !0;case"ExportSpecifier":return "type"===e.parentPath.parent.exportKind;default:return !1}}const c=new WeakSet,p=new WeakMap;function d(e,t){const r=e.find((e=>e.isProgram())).node;return !(e.scope.hasOwnBinding(t)||!p.get(r).has(t)&&(console.warn(`The exported identifier "${t}" is not declared in Babel's scope tracker\nas a JavaScript value binding, and "@babel/plugin-transform-typescript"\nnever encountered it as a TypeScript type declaration.\nIt will be treated as a JavaScript value.\n\nThis problem is likely caused by another plugin injecting\n"${t}" without registering it in the scope tracker. If you are the author\n of that plugin, please use "scope.registerDeclaration(declarationPath)".`),1))}function f(e,t){p.get(e.path.node).add(t);}var h=(0, n.declare)(((e,t)=>{e.assertVersion(7);const r=/\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/,{allowNamespaces:n=!0,jsxPragma:h="React.createElement",jsxPragmaFrag:m="React.Fragment",onlyRemoveTypeImports:y=!1}=t;var{allowDeclareFields:b=!1}=t;const g={field(e){const{node:t}=e;if(!b&&t.declare)throw e.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");if(t.declare){if(t.value)throw e.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");t.decorators||e.remove();}else if(t.definite){if(t.value)throw e.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");b||t.decorators||e.remove();}else b||t.value||t.decorators||i.types.isClassPrivateProperty(t)||e.remove();t.accessibility&&(t.accessibility=null),t.abstract&&(t.abstract=null),t.readonly&&(t.readonly=null),t.optional&&(t.optional=null),t.typeAnnotation&&(t.typeAnnotation=null),t.definite&&(t.definite=null),t.declare&&(t.declare=null);},method({node:e}){e.accessibility&&(e.accessibility=null),e.abstract&&(e.abstract=null),e.optional&&(e.optional=null);},constructor(e,t){e.node.accessibility&&(e.node.accessibility=null);const r=[];for(const t of e.node.params)"TSParameterProperty"!==t.type||c.has(t.parameter)||(c.add(t.parameter),r.push(t.parameter));if(r.length){const n=r.map((t=>{let r;if(i.types.isIdentifier(t))r=t;else {if(!i.types.isAssignmentPattern(t)||!i.types.isIdentifier(t.left))throw e.buildCodeFrameError("Parameter properties can not be destructuring patterns.");r=t.left;}return i.template.statement.ast`
              this.${i.types.cloneNode(r)} = ${i.types.cloneNode(r)}`}));(0, o.injectInitialization)(t,e,n);}}};return {name:"transform-typescript",inherits:s.default,visitor:{Pattern:E,Identifier:E,RestElement:E,Program(e,t){const{file:n}=t;let s=null,i=null;if(p.has(e.node)||p.set(e.node,new Set),n.ast.comments)for(const e of n.ast.comments){const t=r.exec(e.value);t&&(t[1]?i=t[2]:s=t[2]);}let o=s||h;o&&([o]=o.split("."));let a=i||m;a&&([a]=a.split("."));for(let t of e.get("body"))if(t.isImportDeclaration()){if("type"===t.node.importKind){t.remove();continue}if(!y){if(0===t.node.specifiers.length)continue;let r=!0;const n=[];for(const s of t.node.specifiers){const i=t.scope.getBinding(s.local.name);i&&v({binding:i,programPath:e,pragmaImportName:o,pragmaFragImportName:a})?n.push(i.path):r=!1;}if(r)t.remove();else for(const e of n)e.remove();}}else if(t.isExportDeclaration()&&(t=t.get("declaration")),t.isVariableDeclaration({declare:!0}))for(const r of Object.keys(t.getBindingIdentifiers()))f(e.scope,r);else (t.isTSTypeAliasDeclaration()||t.isTSDeclareFunction()||t.isTSInterfaceDeclaration()||t.isClassDeclaration({declare:!0})||t.isTSEnumDeclaration({declare:!0})||t.isTSModuleDeclaration({declare:!0})&&t.get("id").isIdentifier())&&f(e.scope,t.node.id.name);},ExportNamedDeclaration(e){"type"!==e.node.exportKind?!e.node.source&&e.node.specifiers.length>0&&e.node.specifiers.every((({local:t})=>d(e,t.name)))&&e.remove():e.remove();},ExportSpecifier(e){!e.parent.source&&d(e,e.node.local.name)&&e.remove();},ExportDefaultDeclaration(e){i.types.isIdentifier(e.node.declaration)&&d(e,e.node.declaration.name)&&e.remove();},TSDeclareFunction(e){e.remove();},TSDeclareMethod(e){e.remove();},VariableDeclaration(e){e.node.declare&&e.remove();},VariableDeclarator({node:e}){e.definite&&(e.definite=null);},TSIndexSignature(e){e.remove();},ClassDeclaration(e){const{node:t}=e;t.declare&&e.remove();},Class(e){const{node:t}=e;t.typeParameters&&(t.typeParameters=null),t.superTypeParameters&&(t.superTypeParameters=null),t.implements&&(t.implements=null),t.abstract&&(t.abstract=null),e.get("body.body").forEach((t=>{t.isClassMethod()||t.isClassPrivateMethod()?"constructor"===t.node.kind?g.constructor(t,e):g.method(t):(t.isClassProperty()||t.isClassPrivateProperty())&&g.field(t);}));},Function(e){const{node:t,scope:r}=e;t.typeParameters&&(t.typeParameters=null),t.returnType&&(t.returnType=null);const n=t.params;n.length>0&&i.types.isIdentifier(n[0],{name:"this"})&&n.shift();const s=e.get("params");for(const e of s)"TSParameterProperty"===e.type&&(e.replaceWith(e.get("parameter")),r.registerBinding("param",e));},TSModuleDeclaration(e){(0, l.default)(e,i.types,n);},TSInterfaceDeclaration(e){e.remove();},TSTypeAliasDeclaration(e){e.remove();},TSEnumDeclaration(e){(0, a.default)(e,i.types);},TSImportEqualsDeclaration(e){throw e.buildCodeFrameError("`import =` is not supported by @babel/plugin-transform-typescript\nPlease consider using `import <moduleName> from '<moduleName>';` alongside Typescript's --allowSyntheticDefaultImports option.")},TSExportAssignment(e){throw e.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\nPlease consider using `export <value>;`.")},TSTypeAssertion(e){e.replaceWith(e.node.expression);},TSAsExpression(e){let{node:t}=e;do{t=t.expression;}while(i.types.isTSAsExpression(t));e.replaceWith(t);},TSNonNullExpression(e){e.replaceWith(e.node.expression);},CallExpression(e){e.node.typeParameters=null;},OptionalCallExpression(e){e.node.typeParameters=null;},NewExpression(e){e.node.typeParameters=null;},JSXOpeningElement(e){e.node.typeParameters=null;},TaggedTemplateExpression(e){e.node.typeParameters=null;}}};function E({node:e}){e.typeAnnotation&&(e.typeAnnotation=null),i.types.isIdentifier(e)&&e.optional&&(e.optional=null);}function v({binding:e,programPath:t,pragmaImportName:r,pragmaFragImportName:n}){for(const t of e.referencePaths)if(!u(t))return !1;if(e.identifier.name!==r&&e.identifier.name!==n)return !0;let s=!1;return t.traverse({"JSXElement|JSXFragment"(e){s=!0,e.stop();}}),!s}}));t.default=h;},"./node_modules/@babel/plugin-transform-typescript/lib/namespace.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(e.node.declare||"StringLiteral"===e.node.id.type)return void e.remove();if(!r)throw e.hub.file.buildCodeFrameError(e.node.id,"Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const n=e.node.id.name,i=a(e,t,t.cloneDeep(e.node)),o=e.scope.hasOwnBinding(n);"ExportNamedDeclaration"===e.parent.type?o?e.parentPath.replaceWith(i):(e.parentPath.insertAfter(i),e.replaceWith(s(t,n)),e.scope.registerDeclaration(e.parentPath)):o?e.replaceWith(i):e.scope.registerDeclaration(e.replaceWithMultiple([s(t,n),i])[0]);};var n=r("./node_modules/@babel/core/lib/index.js");function s(e,t){return e.variableDeclaration("let",[e.variableDeclarator(e.identifier(t))])}function i(e,t,r){return e.memberExpression(e.identifier(t),e.identifier(r))}function o(e,t,r){if("const"!==e.kind)throw r.file.buildCodeFrameError(e,"Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const{declarations:s}=e;if(s.every((e=>n.types.isIdentifier(e.id)))){for(const e of s)e.init=n.types.assignmentExpression("=",i(n.types,t,e.id.name),e.init);return [e]}const o=n.types.getBindingIdentifiers(e),a=[];for(const e in o)a.push(n.types.assignmentExpression("=",i(n.types,t,e),n.types.cloneNode(o[e])));return [e,n.types.expressionStatement(n.types.sequenceExpression(a))]}function a(e,t,r,l){const u=new Set,c=r.id,p=e.scope.generateUid(c.name),d=r.body.body;for(let r=0;r<d.length;r++){const n=d[r];switch(n.type){case"TSModuleDeclaration":{const i=a(e,t,n),o=n.id.name;u.has(o)?d[r]=i:(u.add(o),d.splice(r++,1,s(t,o),i));continue}case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":u.add(n.id.name);continue;case"VariableDeclaration":for(const e in t.getBindingIdentifiers(n))u.add(e);continue;default:continue;case"ExportNamedDeclaration":}switch(n.declaration.type){case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":{const e=n.declaration.id.name;u.add(e),d.splice(r++,1,n.declaration,t.expressionStatement(t.assignmentExpression("=",i(t,p,e),t.identifier(e))));break}case"VariableDeclaration":{const t=o(n.declaration,p,e.hub);d.splice(r,t.length,...t),r+=t.length-1;break}case"TSModuleDeclaration":{const i=a(e,t,n.declaration,t.identifier(p)),o=n.declaration.id.name;u.has(o)?d[r]=i:(u.add(o),d.splice(r++,1,s(t,o),i));}}}let f=t.objectExpression([]);if(l){const e=t.memberExpression(l,c);f=n.template.expression.ast`
      ${t.cloneNode(e)} ||
        (${t.cloneNode(e)} = ${f})
    `;}return n.template.statement.ast`
    (function (${t.identifier(p)}) {
      ${d}
    })(${c} || (${t.cloneNode(c)} = ${f}));
  `}},"./node_modules/@babel/template/lib/builder.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function e(t,r){const o=new WeakMap,u=new WeakMap,c=r||(0, n.validate)(null);return Object.assign(((r,...a)=>{if("string"==typeof r){if(a.length>1)throw new Error("Unexpected extra params.");return l((0,s.default)(t,r,(0,n.merge)(c,(0,n.validate)(a[0]))))}if(Array.isArray(r)){let e=o.get(r);return e||(e=(0, i.default)(t,r,c),o.set(r,e)),l(e(a))}if("object"==typeof r&&r){if(a.length>0)throw new Error("Unexpected extra params.");return e(t,(0, n.merge)(c,(0, n.validate)(r)))}throw new Error("Unexpected template param "+typeof r)}),{ast:(e,...r)=>{if("string"==typeof e){if(r.length>1)throw new Error("Unexpected extra params.");return (0, s.default)(t,e,(0, n.merge)((0, n.merge)(c,(0, n.validate)(r[0])),a))()}if(Array.isArray(e)){let s=u.get(e);return s||(s=(0, i.default)(t,e,(0, n.merge)(c,a)),u.set(e,s)),s(r)()}throw new Error("Unexpected template param "+typeof e)}})};var n=r("./node_modules/@babel/template/lib/options.js"),s=o(r("./node_modules/@babel/template/lib/string.js")),i=o(r("./node_modules/@babel/template/lib/literal.js"));function o(e){return e&&e.__esModule?e:{default:e}}const a=(0, n.validate)({placeholderPattern:!1});function l(e){let t="";try{throw new Error}catch(e){e.stack&&(t=e.stack.split("\n").slice(3).join("\n"));}return r=>{try{return e(r)}catch(e){throw e.stack+=`\n    =============\n${t}`,e}}}},"./node_modules/@babel/template/lib/formatters.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.program=t.expression=t.statement=t.statements=t.smart=void 0;var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}function i(e){return {code:e=>`/* @babel/template */;\n${e}`,validate:()=>{},unwrap:t=>e(t.program.body.slice(1))}}const o=i((e=>e.length>1?e:e[0]));t.smart=o;const a=i((e=>e));t.statements=a;const l=i((e=>{if(0===e.length)throw new Error("Found nothing to return.");if(e.length>1)throw new Error("Found multiple statements but wanted one");return e[0]}));t.statement=l;const u={code:e=>`(\n${e}\n)`,validate:e=>{if(e.program.body.length>1)throw new Error("Found multiple statements but wanted one");if(0===u.unwrap(e).start)throw new Error("Parse result included parens.")},unwrap:({program:e})=>{const[t]=e.body;return n.assertExpressionStatement(t),t.expression}};t.expression=u,t.program={code:e=>e,validate:()=>{},unwrap:e=>e.program};},"./node_modules/@babel/template/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.program=t.expression=t.statements=t.statement=t.smart=void 0;var n,s=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=o();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var i=n?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(r,s,i):r[s]=e[s];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/template/lib/formatters.js")),i=(n=r("./node_modules/@babel/template/lib/builder.js"))&&n.__esModule?n:{default:n};function o(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return o=function(){return e},e}const a=(0, i.default)(s.smart);t.smart=a;const l=(0, i.default)(s.statement);t.statement=l;const u=(0, i.default)(s.statements);t.statements=u;const c=(0, i.default)(s.expression);t.expression=c;const p=(0, i.default)(s.program);t.program=p;var d=Object.assign(a.bind(void 0),{smart:a,statement:l,statements:u,expression:c,program:p,ast:a.ast});t.default=d;},"./node_modules/@babel/template/lib/literal.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){const{metadata:o,names:l}=function(e,t,r){let n,i,o,l="";do{l+="$";const u=a(t,l);n=u.names,i=new Set(n),o=(0, s.default)(e,e.code(u.code),{parser:r.parser,placeholderWhitelist:new Set(u.names.concat(r.placeholderWhitelist?Array.from(r.placeholderWhitelist):[])),placeholderPattern:r.placeholderPattern,preserveComments:r.preserveComments,syntacticPlaceholders:r.syntacticPlaceholders});}while(o.placeholders.some((e=>e.isDuplicate&&i.has(e.name))));return {metadata:o,names:n}}(e,t,r);return t=>{const r={};return t.forEach(((e,t)=>{r[l[t]]=e;})),t=>{const s=(0, n.normalizeReplacements)(t);return s&&Object.keys(s).forEach((e=>{if(Object.prototype.hasOwnProperty.call(r,e))throw new Error("Unexpected replacement overlap.")})),e.unwrap((0, i.default)(o,s?Object.assign(s,r):r))}}};var n=r("./node_modules/@babel/template/lib/options.js"),s=o(r("./node_modules/@babel/template/lib/parse.js")),i=o(r("./node_modules/@babel/template/lib/populate.js"));function o(e){return e&&e.__esModule?e:{default:e}}function a(e,t){const r=[];let n=e[0];for(let s=1;s<e.length;s++){const i=`${t}${s-1}`;r.push(i),n+=i+e[s];}return {names:r,code:n}}},"./node_modules/@babel/template/lib/options.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.merge=function(e,t){const{placeholderWhitelist:r=e.placeholderWhitelist,placeholderPattern:n=e.placeholderPattern,preserveComments:s=e.preserveComments,syntacticPlaceholders:i=e.syntacticPlaceholders}=t;return {parser:Object.assign({},e.parser,t.parser),placeholderWhitelist:r,placeholderPattern:n,preserveComments:s,syntacticPlaceholders:i}},t.validate=function(e){if(null!=e&&"object"!=typeof e)throw new Error("Unknown template options.");const t=e||{},{placeholderWhitelist:r,placeholderPattern:n,preserveComments:s,syntacticPlaceholders:i}=t,o=function(e,t){if(null==e)return {};var r,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(s[r]=e[r]);return s}(t,["placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders"]);if(null!=r&&!(r instanceof Set))throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");if(null!=n&&!(n instanceof RegExp)&&!1!==n)throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");if(null!=s&&"boolean"!=typeof s)throw new Error("'.preserveComments' must be a boolean, null, or undefined");if(null!=i&&"boolean"!=typeof i)throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");if(!0===i&&(null!=r||null!=n))throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");return {parser:o,placeholderWhitelist:r||void 0,placeholderPattern:null==n?void 0:n,preserveComments:null==s?void 0:s,syntacticPlaceholders:null==i?void 0:i}},t.normalizeReplacements=function(e){if(Array.isArray(e))return e.reduce(((e,t,r)=>(e["$"+r]=t,e)),{});if("object"==typeof e||null==e)return e||void 0;throw new Error("Template replacements must be an array, object, null, or undefined")};},"./node_modules/@babel/template/lib/parse.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){const{placeholderWhitelist:o,placeholderPattern:a,preserveComments:u,syntacticPlaceholders:c}=r,p=function(e,t,r){const n=(t.plugins||[]).slice();!1!==r&&n.push("placeholders"),t=Object.assign({allowReturnOutsideFunction:!0,allowSuperOutsideMethod:!0,sourceType:"module"},t,{plugins:n});try{return (0,s.parse)(e,t)}catch(t){const r=t.loc;throw r&&(t.message+="\n"+(0, i.codeFrameColumns)(e,{start:r}),t.code="BABEL_TEMPLATE_PARSE_ERROR"),t}}(t,r.parser,c);n.removePropertiesDeep(p,{preserveComments:u}),e.validate(p);const d={placeholders:[],placeholderNames:new Set},f={placeholders:[],placeholderNames:new Set},h={value:void 0};return n.traverse(p,l,{syntactic:d,legacy:f,isLegacyRef:h,placeholderWhitelist:o,placeholderPattern:a,syntacticPlaceholders:c}),Object.assign({ast:p},h.value?f:d)};var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=o();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var i=n?Object.getOwnPropertyDescriptor(e,s):null;i&&(i.get||i.set)?Object.defineProperty(r,s,i):r[s]=e[s];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js")),s=r("./node_modules/@babel/parser/lib/index.js"),i=r("./stubs/babel_codeframe.js");function o(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return o=function(){return e},e}const a=/^[_$A-Z0-9]+$/;function l(e,t,r){var s;let i;if(n.isPlaceholder(e)){if(!1===r.syntacticPlaceholders)throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");i=e.name.name,r.isLegacyRef.value=!1;}else {if(!1===r.isLegacyRef.value||r.syntacticPlaceholders)return;if(n.isIdentifier(e)||n.isJSXIdentifier(e))i=e.name,r.isLegacyRef.value=!0;else {if(!n.isStringLiteral(e))return;i=e.value,r.isLegacyRef.value=!0;}}if(!r.isLegacyRef.value&&(null!=r.placeholderPattern||null!=r.placeholderWhitelist))throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");if(r.isLegacyRef.value&&(!1===r.placeholderPattern||!(r.placeholderPattern||a).test(i))&&!(null==(s=r.placeholderWhitelist)?void 0:s.has(i)))return;t=t.slice();const{node:o,key:l}=t[t.length-1];let u;n.isStringLiteral(e)||n.isPlaceholder(e,{expectedNode:"StringLiteral"})?u="string":n.isNewExpression(o)&&"arguments"===l||n.isCallExpression(o)&&"arguments"===l||n.isFunction(o)&&"params"===l?u="param":n.isExpressionStatement(o)&&!n.isPlaceholder(e)?(u="statement",t=t.slice(0,-1)):u=n.isStatement(e)&&n.isPlaceholder(e)?"statement":"other";const{placeholders:c,placeholderNames:p}=r.isLegacyRef.value?r.legacy:r.syntactic;c.push({name:i,type:u,resolve:e=>function(e,t){let r=e;for(let e=0;e<t.length-1;e++){const{key:n,index:s}=t[e];r=void 0===s?r[n]:r[n][s];}const{key:n,index:s}=t[t.length-1];return {parent:r,key:n,index:s}}(e,t),isDuplicate:p.has(i)}),p.add(i);}},"./node_modules/@babel/template/lib/populate.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){const r=n.cloneNode(e.ast);return t&&(e.placeholders.forEach((e=>{if(!Object.prototype.hasOwnProperty.call(t,e.name)){const t=e.name;throw new Error(`Error: No substitution given for "${t}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t}'])}\n            - { placeholderPattern: /^${t}$/ }`)}})),Object.keys(t).forEach((t=>{if(!e.placeholderNames.has(t))throw new Error(`Unknown substitution "${t}" given`)}))),e.placeholders.slice().reverse().forEach((e=>{try{!function(e,t,r){e.isDuplicate&&(Array.isArray(r)?r=r.map((e=>n.cloneNode(e))):"object"==typeof r&&(r=n.cloneNode(r)));const{parent:s,key:i,index:o}=e.resolve(t);if("string"===e.type){if("string"==typeof r&&(r=n.stringLiteral(r)),!r||!n.isStringLiteral(r))throw new Error("Expected string substitution")}else if("statement"===e.type)void 0===o?r?Array.isArray(r)?r=n.blockStatement(r):"string"==typeof r?r=n.expressionStatement(n.identifier(r)):n.isStatement(r)||(r=n.expressionStatement(r)):r=n.emptyStatement():r&&!Array.isArray(r)&&("string"==typeof r&&(r=n.identifier(r)),n.isStatement(r)||(r=n.expressionStatement(r)));else if("param"===e.type){if("string"==typeof r&&(r=n.identifier(r)),void 0===o)throw new Error("Assertion failure.")}else if("string"==typeof r&&(r=n.identifier(r)),Array.isArray(r))throw new Error("Cannot replace single expression with an array.");if(void 0===o)n.validate(s,i,r),s[i]=r;else {const t=s[i].slice();"statement"===e.type||"param"===e.type?null==r?t.splice(o,1):Array.isArray(r)?t.splice(o,1,...r):t[o]=r:t[o]=r,n.validate(s,i,t),s[i]=t;}}(e,r,t&&t[e.name]||null);}catch(t){throw t.message=`@babel/template placeholder "${e.name}": ${t.message}`,t}})),r};var n=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return {default:e};var t=s();if(t&&t.has(e))return t.get(e);var r={},n=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=n?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(r,i,o):r[i]=e[i];}return r.default=e,t&&t.set(e,r),r}(r("./node_modules/@babel/types/lib/index.js"));function s(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return s=function(){return e},e}},"./node_modules/@babel/template/lib/string.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){let o;return t=e.code(t),a=>{const l=(0, n.normalizeReplacements)(a);return o||(o=(0, s.default)(e,t,r)),e.unwrap((0, i.default)(o,l))}};var n=r("./node_modules/@babel/template/lib/options.js"),s=o(r("./node_modules/@babel/template/lib/parse.js")),i=o(r("./node_modules/@babel/template/lib/populate.js"));function o(e){return e&&e.__esModule?e:{default:e}}},"./node_modules/@babel/traverse/lib/cache.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.clear=function(){s(),i();},t.clearPath=s,t.clearScope=i,t.scope=t.path=void 0;let r=new WeakMap;t.path=r;let n=new WeakMap;function s(){t.path=r=new WeakMap;}function i(){t.scope=n=new WeakMap;}t.scope=n;},"./node_modules/@babel/traverse/lib/context.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/traverse/lib/path/index.js"),s=r("./node_modules/@babel/types/lib/index.js");const i="test"===process.env.NODE_ENV;t.default=class{constructor(e,t,r,n){this.queue=null,this.priorityQueue=null,this.parentPath=n,this.scope=e,this.state=r,this.opts=t;}shouldVisit(e){const t=this.opts;if(t.enter||t.exit)return !0;if(t[e.type])return !0;const r=s.VISITOR_KEYS[e.type];if(null==r||!r.length)return !1;for(const t of r)if(e[t])return !0;return !1}create(e,t,r,s){return n.default.get({parentPath:this.parentPath,parent:e,container:t,key:r,listKey:s})}maybeQueue(e,t){if(this.trap)throw new Error("Infinite cycle detected");this.queue&&(t?this.queue.push(e):this.priorityQueue.push(e));}visitMultiple(e,t,r){if(0===e.length)return !1;const n=[];for(let s=0;s<e.length;s++){const i=e[s];i&&this.shouldVisit(i)&&n.push(this.create(t,e,s,r));}return this.visitQueue(n)}visitSingle(e,t){return !!this.shouldVisit(e[t])&&this.visitQueue([this.create(e,e,t)])}visitQueue(e){this.queue=e,this.priorityQueue=[];const t=new WeakSet;let r=!1;for(const n of e){if(n.resync(),0!==n.contexts.length&&n.contexts[n.contexts.length-1]===this||n.pushContext(this),null===n.key)continue;i&&e.length>=1e4&&(this.trap=!0);const{node:s}=n;if(!t.has(s)){if(s&&t.add(s),n.visit()){r=!0;break}if(this.priorityQueue.length&&(r=this.visitQueue(this.priorityQueue),this.priorityQueue=[],this.queue=e,r))break}}for(const t of e)t.popContext();return this.queue=null,r}visit(e,t){const r=e[t];return !!r&&(Array.isArray(r)?this.visitMultiple(r,e,t):this.visitSingle(e,t))}};},"./node_modules/@babel/traverse/lib/hub.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,t.default=class{getCode(){}getScope(){}addHelper(){throw new Error("Helpers are not supported by the default hub.")}buildError(e,t,r=TypeError){return new r(t)}};},"./node_modules/@babel/traverse/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"NodePath",{enumerable:!0,get:function(){return a.default}}),Object.defineProperty(t,"Scope",{enumerable:!0,get:function(){return l.default}}),Object.defineProperty(t,"Hub",{enumerable:!0,get:function(){return u.default}}),t.visitors=t.default=void 0;var n=r("./node_modules/@babel/traverse/lib/context.js"),s=r("./node_modules/@babel/traverse/lib/visitors.js");t.visitors=s;var i=r("./node_modules/@babel/types/lib/index.js"),o=r("./node_modules/@babel/traverse/lib/cache.js"),a=r("./node_modules/@babel/traverse/lib/path/index.js"),l=r("./node_modules/@babel/traverse/lib/scope/index.js"),u=r("./node_modules/@babel/traverse/lib/hub.js");function c(e,t={},r,n,o){if(e){if(!t.noScope&&!r&&"Program"!==e.type&&"File"!==e.type)throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e.type} node without passing scope and parentPath.`);i.VISITOR_KEYS[e.type]&&(s.explode(t),c.node(e,t,r,n,o));}}var p=c;function d(e,t){e.node.type===t.type&&(t.has=!0,e.stop());}t.default=p,c.visitors=s,c.verify=s.verify,c.explode=s.explode,c.cheap=function(e,t){return i.traverseFast(e,t)},c.node=function(e,t,r,s,o,a){const l=i.VISITOR_KEYS[e.type];if(!l)return;const u=new n.default(r,t,s,o);for(const t of l)if((!a||!a[t])&&u.visit(e,t))return},c.clearNode=function(e,t){i.removeProperties(e,t),o.path.delete(e);},c.removeProperties=function(e,t){return i.traverseFast(e,c.clearNode,t),e},c.hasType=function(e,t,r){if(null!=r&&r.includes(e.type))return !1;if(e.type===t)return !0;const n={has:!1,type:t};return c(e,{noScope:!0,denylist:r,enter:d},null,n),n.has},c.cache=o;},"./node_modules/@babel/traverse/lib/path/ancestry.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.findParent=function(e){let t=this;for(;t=t.parentPath;)if(e(t))return t;return null},t.find=function(e){let t=this;do{if(e(t))return t}while(t=t.parentPath);return null},t.getFunctionParent=function(){return this.findParent((e=>e.isFunction()))},t.getStatementParent=function(){let e=this;do{if(!e.parentPath||Array.isArray(e.container)&&e.isStatement())break;e=e.parentPath;}while(e);if(e&&(e.isProgram()||e.isFile()))throw new Error("File/Program node, we can't possibly find a statement parent to this");return e},t.getEarliestCommonAncestorFrom=function(e){return this.getDeepestCommonAncestorFrom(e,(function(e,t,r){let s;const i=n.VISITOR_KEYS[e.type];for(const e of r){const r=e[t+1];s?(r.listKey&&s.listKey===r.listKey&&r.key<s.key||i.indexOf(s.parentKey)>i.indexOf(r.parentKey))&&(s=r):s=r;}return s}))},t.getDeepestCommonAncestorFrom=function(e,t){if(!e.length)return this;if(1===e.length)return e[0];let r,n,s=1/0;const i=e.map((e=>{const t=[];do{t.unshift(e);}while((e=e.parentPath)&&e!==this);return t.length<s&&(s=t.length),t})),o=i[0];e:for(let e=0;e<s;e++){const t=o[e];for(const r of i)if(r[e]!==t)break e;r=e,n=t;}if(n)return t?t(n,r,i):n;throw new Error("Couldn't find intersection")},t.getAncestry=function(){let e=this;const t=[];do{t.push(e);}while(e=e.parentPath);return t},t.isAncestor=function(e){return e.isDescendant(this)},t.isDescendant=function(e){return !!this.findParent((t=>t===e))},t.inType=function(...e){let t=this;for(;t;){for(const r of e)if(t.node.type===r)return !0;t=t.parentPath;}return !1};var n=r("./node_modules/@babel/types/lib/index.js");r("./node_modules/@babel/traverse/lib/path/index.js");},"./node_modules/@babel/traverse/lib/path/comments.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.shareCommentsWithSiblings=function(){if("string"==typeof this.key)return;const e=this.node;if(!e)return;const t=e.trailingComments,r=e.leadingComments;if(!t&&!r)return;const n=this.getSibling(this.key-1),s=this.getSibling(this.key+1),i=Boolean(n.node),o=Boolean(s.node);i&&!o?n.addComments("trailing",t):o&&!i&&s.addComments("leading",r);},t.addComment=function(e,t,r){n.addComment(this.node,e,t,r);},t.addComments=function(e,t){n.addComments(this.node,e,t);};var n=r("./node_modules/@babel/types/lib/index.js");},"./node_modules/@babel/traverse/lib/path/context.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.call=function(e){const t=this.opts;return this.debug(e),!(!this.node||!this._call(t[e]))||!!this.node&&this._call(t[this.node.type]&&t[this.node.type][e])},t._call=function(e){if(!e)return !1;for(const t of e){if(!t)continue;const e=this.node;if(!e)return !0;const r=t.call(this.state,this,this.state);if(r&&"object"==typeof r&&"function"==typeof r.then)throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");if(r)throw new Error(`Unexpected return value from visitor method ${t}`);if(this.node!==e)return !0;if(this._traverseFlags>0)return !0}return !1},t.isBlacklisted=t.isDenylisted=function(){var e;const t=null!=(e=this.opts.denylist)?e:this.opts.blacklist;return t&&t.indexOf(this.node.type)>-1},t.visit=function(){return !!this.node&&(!this.isDenylisted()&&((!this.opts.shouldSkip||!this.opts.shouldSkip(this))&&(this.shouldSkip||this.call("enter")||this.shouldSkip?(this.debug("Skip..."),this.shouldStop):(this.debug("Recursing into..."),n.default.node(this.node,this.opts,this.scope,this.state,this,this.skipKeys),this.call("exit"),this.shouldStop))))},t.skip=function(){this.shouldSkip=!0;},t.skipKey=function(e){null==this.skipKeys&&(this.skipKeys={}),this.skipKeys[e]=!0;},t.stop=function(){this._traverseFlags|=s.SHOULD_SKIP|s.SHOULD_STOP;},t.setScope=function(){if(this.opts&&this.opts.noScope)return;let e,t=this.parentPath;for("key"===this.key&&t.isMethod()&&(t=t.parentPath);t&&!e;){if(t.opts&&t.opts.noScope)return;e=t.scope,t=t.parentPath;}this.scope=this.getScope(e),this.scope&&this.scope.init();},t.setContext=function(e){return null!=this.skipKeys&&(this.skipKeys={}),this._traverseFlags=0,e&&(this.context=e,this.state=e.state,this.opts=e.opts),this.setScope(),this},t.resync=function(){this.removed||(this._resyncParent(),this._resyncList(),this._resyncKey());},t._resyncParent=function(){this.parentPath&&(this.parent=this.parentPath.node);},t._resyncKey=function(){if(this.container&&this.node!==this.container[this.key]){if(Array.isArray(this.container)){for(let e=0;e<this.container.length;e++)if(this.container[e]===this.node)return this.setKey(e)}else for(const e of Object.keys(this.container))if(this.container[e]===this.node)return this.setKey(e);this.key=null;}},t._resyncList=function(){if(!this.parent||!this.inList)return;const e=this.parent[this.listKey];this.container!==e&&(this.container=e||null);},t._resyncRemoved=function(){null!=this.key&&this.container&&this.container[this.key]===this.node||this._markRemoved();},t.popContext=function(){this.contexts.pop(),this.contexts.length>0?this.setContext(this.contexts[this.contexts.length-1]):this.setContext(void 0);},t.pushContext=function(e){this.contexts.push(e),this.setContext(e);},t.setup=function(e,t,r,n){this.listKey=r,this.container=t,this.parentPath=e||this.parentPath,this.setKey(n);},t.setKey=function(e){var t;this.key=e,this.node=this.container[this.key],this.type=null==(t=this.node)?void 0:t.type;},t.requeue=function(e=this){if(e.removed)return;const t=this.contexts;for(const r of t)r.maybeQueue(e);},t._getQueueContexts=function(){let e=this,t=this.contexts;for(;!t.length&&(e=e.parentPath,e);)t=e.contexts;return t};var n=r("./node_modules/@babel/traverse/lib/index.js"),s=r("./node_modules/@babel/traverse/lib/path/index.js");},"./node_modules/@babel/traverse/lib/path/conversion.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.toComputedKey=function(){let e;if(this.isMemberExpression())e=this.node.property;else {if(!this.isProperty()&&!this.isMethod())throw new ReferenceError("todo");e=this.node.key;}return this.node.computed||n.isIdentifier(e)&&(e=n.stringLiteral(e.name)),e},t.ensureBlock=function(){const e=this.get("body"),t=e.node;if(Array.isArray(e))throw new Error("Can't convert array path to a block statement");if(!t)throw new Error("Can't convert node without a body");if(e.isBlockStatement())return t;const r=[];let s,i,o="body";e.isStatement()?(i="body",s=0,r.push(e.node)):(o+=".body.0",this.isFunction()?(s="argument",r.push(n.returnStatement(e.node))):(s="expression",r.push(n.expressionStatement(e.node)))),this.node.body=n.blockStatement(r);const a=this.get(o);return e.setup(a,i?a.node[i]:a.node,i,s),this.node},t.arrowFunctionToShadowed=function(){this.isArrowFunctionExpression()&&this.arrowFunctionToExpression();},t.unwrapFunctionEnvironment=function(){if(!this.isArrowFunctionExpression()&&!this.isFunctionExpression()&&!this.isFunctionDeclaration())throw this.buildCodeFrameError("Can only unwrap the environment of a function.");i(this);},t.arrowFunctionToExpression=function({allowInsertArrow:e=!0,specCompliant:t=!1,noNewArrows:r=!t}={}){if(!this.isArrowFunctionExpression())throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");const o=i(this,r,e);if(this.ensureBlock(),this.node.type="FunctionExpression",!r){const e=o?null:this.parentPath.scope.generateUidIdentifier("arrowCheckId");e&&this.parentPath.scope.push({id:e,init:n.objectExpression([])}),this.get("body").unshiftContainer("body",n.expressionStatement(n.callExpression(this.hub.addHelper("newArrowCheck"),[n.thisExpression(),e?n.identifier(e.name):n.identifier(o)]))),this.replaceWith(n.callExpression(n.memberExpression((0, s.default)(this,!0)||this.node,n.identifier("bind")),[e?n.identifier(e.name):n.thisExpression()]));}};var n=r("./node_modules/@babel/types/lib/index.js"),s=r("./node_modules/@babel/helper-function-name/lib/index.js");function i(e,t=!0,r=!0){const s=e.findParent((e=>e.isFunction()&&!e.isArrowFunctionExpression()||e.isProgram()||e.isClassProperty({static:!1}))),i="constructor"===(null==s?void 0:s.node.kind);if(s.isClassProperty())throw e.buildCodeFrameError("Unable to transform arrow inside class property");const{thisPaths:l,argumentsPaths:u,newTargetPaths:c,superProps:p,superCalls:d}=function(e){const t=[],r=[],n=[],s=[],i=[];return e.traverse({ClassProperty(e){e.skip();},Function(e){e.isArrowFunctionExpression()||e.skip();},ThisExpression(e){t.push(e);},JSXIdentifier(e){"this"===e.node.name&&(e.parentPath.isJSXMemberExpression({object:e.node})||e.parentPath.isJSXOpeningElement({name:e.node}))&&t.push(e);},CallExpression(e){e.get("callee").isSuper()&&i.push(e);},MemberExpression(e){e.get("object").isSuper()&&s.push(e);},ReferencedIdentifier(e){"arguments"===e.node.name&&r.push(e);},MetaProperty(e){e.get("meta").isIdentifier({name:"new"})&&e.get("property").isIdentifier({name:"target"})&&n.push(e);}}),{thisPaths:t,argumentsPaths:r,newTargetPaths:n,superProps:s,superCalls:i}}(e);if(i&&d.length>0){if(!r)throw d[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");const e=[];s.traverse({Function(e){e.isArrowFunctionExpression()||e.skip();},ClassProperty(e){e.skip();},CallExpression(t){t.get("callee").isSuper()&&e.push(t);}});const t=function(e){return a(e,"supercall",(()=>{const t=e.scope.generateUidIdentifier("args");return n.arrowFunctionExpression([n.restElement(t)],n.callExpression(n.super(),[n.spreadElement(n.identifier(t.name))]))}))}(s);e.forEach((e=>{const r=n.identifier(t);r.loc=e.node.callee.loc,e.get("callee").replaceWith(r);}));}if(u.length>0){const e=a(s,"arguments",(()=>n.identifier("arguments")));u.forEach((t=>{const r=n.identifier(e);r.loc=t.node.loc,t.replaceWith(r);}));}if(c.length>0){const e=a(s,"newtarget",(()=>n.metaProperty(n.identifier("new"),n.identifier("target"))));c.forEach((t=>{const r=n.identifier(e);r.loc=t.node.loc,t.replaceWith(r);}));}if(p.length>0){if(!r)throw p[0].buildCodeFrameError("Unable to handle nested super.prop usage");p.reduce(((e,t)=>e.concat(function(e){if(e.parentPath.isAssignmentExpression()&&"="!==e.parentPath.node.operator){const t=e.parentPath,r=t.node.operator.slice(0,-1),s=t.node.right;if(t.node.operator="=",e.node.computed){const i=e.scope.generateDeclaredUidIdentifier("tmp");t.get("left").replaceWith(n.memberExpression(e.node.object,n.assignmentExpression("=",i,e.node.property),!0)),t.get("right").replaceWith(n.binaryExpression(r,n.memberExpression(e.node.object,n.identifier(i.name),!0),s));}else t.get("left").replaceWith(n.memberExpression(e.node.object,e.node.property)),t.get("right").replaceWith(n.binaryExpression(r,n.memberExpression(e.node.object,n.identifier(e.node.property.name)),s));return [t.get("left"),t.get("right").get("left")]}if(e.parentPath.isUpdateExpression()){const t=e.parentPath,r=e.scope.generateDeclaredUidIdentifier("tmp"),s=e.node.computed?e.scope.generateDeclaredUidIdentifier("prop"):null,i=[n.assignmentExpression("=",r,n.memberExpression(e.node.object,s?n.assignmentExpression("=",s,e.node.property):e.node.property,e.node.computed)),n.assignmentExpression("=",n.memberExpression(e.node.object,s?n.identifier(s.name):e.node.property,e.node.computed),n.binaryExpression("+",n.identifier(r.name),n.numericLiteral(1)))];return e.parentPath.node.prefix||i.push(n.identifier(r.name)),t.replaceWith(n.sequenceExpression(i)),[t.get("expressions.0.right"),t.get("expressions.1.left")]}return [e]}(t))),[]).forEach((e=>{const t=e.node.computed?"":e.get("property").node.name,r=e.parentPath.isAssignmentExpression({left:e.node}),i=e.parentPath.isCallExpression({callee:e.node}),o=function(e,t,r){return a(e,`superprop_${t?"set":"get"}:${r||""}`,(()=>{const s=[];let i;if(r)i=n.memberExpression(n.super(),n.identifier(r));else {const t=e.scope.generateUidIdentifier("prop");s.unshift(t),i=n.memberExpression(n.super(),n.identifier(t.name),!0);}if(t){const t=e.scope.generateUidIdentifier("value");s.push(t),i=n.assignmentExpression("=",i,n.identifier(t.name));}return n.arrowFunctionExpression(s,i)}))}(s,r,t),u=[];if(e.node.computed&&u.push(e.get("property").node),r){const t=e.parentPath.node.right;u.push(t);}const c=n.callExpression(n.identifier(o),u);i?(e.parentPath.unshiftContainer("arguments",n.thisExpression()),e.replaceWith(n.memberExpression(c,n.identifier("call"))),l.push(e.parentPath.get("arguments.0"))):r?e.parentPath.replaceWith(c):e.replaceWith(c);}));}let f;return (l.length>0||!t)&&(f=function(e,t){return a(e,"this",(r=>{if(!t||!o(e))return n.thisExpression();const s=new WeakSet;e.traverse({Function(e){e.isArrowFunctionExpression()||e.skip();},ClassProperty(e){e.skip();},CallExpression(e){e.get("callee").isSuper()&&(s.has(e.node)||(s.add(e.node),e.replaceWithMultiple([e.node,n.assignmentExpression("=",n.identifier(r),n.identifier("this"))])));}});}))}(s,i),(t||i&&o(s))&&(l.forEach((e=>{const t=e.isJSX()?n.jsxIdentifier(f):n.identifier(f);t.loc=e.node.loc,e.replaceWith(t);})),t||(f=null))),f}function o(e){return e.isClassMethod()&&!!e.parentPath.parentPath.node.superClass}function a(e,t,r){const n="binding:"+t;let s=e.getData(n);if(!s){const i=e.scope.generateUidIdentifier(t);s=i.name,e.setData(n,s),e.scope.push({id:i,init:r(s)});}return s}},"./node_modules/@babel/traverse/lib/path/evaluation.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.evaluateTruthy=function(){const e=this.evaluate();if(e.confident)return !!e.value},t.evaluate=function(){const e={confident:!0,deoptPath:null,seen:new Map};let t=i(this,e);return e.confident||(t=void 0),{confident:e.confident,deopt:e.deoptPath,value:t}};const r=["String","Number","Math"],n=["random"];function s(e,t){t.confident&&(t.deoptPath=e,t.confident=!1);}function i(e,t){const{node:a}=e,{seen:l}=t;if(l.has(a)){const r=l.get(a);return r.resolved?r.value:void s(e,t)}{const u={resolved:!1};l.set(a,u);const c=function(e,t){if(t.confident){if(e.isSequenceExpression()){const r=e.get("expressions");return i(r[r.length-1],t)}if(e.isStringLiteral()||e.isNumericLiteral()||e.isBooleanLiteral())return e.node.value;if(e.isNullLiteral())return null;if(e.isTemplateLiteral())return o(e,e.node.quasis,t);if(e.isTaggedTemplateExpression()&&e.get("tag").isMemberExpression()){const r=e.get("tag.object"),{node:{name:n}}=r,s=e.get("tag.property");if(r.isIdentifier()&&"String"===n&&!e.scope.getBinding(n)&&s.isIdentifier()&&"raw"===s.node.name)return o(e,e.node.quasi.quasis,t,!0)}if(e.isConditionalExpression()){const r=i(e.get("test"),t);if(!t.confident)return;return i(r?e.get("consequent"):e.get("alternate"),t)}if(e.isExpressionWrapper())return i(e.get("expression"),t);if(e.isMemberExpression()&&!e.parentPath.isCallExpression({callee:e.node})){const t=e.get("property"),r=e.get("object");if(r.isLiteral()&&t.isIdentifier()){const e=r.node.value,n=typeof e;if("number"===n||"string"===n)return e[t.node.name]}}if(e.isReferencedIdentifier()){const r=e.scope.getBinding(e.node.name);if(r&&r.constantViolations.length>0)return s(r.path,t);if(r&&e.node.start<r.path.node.end)return s(r.path,t);if(null!=r&&r.hasValue)return r.value;{if("undefined"===e.node.name)return r?s(r.path,t):void 0;if("Infinity"===e.node.name)return r?s(r.path,t):1/0;if("NaN"===e.node.name)return r?s(r.path,t):NaN;const n=e.resolve();return n===e?s(e,t):i(n,t)}}if(e.isUnaryExpression({prefix:!0})){if("void"===e.node.operator)return;const r=e.get("argument");if("typeof"===e.node.operator&&(r.isFunction()||r.isClass()))return "function";const n=i(r,t);if(!t.confident)return;switch(e.node.operator){case"!":return !n;case"+":return +n;case"-":return -n;case"~":return ~n;case"typeof":return typeof n}}if(e.isArrayExpression()){const r=[],n=e.get("elements");for(const e of n){const n=e.evaluate();if(!n.confident)return s(n.deopt,t);r.push(n.value);}return r}if(e.isObjectExpression()){const r={},n=e.get("properties");for(const e of n){if(e.isObjectMethod()||e.isSpreadElement())return s(e,t);let n=e.get("key");if(e.node.computed){if(n=n.evaluate(),!n.confident)return s(n.deopt,t);n=n.value;}else n=n.isIdentifier()?n.node.name:n.node.value;let i=e.get("value").evaluate();if(!i.confident)return s(i.deopt,t);i=i.value,r[n]=i;}return r}if(e.isLogicalExpression()){const r=t.confident,n=i(e.get("left"),t),s=t.confident;t.confident=r;const o=i(e.get("right"),t),a=t.confident;switch(e.node.operator){case"||":if(t.confident=s&&(!!n||a),!t.confident)return;return n||o;case"&&":if(t.confident=s&&(!n||a),!t.confident)return;return n&&o}}if(e.isBinaryExpression()){const r=i(e.get("left"),t);if(!t.confident)return;const n=i(e.get("right"),t);if(!t.confident)return;switch(e.node.operator){case"-":return r-n;case"+":return r+n;case"/":return r/n;case"*":return r*n;case"%":return r%n;case"**":return Math.pow(r,n);case"<":return r<n;case">":return r>n;case"<=":return r<=n;case">=":return r>=n;case"==":return r==n;case"!=":return r!=n;case"===":return r===n;case"!==":return r!==n;case"|":return r|n;case"&":return r&n;case"^":return r^n;case"<<":return r<<n;case">>":return r>>n;case">>>":return r>>>n}}if(e.isCallExpression()){const s=e.get("callee");let o,a;if(s.isIdentifier()&&!e.scope.getBinding(s.node.name)&&r.indexOf(s.node.name)>=0&&(a=commonjsGlobal[s.node.name]),s.isMemberExpression()){const e=s.get("object"),t=s.get("property");if(e.isIdentifier()&&t.isIdentifier()&&r.indexOf(e.node.name)>=0&&n.indexOf(t.node.name)<0&&(o=commonjsGlobal[e.node.name],a=o[t.node.name]),e.isLiteral()&&t.isIdentifier()){const r=typeof e.node.value;"string"!==r&&"number"!==r||(o=e.node.value,a=o[t.node.name]);}}if(a){const r=e.get("arguments").map((e=>i(e,t)));if(!t.confident)return;return a.apply(o,r)}}s(e,t);}}(e,t);return t.confident&&(u.resolved=!0,u.value=c),c}}function o(e,t,r,n=!1){let s="",o=0;const a=e.get("expressions");for(const e of t){if(!r.confident)break;s+=n?e.value.raw:e.value.cooked;const t=a[o++];t&&(s+=String(i(t,r)));}if(r.confident)return s}},"./node_modules/@babel/traverse/lib/path/family.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getOpposite=function(){return "left"===this.key?this.getSibling("right"):"right"===this.key?this.getSibling("left"):null},t.getCompletionRecords=function(){return u(this,{canHaveBreak:!1,shouldPopulateBreak:!1,inCaseClause:!1}).map((e=>e.path))},t.getSibling=function(e){return n.default.get({parentPath:this.parentPath,parent:this.parent,container:this.container,listKey:this.listKey,key:e}).setContext(this.context)},t.getPrevSibling=function(){return this.getSibling(this.key-1)},t.getNextSibling=function(){return this.getSibling(this.key+1)},t.getAllNextSiblings=function(){let e=this.key,t=this.getSibling(++e);const r=[];for(;t.node;)r.push(t),t=this.getSibling(++e);return r},t.getAllPrevSiblings=function(){let e=this.key,t=this.getSibling(--e);const r=[];for(;t.node;)r.push(t),t=this.getSibling(--e);return r},t.get=function(e,t=!0){!0===t&&(t=this.context);const r=e.split(".");return 1===r.length?this._getKey(e,t):this._getPattern(r,t)},t._getKey=function(e,t){const r=this.node,s=r[e];return Array.isArray(s)?s.map(((i,o)=>n.default.get({listKey:e,parentPath:this,parent:r,container:s,key:o}).setContext(t))):n.default.get({parentPath:this,parent:r,container:r,key:e}).setContext(t)},t._getPattern=function(e,t){let r=this;for(const n of e)r="."===n?r.parentPath:Array.isArray(r)?r[n]:r.get(n,t);return r},t.getBindingIdentifiers=function(e){return s.getBindingIdentifiers(this.node,e)},t.getOuterBindingIdentifiers=function(e){return s.getOuterBindingIdentifiers(this.node,e)},t.getBindingIdentifierPaths=function(e=!1,t=!1){let r=[].concat(this);const n=Object.create(null);for(;r.length;){const i=r.shift();if(!i)continue;if(!i.node)continue;const o=s.getBindingIdentifiers.keys[i.node.type];if(i.isIdentifier())e?(n[i.node.name]=n[i.node.name]||[]).push(i):n[i.node.name]=i;else if(i.isExportDeclaration()){const e=i.get("declaration");e.isDeclaration()&&r.push(e);}else {if(t){if(i.isFunctionDeclaration()){r.push(i.get("id"));continue}if(i.isFunctionExpression())continue}if(o)for(let e=0;e<o.length;e++){const t=o[e],n=i.get(t);(Array.isArray(n)||n.node)&&(r=r.concat(n));}}}return n},t.getOuterBindingIdentifierPaths=function(e){return this.getBindingIdentifierPaths(e,!0)};var n=r("./node_modules/@babel/traverse/lib/path/index.js"),s=r("./node_modules/@babel/types/lib/index.js");function i(e,t,r){return e?t.concat(u(e,r)):t}function o(e){e.forEach((e=>{e.type=1;}));}function a(e,t){e.forEach((e=>{e.path.isBreakStatement({label:null})&&(t?e.path.replaceWith(s.unaryExpression("void",s.numericLiteral(0))):e.path.remove());}));}function l(e,t){let r=[];if(t.canHaveBreak){let n=[];for(let s=0;s<e.length;s++){const i=e[s],l=Object.assign({},t,{inCaseClause:!1});i.isBlockStatement()&&(t.inCaseClause||t.shouldPopulateBreak)?l.shouldPopulateBreak=!0:l.shouldPopulateBreak=!1;const c=u(i,l);if(c.length>0&&c.every((e=>1===e.type))){n.length>0&&c.every((e=>e.path.isBreakStatement({label:null})))?(o(n),r=r.concat(n),n.some((e=>e.path.isDeclaration()))&&(r=r.concat(c),a(c,!0)),a(c,!1)):(r=r.concat(c),t.shouldPopulateBreak||a(c,!0));break}s===e.length-1?r=r.concat(c):(r=r.concat(c.filter((e=>1===e.type))),n=c.filter((e=>0===e.type)));}}else e.length&&(r=r.concat(u(e[e.length-1],t)));return r}function u(e,t){let r=[];if(e.isIfStatement())r=i(e.get("consequent"),r,t),r=i(e.get("alternate"),r,t);else if(e.isDoExpression()||e.isFor()||e.isWhile()||e.isLabeledStatement())r=i(e.get("body"),r,t);else if(e.isProgram()||e.isBlockStatement())r=r.concat(l(e.get("body"),t));else {if(e.isFunction())return u(e.get("body"),t);e.isTryStatement()?(r=i(e.get("block"),r,t),r=i(e.get("handler"),r,t)):e.isCatchClause()?r=i(e.get("body"),r,t):e.isSwitchStatement()?r=function(e,t,r){let n=[];for(let s=0;s<e.length;s++){const i=u(e[s],r),o=[],a=[];for(const e of i)0===e.type&&o.push(e),1===e.type&&a.push(e);o.length&&(n=o),t=t.concat(a);}return t.concat(n)}(e.get("cases"),r,t):e.isSwitchCase()?r=r.concat(l(e.get("consequent"),{canHaveBreak:!0,shouldPopulateBreak:!1,inCaseClause:!0})):e.isBreakStatement()?r.push(function(e){return {type:1,path:e}}(e)):r.push(function(e){return {type:0,path:e}}(e));}return r}},"./node_modules/@babel/traverse/lib/path/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.SHOULD_SKIP=t.SHOULD_STOP=t.REMOVED=void 0;var n=r("./node_modules/@babel/traverse/lib/path/lib/virtual-types.js"),s=r("./node_modules/debug/src/index.js"),i=r("./node_modules/@babel/traverse/lib/index.js"),o=r("./node_modules/@babel/traverse/lib/scope/index.js"),a=r("./node_modules/@babel/types/lib/index.js"),l=r("./node_modules/@babel/traverse/lib/cache.js"),u=r("./node_modules/@babel/generator/lib/index.js"),c=r("./node_modules/@babel/traverse/lib/path/ancestry.js"),p=r("./node_modules/@babel/traverse/lib/path/inference/index.js"),d=r("./node_modules/@babel/traverse/lib/path/replacement.js"),f=r("./node_modules/@babel/traverse/lib/path/evaluation.js"),h=r("./node_modules/@babel/traverse/lib/path/conversion.js"),m=r("./node_modules/@babel/traverse/lib/path/introspection.js"),y=r("./node_modules/@babel/traverse/lib/path/context.js"),b=r("./node_modules/@babel/traverse/lib/path/removal.js"),g=r("./node_modules/@babel/traverse/lib/path/modification.js"),E=r("./node_modules/@babel/traverse/lib/path/family.js"),v=r("./node_modules/@babel/traverse/lib/path/comments.js");const x=s("babel");t.REMOVED=1,t.SHOULD_STOP=2,t.SHOULD_SKIP=4;class T{constructor(e,t){this.contexts=[],this.state=null,this.opts=null,this._traverseFlags=0,this.skipKeys=null,this.parentPath=null,this.container=null,this.listKey=null,this.key=null,this.node=null,this.type=null,this.parent=t,this.hub=e,this.data=null,this.context=null,this.scope=null;}static get({hub:e,parentPath:t,parent:r,container:n,listKey:s,key:i}){if(!e&&t&&(e=t.hub),!r)throw new Error("To get a node path the parent needs to exist");const o=n[i];let a=l.path.get(r);a||(a=new Map,l.path.set(r,a));let u=a.get(o);return u||(u=new T(e,r),o&&a.set(o,u)),u.setup(t,n,s,i),u}getScope(e){return this.isScope()?new o.default(this):e}setData(e,t){return null==this.data&&(this.data=Object.create(null)),this.data[e]=t}getData(e,t){null==this.data&&(this.data=Object.create(null));let r=this.data[e];return void 0===r&&void 0!==t&&(r=this.data[e]=t),r}buildCodeFrameError(e,t=SyntaxError){return this.hub.buildError(this.node,e,t)}traverse(e,t){(0, i.default)(this.node,e,this.scope,t,this);}set(e,t){a.validate(this.node,e,t),this.node[e]=t;}getPathLocation(){const e=[];let t=this;do{let r=t.key;t.inList&&(r=`${t.listKey}[${r}]`),e.unshift(r);}while(t=t.parentPath);return e.join(".")}debug(e){x.enabled&&x(`${this.getPathLocation()} ${this.type}: ${e}`);}toString(){return (0, u.default)(this.node).code}get inList(){return !!this.listKey}set inList(e){e||(this.listKey=null);}get parentKey(){return this.listKey||this.key}get shouldSkip(){return !!(4&this._traverseFlags)}set shouldSkip(e){e?this._traverseFlags|=4:this._traverseFlags&=-5;}get shouldStop(){return !!(2&this._traverseFlags)}set shouldStop(e){e?this._traverseFlags|=2:this._traverseFlags&=-3;}get removed(){return !!(1&this._traverseFlags)}set removed(e){e?this._traverseFlags|=1:this._traverseFlags&=-2;}}Object.assign(T.prototype,c,p,d,f,h,m,y,b,g,E,v);for(const e of a.TYPES){const t=`is${e}`,r=a[t];T.prototype[t]=function(e){return r(this.node,e)},T.prototype[`assert${e}`]=function(t){if(!r(this.node,t))throw new TypeError(`Expected node path of type ${e}`)};}for(const e of Object.keys(n)){if("_"===e[0])continue;a.TYPES.indexOf(e)<0&&a.TYPES.push(e);const t=n[e];T.prototype[`is${e}`]=function(e){return t.checkPath(this,e)};}var S=T;t.default=S;},"./node_modules/@babel/traverse/lib/path/inference/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getTypeAnnotation=function(){if(this.typeAnnotation)return this.typeAnnotation;let e=this._getTypeAnnotation()||s.anyTypeAnnotation();return s.isTypeAnnotation(e)&&(e=e.typeAnnotation),this.typeAnnotation=e},t._getTypeAnnotation=function(){const e=this.node;if(e){if(e.typeAnnotation)return e.typeAnnotation;if(!i.has(e)){i.add(e);try{var t;let r=n[e.type];if(r)return r.call(this,e);if(r=n[this.parentPath.type],null!=(t=r)&&t.validParent)return this.parentPath.getTypeAnnotation()}finally{i.delete(e);}}}else if("init"===this.key&&this.parentPath.isVariableDeclarator()){const e=this.parentPath.parentPath,t=e.parentPath;return "left"===e.key&&t.isForInStatement()?s.stringTypeAnnotation():"left"===e.key&&t.isForOfStatement()?s.anyTypeAnnotation():s.voidTypeAnnotation()}},t.isBaseType=function(e,t){return o(e,this.getTypeAnnotation(),t)},t.couldBeBaseType=function(e){const t=this.getTypeAnnotation();if(s.isAnyTypeAnnotation(t))return !0;if(s.isUnionTypeAnnotation(t)){for(const r of t.types)if(s.isAnyTypeAnnotation(r)||o(e,r,!0))return !0;return !1}return o(e,t,!0)},t.baseTypeStrictlyMatches=function(e){const t=this.getTypeAnnotation(),r=e.getTypeAnnotation();return !(s.isAnyTypeAnnotation(t)||!s.isFlowBaseAnnotation(t))&&r.type===t.type},t.isGenericType=function(e){const t=this.getTypeAnnotation();return s.isGenericTypeAnnotation(t)&&s.isIdentifier(t.id,{name:e})};var n=r("./node_modules/@babel/traverse/lib/path/inference/inferers.js"),s=r("./node_modules/@babel/types/lib/index.js");const i=new WeakSet;function o(e,t,r){if("string"===e)return s.isStringTypeAnnotation(t);if("number"===e)return s.isNumberTypeAnnotation(t);if("boolean"===e)return s.isBooleanTypeAnnotation(t);if("any"===e)return s.isAnyTypeAnnotation(t);if("mixed"===e)return s.isMixedTypeAnnotation(t);if("empty"===e)return s.isEmptyTypeAnnotation(t);if("void"===e)return s.isVoidTypeAnnotation(t);if(r)return !1;throw new Error(`Unknown base type ${e}`)}},"./node_modules/@babel/traverse/lib/path/inference/inferer-reference.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){if(!this.isReferenced())return;const t=this.scope.getBinding(e.name);return t?t.identifier.typeAnnotation?t.identifier.typeAnnotation:function(e,t,r){const i=[],a=[];let l=s(e,t,a);const u=o(e,t,r);if(u){const t=s(e,u.ifStatement);l=l.filter((e=>t.indexOf(e)<0)),i.push(u.typeAnnotation);}if(l.length){l=l.concat(a);for(const e of l)i.push(e.getTypeAnnotation());}if(i.length)return n.isTSTypeAnnotation(i[0])&&n.createTSUnionType?n.createTSUnionType(i):n.createFlowUnionType?n.createFlowUnionType(i):n.createUnionTypeAnnotation(i)}(t,this,e.name):"undefined"===e.name?n.voidTypeAnnotation():"NaN"===e.name||"Infinity"===e.name?n.numberTypeAnnotation():void e.name};var n=r("./node_modules/@babel/types/lib/index.js");function s(e,t,r){const n=e.constantViolations.slice();return n.unshift(e.path),n.filter((e=>{const n=(e=e.resolve())._guessExecutionStatusRelativeTo(t);return r&&"unknown"===n&&r.push(e),"before"===n}))}function i(e,t){const r=t.node.operator,s=t.get("right").resolve(),i=t.get("left").resolve();let o,a,l;if(i.isIdentifier({name:e})?o=s:s.isIdentifier({name:e})&&(o=i),o)return "==="===r?o.getTypeAnnotation():n.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(r)>=0?n.numberTypeAnnotation():void 0;if("==="!==r&&"=="!==r)return;if(i.isUnaryExpression({operator:"typeof"})?(a=i,l=s):s.isUnaryExpression({operator:"typeof"})&&(a=s,l=i),!a)return;if(!a.get("argument").isIdentifier({name:e}))return;if(l=l.resolve(),!l.isLiteral())return;const u=l.node.value;return "string"==typeof u?n.createTypeAnnotationBasedOnTypeof(u):void 0}function o(e,t,r){const s=function(e,t,r){let n;for(;n=t.parentPath;){if(n.isIfStatement()||n.isConditionalExpression()){if("test"===t.key)return;return n}if(n.isFunction()&&n.parentPath.scope.getBinding(r)!==e)return;t=n;}}(e,t,r);if(!s)return;const a=[s.get("test")],l=[];for(let e=0;e<a.length;e++){const t=a[e];if(t.isLogicalExpression())"&&"===t.node.operator&&(a.push(t.get("left")),a.push(t.get("right")));else if(t.isBinaryExpression()){const e=i(r,t);e&&l.push(e);}}return l.length?n.isTSTypeAnnotation(l[0])&&n.createTSUnionType?{typeAnnotation:n.createTSUnionType(l),ifStatement:s}:n.createFlowUnionType?{typeAnnotation:n.createFlowUnionType(l),ifStatement:s}:{typeAnnotation:n.createUnionTypeAnnotation(l),ifStatement:s}:o(s,r)}},"./node_modules/@babel/traverse/lib/path/inference/inferers.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.VariableDeclarator=function(){var e;if(!this.get("id").isIdentifier())return;const t=this.get("init");let r=t.getTypeAnnotation();return "AnyTypeAnnotation"===(null==(e=r)?void 0:e.type)&&t.isCallExpression()&&t.get("callee").isIdentifier({name:"Array"})&&!t.scope.hasBinding("Array",!0)&&(r=o()),r},t.TypeCastExpression=i,t.NewExpression=function(e){if(this.get("callee").isIdentifier())return n.genericTypeAnnotation(e.callee)},t.TemplateLiteral=function(){return n.stringTypeAnnotation()},t.UnaryExpression=function(e){const t=e.operator;return "void"===t?n.voidTypeAnnotation():n.NUMBER_UNARY_OPERATORS.indexOf(t)>=0?n.numberTypeAnnotation():n.STRING_UNARY_OPERATORS.indexOf(t)>=0?n.stringTypeAnnotation():n.BOOLEAN_UNARY_OPERATORS.indexOf(t)>=0?n.booleanTypeAnnotation():void 0},t.BinaryExpression=function(e){const t=e.operator;if(n.NUMBER_BINARY_OPERATORS.indexOf(t)>=0)return n.numberTypeAnnotation();if(n.BOOLEAN_BINARY_OPERATORS.indexOf(t)>=0)return n.booleanTypeAnnotation();if("+"===t){const e=this.get("right"),t=this.get("left");return t.isBaseType("number")&&e.isBaseType("number")?n.numberTypeAnnotation():t.isBaseType("string")||e.isBaseType("string")?n.stringTypeAnnotation():n.unionTypeAnnotation([n.stringTypeAnnotation(),n.numberTypeAnnotation()])}},t.LogicalExpression=function(){const e=[this.get("left").getTypeAnnotation(),this.get("right").getTypeAnnotation()];return n.isTSTypeAnnotation(e[0])&&n.createTSUnionType?n.createTSUnionType(e):n.createFlowUnionType?n.createFlowUnionType(e):n.createUnionTypeAnnotation(e)},t.ConditionalExpression=function(){const e=[this.get("consequent").getTypeAnnotation(),this.get("alternate").getTypeAnnotation()];return n.isTSTypeAnnotation(e[0])&&n.createTSUnionType?n.createTSUnionType(e):n.createFlowUnionType?n.createFlowUnionType(e):n.createUnionTypeAnnotation(e)},t.SequenceExpression=function(){return this.get("expressions").pop().getTypeAnnotation()},t.ParenthesizedExpression=function(){return this.get("expression").getTypeAnnotation()},t.AssignmentExpression=function(){return this.get("right").getTypeAnnotation()},t.UpdateExpression=function(e){const t=e.operator;if("++"===t||"--"===t)return n.numberTypeAnnotation()},t.StringLiteral=function(){return n.stringTypeAnnotation()},t.NumericLiteral=function(){return n.numberTypeAnnotation()},t.BooleanLiteral=function(){return n.booleanTypeAnnotation()},t.NullLiteral=function(){return n.nullLiteralTypeAnnotation()},t.RegExpLiteral=function(){return n.genericTypeAnnotation(n.identifier("RegExp"))},t.ObjectExpression=function(){return n.genericTypeAnnotation(n.identifier("Object"))},t.ArrayExpression=o,t.RestElement=a,t.ClassDeclaration=t.ClassExpression=t.FunctionDeclaration=t.ArrowFunctionExpression=t.FunctionExpression=function(){return n.genericTypeAnnotation(n.identifier("Function"))},t.CallExpression=function(){const{callee:e}=this.node;return u(e)?n.arrayTypeAnnotation(n.stringTypeAnnotation()):l(e)||c(e)?n.arrayTypeAnnotation(n.anyTypeAnnotation()):p(e)?n.arrayTypeAnnotation(n.tupleTypeAnnotation([n.stringTypeAnnotation(),n.anyTypeAnnotation()])):d(this.get("callee"))},t.TaggedTemplateExpression=function(){return d(this.get("tag"))},Object.defineProperty(t,"Identifier",{enumerable:!0,get:function(){return s.default}});var n=r("./node_modules/@babel/types/lib/index.js"),s=r("./node_modules/@babel/traverse/lib/path/inference/inferer-reference.js");function i(e){return e.typeAnnotation}function o(){return n.genericTypeAnnotation(n.identifier("Array"))}function a(){return o()}i.validParent=!0,a.validParent=!0;const l=n.buildMatchMemberExpression("Array.from"),u=n.buildMatchMemberExpression("Object.keys"),c=n.buildMatchMemberExpression("Object.values"),p=n.buildMatchMemberExpression("Object.entries");function d(e){if((e=e.resolve()).isFunction()){if(e.is("async"))return e.is("generator")?n.genericTypeAnnotation(n.identifier("AsyncIterator")):n.genericTypeAnnotation(n.identifier("Promise"));if(e.node.returnType)return e.node.returnType}}},"./node_modules/@babel/traverse/lib/path/introspection.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.matchesPattern=function(e,t){return n.matchesPattern(this.node,e,t)},t.has=s,t.isStatic=function(){return this.scope.isStatic(this.node)},t.isnt=function(e){return !this.has(e)},t.equals=function(e,t){return this.node[e]===t},t.isNodeType=function(e){return n.isType(this.type,e)},t.canHaveVariableDeclarationOrExpression=function(){return ("init"===this.key||"left"===this.key)&&this.parentPath.isFor()},t.canSwapBetweenExpressionAndStatement=function(e){return !("body"!==this.key||!this.parentPath.isArrowFunctionExpression())&&(this.isExpression()?n.isBlockStatement(e):!!this.isBlockStatement()&&n.isExpression(e))},t.isCompletionRecord=function(e){let t=this,r=!0;do{const n=t.container;if(t.isFunction()&&!r)return !!e;if(r=!1,Array.isArray(n)&&t.key!==n.length-1)return !1}while((t=t.parentPath)&&!t.isProgram());return !0},t.isStatementOrBlock=function(){return !this.parentPath.isLabeledStatement()&&!n.isBlockStatement(this.container)&&n.STATEMENT_OR_BLOCK_KEYS.includes(this.key)},t.referencesImport=function(e,t){if(!this.isReferencedIdentifier()){if((this.isMemberExpression()||this.isOptionalMemberExpression())&&(this.node.computed?n.isStringLiteral(this.node.property,{value:t}):this.node.property.name===t)){const t=this.get("object");return t.isReferencedIdentifier()&&t.referencesImport(e,"*")}return !1}const r=this.scope.getBinding(this.node.name);if(!r||"module"!==r.kind)return !1;const s=r.path,i=s.parentPath;return !!i.isImportDeclaration()&&(i.node.source.value===e&&(!t||(!(!s.isImportDefaultSpecifier()||"default"!==t)||(!(!s.isImportNamespaceSpecifier()||"*"!==t)||!(!s.isImportSpecifier()||!n.isIdentifier(s.node.imported,{name:t}))))))},t.getSource=function(){const e=this.node;if(e.end){const t=this.hub.getCode();if(t)return t.slice(e.start,e.end)}return ""},t.willIMaybeExecuteBefore=function(e){return "after"!==this._guessExecutionStatusRelativeTo(e)},t._guessExecutionStatusRelativeTo=function(e){const t={this:o(this),target:o(e)};if(t.target.node!==t.this.node)return this._guessExecutionStatusRelativeToDifferentFunctions(t.target);const r={target:e.getAncestry(),this:this.getAncestry()};if(r.target.indexOf(this)>=0)return "after";if(r.this.indexOf(e)>=0)return "before";let s;const i={target:0,this:0};for(;!s&&i.this<r.this.length;){const e=r.this[i.this];i.target=r.target.indexOf(e),i.target>=0?s=e:i.this++;}if(!s)throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");if(l(r.this,i.this-1)||l(r.target,i.target-1))return "unknown";const a={this:r.this[i.this-1],target:r.target[i.target-1]};if(a.target.listKey&&a.this.listKey&&a.target.container===a.this.container)return a.target.key>a.this.key?"before":"after";const u=n.VISITOR_KEYS[s.type],c=u.indexOf(a.this.parentKey);return u.indexOf(a.target.parentKey)>c?"before":"after"},t._guessExecutionStatusRelativeToDifferentFunctions=function(e){if(!e.isFunctionDeclaration()||e.parentPath.isExportDeclaration())return "unknown";const t=e.scope.getBinding(e.node.id.name);if(!t.references)return "before";const r=t.referencePaths;let n;for(const t of r){if(t.find((t=>t.node===e.node)))continue;if("callee"!==t.key||!t.parentPath.isCallExpression())return "unknown";if(u.has(t.node))continue;u.add(t.node);const r=this._guessExecutionStatusRelativeTo(t);if(u.delete(t.node),n&&n!==r)return "unknown";n=r;}return n},t.resolve=function(e,t){return this._resolve(e,t)||this},t._resolve=function(e,t){if(!(t&&t.indexOf(this)>=0))if((t=t||[]).push(this),this.isVariableDeclarator()){if(this.get("id").isIdentifier())return this.get("init").resolve(e,t)}else if(this.isReferencedIdentifier()){const r=this.scope.getBinding(this.node.name);if(!r)return;if(!r.constant)return;if("module"===r.kind)return;if(r.path!==this){const n=r.path.resolve(e,t);if(this.find((e=>e.node===n.node)))return;return n}}else {if(this.isTypeCastExpression())return this.get("expression").resolve(e,t);if(e&&this.isMemberExpression()){const r=this.toComputedKey();if(!n.isLiteral(r))return;const s=r.value,i=this.get("object").resolve(e,t);if(i.isObjectExpression()){const r=i.get("properties");for(const n of r){if(!n.isProperty())continue;const r=n.get("key");let i=n.isnt("computed")&&r.isIdentifier({name:s});if(i=i||r.isLiteral({value:s}),i)return n.get("value").resolve(e,t)}}else if(i.isArrayExpression()&&!isNaN(+s)){const r=i.get("elements")[s];if(r)return r.resolve(e,t)}}}},t.isConstantExpression=function(){if(this.isIdentifier()){const e=this.scope.getBinding(this.node.name);return !!e&&e.constant}return this.isLiteral()?!this.isRegExpLiteral()&&(!this.isTemplateLiteral()||this.get("expressions").every((e=>e.isConstantExpression()))):this.isUnaryExpression()?"void"===this.node.operator&&this.get("argument").isConstantExpression():!!this.isBinaryExpression()&&(this.get("left").isConstantExpression()&&this.get("right").isConstantExpression())},t.isInStrictMode=function(){return !!(this.isProgram()?this:this.parentPath).find((e=>{if(e.isProgram({sourceType:"module"}))return !0;if(e.isClass())return !0;if(!e.isProgram()&&!e.isFunction())return !1;if(e.isArrowFunctionExpression()&&!e.get("body").isBlockStatement())return !1;const t=e.isFunction()?e.node.body:e.node;for(const e of t.directives)if("use strict"===e.value.value)return !0}))},t.is=void 0;var n=r("./node_modules/@babel/types/lib/index.js");function s(e){const t=this.node&&this.node[e];return t&&Array.isArray(t)?!!t.length:!!t}const i=s;function o(e){return (e.scope.getFunctionParent()||e.scope.getProgramParent()).path}function a(e,t){switch(e){case"LogicalExpression":return "right"===t;case"ConditionalExpression":case"IfStatement":return "consequent"===t||"alternate"===t;case"WhileStatement":case"DoWhileStatement":case"ForInStatement":case"ForOfStatement":return "body"===t;case"ForStatement":return "body"===t||"update"===t;case"SwitchStatement":return "cases"===t;case"TryStatement":return "handler"===t;case"AssignmentPattern":return "right"===t;case"OptionalMemberExpression":return "property"===t;case"OptionalCallExpression":return "arguments"===t;default:return !1}}function l(e,t){for(let r=0;r<t;r++){const t=e[r];if(a(t.parent.type,t.parentKey))return !0}return !1}t.is=i;const u=new WeakSet;},"./node_modules/@babel/traverse/lib/path/lib/hoister.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/types/lib/index.js");const s={ReferencedIdentifier(e,t){if(e.isJSXIdentifier()&&n.react.isCompatTag(e.node.name)&&!e.parentPath.isJSXMemberExpression())return;if("this"===e.node.name){let r=e.scope;do{if(r.path.isFunction()&&!r.path.isArrowFunctionExpression())break}while(r=r.parent);r&&t.breakOnScopePaths.push(r.path);}const r=e.scope.getBinding(e.node.name);if(r){for(const n of r.constantViolations)if(n.scope!==r.path.scope)return t.mutableBinding=!0,void e.stop();r===t.scope.getBinding(e.node.name)&&(t.bindings[e.node.name]=r);}}};t.default=class{constructor(e,t){this.breakOnScopePaths=void 0,this.bindings=void 0,this.mutableBinding=void 0,this.scopes=void 0,this.scope=void 0,this.path=void 0,this.attachAfter=void 0,this.breakOnScopePaths=[],this.bindings={},this.mutableBinding=!1,this.scopes=[],this.scope=t,this.path=e,this.attachAfter=!1;}isCompatibleScope(e){for(const t of Object.keys(this.bindings)){const r=this.bindings[t];if(!e.bindingIdentifierEquals(t,r.identifier))return !1}return !0}getCompatibleScopes(){let e=this.path.scope;do{if(!this.isCompatibleScope(e))break;if(this.scopes.push(e),this.breakOnScopePaths.indexOf(e.path)>=0)break}while(e=e.parent)}getAttachmentPath(){let e=this._getAttachmentPath();if(!e)return;let t=e.scope;if(t.path===e&&(t=e.scope.parent),t.path.isProgram()||t.path.isFunction())for(const r of Object.keys(this.bindings)){if(!t.hasOwnBinding(r))continue;const n=this.bindings[r];if("param"!==n.kind&&"params"!==n.path.parentKey&&this.getAttachmentParentForPath(n.path).key>=e.key){this.attachAfter=!0,e=n.path;for(const t of n.constantViolations)this.getAttachmentParentForPath(t).key>e.key&&(e=t);}}return e}_getAttachmentPath(){const e=this.scopes.pop();if(e)if(e.path.isFunction()){if(!this.hasOwnParamBindings(e))return this.getNextScopeAttachmentParent();{if(this.scope===e)return;const t=e.path.get("body").get("body");for(let e=0;e<t.length;e++)if(!t[e].node._blockHoist)return t[e]}}else if(e.path.isProgram())return this.getNextScopeAttachmentParent()}getNextScopeAttachmentParent(){const e=this.scopes.pop();if(e)return this.getAttachmentParentForPath(e.path)}getAttachmentParentForPath(e){do{if(!e.parentPath||Array.isArray(e.container)&&e.isStatement())return e}while(e=e.parentPath)}hasOwnParamBindings(e){for(const t of Object.keys(this.bindings)){if(!e.hasOwnBinding(t))continue;const r=this.bindings[t];if("param"===r.kind&&r.constant)return !0}return !1}run(){if(this.path.traverse(s,this),this.mutableBinding)return;this.getCompatibleScopes();const e=this.getAttachmentPath();if(!e)return;if(e.getFunctionParent()===this.path.getFunctionParent())return;let t=e.scope.generateUidIdentifier("ref");const r=n.variableDeclarator(t,this.path.node),i=this.attachAfter?"insertAfter":"insertBefore",[o]=e[i]([e.isVariableDeclarator()?r:n.variableDeclaration("var",[r])]),a=this.path.parentPath;return a.isJSXElement()&&this.path.container===a.node.children&&(t=n.jsxExpressionContainer(t)),this.path.replaceWith(n.cloneNode(t)),e.isVariableDeclarator()?o.get("init"):o.get("declarations.0.init")}};},"./node_modules/@babel/traverse/lib/path/lib/removal-hooks.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.hooks=void 0,t.hooks=[function(e,t){if("test"===e.key&&(t.isWhile()||t.isSwitchCase())||"declaration"===e.key&&t.isExportDeclaration()||"body"===e.key&&t.isLabeledStatement()||"declarations"===e.listKey&&t.isVariableDeclaration()&&1===t.node.declarations.length||"expression"===e.key&&t.isExpressionStatement())return t.remove(),!0},function(e,t){if(t.isSequenceExpression()&&1===t.node.expressions.length)return t.replaceWith(t.node.expressions[0]),!0},function(e,t){if(t.isBinary())return "left"===e.key?t.replaceWith(t.node.right):t.replaceWith(t.node.left),!0},function(e,t){if(t.isIfStatement()&&("consequent"===e.key||"alternate"===e.key)||"body"===e.key&&(t.isLoop()||t.isArrowFunctionExpression()))return e.replaceWith({type:"BlockStatement",body:[]}),!0}];},"./node_modules/@babel/traverse/lib/path/lib/virtual-types.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ForAwaitStatement=t.NumericLiteralTypeAnnotation=t.ExistentialTypeParam=t.SpreadProperty=t.RestProperty=t.Flow=t.Pure=t.Generated=t.User=t.Var=t.BlockScoped=t.Referenced=t.Scope=t.Expression=t.Statement=t.BindingIdentifier=t.ReferencedMemberExpression=t.ReferencedIdentifier=void 0;var n=r("./node_modules/@babel/types/lib/index.js");const s={types:["Identifier","JSXIdentifier"],checkPath(e,t){const{node:r,parent:s}=e;if(!n.isIdentifier(r,t)&&!n.isJSXMemberExpression(s,t)){if(!n.isJSXIdentifier(r,t))return !1;if(n.react.isCompatTag(r.name))return !1}return n.isReferenced(r,s,e.parentPath.parent)}};t.ReferencedIdentifier=s;const i={types:["MemberExpression"],checkPath:({node:e,parent:t})=>n.isMemberExpression(e)&&n.isReferenced(e,t)};t.ReferencedMemberExpression=i;const o={types:["Identifier"],checkPath(e){const{node:t,parent:r}=e,s=e.parentPath.parent;return n.isIdentifier(t)&&n.isBinding(t,r,s)}};t.BindingIdentifier=o;const a={types:["Statement"],checkPath({node:e,parent:t}){if(n.isStatement(e)){if(n.isVariableDeclaration(e)){if(n.isForXStatement(t,{left:e}))return !1;if(n.isForStatement(t,{init:e}))return !1}return !0}return !1}};t.Statement=a;const l={types:["Expression"],checkPath:e=>e.isIdentifier()?e.isReferencedIdentifier():n.isExpression(e.node)};t.Expression=l;const u={types:["Scopable","Pattern"],checkPath:e=>n.isScope(e.node,e.parent)};t.Scope=u;const c={checkPath:e=>n.isReferenced(e.node,e.parent)};t.Referenced=c;const p={checkPath:e=>n.isBlockScoped(e.node)};t.BlockScoped=p;const d={types:["VariableDeclaration"],checkPath:e=>n.isVar(e.node)};t.Var=d;t.User={checkPath:e=>e.node&&!!e.node.loc};t.Generated={checkPath:e=>!e.isUser()};t.Pure={checkPath:(e,t)=>e.scope.isPure(e.node,t)};const f={types:["Flow","ImportDeclaration","ExportDeclaration","ImportSpecifier"],checkPath:({node:e})=>!(!n.isFlow(e)&&(n.isImportDeclaration(e)?"type"!==e.importKind&&"typeof"!==e.importKind:n.isExportDeclaration(e)?"type"!==e.exportKind:!n.isImportSpecifier(e)||"type"!==e.importKind&&"typeof"!==e.importKind))};t.Flow=f;t.RestProperty={types:["RestElement"],checkPath:e=>e.parentPath&&e.parentPath.isObjectPattern()};t.SpreadProperty={types:["RestElement"],checkPath:e=>e.parentPath&&e.parentPath.isObjectExpression()},t.ExistentialTypeParam={types:["ExistsTypeAnnotation"]},t.NumericLiteralTypeAnnotation={types:["NumberLiteralTypeAnnotation"]};t.ForAwaitStatement={types:["ForOfStatement"],checkPath:({node:e})=>!0===e.await};},"./node_modules/@babel/traverse/lib/path/modification.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.insertBefore=function(e){this._assertUnremoved();const t=this._verifyNodeList(e),{parentPath:r}=this;if(r.isExpressionStatement()||r.isLabeledStatement()||r.isExportNamedDeclaration()||r.isExportDefaultDeclaration()&&this.isDeclaration())return r.insertBefore(t);if(this.isNodeType("Expression")&&!this.isJSXElement()||r.isForStatement()&&"init"===this.key)return this.node&&t.push(this.node),this.replaceExpressionWithStatements(t);if(Array.isArray(this.container))return this._containerInsertBefore(t);if(this.isStatementOrBlock()){const e=this.node,r=e&&(!this.isExpressionStatement()||null!=e.expression);return this.replaceWith(o.blockStatement(r?[e]:[])),this.unshiftContainer("body",t)}throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?")},t._containerInsert=function(e,t){this.updateSiblingKeys(e,t.length);const r=[];this.container.splice(e,0,...t);for(let n=0;n<t.length;n++){const t=e+n,s=this.getSibling(t);r.push(s),this.context&&this.context.queue&&s.pushContext(this.context);}const n=this._getQueueContexts();for(const e of r){e.setScope(),e.debug("Inserted.");for(const t of n)t.maybeQueue(e,!0);}return r},t._containerInsertBefore=function(e){return this._containerInsert(this.key,e)},t._containerInsertAfter=function(e){return this._containerInsert(this.key+1,e)},t.insertAfter=function(e){this._assertUnremoved();const t=this._verifyNodeList(e),{parentPath:r}=this;if(r.isExpressionStatement()||r.isLabeledStatement()||r.isExportNamedDeclaration()||r.isExportDefaultDeclaration()&&this.isDeclaration())return r.insertAfter(t.map((e=>o.isExpression(e)?o.expressionStatement(e):e)));if(this.isNodeType("Expression")&&!this.isJSXElement()&&!r.isJSXElement()||r.isForStatement()&&"init"===this.key){if(this.node){const e=this.node;let{scope:n}=this;if(n.path.isPattern())return o.assertExpression(e),this.replaceWith(o.callExpression(o.arrowFunctionExpression([],e),[])),this.get("callee.body").insertAfter(t),[this];r.isMethod({computed:!0,key:e})&&(n=n.parent);const s=n.generateDeclaredUidIdentifier();t.unshift(o.expressionStatement(o.assignmentExpression("=",o.cloneNode(s),e))),t.push(o.expressionStatement(o.cloneNode(s)));}return this.replaceExpressionWithStatements(t)}if(Array.isArray(this.container))return this._containerInsertAfter(t);if(this.isStatementOrBlock()){const e=this.node,r=e&&(!this.isExpressionStatement()||null!=e.expression);return this.replaceWith(o.blockStatement(r?[e]:[])),this.pushContainer("body",t)}throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?")},t.updateSiblingKeys=function(e,t){if(!this.parent)return;const r=n.path.get(this.parent);for(const[,n]of r)n.key>=e&&(n.key+=t);},t._verifyNodeList=function(e){if(!e)return [];Array.isArray(e)||(e=[e]);for(let t=0;t<e.length;t++){const r=e[t];let n;if(r?"object"!=typeof r?n="contains a non-object node":r.type?r instanceof i.default&&(n="has a NodePath when it expected a raw object"):n="without a type":n="has falsy node",n){const e=Array.isArray(r)?"array":typeof r;throw new Error(`Node list ${n} with the index of ${t} and type of ${e}`)}}return e},t.unshiftContainer=function(e,t){return this._assertUnremoved(),t=this._verifyNodeList(t),i.default.get({parentPath:this,parent:this.node,container:this.node[e],listKey:e,key:0}).setContext(this.context)._containerInsertBefore(t)},t.pushContainer=function(e,t){this._assertUnremoved();const r=this._verifyNodeList(t),n=this.node[e];return i.default.get({parentPath:this,parent:this.node,container:n,listKey:e,key:n.length}).setContext(this.context).replaceWithMultiple(r)},t.hoist=function(e=this.scope){return new s.default(this,e).run()};var n=r("./node_modules/@babel/traverse/lib/cache.js"),s=r("./node_modules/@babel/traverse/lib/path/lib/hoister.js"),i=r("./node_modules/@babel/traverse/lib/path/index.js"),o=r("./node_modules/@babel/types/lib/index.js");},"./node_modules/@babel/traverse/lib/path/removal.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.remove=function(){var e;this._assertUnremoved(),this.resync(),null!=(e=this.opts)&&e.noScope||this._removeFromScope(),this._callRemovalHooks()||(this.shareCommentsWithSiblings(),this._remove()),this._markRemoved();},t._removeFromScope=function(){const e=this.getBindingIdentifiers();Object.keys(e).forEach((e=>this.scope.removeBinding(e)));},t._callRemovalHooks=function(){for(const e of n.hooks)if(e(this,this.parentPath))return !0},t._remove=function(){Array.isArray(this.container)?(this.container.splice(this.key,1),this.updateSiblingKeys(this.key,-1)):this._replaceWith(null);},t._markRemoved=function(){this._traverseFlags|=i.SHOULD_SKIP|i.REMOVED,this.parent&&s.path.get(this.parent).delete(this.node),this.node=null;},t._assertUnremoved=function(){if(this.removed)throw this.buildCodeFrameError("NodePath has been removed so is read-only.")};var n=r("./node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"),s=r("./node_modules/@babel/traverse/lib/cache.js"),i=r("./node_modules/@babel/traverse/lib/path/index.js");},"./node_modules/@babel/traverse/lib/path/replacement.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.replaceWithMultiple=function(e){var t;this.resync(),e=this._verifyNodeList(e),l.inheritLeadingComments(e[0],this.node),l.inheritTrailingComments(e[e.length-1],this.node),null==(t=o.path.get(this.parent))||t.delete(this.node),this.node=this.container[this.key]=null;const r=this.insertAfter(e);return this.node?this.requeue():this.remove(),r},t.replaceWithSourceString=function(e){this.resync();try{e=`(${e})`,e=(0,a.parse)(e);}catch(t){const r=t.loc;throw r&&(t.message+=" - make sure this is an expression.\n"+(0, n.codeFrameColumns)(e,{start:{line:r.line,column:r.column+1}}),t.code="BABEL_REPLACE_SOURCE_ERROR"),t}return e=e.program.body[0].expression,s.default.removeProperties(e),this.replaceWith(e)},t.replaceWith=function(e){if(this.resync(),this.removed)throw new Error("You can't replace this node, we've already removed it");if(e instanceof i.default&&(e=e.node),!e)throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");if(this.node===e)return [this];if(this.isProgram()&&!l.isProgram(e))throw new Error("You can only replace a Program root node with another Program node");if(Array.isArray(e))throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");if("string"==typeof e)throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");let t="";if(this.isNodeType("Statement")&&l.isExpression(e)&&(this.canHaveVariableDeclarationOrExpression()||this.canSwapBetweenExpressionAndStatement(e)||this.parentPath.isExportDefaultDeclaration()||(e=l.expressionStatement(e),t="expression")),this.isNodeType("Expression")&&l.isStatement(e)&&!this.canHaveVariableDeclarationOrExpression()&&!this.canSwapBetweenExpressionAndStatement(e))return this.replaceExpressionWithStatements([e]);const r=this.node;return r&&(l.inheritsComments(e,r),l.removeComments(r)),this._replaceWith(e),this.type=e.type,this.setScope(),this.requeue(),[t?this.get(t):this]},t._replaceWith=function(e){var t;if(!this.container)throw new ReferenceError("Container is falsy");this.inList?l.validate(this.parent,this.key,[e]):l.validate(this.parent,this.key,e),this.debug(`Replace with ${null==e?void 0:e.type}`),null==(t=o.path.get(this.parent))||t.set(e,this).delete(this.node),this.node=this.container[this.key]=e;},t.replaceExpressionWithStatements=function(e){this.resync();const t=l.toSequenceExpression(e,this.scope);if(t)return this.replaceWith(t)[0].get("expressions");const r=this.getFunctionParent(),n=null==r?void 0:r.is("async"),i=null==r?void 0:r.is("generator"),o=l.arrowFunctionExpression([],l.blockStatement(e));this.replaceWith(l.callExpression(o,[])),this.traverse(u);const a=this.get("callee").getCompletionRecords();for(const e of a){if(!e.isExpressionStatement())continue;const t=e.findParent((e=>e.isLoop()));if(t){let r=t.getData("expressionReplacementReturnUid");if(r)r=l.identifier(r.name);else {const e=this.get("callee");r=e.scope.generateDeclaredUidIdentifier("ret"),e.get("body").pushContainer("body",l.returnStatement(l.cloneNode(r))),t.setData("expressionReplacementReturnUid",r);}e.get("expression").replaceWith(l.assignmentExpression("=",l.cloneNode(r),e.node.expression));}else e.replaceWith(l.returnStatement(e.node.expression));}const c=this.get("callee");c.arrowFunctionToExpression();const p=n&&s.default.hasType(this.get("callee.body").node,"AwaitExpression",l.FUNCTION_TYPES),d=i&&s.default.hasType(this.get("callee.body").node,"YieldExpression",l.FUNCTION_TYPES);return p&&(c.set("async",!0),d||this.replaceWith(l.awaitExpression(this.node))),d&&(c.set("generator",!0),this.replaceWith(l.yieldExpression(this.node,!0))),c.get("body.body")},t.replaceInline=function(e){if(this.resync(),Array.isArray(e)){if(Array.isArray(this.container)){e=this._verifyNodeList(e);const t=this._containerInsertAfter(e);return this.remove(),t}return this.replaceWithMultiple(e)}return this.replaceWith(e)};var n=r("./stubs/babel_codeframe.js"),s=r("./node_modules/@babel/traverse/lib/index.js"),i=r("./node_modules/@babel/traverse/lib/path/index.js"),o=r("./node_modules/@babel/traverse/lib/cache.js"),a=r("./node_modules/@babel/parser/lib/index.js"),l=r("./node_modules/@babel/types/lib/index.js");const u={Function(e){e.skip();},VariableDeclaration(e){if("var"!==e.node.kind)return;const t=e.getBindingIdentifiers();for(const r of Object.keys(t))e.scope.push({id:t[r]});const r=[];for(const t of e.node.declarations)t.init&&r.push(l.expressionStatement(l.assignmentExpression("=",t.id,t.init)));e.replaceWithMultiple(r);}};},"./node_modules/@babel/traverse/lib/scope/binding.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,t.default=class{constructor({identifier:e,scope:t,path:r,kind:n}){this.identifier=void 0,this.scope=void 0,this.path=void 0,this.kind=void 0,this.constantViolations=[],this.constant=!0,this.referencePaths=[],this.referenced=!1,this.references=0,this.identifier=e,this.scope=t,this.path=r,this.kind=n,this.clearValue();}deoptValue(){this.clearValue(),this.hasDeoptedValue=!0;}setValue(e){this.hasDeoptedValue||(this.hasValue=!0,this.value=e);}clearValue(){this.hasDeoptedValue=!1,this.hasValue=!1,this.value=null;}reassign(e){this.constant=!1,-1===this.constantViolations.indexOf(e)&&this.constantViolations.push(e);}reference(e){-1===this.referencePaths.indexOf(e)&&(this.referenced=!0,this.references++,this.referencePaths.push(e));}dereference(){this.references--,this.referenced=!!this.references;}};},"./node_modules/@babel/traverse/lib/scope/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/traverse/lib/scope/lib/renamer.js"),s=r("./node_modules/@babel/traverse/lib/index.js"),i=r("./node_modules/@babel/traverse/lib/scope/binding.js"),o=r("./node_modules/@babel/traverse/node_modules/globals/index.js"),a=r("./node_modules/@babel/types/lib/index.js"),l=r("./node_modules/@babel/traverse/lib/cache.js");function u(e,t){switch(null==e?void 0:e.type){default:if(a.isModuleDeclaration(e))if((a.isExportAllDeclaration(e)||a.isExportNamedDeclaration(e)||a.isImportDeclaration(e))&&e.source)u(e.source,t);else if((a.isExportNamedDeclaration(e)||a.isImportDeclaration(e))&&e.specifiers&&e.specifiers.length)for(const r of e.specifiers)u(r,t);else (a.isExportDefaultDeclaration(e)||a.isExportNamedDeclaration(e))&&e.declaration&&u(e.declaration,t);else a.isModuleSpecifier(e)?u(e.local,t):a.isLiteral(e)&&t.push(e.value);break;case"MemberExpression":case"OptionalMemberExpression":case"JSXMemberExpression":u(e.object,t),u(e.property,t);break;case"Identifier":case"JSXIdentifier":t.push(e.name);break;case"CallExpression":case"OptionalCallExpression":case"NewExpression":u(e.callee,t);break;case"ObjectExpression":case"ObjectPattern":for(const r of e.properties)u(r,t);break;case"SpreadElement":case"RestElement":u(e.argument,t);break;case"ObjectProperty":case"ObjectMethod":case"ClassProperty":case"ClassMethod":case"ClassPrivateProperty":case"ClassPrivateMethod":u(e.key,t);break;case"ThisExpression":t.push("this");break;case"Super":t.push("super");break;case"Import":t.push("import");break;case"DoExpression":t.push("do");break;case"YieldExpression":t.push("yield"),u(e.argument,t);break;case"AwaitExpression":t.push("await"),u(e.argument,t);break;case"AssignmentExpression":u(e.left,t);break;case"VariableDeclarator":u(e.id,t);break;case"FunctionExpression":case"FunctionDeclaration":case"ClassExpression":case"ClassDeclaration":case"PrivateName":u(e.id,t);break;case"ParenthesizedExpression":u(e.expression,t);break;case"UnaryExpression":case"UpdateExpression":u(e.argument,t);break;case"MetaProperty":u(e.meta,t),u(e.property,t);break;case"JSXElement":u(e.openingElement,t);break;case"JSXOpeningElement":t.push(e.name);break;case"JSXFragment":u(e.openingFragment,t);break;case"JSXOpeningFragment":t.push("Fragment");break;case"JSXNamespacedName":u(e.namespace,t),u(e.name,t);}}const c={For(e){for(const t of a.FOR_INIT_KEYS){const r=e.get(t);r.isVar()&&(e.scope.getFunctionParent()||e.scope.getProgramParent()).registerBinding("var",r);}},Declaration(e){e.isBlockScoped()||e.isExportDeclaration()||(e.scope.getFunctionParent()||e.scope.getProgramParent()).registerDeclaration(e);},ReferencedIdentifier(e,t){t.references.push(e);},ForXStatement(e,t){const r=e.get("left");(r.isPattern()||r.isIdentifier())&&t.constantViolations.push(e);},ExportDeclaration:{exit(e){const{node:t,scope:r}=e;if(a.isExportAllDeclaration(t))return;const n=t.declaration;if(a.isClassDeclaration(n)||a.isFunctionDeclaration(n)){const t=n.id;if(!t)return;const s=r.getBinding(t.name);s&&s.reference(e);}else if(a.isVariableDeclaration(n))for(const t of n.declarations)for(const n of Object.keys(a.getBindingIdentifiers(t))){const t=r.getBinding(n);t&&t.reference(e);}}},LabeledStatement(e){e.scope.getBlockParent().registerDeclaration(e);},AssignmentExpression(e,t){t.assignments.push(e);},UpdateExpression(e,t){t.constantViolations.push(e);},UnaryExpression(e,t){"delete"===e.node.operator&&t.constantViolations.push(e);},BlockScoped(e){let t=e.scope;if(t.path===e&&(t=t.parent),t.getBlockParent().registerDeclaration(e),e.isClassDeclaration()&&e.node.id){const t=e.node.id.name;e.scope.bindings[t]=e.scope.parent.getBinding(t);}},CatchClause(e){e.scope.registerBinding("let",e);},Function(e){e.isFunctionExpression()&&e.has("id")&&!e.get("id").node[a.NOT_LOCAL_BINDING]&&e.scope.registerBinding("local",e.get("id"),e);const t=e.get("params");for(const r of t)e.scope.registerBinding("param",r);},ClassExpression(e){e.has("id")&&!e.get("id").node[a.NOT_LOCAL_BINDING]&&e.scope.registerBinding("local",e);}};let p=0;class d{constructor(e){this.uid=void 0,this.path=void 0,this.block=void 0,this.labels=void 0,this.inited=void 0,this.bindings=void 0,this.references=void 0,this.globals=void 0,this.uids=void 0,this.data=void 0,this.crawling=void 0;const{node:t}=e,r=l.scope.get(t);if((null==r?void 0:r.path)===e)return r;l.scope.set(t,this),this.uid=p++,this.block=t,this.path=e,this.labels=new Map,this.inited=!1;}get parent(){var e;let t,r=this.path;do{const e="key"===r.key;r=r.parentPath,e&&r.isMethod()&&(r=r.parentPath),r&&r.isScope()&&(t=r);}while(r&&!t);return null==(e=t)?void 0:e.scope}get parentBlock(){return this.path.parent}get hub(){return this.path.hub}traverse(e,t,r){(0, s.default)(e,t,this,r,this.path);}generateDeclaredUidIdentifier(e){const t=this.generateUidIdentifier(e);return this.push({id:t}),a.cloneNode(t)}generateUidIdentifier(e){return a.identifier(this.generateUid(e))}generateUid(e="temp"){let t;e=a.toIdentifier(e).replace(/^_+/,"").replace(/[0-9]+$/g,"");let r=1;do{t=this._generateUid(e,r),r++;}while(this.hasLabel(t)||this.hasBinding(t)||this.hasGlobal(t)||this.hasReference(t));const n=this.getProgramParent();return n.references[t]=!0,n.uids[t]=!0,t}_generateUid(e,t){let r=e;return t>1&&(r+=t),`_${r}`}generateUidBasedOnNode(e,t){const r=[];u(e,r);let n=r.join("$");return n=n.replace(/^_/,"")||t||"ref",this.generateUid(n.slice(0,20))}generateUidIdentifierBasedOnNode(e,t){return a.identifier(this.generateUidBasedOnNode(e,t))}isStatic(e){if(a.isThisExpression(e)||a.isSuper(e))return !0;if(a.isIdentifier(e)){const t=this.getBinding(e.name);return t?t.constant:this.hasBinding(e.name)}return !1}maybeGenerateMemoised(e,t){if(this.isStatic(e))return null;{const r=this.generateUidIdentifierBasedOnNode(e);return t?r:(this.push({id:r}),a.cloneNode(r))}}checkBlockScopedCollisions(e,t,r,n){if("param"!==t&&"local"!==e.kind&&("let"===t||"let"===e.kind||"const"===e.kind||"module"===e.kind||"param"===e.kind&&("let"===t||"const"===t)))throw this.hub.buildError(n,`Duplicate declaration "${r}"`,TypeError)}rename(e,t,r){const s=this.getBinding(e);if(s)return t=t||this.generateUidIdentifier(e).name,new n.default(s,e,t).rename(r)}_renameFromMap(e,t,r,n){e[t]&&(e[r]=n,e[t]=null);}dump(){const e="-".repeat(60);console.log(e);let t=this;do{console.log("#",t.block.type);for(const e of Object.keys(t.bindings)){const r=t.bindings[e];console.log(" -",e,{constant:r.constant,references:r.references,violations:r.constantViolations.length,kind:r.kind});}}while(t=t.parent);console.log(e);}toArray(e,t,r){if(a.isIdentifier(e)){const t=this.getBinding(e.name);if(null!=t&&t.constant&&t.path.isGenericType("Array"))return e}if(a.isArrayExpression(e))return e;if(a.isIdentifier(e,{name:"arguments"}))return a.callExpression(a.memberExpression(a.memberExpression(a.memberExpression(a.identifier("Array"),a.identifier("prototype")),a.identifier("slice")),a.identifier("call")),[e]);let n;const s=[e];return !0===t?n="toConsumableArray":t?(s.push(a.numericLiteral(t)),n="slicedToArray"):n="toArray",r&&(s.unshift(this.hub.addHelper(n)),n="maybeArrayLike"),a.callExpression(this.hub.addHelper(n),s)}hasLabel(e){return !!this.getLabel(e)}getLabel(e){return this.labels.get(e)}registerLabel(e){this.labels.set(e.node.label.name,e);}registerDeclaration(e){if(e.isLabeledStatement())this.registerLabel(e);else if(e.isFunctionDeclaration())this.registerBinding("hoisted",e.get("id"),e);else if(e.isVariableDeclaration()){const t=e.get("declarations");for(const r of t)this.registerBinding(e.node.kind,r);}else if(e.isClassDeclaration())this.registerBinding("let",e);else if(e.isImportDeclaration()){const t=e.get("specifiers");for(const e of t)this.registerBinding("module",e);}else if(e.isExportDeclaration()){const t=e.get("declaration");(t.isClassDeclaration()||t.isFunctionDeclaration()||t.isVariableDeclaration())&&this.registerDeclaration(t);}else this.registerBinding("unknown",e);}buildUndefinedNode(){return a.unaryExpression("void",a.numericLiteral(0),!0)}registerConstantViolation(e){const t=e.getBindingIdentifiers();for(const r of Object.keys(t)){const t=this.getBinding(r);t&&t.reassign(e);}}registerBinding(e,t,r=t){if(!e)throw new ReferenceError("no `kind`");if(t.isVariableDeclaration()){const r=t.get("declarations");for(const t of r)this.registerBinding(e,t);return}const n=this.getProgramParent(),s=t.getOuterBindingIdentifiers(!0);for(const t of Object.keys(s)){n.references[t]=!0;for(const n of s[t]){const s=this.getOwnBinding(t);if(s){if(s.identifier===n)continue;this.checkBlockScopedCollisions(s,e,t,n);}s?this.registerConstantViolation(r):this.bindings[t]=new i.default({identifier:n,scope:this,path:r,kind:e});}}}addGlobal(e){this.globals[e.name]=e;}hasUid(e){let t=this;do{if(t.uids[e])return !0}while(t=t.parent);return !1}hasGlobal(e){let t=this;do{if(t.globals[e])return !0}while(t=t.parent);return !1}hasReference(e){return !!this.getProgramParent().references[e]}isPure(e,t){if(a.isIdentifier(e)){const r=this.getBinding(e.name);return !!r&&(!t||r.constant)}if(a.isClass(e))return !(e.superClass&&!this.isPure(e.superClass,t))&&this.isPure(e.body,t);if(a.isClassBody(e)){for(const r of e.body)if(!this.isPure(r,t))return !1;return !0}if(a.isBinary(e))return this.isPure(e.left,t)&&this.isPure(e.right,t);if(a.isArrayExpression(e)){for(const r of e.elements)if(!this.isPure(r,t))return !1;return !0}if(a.isObjectExpression(e)){for(const r of e.properties)if(!this.isPure(r,t))return !1;return !0}if(a.isMethod(e))return !(e.computed&&!this.isPure(e.key,t))&&"get"!==e.kind&&"set"!==e.kind;if(a.isProperty(e))return !(e.computed&&!this.isPure(e.key,t))&&this.isPure(e.value,t);if(a.isUnaryExpression(e))return this.isPure(e.argument,t);if(a.isTaggedTemplateExpression(e))return a.matchesPattern(e.tag,"String.raw")&&!this.hasBinding("String",!0)&&this.isPure(e.quasi,t);if(a.isTemplateLiteral(e)){for(const r of e.expressions)if(!this.isPure(r,t))return !1;return !0}return a.isPureish(e)}setData(e,t){return this.data[e]=t}getData(e){let t=this;do{const r=t.data[e];if(null!=r)return r}while(t=t.parent)}removeData(e){let t=this;do{null!=t.data[e]&&(t.data[e]=null);}while(t=t.parent)}init(){this.inited||(this.inited=!0,this.crawl());}crawl(){const e=this.path;this.references=Object.create(null),this.bindings=Object.create(null),this.globals=Object.create(null),this.uids=Object.create(null),this.data=Object.create(null);const t=this.getProgramParent();if(t.crawling)return;const r={references:[],constantViolations:[],assignments:[]};if(this.crawling=!0,"Program"!==e.type&&c._exploded){for(const t of c.enter)t(e,r);const t=c[e.type];if(t)for(const n of t.enter)n(e,r);}e.traverse(c,r),this.crawling=!1;for(const e of r.assignments){const r=e.getBindingIdentifiers();for(const n of Object.keys(r))e.scope.getBinding(n)||t.addGlobal(r[n]);e.scope.registerConstantViolation(e);}for(const e of r.references){const r=e.scope.getBinding(e.node.name);r?r.reference(e):t.addGlobal(e.node);}for(const e of r.constantViolations)e.scope.registerConstantViolation(e);}push(e){let t=this.path;t.isBlockStatement()||t.isProgram()||(t=this.getBlockParent().path),t.isSwitchStatement()&&(t=(this.getFunctionParent()||this.getProgramParent()).path),(t.isLoop()||t.isCatchClause()||t.isFunction())&&(t.ensureBlock(),t=t.get("body"));const r=e.unique,n=e.kind||"var",s=null==e._blockHoist?2:e._blockHoist,i=`declaration:${n}:${s}`;let o=!r&&t.getData(i);if(!o){const e=a.variableDeclaration(n,[]);e._blockHoist=s,[o]=t.unshiftContainer("body",[e]),r||t.setData(i,o);}const l=a.variableDeclarator(e.id,e.init);o.node.declarations.push(l),this.registerBinding(n,o.get("declarations").pop());}getProgramParent(){let e=this;do{if(e.path.isProgram())return e}while(e=e.parent);throw new Error("Couldn't find a Program")}getFunctionParent(){let e=this;do{if(e.path.isFunctionParent())return e}while(e=e.parent);return null}getBlockParent(){let e=this;do{if(e.path.isBlockParent())return e}while(e=e.parent);throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...")}getAllBindings(){const e=Object.create(null);let t=this;do{for(const r of Object.keys(t.bindings))r in e==0&&(e[r]=t.bindings[r]);t=t.parent;}while(t);return e}getAllBindingsOfKind(...e){const t=Object.create(null);for(const r of e){let e=this;do{for(const n of Object.keys(e.bindings)){const s=e.bindings[n];s.kind===r&&(t[n]=s);}e=e.parent;}while(e)}return t}bindingIdentifierEquals(e,t){return this.getBindingIdentifier(e)===t}getBinding(e){let t,r=this;do{const s=r.getOwnBinding(e);var n;if(s&&(null==(n=t)||!n.isPattern()||"param"===s.kind))return s;t=r.path;}while(r=r.parent)}getOwnBinding(e){return this.bindings[e]}getBindingIdentifier(e){var t;return null==(t=this.getBinding(e))?void 0:t.identifier}getOwnBindingIdentifier(e){const t=this.bindings[e];return null==t?void 0:t.identifier}hasOwnBinding(e){return !!this.getOwnBinding(e)}hasBinding(e,t){return !(!e||!this.hasOwnBinding(e)&&!this.parentHasBinding(e,t)&&!this.hasUid(e)&&(t||!d.globals.includes(e))&&(t||!d.contextVariables.includes(e)))}parentHasBinding(e,t){var r;return null==(r=this.parent)?void 0:r.hasBinding(e,t)}moveBindingTo(e,t){const r=this.getBinding(e);r&&(r.scope.removeOwnBinding(e),r.scope=t,t.bindings[e]=r);}removeOwnBinding(e){delete this.bindings[e];}removeBinding(e){var t;null==(t=this.getBinding(e))||t.scope.removeOwnBinding(e);let r=this;do{r.uids[e]&&(r.uids[e]=!1);}while(r=r.parent)}}t.default=d,d.globals=Object.keys(o.builtin),d.contextVariables=["arguments","undefined","Infinity","NaN"];},"./node_modules/@babel/traverse/lib/scope/lib/renamer.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0,r("./node_modules/@babel/traverse/lib/scope/binding.js");var n=r("./node_modules/@babel/helper-split-export-declaration/lib/index.js"),s=r("./node_modules/@babel/types/lib/index.js");const i={ReferencedIdentifier({node:e},t){e.name===t.oldName&&(e.name=t.newName);},Scope(e,t){e.scope.bindingIdentifierEquals(t.oldName,t.binding.identifier)||function(e){if(!e.isMethod()||!e.node.computed)return void e.skip();const t=s.VISITOR_KEYS[e.type];for(const r of t)"key"!==r&&e.skipKey(r);}(e);},"AssignmentExpression|Declaration|VariableDeclarator"(e,t){if(e.isVariableDeclaration())return;const r=e.getOuterBindingIdentifiers();for(const e in r)e===t.oldName&&(r[e].name=t.newName);}};t.default=class{constructor(e,t,r){this.newName=r,this.oldName=t,this.binding=e;}maybeConvertFromExportDeclaration(e){const t=e.parentPath;t.isExportDeclaration()&&(t.isExportDefaultDeclaration()&&!t.get("declaration").node.id||(0, n.default)(t));}maybeConvertFromClassFunctionDeclaration(e){}maybeConvertFromClassFunctionExpression(e){}rename(e){const{binding:t,oldName:r,newName:n}=this,{scope:s,path:o}=t,a=o.find((e=>e.isDeclaration()||e.isFunctionExpression()||e.isClassExpression()));a&&a.getOuterBindingIdentifiers()[r]===t.identifier&&this.maybeConvertFromExportDeclaration(a);const l=e||s.block;"SwitchStatement"===(null==l?void 0:l.type)?l.cases.forEach((e=>{s.traverse(e,i,this);})):s.traverse(l,i,this),e||(s.removeOwnBinding(r),s.bindings[n]=t,this.binding.identifier.name=n),a&&(this.maybeConvertFromClassFunctionDeclaration(a),this.maybeConvertFromClassFunctionExpression(a));}};},"./node_modules/@babel/traverse/lib/visitors.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.explode=i,t.verify=o,t.merge=function(e,t=[],r){const n={};for(let s=0;s<e.length;s++){const o=e[s],a=t[s];i(o);for(const e of Object.keys(o)){let t=o[e];(a||r)&&(t=l(t,a,r)),d(n[e]=n[e]||{},t);}}return n};var n=r("./node_modules/@babel/traverse/lib/path/lib/virtual-types.js"),s=r("./node_modules/@babel/types/lib/index.js");function i(e){if(e._exploded)return e;e._exploded=!0;for(const t of Object.keys(e)){if(p(t))continue;const r=t.split("|");if(1===r.length)continue;const n=e[t];delete e[t];for(const t of r)e[t]=n;}o(e),delete e.__esModule,function(e){for(const t of Object.keys(e)){if(p(t))continue;const r=e[t];"function"==typeof r&&(e[t]={enter:r});}}(e),u(e);for(const t of Object.keys(e)){if(p(t))continue;const r=n[t];if(!r)continue;const s=e[t];for(const e of Object.keys(s))s[e]=c(r,s[e]);if(delete e[t],r.types)for(const t of r.types)e[t]?d(e[t],s):e[t]=s;else d(e,s);}for(const t of Object.keys(e)){if(p(t))continue;const r=e[t];let n=s.FLIPPED_ALIAS_KEYS[t];const i=s.DEPRECATED_KEYS[t];if(i&&(console.trace(`Visitor defined for ${t} but it has been renamed to ${i}`),n=[i]),n){delete e[t];for(const t of n){const n=e[t];n?d(n,r):e[t]=Object.assign({},r);}}}for(const t of Object.keys(e))p(t)||u(e[t]);return e}function o(e){if(!e._verified){if("function"==typeof e)throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");for(const t of Object.keys(e)){if("enter"!==t&&"exit"!==t||a(t,e[t]),p(t))continue;if(s.TYPES.indexOf(t)<0)throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type`);const r=e[t];if("object"==typeof r)for(const e of Object.keys(r)){if("enter"!==e&&"exit"!==e)throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${e}`);a(`${t}.${e}`,r[e]);}}e._verified=!0;}}function a(e,t){const r=[].concat(t);for(const t of r)if("function"!=typeof t)throw new TypeError(`Non-function found defined in ${e} with type ${typeof t}`)}function l(e,t,r){const n={};for(const s of Object.keys(e)){let i=e[s];Array.isArray(i)&&(i=i.map((function(e){let n=e;return t&&(n=function(r){return e.call(t,r,t)}),r&&(n=r(t.key,s,n)),n!==e&&(n.toString=()=>e.toString()),n})),n[s]=i);}return n}function u(e){e.enter&&!Array.isArray(e.enter)&&(e.enter=[e.enter]),e.exit&&!Array.isArray(e.exit)&&(e.exit=[e.exit]);}function c(e,t){const r=function(r){if(e.checkPath(r))return t.apply(this,arguments)};return r.toString=()=>t.toString(),r}function p(e){return "_"===e[0]||"enter"===e||"exit"===e||"shouldSkip"===e||"denylist"===e||"noScope"===e||"skipKeys"===e||"blacklist"===e}function d(e,t){for(const r of Object.keys(t))e[r]=[].concat(e[r]||[],t[r]);}},"./node_modules/@babel/traverse/node_modules/globals/globals.json":e=>{e.exports=JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');},"./node_modules/@babel/traverse/node_modules/globals/index.js":(e,t,r)=>{e.exports=r("./node_modules/@babel/traverse/node_modules/globals/globals.json");},"./node_modules/@babel/types/lib/asserts/assertNode.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){if(!(0, n.default)(e)){var t;const r=null!=(t=null==e?void 0:e.type)?t:JSON.stringify(e);throw new TypeError(`Not a valid node of type "${r}"`)}};var n=r("./node_modules/@babel/types/lib/validators/isNode.js");},"./node_modules/@babel/types/lib/asserts/generated/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.assertArrayExpression=function(e,t){s("ArrayExpression",e,t);},t.assertAssignmentExpression=function(e,t){s("AssignmentExpression",e,t);},t.assertBinaryExpression=function(e,t){s("BinaryExpression",e,t);},t.assertInterpreterDirective=function(e,t){s("InterpreterDirective",e,t);},t.assertDirective=function(e,t){s("Directive",e,t);},t.assertDirectiveLiteral=function(e,t){s("DirectiveLiteral",e,t);},t.assertBlockStatement=function(e,t){s("BlockStatement",e,t);},t.assertBreakStatement=function(e,t){s("BreakStatement",e,t);},t.assertCallExpression=function(e,t){s("CallExpression",e,t);},t.assertCatchClause=function(e,t){s("CatchClause",e,t);},t.assertConditionalExpression=function(e,t){s("ConditionalExpression",e,t);},t.assertContinueStatement=function(e,t){s("ContinueStatement",e,t);},t.assertDebuggerStatement=function(e,t){s("DebuggerStatement",e,t);},t.assertDoWhileStatement=function(e,t){s("DoWhileStatement",e,t);},t.assertEmptyStatement=function(e,t){s("EmptyStatement",e,t);},t.assertExpressionStatement=function(e,t){s("ExpressionStatement",e,t);},t.assertFile=function(e,t){s("File",e,t);},t.assertForInStatement=function(e,t){s("ForInStatement",e,t);},t.assertForStatement=function(e,t){s("ForStatement",e,t);},t.assertFunctionDeclaration=function(e,t){s("FunctionDeclaration",e,t);},t.assertFunctionExpression=function(e,t){s("FunctionExpression",e,t);},t.assertIdentifier=function(e,t){s("Identifier",e,t);},t.assertIfStatement=function(e,t){s("IfStatement",e,t);},t.assertLabeledStatement=function(e,t){s("LabeledStatement",e,t);},t.assertStringLiteral=function(e,t){s("StringLiteral",e,t);},t.assertNumericLiteral=function(e,t){s("NumericLiteral",e,t);},t.assertNullLiteral=function(e,t){s("NullLiteral",e,t);},t.assertBooleanLiteral=function(e,t){s("BooleanLiteral",e,t);},t.assertRegExpLiteral=function(e,t){s("RegExpLiteral",e,t);},t.assertLogicalExpression=function(e,t){s("LogicalExpression",e,t);},t.assertMemberExpression=function(e,t){s("MemberExpression",e,t);},t.assertNewExpression=function(e,t){s("NewExpression",e,t);},t.assertProgram=function(e,t){s("Program",e,t);},t.assertObjectExpression=function(e,t){s("ObjectExpression",e,t);},t.assertObjectMethod=function(e,t){s("ObjectMethod",e,t);},t.assertObjectProperty=function(e,t){s("ObjectProperty",e,t);},t.assertRestElement=function(e,t){s("RestElement",e,t);},t.assertReturnStatement=function(e,t){s("ReturnStatement",e,t);},t.assertSequenceExpression=function(e,t){s("SequenceExpression",e,t);},t.assertParenthesizedExpression=function(e,t){s("ParenthesizedExpression",e,t);},t.assertSwitchCase=function(e,t){s("SwitchCase",e,t);},t.assertSwitchStatement=function(e,t){s("SwitchStatement",e,t);},t.assertThisExpression=function(e,t){s("ThisExpression",e,t);},t.assertThrowStatement=function(e,t){s("ThrowStatement",e,t);},t.assertTryStatement=function(e,t){s("TryStatement",e,t);},t.assertUnaryExpression=function(e,t){s("UnaryExpression",e,t);},t.assertUpdateExpression=function(e,t){s("UpdateExpression",e,t);},t.assertVariableDeclaration=function(e,t){s("VariableDeclaration",e,t);},t.assertVariableDeclarator=function(e,t){s("VariableDeclarator",e,t);},t.assertWhileStatement=function(e,t){s("WhileStatement",e,t);},t.assertWithStatement=function(e,t){s("WithStatement",e,t);},t.assertAssignmentPattern=function(e,t){s("AssignmentPattern",e,t);},t.assertArrayPattern=function(e,t){s("ArrayPattern",e,t);},t.assertArrowFunctionExpression=function(e,t){s("ArrowFunctionExpression",e,t);},t.assertClassBody=function(e,t){s("ClassBody",e,t);},t.assertClassExpression=function(e,t){s("ClassExpression",e,t);},t.assertClassDeclaration=function(e,t){s("ClassDeclaration",e,t);},t.assertExportAllDeclaration=function(e,t){s("ExportAllDeclaration",e,t);},t.assertExportDefaultDeclaration=function(e,t){s("ExportDefaultDeclaration",e,t);},t.assertExportNamedDeclaration=function(e,t){s("ExportNamedDeclaration",e,t);},t.assertExportSpecifier=function(e,t){s("ExportSpecifier",e,t);},t.assertForOfStatement=function(e,t){s("ForOfStatement",e,t);},t.assertImportDeclaration=function(e,t){s("ImportDeclaration",e,t);},t.assertImportDefaultSpecifier=function(e,t){s("ImportDefaultSpecifier",e,t);},t.assertImportNamespaceSpecifier=function(e,t){s("ImportNamespaceSpecifier",e,t);},t.assertImportSpecifier=function(e,t){s("ImportSpecifier",e,t);},t.assertMetaProperty=function(e,t){s("MetaProperty",e,t);},t.assertClassMethod=function(e,t){s("ClassMethod",e,t);},t.assertObjectPattern=function(e,t){s("ObjectPattern",e,t);},t.assertSpreadElement=function(e,t){s("SpreadElement",e,t);},t.assertSuper=function(e,t){s("Super",e,t);},t.assertTaggedTemplateExpression=function(e,t){s("TaggedTemplateExpression",e,t);},t.assertTemplateElement=function(e,t){s("TemplateElement",e,t);},t.assertTemplateLiteral=function(e,t){s("TemplateLiteral",e,t);},t.assertYieldExpression=function(e,t){s("YieldExpression",e,t);},t.assertAwaitExpression=function(e,t){s("AwaitExpression",e,t);},t.assertImport=function(e,t){s("Import",e,t);},t.assertBigIntLiteral=function(e,t){s("BigIntLiteral",e,t);},t.assertExportNamespaceSpecifier=function(e,t){s("ExportNamespaceSpecifier",e,t);},t.assertOptionalMemberExpression=function(e,t){s("OptionalMemberExpression",e,t);},t.assertOptionalCallExpression=function(e,t){s("OptionalCallExpression",e,t);},t.assertAnyTypeAnnotation=function(e,t){s("AnyTypeAnnotation",e,t);},t.assertArrayTypeAnnotation=function(e,t){s("ArrayTypeAnnotation",e,t);},t.assertBooleanTypeAnnotation=function(e,t){s("BooleanTypeAnnotation",e,t);},t.assertBooleanLiteralTypeAnnotation=function(e,t){s("BooleanLiteralTypeAnnotation",e,t);},t.assertNullLiteralTypeAnnotation=function(e,t){s("NullLiteralTypeAnnotation",e,t);},t.assertClassImplements=function(e,t){s("ClassImplements",e,t);},t.assertDeclareClass=function(e,t){s("DeclareClass",e,t);},t.assertDeclareFunction=function(e,t){s("DeclareFunction",e,t);},t.assertDeclareInterface=function(e,t){s("DeclareInterface",e,t);},t.assertDeclareModule=function(e,t){s("DeclareModule",e,t);},t.assertDeclareModuleExports=function(e,t){s("DeclareModuleExports",e,t);},t.assertDeclareTypeAlias=function(e,t){s("DeclareTypeAlias",e,t);},t.assertDeclareOpaqueType=function(e,t){s("DeclareOpaqueType",e,t);},t.assertDeclareVariable=function(e,t){s("DeclareVariable",e,t);},t.assertDeclareExportDeclaration=function(e,t){s("DeclareExportDeclaration",e,t);},t.assertDeclareExportAllDeclaration=function(e,t){s("DeclareExportAllDeclaration",e,t);},t.assertDeclaredPredicate=function(e,t){s("DeclaredPredicate",e,t);},t.assertExistsTypeAnnotation=function(e,t){s("ExistsTypeAnnotation",e,t);},t.assertFunctionTypeAnnotation=function(e,t){s("FunctionTypeAnnotation",e,t);},t.assertFunctionTypeParam=function(e,t){s("FunctionTypeParam",e,t);},t.assertGenericTypeAnnotation=function(e,t){s("GenericTypeAnnotation",e,t);},t.assertInferredPredicate=function(e,t){s("InferredPredicate",e,t);},t.assertInterfaceExtends=function(e,t){s("InterfaceExtends",e,t);},t.assertInterfaceDeclaration=function(e,t){s("InterfaceDeclaration",e,t);},t.assertInterfaceTypeAnnotation=function(e,t){s("InterfaceTypeAnnotation",e,t);},t.assertIntersectionTypeAnnotation=function(e,t){s("IntersectionTypeAnnotation",e,t);},t.assertMixedTypeAnnotation=function(e,t){s("MixedTypeAnnotation",e,t);},t.assertEmptyTypeAnnotation=function(e,t){s("EmptyTypeAnnotation",e,t);},t.assertNullableTypeAnnotation=function(e,t){s("NullableTypeAnnotation",e,t);},t.assertNumberLiteralTypeAnnotation=function(e,t){s("NumberLiteralTypeAnnotation",e,t);},t.assertNumberTypeAnnotation=function(e,t){s("NumberTypeAnnotation",e,t);},t.assertObjectTypeAnnotation=function(e,t){s("ObjectTypeAnnotation",e,t);},t.assertObjectTypeInternalSlot=function(e,t){s("ObjectTypeInternalSlot",e,t);},t.assertObjectTypeCallProperty=function(e,t){s("ObjectTypeCallProperty",e,t);},t.assertObjectTypeIndexer=function(e,t){s("ObjectTypeIndexer",e,t);},t.assertObjectTypeProperty=function(e,t){s("ObjectTypeProperty",e,t);},t.assertObjectTypeSpreadProperty=function(e,t){s("ObjectTypeSpreadProperty",e,t);},t.assertOpaqueType=function(e,t){s("OpaqueType",e,t);},t.assertQualifiedTypeIdentifier=function(e,t){s("QualifiedTypeIdentifier",e,t);},t.assertStringLiteralTypeAnnotation=function(e,t){s("StringLiteralTypeAnnotation",e,t);},t.assertStringTypeAnnotation=function(e,t){s("StringTypeAnnotation",e,t);},t.assertSymbolTypeAnnotation=function(e,t){s("SymbolTypeAnnotation",e,t);},t.assertThisTypeAnnotation=function(e,t){s("ThisTypeAnnotation",e,t);},t.assertTupleTypeAnnotation=function(e,t){s("TupleTypeAnnotation",e,t);},t.assertTypeofTypeAnnotation=function(e,t){s("TypeofTypeAnnotation",e,t);},t.assertTypeAlias=function(e,t){s("TypeAlias",e,t);},t.assertTypeAnnotation=function(e,t){s("TypeAnnotation",e,t);},t.assertTypeCastExpression=function(e,t){s("TypeCastExpression",e,t);},t.assertTypeParameter=function(e,t){s("TypeParameter",e,t);},t.assertTypeParameterDeclaration=function(e,t){s("TypeParameterDeclaration",e,t);},t.assertTypeParameterInstantiation=function(e,t){s("TypeParameterInstantiation",e,t);},t.assertUnionTypeAnnotation=function(e,t){s("UnionTypeAnnotation",e,t);},t.assertVariance=function(e,t){s("Variance",e,t);},t.assertVoidTypeAnnotation=function(e,t){s("VoidTypeAnnotation",e,t);},t.assertEnumDeclaration=function(e,t){s("EnumDeclaration",e,t);},t.assertEnumBooleanBody=function(e,t){s("EnumBooleanBody",e,t);},t.assertEnumNumberBody=function(e,t){s("EnumNumberBody",e,t);},t.assertEnumStringBody=function(e,t){s("EnumStringBody",e,t);},t.assertEnumSymbolBody=function(e,t){s("EnumSymbolBody",e,t);},t.assertEnumBooleanMember=function(e,t){s("EnumBooleanMember",e,t);},t.assertEnumNumberMember=function(e,t){s("EnumNumberMember",e,t);},t.assertEnumStringMember=function(e,t){s("EnumStringMember",e,t);},t.assertEnumDefaultedMember=function(e,t){s("EnumDefaultedMember",e,t);},t.assertIndexedAccessType=function(e,t){s("IndexedAccessType",e,t);},t.assertOptionalIndexedAccessType=function(e,t){s("OptionalIndexedAccessType",e,t);},t.assertJSXAttribute=function(e,t){s("JSXAttribute",e,t);},t.assertJSXClosingElement=function(e,t){s("JSXClosingElement",e,t);},t.assertJSXElement=function(e,t){s("JSXElement",e,t);},t.assertJSXEmptyExpression=function(e,t){s("JSXEmptyExpression",e,t);},t.assertJSXExpressionContainer=function(e,t){s("JSXExpressionContainer",e,t);},t.assertJSXSpreadChild=function(e,t){s("JSXSpreadChild",e,t);},t.assertJSXIdentifier=function(e,t){s("JSXIdentifier",e,t);},t.assertJSXMemberExpression=function(e,t){s("JSXMemberExpression",e,t);},t.assertJSXNamespacedName=function(e,t){s("JSXNamespacedName",e,t);},t.assertJSXOpeningElement=function(e,t){s("JSXOpeningElement",e,t);},t.assertJSXSpreadAttribute=function(e,t){s("JSXSpreadAttribute",e,t);},t.assertJSXText=function(e,t){s("JSXText",e,t);},t.assertJSXFragment=function(e,t){s("JSXFragment",e,t);},t.assertJSXOpeningFragment=function(e,t){s("JSXOpeningFragment",e,t);},t.assertJSXClosingFragment=function(e,t){s("JSXClosingFragment",e,t);},t.assertNoop=function(e,t){s("Noop",e,t);},t.assertPlaceholder=function(e,t){s("Placeholder",e,t);},t.assertV8IntrinsicIdentifier=function(e,t){s("V8IntrinsicIdentifier",e,t);},t.assertArgumentPlaceholder=function(e,t){s("ArgumentPlaceholder",e,t);},t.assertBindExpression=function(e,t){s("BindExpression",e,t);},t.assertClassProperty=function(e,t){s("ClassProperty",e,t);},t.assertPipelineTopicExpression=function(e,t){s("PipelineTopicExpression",e,t);},t.assertPipelineBareFunction=function(e,t){s("PipelineBareFunction",e,t);},t.assertPipelinePrimaryTopicReference=function(e,t){s("PipelinePrimaryTopicReference",e,t);},t.assertClassPrivateProperty=function(e,t){s("ClassPrivateProperty",e,t);},t.assertClassPrivateMethod=function(e,t){s("ClassPrivateMethod",e,t);},t.assertImportAttribute=function(e,t){s("ImportAttribute",e,t);},t.assertDecorator=function(e,t){s("Decorator",e,t);},t.assertDoExpression=function(e,t){s("DoExpression",e,t);},t.assertExportDefaultSpecifier=function(e,t){s("ExportDefaultSpecifier",e,t);},t.assertPrivateName=function(e,t){s("PrivateName",e,t);},t.assertRecordExpression=function(e,t){s("RecordExpression",e,t);},t.assertTupleExpression=function(e,t){s("TupleExpression",e,t);},t.assertDecimalLiteral=function(e,t){s("DecimalLiteral",e,t);},t.assertStaticBlock=function(e,t){s("StaticBlock",e,t);},t.assertModuleExpression=function(e,t){s("ModuleExpression",e,t);},t.assertTSParameterProperty=function(e,t){s("TSParameterProperty",e,t);},t.assertTSDeclareFunction=function(e,t){s("TSDeclareFunction",e,t);},t.assertTSDeclareMethod=function(e,t){s("TSDeclareMethod",e,t);},t.assertTSQualifiedName=function(e,t){s("TSQualifiedName",e,t);},t.assertTSCallSignatureDeclaration=function(e,t){s("TSCallSignatureDeclaration",e,t);},t.assertTSConstructSignatureDeclaration=function(e,t){s("TSConstructSignatureDeclaration",e,t);},t.assertTSPropertySignature=function(e,t){s("TSPropertySignature",e,t);},t.assertTSMethodSignature=function(e,t){s("TSMethodSignature",e,t);},t.assertTSIndexSignature=function(e,t){s("TSIndexSignature",e,t);},t.assertTSAnyKeyword=function(e,t){s("TSAnyKeyword",e,t);},t.assertTSBooleanKeyword=function(e,t){s("TSBooleanKeyword",e,t);},t.assertTSBigIntKeyword=function(e,t){s("TSBigIntKeyword",e,t);},t.assertTSIntrinsicKeyword=function(e,t){s("TSIntrinsicKeyword",e,t);},t.assertTSNeverKeyword=function(e,t){s("TSNeverKeyword",e,t);},t.assertTSNullKeyword=function(e,t){s("TSNullKeyword",e,t);},t.assertTSNumberKeyword=function(e,t){s("TSNumberKeyword",e,t);},t.assertTSObjectKeyword=function(e,t){s("TSObjectKeyword",e,t);},t.assertTSStringKeyword=function(e,t){s("TSStringKeyword",e,t);},t.assertTSSymbolKeyword=function(e,t){s("TSSymbolKeyword",e,t);},t.assertTSUndefinedKeyword=function(e,t){s("TSUndefinedKeyword",e,t);},t.assertTSUnknownKeyword=function(e,t){s("TSUnknownKeyword",e,t);},t.assertTSVoidKeyword=function(e,t){s("TSVoidKeyword",e,t);},t.assertTSThisType=function(e,t){s("TSThisType",e,t);},t.assertTSFunctionType=function(e,t){s("TSFunctionType",e,t);},t.assertTSConstructorType=function(e,t){s("TSConstructorType",e,t);},t.assertTSTypeReference=function(e,t){s("TSTypeReference",e,t);},t.assertTSTypePredicate=function(e,t){s("TSTypePredicate",e,t);},t.assertTSTypeQuery=function(e,t){s("TSTypeQuery",e,t);},t.assertTSTypeLiteral=function(e,t){s("TSTypeLiteral",e,t);},t.assertTSArrayType=function(e,t){s("TSArrayType",e,t);},t.assertTSTupleType=function(e,t){s("TSTupleType",e,t);},t.assertTSOptionalType=function(e,t){s("TSOptionalType",e,t);},t.assertTSRestType=function(e,t){s("TSRestType",e,t);},t.assertTSNamedTupleMember=function(e,t){s("TSNamedTupleMember",e,t);},t.assertTSUnionType=function(e,t){s("TSUnionType",e,t);},t.assertTSIntersectionType=function(e,t){s("TSIntersectionType",e,t);},t.assertTSConditionalType=function(e,t){s("TSConditionalType",e,t);},t.assertTSInferType=function(e,t){s("TSInferType",e,t);},t.assertTSParenthesizedType=function(e,t){s("TSParenthesizedType",e,t);},t.assertTSTypeOperator=function(e,t){s("TSTypeOperator",e,t);},t.assertTSIndexedAccessType=function(e,t){s("TSIndexedAccessType",e,t);},t.assertTSMappedType=function(e,t){s("TSMappedType",e,t);},t.assertTSLiteralType=function(e,t){s("TSLiteralType",e,t);},t.assertTSExpressionWithTypeArguments=function(e,t){s("TSExpressionWithTypeArguments",e,t);},t.assertTSInterfaceDeclaration=function(e,t){s("TSInterfaceDeclaration",e,t);},t.assertTSInterfaceBody=function(e,t){s("TSInterfaceBody",e,t);},t.assertTSTypeAliasDeclaration=function(e,t){s("TSTypeAliasDeclaration",e,t);},t.assertTSAsExpression=function(e,t){s("TSAsExpression",e,t);},t.assertTSTypeAssertion=function(e,t){s("TSTypeAssertion",e,t);},t.assertTSEnumDeclaration=function(e,t){s("TSEnumDeclaration",e,t);},t.assertTSEnumMember=function(e,t){s("TSEnumMember",e,t);},t.assertTSModuleDeclaration=function(e,t){s("TSModuleDeclaration",e,t);},t.assertTSModuleBlock=function(e,t){s("TSModuleBlock",e,t);},t.assertTSImportType=function(e,t){s("TSImportType",e,t);},t.assertTSImportEqualsDeclaration=function(e,t){s("TSImportEqualsDeclaration",e,t);},t.assertTSExternalModuleReference=function(e,t){s("TSExternalModuleReference",e,t);},t.assertTSNonNullExpression=function(e,t){s("TSNonNullExpression",e,t);},t.assertTSExportAssignment=function(e,t){s("TSExportAssignment",e,t);},t.assertTSNamespaceExportDeclaration=function(e,t){s("TSNamespaceExportDeclaration",e,t);},t.assertTSTypeAnnotation=function(e,t){s("TSTypeAnnotation",e,t);},t.assertTSTypeParameterInstantiation=function(e,t){s("TSTypeParameterInstantiation",e,t);},t.assertTSTypeParameterDeclaration=function(e,t){s("TSTypeParameterDeclaration",e,t);},t.assertTSTypeParameter=function(e,t){s("TSTypeParameter",e,t);},t.assertExpression=function(e,t){s("Expression",e,t);},t.assertBinary=function(e,t){s("Binary",e,t);},t.assertScopable=function(e,t){s("Scopable",e,t);},t.assertBlockParent=function(e,t){s("BlockParent",e,t);},t.assertBlock=function(e,t){s("Block",e,t);},t.assertStatement=function(e,t){s("Statement",e,t);},t.assertTerminatorless=function(e,t){s("Terminatorless",e,t);},t.assertCompletionStatement=function(e,t){s("CompletionStatement",e,t);},t.assertConditional=function(e,t){s("Conditional",e,t);},t.assertLoop=function(e,t){s("Loop",e,t);},t.assertWhile=function(e,t){s("While",e,t);},t.assertExpressionWrapper=function(e,t){s("ExpressionWrapper",e,t);},t.assertFor=function(e,t){s("For",e,t);},t.assertForXStatement=function(e,t){s("ForXStatement",e,t);},t.assertFunction=function(e,t){s("Function",e,t);},t.assertFunctionParent=function(e,t){s("FunctionParent",e,t);},t.assertPureish=function(e,t){s("Pureish",e,t);},t.assertDeclaration=function(e,t){s("Declaration",e,t);},t.assertPatternLike=function(e,t){s("PatternLike",e,t);},t.assertLVal=function(e,t){s("LVal",e,t);},t.assertTSEntityName=function(e,t){s("TSEntityName",e,t);},t.assertLiteral=function(e,t){s("Literal",e,t);},t.assertImmutable=function(e,t){s("Immutable",e,t);},t.assertUserWhitespacable=function(e,t){s("UserWhitespacable",e,t);},t.assertMethod=function(e,t){s("Method",e,t);},t.assertObjectMember=function(e,t){s("ObjectMember",e,t);},t.assertProperty=function(e,t){s("Property",e,t);},t.assertUnaryLike=function(e,t){s("UnaryLike",e,t);},t.assertPattern=function(e,t){s("Pattern",e,t);},t.assertClass=function(e,t){s("Class",e,t);},t.assertModuleDeclaration=function(e,t){s("ModuleDeclaration",e,t);},t.assertExportDeclaration=function(e,t){s("ExportDeclaration",e,t);},t.assertModuleSpecifier=function(e,t){s("ModuleSpecifier",e,t);},t.assertFlow=function(e,t){s("Flow",e,t);},t.assertFlowType=function(e,t){s("FlowType",e,t);},t.assertFlowBaseAnnotation=function(e,t){s("FlowBaseAnnotation",e,t);},t.assertFlowDeclaration=function(e,t){s("FlowDeclaration",e,t);},t.assertFlowPredicate=function(e,t){s("FlowPredicate",e,t);},t.assertEnumBody=function(e,t){s("EnumBody",e,t);},t.assertEnumMember=function(e,t){s("EnumMember",e,t);},t.assertJSX=function(e,t){s("JSX",e,t);},t.assertPrivate=function(e,t){s("Private",e,t);},t.assertTSTypeElement=function(e,t){s("TSTypeElement",e,t);},t.assertTSType=function(e,t){s("TSType",e,t);},t.assertTSBaseType=function(e,t){s("TSBaseType",e,t);},t.assertNumberLiteral=function(e,t){console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),s("NumberLiteral",e,t);},t.assertRegexLiteral=function(e,t){console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),s("RegexLiteral",e,t);},t.assertRestProperty=function(e,t){console.trace("The node type RestProperty has been renamed to RestElement"),s("RestProperty",e,t);},t.assertSpreadProperty=function(e,t){console.trace("The node type SpreadProperty has been renamed to SpreadElement"),s("SpreadProperty",e,t);};var n=r("./node_modules/@babel/types/lib/validators/is.js");function s(e,t,r){if(!(0, n.default)(e,t,r))throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`)}},"./node_modules/@babel/types/lib/ast-types/generated/index.js":()=>{},"./node_modules/@babel/types/lib/builders/builder.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,...t){const r=n.BUILDER_KEYS[e],i=t.length;if(i>r.length)throw new Error(`${e}: Too many arguments passed. Received ${i} but can receive no more than ${r.length}`);const o={type:e};let a=0;r.forEach((r=>{const s=n.NODE_FIELDS[e][r];let l;a<i&&(l=t[a]),void 0===l&&(l=Array.isArray(s.default)?[]:s.default),o[r]=l,a++;}));for(const e of Object.keys(o))(0, s.default)(o,e,o[e]);return o};var n=r("./node_modules/@babel/types/lib/definitions/index.js"),s=r("./node_modules/@babel/types/lib/validators/validate.js");},"./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){const t=(0, s.default)(e);return 1===t.length?t[0]:(0, n.unionTypeAnnotation)(t)};var n=r("./node_modules/@babel/types/lib/builders/generated/index.js"),s=r("./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js");},"./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){if("string"===e)return (0, n.stringTypeAnnotation)();if("number"===e)return (0, n.numberTypeAnnotation)();if("undefined"===e)return (0, n.voidTypeAnnotation)();if("boolean"===e)return (0, n.booleanTypeAnnotation)();if("function"===e)return (0, n.genericTypeAnnotation)((0, n.identifier)("Function"));if("object"===e)return (0, n.genericTypeAnnotation)((0, n.identifier)("Object"));if("symbol"===e)return (0, n.genericTypeAnnotation)((0, n.identifier)("Symbol"));if("bigint"===e)return (0, n.anyTypeAnnotation)();throw new Error("Invalid typeof value: "+e)};var n=r("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/builders/generated/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.arrayExpression=function(e){return (0, n.default)("ArrayExpression",...arguments)},t.assignmentExpression=function(e,t,r){return (0, n.default)("AssignmentExpression",...arguments)},t.binaryExpression=function(e,t,r){return (0, n.default)("BinaryExpression",...arguments)},t.interpreterDirective=function(e){return (0, n.default)("InterpreterDirective",...arguments)},t.directive=function(e){return (0, n.default)("Directive",...arguments)},t.directiveLiteral=function(e){return (0, n.default)("DirectiveLiteral",...arguments)},t.blockStatement=function(e,t){return (0, n.default)("BlockStatement",...arguments)},t.breakStatement=function(e){return (0, n.default)("BreakStatement",...arguments)},t.callExpression=function(e,t){return (0, n.default)("CallExpression",...arguments)},t.catchClause=function(e,t){return (0, n.default)("CatchClause",...arguments)},t.conditionalExpression=function(e,t,r){return (0, n.default)("ConditionalExpression",...arguments)},t.continueStatement=function(e){return (0, n.default)("ContinueStatement",...arguments)},t.debuggerStatement=function(){return (0, n.default)("DebuggerStatement",...arguments)},t.doWhileStatement=function(e,t){return (0, n.default)("DoWhileStatement",...arguments)},t.emptyStatement=function(){return (0, n.default)("EmptyStatement",...arguments)},t.expressionStatement=function(e){return (0, n.default)("ExpressionStatement",...arguments)},t.file=function(e,t,r){return (0, n.default)("File",...arguments)},t.forInStatement=function(e,t,r){return (0, n.default)("ForInStatement",...arguments)},t.forStatement=function(e,t,r,s){return (0, n.default)("ForStatement",...arguments)},t.functionDeclaration=function(e,t,r,s,i){return (0, n.default)("FunctionDeclaration",...arguments)},t.functionExpression=function(e,t,r,s,i){return (0, n.default)("FunctionExpression",...arguments)},t.identifier=function(e){return (0, n.default)("Identifier",...arguments)},t.ifStatement=function(e,t,r){return (0, n.default)("IfStatement",...arguments)},t.labeledStatement=function(e,t){return (0, n.default)("LabeledStatement",...arguments)},t.stringLiteral=function(e){return (0, n.default)("StringLiteral",...arguments)},t.numericLiteral=function(e){return (0, n.default)("NumericLiteral",...arguments)},t.nullLiteral=function(){return (0, n.default)("NullLiteral",...arguments)},t.booleanLiteral=function(e){return (0, n.default)("BooleanLiteral",...arguments)},t.regExpLiteral=function(e,t){return (0, n.default)("RegExpLiteral",...arguments)},t.logicalExpression=function(e,t,r){return (0, n.default)("LogicalExpression",...arguments)},t.memberExpression=function(e,t,r,s){return (0, n.default)("MemberExpression",...arguments)},t.newExpression=function(e,t){return (0, n.default)("NewExpression",...arguments)},t.program=function(e,t,r,s){return (0, n.default)("Program",...arguments)},t.objectExpression=function(e){return (0, n.default)("ObjectExpression",...arguments)},t.objectMethod=function(e,t,r,s,i,o,a){return (0, n.default)("ObjectMethod",...arguments)},t.objectProperty=function(e,t,r,s,i){return (0, n.default)("ObjectProperty",...arguments)},t.restElement=function(e){return (0, n.default)("RestElement",...arguments)},t.returnStatement=function(e){return (0, n.default)("ReturnStatement",...arguments)},t.sequenceExpression=function(e){return (0, n.default)("SequenceExpression",...arguments)},t.parenthesizedExpression=function(e){return (0, n.default)("ParenthesizedExpression",...arguments)},t.switchCase=function(e,t){return (0, n.default)("SwitchCase",...arguments)},t.switchStatement=function(e,t){return (0, n.default)("SwitchStatement",...arguments)},t.thisExpression=function(){return (0, n.default)("ThisExpression",...arguments)},t.throwStatement=function(e){return (0, n.default)("ThrowStatement",...arguments)},t.tryStatement=function(e,t,r){return (0, n.default)("TryStatement",...arguments)},t.unaryExpression=function(e,t,r){return (0, n.default)("UnaryExpression",...arguments)},t.updateExpression=function(e,t,r){return (0, n.default)("UpdateExpression",...arguments)},t.variableDeclaration=function(e,t){return (0, n.default)("VariableDeclaration",...arguments)},t.variableDeclarator=function(e,t){return (0, n.default)("VariableDeclarator",...arguments)},t.whileStatement=function(e,t){return (0, n.default)("WhileStatement",...arguments)},t.withStatement=function(e,t){return (0, n.default)("WithStatement",...arguments)},t.assignmentPattern=function(e,t){return (0, n.default)("AssignmentPattern",...arguments)},t.arrayPattern=function(e){return (0, n.default)("ArrayPattern",...arguments)},t.arrowFunctionExpression=function(e,t,r){return (0, n.default)("ArrowFunctionExpression",...arguments)},t.classBody=function(e){return (0, n.default)("ClassBody",...arguments)},t.classExpression=function(e,t,r,s){return (0, n.default)("ClassExpression",...arguments)},t.classDeclaration=function(e,t,r,s){return (0, n.default)("ClassDeclaration",...arguments)},t.exportAllDeclaration=function(e){return (0, n.default)("ExportAllDeclaration",...arguments)},t.exportDefaultDeclaration=function(e){return (0, n.default)("ExportDefaultDeclaration",...arguments)},t.exportNamedDeclaration=function(e,t,r){return (0, n.default)("ExportNamedDeclaration",...arguments)},t.exportSpecifier=function(e,t){return (0, n.default)("ExportSpecifier",...arguments)},t.forOfStatement=function(e,t,r,s){return (0, n.default)("ForOfStatement",...arguments)},t.importDeclaration=function(e,t){return (0, n.default)("ImportDeclaration",...arguments)},t.importDefaultSpecifier=function(e){return (0, n.default)("ImportDefaultSpecifier",...arguments)},t.importNamespaceSpecifier=function(e){return (0, n.default)("ImportNamespaceSpecifier",...arguments)},t.importSpecifier=function(e,t){return (0, n.default)("ImportSpecifier",...arguments)},t.metaProperty=function(e,t){return (0, n.default)("MetaProperty",...arguments)},t.classMethod=function(e,t,r,s,i,o,a,l){return (0, n.default)("ClassMethod",...arguments)},t.objectPattern=function(e){return (0, n.default)("ObjectPattern",...arguments)},t.spreadElement=function(e){return (0, n.default)("SpreadElement",...arguments)},t.super=function(){return (0, n.default)("Super",...arguments)},t.taggedTemplateExpression=function(e,t){return (0, n.default)("TaggedTemplateExpression",...arguments)},t.templateElement=function(e,t){return (0, n.default)("TemplateElement",...arguments)},t.templateLiteral=function(e,t){return (0, n.default)("TemplateLiteral",...arguments)},t.yieldExpression=function(e,t){return (0, n.default)("YieldExpression",...arguments)},t.awaitExpression=function(e){return (0, n.default)("AwaitExpression",...arguments)},t.import=function(){return (0, n.default)("Import",...arguments)},t.bigIntLiteral=function(e){return (0, n.default)("BigIntLiteral",...arguments)},t.exportNamespaceSpecifier=function(e){return (0, n.default)("ExportNamespaceSpecifier",...arguments)},t.optionalMemberExpression=function(e,t,r,s){return (0, n.default)("OptionalMemberExpression",...arguments)},t.optionalCallExpression=function(e,t,r){return (0, n.default)("OptionalCallExpression",...arguments)},t.anyTypeAnnotation=function(){return (0, n.default)("AnyTypeAnnotation",...arguments)},t.arrayTypeAnnotation=function(e){return (0, n.default)("ArrayTypeAnnotation",...arguments)},t.booleanTypeAnnotation=function(){return (0, n.default)("BooleanTypeAnnotation",...arguments)},t.booleanLiteralTypeAnnotation=function(e){return (0, n.default)("BooleanLiteralTypeAnnotation",...arguments)},t.nullLiteralTypeAnnotation=function(){return (0, n.default)("NullLiteralTypeAnnotation",...arguments)},t.classImplements=function(e,t){return (0, n.default)("ClassImplements",...arguments)},t.declareClass=function(e,t,r,s){return (0, n.default)("DeclareClass",...arguments)},t.declareFunction=function(e){return (0, n.default)("DeclareFunction",...arguments)},t.declareInterface=function(e,t,r,s){return (0, n.default)("DeclareInterface",...arguments)},t.declareModule=function(e,t,r){return (0, n.default)("DeclareModule",...arguments)},t.declareModuleExports=function(e){return (0, n.default)("DeclareModuleExports",...arguments)},t.declareTypeAlias=function(e,t,r){return (0, n.default)("DeclareTypeAlias",...arguments)},t.declareOpaqueType=function(e,t,r){return (0, n.default)("DeclareOpaqueType",...arguments)},t.declareVariable=function(e){return (0, n.default)("DeclareVariable",...arguments)},t.declareExportDeclaration=function(e,t,r){return (0, n.default)("DeclareExportDeclaration",...arguments)},t.declareExportAllDeclaration=function(e){return (0, n.default)("DeclareExportAllDeclaration",...arguments)},t.declaredPredicate=function(e){return (0, n.default)("DeclaredPredicate",...arguments)},t.existsTypeAnnotation=function(){return (0, n.default)("ExistsTypeAnnotation",...arguments)},t.functionTypeAnnotation=function(e,t,r,s){return (0, n.default)("FunctionTypeAnnotation",...arguments)},t.functionTypeParam=function(e,t){return (0, n.default)("FunctionTypeParam",...arguments)},t.genericTypeAnnotation=function(e,t){return (0, n.default)("GenericTypeAnnotation",...arguments)},t.inferredPredicate=function(){return (0, n.default)("InferredPredicate",...arguments)},t.interfaceExtends=function(e,t){return (0, n.default)("InterfaceExtends",...arguments)},t.interfaceDeclaration=function(e,t,r,s){return (0, n.default)("InterfaceDeclaration",...arguments)},t.interfaceTypeAnnotation=function(e,t){return (0, n.default)("InterfaceTypeAnnotation",...arguments)},t.intersectionTypeAnnotation=function(e){return (0, n.default)("IntersectionTypeAnnotation",...arguments)},t.mixedTypeAnnotation=function(){return (0, n.default)("MixedTypeAnnotation",...arguments)},t.emptyTypeAnnotation=function(){return (0, n.default)("EmptyTypeAnnotation",...arguments)},t.nullableTypeAnnotation=function(e){return (0, n.default)("NullableTypeAnnotation",...arguments)},t.numberLiteralTypeAnnotation=function(e){return (0, n.default)("NumberLiteralTypeAnnotation",...arguments)},t.numberTypeAnnotation=function(){return (0, n.default)("NumberTypeAnnotation",...arguments)},t.objectTypeAnnotation=function(e,t,r,s,i){return (0, n.default)("ObjectTypeAnnotation",...arguments)},t.objectTypeInternalSlot=function(e,t,r,s,i){return (0, n.default)("ObjectTypeInternalSlot",...arguments)},t.objectTypeCallProperty=function(e){return (0, n.default)("ObjectTypeCallProperty",...arguments)},t.objectTypeIndexer=function(e,t,r,s){return (0, n.default)("ObjectTypeIndexer",...arguments)},t.objectTypeProperty=function(e,t,r){return (0, n.default)("ObjectTypeProperty",...arguments)},t.objectTypeSpreadProperty=function(e){return (0, n.default)("ObjectTypeSpreadProperty",...arguments)},t.opaqueType=function(e,t,r,s){return (0, n.default)("OpaqueType",...arguments)},t.qualifiedTypeIdentifier=function(e,t){return (0, n.default)("QualifiedTypeIdentifier",...arguments)},t.stringLiteralTypeAnnotation=function(e){return (0, n.default)("StringLiteralTypeAnnotation",...arguments)},t.stringTypeAnnotation=function(){return (0, n.default)("StringTypeAnnotation",...arguments)},t.symbolTypeAnnotation=function(){return (0, n.default)("SymbolTypeAnnotation",...arguments)},t.thisTypeAnnotation=function(){return (0, n.default)("ThisTypeAnnotation",...arguments)},t.tupleTypeAnnotation=function(e){return (0, n.default)("TupleTypeAnnotation",...arguments)},t.typeofTypeAnnotation=function(e){return (0, n.default)("TypeofTypeAnnotation",...arguments)},t.typeAlias=function(e,t,r){return (0, n.default)("TypeAlias",...arguments)},t.typeAnnotation=function(e){return (0, n.default)("TypeAnnotation",...arguments)},t.typeCastExpression=function(e,t){return (0, n.default)("TypeCastExpression",...arguments)},t.typeParameter=function(e,t,r){return (0, n.default)("TypeParameter",...arguments)},t.typeParameterDeclaration=function(e){return (0, n.default)("TypeParameterDeclaration",...arguments)},t.typeParameterInstantiation=function(e){return (0, n.default)("TypeParameterInstantiation",...arguments)},t.unionTypeAnnotation=function(e){return (0, n.default)("UnionTypeAnnotation",...arguments)},t.variance=function(e){return (0, n.default)("Variance",...arguments)},t.voidTypeAnnotation=function(){return (0, n.default)("VoidTypeAnnotation",...arguments)},t.enumDeclaration=function(e,t){return (0, n.default)("EnumDeclaration",...arguments)},t.enumBooleanBody=function(e){return (0, n.default)("EnumBooleanBody",...arguments)},t.enumNumberBody=function(e){return (0, n.default)("EnumNumberBody",...arguments)},t.enumStringBody=function(e){return (0, n.default)("EnumStringBody",...arguments)},t.enumSymbolBody=function(e){return (0, n.default)("EnumSymbolBody",...arguments)},t.enumBooleanMember=function(e){return (0, n.default)("EnumBooleanMember",...arguments)},t.enumNumberMember=function(e,t){return (0, n.default)("EnumNumberMember",...arguments)},t.enumStringMember=function(e,t){return (0, n.default)("EnumStringMember",...arguments)},t.enumDefaultedMember=function(e){return (0, n.default)("EnumDefaultedMember",...arguments)},t.indexedAccessType=function(e,t){return (0, n.default)("IndexedAccessType",...arguments)},t.optionalIndexedAccessType=function(e,t){return (0, n.default)("OptionalIndexedAccessType",...arguments)},t.jSXAttribute=t.jsxAttribute=function(e,t){return (0, n.default)("JSXAttribute",...arguments)},t.jSXClosingElement=t.jsxClosingElement=function(e){return (0, n.default)("JSXClosingElement",...arguments)},t.jSXElement=t.jsxElement=function(e,t,r,s){return (0, n.default)("JSXElement",...arguments)},t.jSXEmptyExpression=t.jsxEmptyExpression=function(){return (0, n.default)("JSXEmptyExpression",...arguments)},t.jSXExpressionContainer=t.jsxExpressionContainer=function(e){return (0, n.default)("JSXExpressionContainer",...arguments)},t.jSXSpreadChild=t.jsxSpreadChild=function(e){return (0, n.default)("JSXSpreadChild",...arguments)},t.jSXIdentifier=t.jsxIdentifier=function(e){return (0, n.default)("JSXIdentifier",...arguments)},t.jSXMemberExpression=t.jsxMemberExpression=function(e,t){return (0, n.default)("JSXMemberExpression",...arguments)},t.jSXNamespacedName=t.jsxNamespacedName=function(e,t){return (0, n.default)("JSXNamespacedName",...arguments)},t.jSXOpeningElement=t.jsxOpeningElement=function(e,t,r){return (0, n.default)("JSXOpeningElement",...arguments)},t.jSXSpreadAttribute=t.jsxSpreadAttribute=function(e){return (0, n.default)("JSXSpreadAttribute",...arguments)},t.jSXText=t.jsxText=function(e){return (0, n.default)("JSXText",...arguments)},t.jSXFragment=t.jsxFragment=function(e,t,r){return (0, n.default)("JSXFragment",...arguments)},t.jSXOpeningFragment=t.jsxOpeningFragment=function(){return (0, n.default)("JSXOpeningFragment",...arguments)},t.jSXClosingFragment=t.jsxClosingFragment=function(){return (0, n.default)("JSXClosingFragment",...arguments)},t.noop=function(){return (0, n.default)("Noop",...arguments)},t.placeholder=function(e,t){return (0, n.default)("Placeholder",...arguments)},t.v8IntrinsicIdentifier=function(e){return (0, n.default)("V8IntrinsicIdentifier",...arguments)},t.argumentPlaceholder=function(){return (0, n.default)("ArgumentPlaceholder",...arguments)},t.bindExpression=function(e,t){return (0, n.default)("BindExpression",...arguments)},t.classProperty=function(e,t,r,s,i,o){return (0, n.default)("ClassProperty",...arguments)},t.pipelineTopicExpression=function(e){return (0, n.default)("PipelineTopicExpression",...arguments)},t.pipelineBareFunction=function(e){return (0, n.default)("PipelineBareFunction",...arguments)},t.pipelinePrimaryTopicReference=function(){return (0, n.default)("PipelinePrimaryTopicReference",...arguments)},t.classPrivateProperty=function(e,t,r,s){return (0, n.default)("ClassPrivateProperty",...arguments)},t.classPrivateMethod=function(e,t,r,s,i){return (0, n.default)("ClassPrivateMethod",...arguments)},t.importAttribute=function(e,t){return (0, n.default)("ImportAttribute",...arguments)},t.decorator=function(e){return (0, n.default)("Decorator",...arguments)},t.doExpression=function(e,t){return (0, n.default)("DoExpression",...arguments)},t.exportDefaultSpecifier=function(e){return (0, n.default)("ExportDefaultSpecifier",...arguments)},t.privateName=function(e){return (0, n.default)("PrivateName",...arguments)},t.recordExpression=function(e){return (0, n.default)("RecordExpression",...arguments)},t.tupleExpression=function(e){return (0, n.default)("TupleExpression",...arguments)},t.decimalLiteral=function(e){return (0, n.default)("DecimalLiteral",...arguments)},t.staticBlock=function(e){return (0, n.default)("StaticBlock",...arguments)},t.moduleExpression=function(e){return (0, n.default)("ModuleExpression",...arguments)},t.tSParameterProperty=t.tsParameterProperty=function(e){return (0, n.default)("TSParameterProperty",...arguments)},t.tSDeclareFunction=t.tsDeclareFunction=function(e,t,r,s){return (0, n.default)("TSDeclareFunction",...arguments)},t.tSDeclareMethod=t.tsDeclareMethod=function(e,t,r,s,i){return (0, n.default)("TSDeclareMethod",...arguments)},t.tSQualifiedName=t.tsQualifiedName=function(e,t){return (0, n.default)("TSQualifiedName",...arguments)},t.tSCallSignatureDeclaration=t.tsCallSignatureDeclaration=function(e,t,r){return (0, n.default)("TSCallSignatureDeclaration",...arguments)},t.tSConstructSignatureDeclaration=t.tsConstructSignatureDeclaration=function(e,t,r){return (0, n.default)("TSConstructSignatureDeclaration",...arguments)},t.tSPropertySignature=t.tsPropertySignature=function(e,t,r){return (0, n.default)("TSPropertySignature",...arguments)},t.tSMethodSignature=t.tsMethodSignature=function(e,t,r,s){return (0, n.default)("TSMethodSignature",...arguments)},t.tSIndexSignature=t.tsIndexSignature=function(e,t){return (0, n.default)("TSIndexSignature",...arguments)},t.tSAnyKeyword=t.tsAnyKeyword=function(){return (0, n.default)("TSAnyKeyword",...arguments)},t.tSBooleanKeyword=t.tsBooleanKeyword=function(){return (0, n.default)("TSBooleanKeyword",...arguments)},t.tSBigIntKeyword=t.tsBigIntKeyword=function(){return (0, n.default)("TSBigIntKeyword",...arguments)},t.tSIntrinsicKeyword=t.tsIntrinsicKeyword=function(){return (0, n.default)("TSIntrinsicKeyword",...arguments)},t.tSNeverKeyword=t.tsNeverKeyword=function(){return (0, n.default)("TSNeverKeyword",...arguments)},t.tSNullKeyword=t.tsNullKeyword=function(){return (0, n.default)("TSNullKeyword",...arguments)},t.tSNumberKeyword=t.tsNumberKeyword=function(){return (0, n.default)("TSNumberKeyword",...arguments)},t.tSObjectKeyword=t.tsObjectKeyword=function(){return (0, n.default)("TSObjectKeyword",...arguments)},t.tSStringKeyword=t.tsStringKeyword=function(){return (0, n.default)("TSStringKeyword",...arguments)},t.tSSymbolKeyword=t.tsSymbolKeyword=function(){return (0, n.default)("TSSymbolKeyword",...arguments)},t.tSUndefinedKeyword=t.tsUndefinedKeyword=function(){return (0, n.default)("TSUndefinedKeyword",...arguments)},t.tSUnknownKeyword=t.tsUnknownKeyword=function(){return (0, n.default)("TSUnknownKeyword",...arguments)},t.tSVoidKeyword=t.tsVoidKeyword=function(){return (0, n.default)("TSVoidKeyword",...arguments)},t.tSThisType=t.tsThisType=function(){return (0, n.default)("TSThisType",...arguments)},t.tSFunctionType=t.tsFunctionType=function(e,t,r){return (0, n.default)("TSFunctionType",...arguments)},t.tSConstructorType=t.tsConstructorType=function(e,t,r){return (0, n.default)("TSConstructorType",...arguments)},t.tSTypeReference=t.tsTypeReference=function(e,t){return (0, n.default)("TSTypeReference",...arguments)},t.tSTypePredicate=t.tsTypePredicate=function(e,t,r){return (0, n.default)("TSTypePredicate",...arguments)},t.tSTypeQuery=t.tsTypeQuery=function(e){return (0, n.default)("TSTypeQuery",...arguments)},t.tSTypeLiteral=t.tsTypeLiteral=function(e){return (0, n.default)("TSTypeLiteral",...arguments)},t.tSArrayType=t.tsArrayType=function(e){return (0, n.default)("TSArrayType",...arguments)},t.tSTupleType=t.tsTupleType=function(e){return (0, n.default)("TSTupleType",...arguments)},t.tSOptionalType=t.tsOptionalType=function(e){return (0, n.default)("TSOptionalType",...arguments)},t.tSRestType=t.tsRestType=function(e){return (0, n.default)("TSRestType",...arguments)},t.tSNamedTupleMember=t.tsNamedTupleMember=function(e,t,r){return (0, n.default)("TSNamedTupleMember",...arguments)},t.tSUnionType=t.tsUnionType=function(e){return (0, n.default)("TSUnionType",...arguments)},t.tSIntersectionType=t.tsIntersectionType=function(e){return (0, n.default)("TSIntersectionType",...arguments)},t.tSConditionalType=t.tsConditionalType=function(e,t,r,s){return (0, n.default)("TSConditionalType",...arguments)},t.tSInferType=t.tsInferType=function(e){return (0, n.default)("TSInferType",...arguments)},t.tSParenthesizedType=t.tsParenthesizedType=function(e){return (0, n.default)("TSParenthesizedType",...arguments)},t.tSTypeOperator=t.tsTypeOperator=function(e){return (0, n.default)("TSTypeOperator",...arguments)},t.tSIndexedAccessType=t.tsIndexedAccessType=function(e,t){return (0, n.default)("TSIndexedAccessType",...arguments)},t.tSMappedType=t.tsMappedType=function(e,t,r){return (0, n.default)("TSMappedType",...arguments)},t.tSLiteralType=t.tsLiteralType=function(e){return (0, n.default)("TSLiteralType",...arguments)},t.tSExpressionWithTypeArguments=t.tsExpressionWithTypeArguments=function(e,t){return (0, n.default)("TSExpressionWithTypeArguments",...arguments)},t.tSInterfaceDeclaration=t.tsInterfaceDeclaration=function(e,t,r,s){return (0, n.default)("TSInterfaceDeclaration",...arguments)},t.tSInterfaceBody=t.tsInterfaceBody=function(e){return (0, n.default)("TSInterfaceBody",...arguments)},t.tSTypeAliasDeclaration=t.tsTypeAliasDeclaration=function(e,t,r){return (0, n.default)("TSTypeAliasDeclaration",...arguments)},t.tSAsExpression=t.tsAsExpression=function(e,t){return (0, n.default)("TSAsExpression",...arguments)},t.tSTypeAssertion=t.tsTypeAssertion=function(e,t){return (0, n.default)("TSTypeAssertion",...arguments)},t.tSEnumDeclaration=t.tsEnumDeclaration=function(e,t){return (0, n.default)("TSEnumDeclaration",...arguments)},t.tSEnumMember=t.tsEnumMember=function(e,t){return (0, n.default)("TSEnumMember",...arguments)},t.tSModuleDeclaration=t.tsModuleDeclaration=function(e,t){return (0, n.default)("TSModuleDeclaration",...arguments)},t.tSModuleBlock=t.tsModuleBlock=function(e){return (0, n.default)("TSModuleBlock",...arguments)},t.tSImportType=t.tsImportType=function(e,t,r){return (0, n.default)("TSImportType",...arguments)},t.tSImportEqualsDeclaration=t.tsImportEqualsDeclaration=function(e,t){return (0, n.default)("TSImportEqualsDeclaration",...arguments)},t.tSExternalModuleReference=t.tsExternalModuleReference=function(e){return (0, n.default)("TSExternalModuleReference",...arguments)},t.tSNonNullExpression=t.tsNonNullExpression=function(e){return (0, n.default)("TSNonNullExpression",...arguments)},t.tSExportAssignment=t.tsExportAssignment=function(e){return (0, n.default)("TSExportAssignment",...arguments)},t.tSNamespaceExportDeclaration=t.tsNamespaceExportDeclaration=function(e){return (0, n.default)("TSNamespaceExportDeclaration",...arguments)},t.tSTypeAnnotation=t.tsTypeAnnotation=function(e){return (0, n.default)("TSTypeAnnotation",...arguments)},t.tSTypeParameterInstantiation=t.tsTypeParameterInstantiation=function(e){return (0, n.default)("TSTypeParameterInstantiation",...arguments)},t.tSTypeParameterDeclaration=t.tsTypeParameterDeclaration=function(e){return (0, n.default)("TSTypeParameterDeclaration",...arguments)},t.tSTypeParameter=t.tsTypeParameter=function(e,t,r){return (0, n.default)("TSTypeParameter",...arguments)},t.numberLiteral=function(...e){return console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),(0, n.default)("NumberLiteral",...e)},t.regexLiteral=function(...e){return console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),(0, n.default)("RegexLiteral",...e)},t.restProperty=function(...e){return console.trace("The node type RestProperty has been renamed to RestElement"),(0, n.default)("RestProperty",...e)},t.spreadProperty=function(...e){return console.trace("The node type SpreadProperty has been renamed to SpreadElement"),(0, n.default)("SpreadProperty",...e)};var n=r("./node_modules/@babel/types/lib/builders/builder.js");},"./node_modules/@babel/types/lib/builders/generated/uppercase.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"ArrayExpression",{enumerable:!0,get:function(){return n.arrayExpression}}),Object.defineProperty(t,"AssignmentExpression",{enumerable:!0,get:function(){return n.assignmentExpression}}),Object.defineProperty(t,"BinaryExpression",{enumerable:!0,get:function(){return n.binaryExpression}}),Object.defineProperty(t,"InterpreterDirective",{enumerable:!0,get:function(){return n.interpreterDirective}}),Object.defineProperty(t,"Directive",{enumerable:!0,get:function(){return n.directive}}),Object.defineProperty(t,"DirectiveLiteral",{enumerable:!0,get:function(){return n.directiveLiteral}}),Object.defineProperty(t,"BlockStatement",{enumerable:!0,get:function(){return n.blockStatement}}),Object.defineProperty(t,"BreakStatement",{enumerable:!0,get:function(){return n.breakStatement}}),Object.defineProperty(t,"CallExpression",{enumerable:!0,get:function(){return n.callExpression}}),Object.defineProperty(t,"CatchClause",{enumerable:!0,get:function(){return n.catchClause}}),Object.defineProperty(t,"ConditionalExpression",{enumerable:!0,get:function(){return n.conditionalExpression}}),Object.defineProperty(t,"ContinueStatement",{enumerable:!0,get:function(){return n.continueStatement}}),Object.defineProperty(t,"DebuggerStatement",{enumerable:!0,get:function(){return n.debuggerStatement}}),Object.defineProperty(t,"DoWhileStatement",{enumerable:!0,get:function(){return n.doWhileStatement}}),Object.defineProperty(t,"EmptyStatement",{enumerable:!0,get:function(){return n.emptyStatement}}),Object.defineProperty(t,"ExpressionStatement",{enumerable:!0,get:function(){return n.expressionStatement}}),Object.defineProperty(t,"File",{enumerable:!0,get:function(){return n.file}}),Object.defineProperty(t,"ForInStatement",{enumerable:!0,get:function(){return n.forInStatement}}),Object.defineProperty(t,"ForStatement",{enumerable:!0,get:function(){return n.forStatement}}),Object.defineProperty(t,"FunctionDeclaration",{enumerable:!0,get:function(){return n.functionDeclaration}}),Object.defineProperty(t,"FunctionExpression",{enumerable:!0,get:function(){return n.functionExpression}}),Object.defineProperty(t,"Identifier",{enumerable:!0,get:function(){return n.identifier}}),Object.defineProperty(t,"IfStatement",{enumerable:!0,get:function(){return n.ifStatement}}),Object.defineProperty(t,"LabeledStatement",{enumerable:!0,get:function(){return n.labeledStatement}}),Object.defineProperty(t,"StringLiteral",{enumerable:!0,get:function(){return n.stringLiteral}}),Object.defineProperty(t,"NumericLiteral",{enumerable:!0,get:function(){return n.numericLiteral}}),Object.defineProperty(t,"NullLiteral",{enumerable:!0,get:function(){return n.nullLiteral}}),Object.defineProperty(t,"BooleanLiteral",{enumerable:!0,get:function(){return n.booleanLiteral}}),Object.defineProperty(t,"RegExpLiteral",{enumerable:!0,get:function(){return n.regExpLiteral}}),Object.defineProperty(t,"LogicalExpression",{enumerable:!0,get:function(){return n.logicalExpression}}),Object.defineProperty(t,"MemberExpression",{enumerable:!0,get:function(){return n.memberExpression}}),Object.defineProperty(t,"NewExpression",{enumerable:!0,get:function(){return n.newExpression}}),Object.defineProperty(t,"Program",{enumerable:!0,get:function(){return n.program}}),Object.defineProperty(t,"ObjectExpression",{enumerable:!0,get:function(){return n.objectExpression}}),Object.defineProperty(t,"ObjectMethod",{enumerable:!0,get:function(){return n.objectMethod}}),Object.defineProperty(t,"ObjectProperty",{enumerable:!0,get:function(){return n.objectProperty}}),Object.defineProperty(t,"RestElement",{enumerable:!0,get:function(){return n.restElement}}),Object.defineProperty(t,"ReturnStatement",{enumerable:!0,get:function(){return n.returnStatement}}),Object.defineProperty(t,"SequenceExpression",{enumerable:!0,get:function(){return n.sequenceExpression}}),Object.defineProperty(t,"ParenthesizedExpression",{enumerable:!0,get:function(){return n.parenthesizedExpression}}),Object.defineProperty(t,"SwitchCase",{enumerable:!0,get:function(){return n.switchCase}}),Object.defineProperty(t,"SwitchStatement",{enumerable:!0,get:function(){return n.switchStatement}}),Object.defineProperty(t,"ThisExpression",{enumerable:!0,get:function(){return n.thisExpression}}),Object.defineProperty(t,"ThrowStatement",{enumerable:!0,get:function(){return n.throwStatement}}),Object.defineProperty(t,"TryStatement",{enumerable:!0,get:function(){return n.tryStatement}}),Object.defineProperty(t,"UnaryExpression",{enumerable:!0,get:function(){return n.unaryExpression}}),Object.defineProperty(t,"UpdateExpression",{enumerable:!0,get:function(){return n.updateExpression}}),Object.defineProperty(t,"VariableDeclaration",{enumerable:!0,get:function(){return n.variableDeclaration}}),Object.defineProperty(t,"VariableDeclarator",{enumerable:!0,get:function(){return n.variableDeclarator}}),Object.defineProperty(t,"WhileStatement",{enumerable:!0,get:function(){return n.whileStatement}}),Object.defineProperty(t,"WithStatement",{enumerable:!0,get:function(){return n.withStatement}}),Object.defineProperty(t,"AssignmentPattern",{enumerable:!0,get:function(){return n.assignmentPattern}}),Object.defineProperty(t,"ArrayPattern",{enumerable:!0,get:function(){return n.arrayPattern}}),Object.defineProperty(t,"ArrowFunctionExpression",{enumerable:!0,get:function(){return n.arrowFunctionExpression}}),Object.defineProperty(t,"ClassBody",{enumerable:!0,get:function(){return n.classBody}}),Object.defineProperty(t,"ClassExpression",{enumerable:!0,get:function(){return n.classExpression}}),Object.defineProperty(t,"ClassDeclaration",{enumerable:!0,get:function(){return n.classDeclaration}}),Object.defineProperty(t,"ExportAllDeclaration",{enumerable:!0,get:function(){return n.exportAllDeclaration}}),Object.defineProperty(t,"ExportDefaultDeclaration",{enumerable:!0,get:function(){return n.exportDefaultDeclaration}}),Object.defineProperty(t,"ExportNamedDeclaration",{enumerable:!0,get:function(){return n.exportNamedDeclaration}}),Object.defineProperty(t,"ExportSpecifier",{enumerable:!0,get:function(){return n.exportSpecifier}}),Object.defineProperty(t,"ForOfStatement",{enumerable:!0,get:function(){return n.forOfStatement}}),Object.defineProperty(t,"ImportDeclaration",{enumerable:!0,get:function(){return n.importDeclaration}}),Object.defineProperty(t,"ImportDefaultSpecifier",{enumerable:!0,get:function(){return n.importDefaultSpecifier}}),Object.defineProperty(t,"ImportNamespaceSpecifier",{enumerable:!0,get:function(){return n.importNamespaceSpecifier}}),Object.defineProperty(t,"ImportSpecifier",{enumerable:!0,get:function(){return n.importSpecifier}}),Object.defineProperty(t,"MetaProperty",{enumerable:!0,get:function(){return n.metaProperty}}),Object.defineProperty(t,"ClassMethod",{enumerable:!0,get:function(){return n.classMethod}}),Object.defineProperty(t,"ObjectPattern",{enumerable:!0,get:function(){return n.objectPattern}}),Object.defineProperty(t,"SpreadElement",{enumerable:!0,get:function(){return n.spreadElement}}),Object.defineProperty(t,"Super",{enumerable:!0,get:function(){return n.super}}),Object.defineProperty(t,"TaggedTemplateExpression",{enumerable:!0,get:function(){return n.taggedTemplateExpression}}),Object.defineProperty(t,"TemplateElement",{enumerable:!0,get:function(){return n.templateElement}}),Object.defineProperty(t,"TemplateLiteral",{enumerable:!0,get:function(){return n.templateLiteral}}),Object.defineProperty(t,"YieldExpression",{enumerable:!0,get:function(){return n.yieldExpression}}),Object.defineProperty(t,"AwaitExpression",{enumerable:!0,get:function(){return n.awaitExpression}}),Object.defineProperty(t,"Import",{enumerable:!0,get:function(){return n.import}}),Object.defineProperty(t,"BigIntLiteral",{enumerable:!0,get:function(){return n.bigIntLiteral}}),Object.defineProperty(t,"ExportNamespaceSpecifier",{enumerable:!0,get:function(){return n.exportNamespaceSpecifier}}),Object.defineProperty(t,"OptionalMemberExpression",{enumerable:!0,get:function(){return n.optionalMemberExpression}}),Object.defineProperty(t,"OptionalCallExpression",{enumerable:!0,get:function(){return n.optionalCallExpression}}),Object.defineProperty(t,"AnyTypeAnnotation",{enumerable:!0,get:function(){return n.anyTypeAnnotation}}),Object.defineProperty(t,"ArrayTypeAnnotation",{enumerable:!0,get:function(){return n.arrayTypeAnnotation}}),Object.defineProperty(t,"BooleanTypeAnnotation",{enumerable:!0,get:function(){return n.booleanTypeAnnotation}}),Object.defineProperty(t,"BooleanLiteralTypeAnnotation",{enumerable:!0,get:function(){return n.booleanLiteralTypeAnnotation}}),Object.defineProperty(t,"NullLiteralTypeAnnotation",{enumerable:!0,get:function(){return n.nullLiteralTypeAnnotation}}),Object.defineProperty(t,"ClassImplements",{enumerable:!0,get:function(){return n.classImplements}}),Object.defineProperty(t,"DeclareClass",{enumerable:!0,get:function(){return n.declareClass}}),Object.defineProperty(t,"DeclareFunction",{enumerable:!0,get:function(){return n.declareFunction}}),Object.defineProperty(t,"DeclareInterface",{enumerable:!0,get:function(){return n.declareInterface}}),Object.defineProperty(t,"DeclareModule",{enumerable:!0,get:function(){return n.declareModule}}),Object.defineProperty(t,"DeclareModuleExports",{enumerable:!0,get:function(){return n.declareModuleExports}}),Object.defineProperty(t,"DeclareTypeAlias",{enumerable:!0,get:function(){return n.declareTypeAlias}}),Object.defineProperty(t,"DeclareOpaqueType",{enumerable:!0,get:function(){return n.declareOpaqueType}}),Object.defineProperty(t,"DeclareVariable",{enumerable:!0,get:function(){return n.declareVariable}}),Object.defineProperty(t,"DeclareExportDeclaration",{enumerable:!0,get:function(){return n.declareExportDeclaration}}),Object.defineProperty(t,"DeclareExportAllDeclaration",{enumerable:!0,get:function(){return n.declareExportAllDeclaration}}),Object.defineProperty(t,"DeclaredPredicate",{enumerable:!0,get:function(){return n.declaredPredicate}}),Object.defineProperty(t,"ExistsTypeAnnotation",{enumerable:!0,get:function(){return n.existsTypeAnnotation}}),Object.defineProperty(t,"FunctionTypeAnnotation",{enumerable:!0,get:function(){return n.functionTypeAnnotation}}),Object.defineProperty(t,"FunctionTypeParam",{enumerable:!0,get:function(){return n.functionTypeParam}}),Object.defineProperty(t,"GenericTypeAnnotation",{enumerable:!0,get:function(){return n.genericTypeAnnotation}}),Object.defineProperty(t,"InferredPredicate",{enumerable:!0,get:function(){return n.inferredPredicate}}),Object.defineProperty(t,"InterfaceExtends",{enumerable:!0,get:function(){return n.interfaceExtends}}),Object.defineProperty(t,"InterfaceDeclaration",{enumerable:!0,get:function(){return n.interfaceDeclaration}}),Object.defineProperty(t,"InterfaceTypeAnnotation",{enumerable:!0,get:function(){return n.interfaceTypeAnnotation}}),Object.defineProperty(t,"IntersectionTypeAnnotation",{enumerable:!0,get:function(){return n.intersectionTypeAnnotation}}),Object.defineProperty(t,"MixedTypeAnnotation",{enumerable:!0,get:function(){return n.mixedTypeAnnotation}}),Object.defineProperty(t,"EmptyTypeAnnotation",{enumerable:!0,get:function(){return n.emptyTypeAnnotation}}),Object.defineProperty(t,"NullableTypeAnnotation",{enumerable:!0,get:function(){return n.nullableTypeAnnotation}}),Object.defineProperty(t,"NumberLiteralTypeAnnotation",{enumerable:!0,get:function(){return n.numberLiteralTypeAnnotation}}),Object.defineProperty(t,"NumberTypeAnnotation",{enumerable:!0,get:function(){return n.numberTypeAnnotation}}),Object.defineProperty(t,"ObjectTypeAnnotation",{enumerable:!0,get:function(){return n.objectTypeAnnotation}}),Object.defineProperty(t,"ObjectTypeInternalSlot",{enumerable:!0,get:function(){return n.objectTypeInternalSlot}}),Object.defineProperty(t,"ObjectTypeCallProperty",{enumerable:!0,get:function(){return n.objectTypeCallProperty}}),Object.defineProperty(t,"ObjectTypeIndexer",{enumerable:!0,get:function(){return n.objectTypeIndexer}}),Object.defineProperty(t,"ObjectTypeProperty",{enumerable:!0,get:function(){return n.objectTypeProperty}}),Object.defineProperty(t,"ObjectTypeSpreadProperty",{enumerable:!0,get:function(){return n.objectTypeSpreadProperty}}),Object.defineProperty(t,"OpaqueType",{enumerable:!0,get:function(){return n.opaqueType}}),Object.defineProperty(t,"QualifiedTypeIdentifier",{enumerable:!0,get:function(){return n.qualifiedTypeIdentifier}}),Object.defineProperty(t,"StringLiteralTypeAnnotation",{enumerable:!0,get:function(){return n.stringLiteralTypeAnnotation}}),Object.defineProperty(t,"StringTypeAnnotation",{enumerable:!0,get:function(){return n.stringTypeAnnotation}}),Object.defineProperty(t,"SymbolTypeAnnotation",{enumerable:!0,get:function(){return n.symbolTypeAnnotation}}),Object.defineProperty(t,"ThisTypeAnnotation",{enumerable:!0,get:function(){return n.thisTypeAnnotation}}),Object.defineProperty(t,"TupleTypeAnnotation",{enumerable:!0,get:function(){return n.tupleTypeAnnotation}}),Object.defineProperty(t,"TypeofTypeAnnotation",{enumerable:!0,get:function(){return n.typeofTypeAnnotation}}),Object.defineProperty(t,"TypeAlias",{enumerable:!0,get:function(){return n.typeAlias}}),Object.defineProperty(t,"TypeAnnotation",{enumerable:!0,get:function(){return n.typeAnnotation}}),Object.defineProperty(t,"TypeCastExpression",{enumerable:!0,get:function(){return n.typeCastExpression}}),Object.defineProperty(t,"TypeParameter",{enumerable:!0,get:function(){return n.typeParameter}}),Object.defineProperty(t,"TypeParameterDeclaration",{enumerable:!0,get:function(){return n.typeParameterDeclaration}}),Object.defineProperty(t,"TypeParameterInstantiation",{enumerable:!0,get:function(){return n.typeParameterInstantiation}}),Object.defineProperty(t,"UnionTypeAnnotation",{enumerable:!0,get:function(){return n.unionTypeAnnotation}}),Object.defineProperty(t,"Variance",{enumerable:!0,get:function(){return n.variance}}),Object.defineProperty(t,"VoidTypeAnnotation",{enumerable:!0,get:function(){return n.voidTypeAnnotation}}),Object.defineProperty(t,"EnumDeclaration",{enumerable:!0,get:function(){return n.enumDeclaration}}),Object.defineProperty(t,"EnumBooleanBody",{enumerable:!0,get:function(){return n.enumBooleanBody}}),Object.defineProperty(t,"EnumNumberBody",{enumerable:!0,get:function(){return n.enumNumberBody}}),Object.defineProperty(t,"EnumStringBody",{enumerable:!0,get:function(){return n.enumStringBody}}),Object.defineProperty(t,"EnumSymbolBody",{enumerable:!0,get:function(){return n.enumSymbolBody}}),Object.defineProperty(t,"EnumBooleanMember",{enumerable:!0,get:function(){return n.enumBooleanMember}}),Object.defineProperty(t,"EnumNumberMember",{enumerable:!0,get:function(){return n.enumNumberMember}}),Object.defineProperty(t,"EnumStringMember",{enumerable:!0,get:function(){return n.enumStringMember}}),Object.defineProperty(t,"EnumDefaultedMember",{enumerable:!0,get:function(){return n.enumDefaultedMember}}),Object.defineProperty(t,"IndexedAccessType",{enumerable:!0,get:function(){return n.indexedAccessType}}),Object.defineProperty(t,"OptionalIndexedAccessType",{enumerable:!0,get:function(){return n.optionalIndexedAccessType}}),Object.defineProperty(t,"JSXAttribute",{enumerable:!0,get:function(){return n.jsxAttribute}}),Object.defineProperty(t,"JSXClosingElement",{enumerable:!0,get:function(){return n.jsxClosingElement}}),Object.defineProperty(t,"JSXElement",{enumerable:!0,get:function(){return n.jsxElement}}),Object.defineProperty(t,"JSXEmptyExpression",{enumerable:!0,get:function(){return n.jsxEmptyExpression}}),Object.defineProperty(t,"JSXExpressionContainer",{enumerable:!0,get:function(){return n.jsxExpressionContainer}}),Object.defineProperty(t,"JSXSpreadChild",{enumerable:!0,get:function(){return n.jsxSpreadChild}}),Object.defineProperty(t,"JSXIdentifier",{enumerable:!0,get:function(){return n.jsxIdentifier}}),Object.defineProperty(t,"JSXMemberExpression",{enumerable:!0,get:function(){return n.jsxMemberExpression}}),Object.defineProperty(t,"JSXNamespacedName",{enumerable:!0,get:function(){return n.jsxNamespacedName}}),Object.defineProperty(t,"JSXOpeningElement",{enumerable:!0,get:function(){return n.jsxOpeningElement}}),Object.defineProperty(t,"JSXSpreadAttribute",{enumerable:!0,get:function(){return n.jsxSpreadAttribute}}),Object.defineProperty(t,"JSXText",{enumerable:!0,get:function(){return n.jsxText}}),Object.defineProperty(t,"JSXFragment",{enumerable:!0,get:function(){return n.jsxFragment}}),Object.defineProperty(t,"JSXOpeningFragment",{enumerable:!0,get:function(){return n.jsxOpeningFragment}}),Object.defineProperty(t,"JSXClosingFragment",{enumerable:!0,get:function(){return n.jsxClosingFragment}}),Object.defineProperty(t,"Noop",{enumerable:!0,get:function(){return n.noop}}),Object.defineProperty(t,"Placeholder",{enumerable:!0,get:function(){return n.placeholder}}),Object.defineProperty(t,"V8IntrinsicIdentifier",{enumerable:!0,get:function(){return n.v8IntrinsicIdentifier}}),Object.defineProperty(t,"ArgumentPlaceholder",{enumerable:!0,get:function(){return n.argumentPlaceholder}}),Object.defineProperty(t,"BindExpression",{enumerable:!0,get:function(){return n.bindExpression}}),Object.defineProperty(t,"ClassProperty",{enumerable:!0,get:function(){return n.classProperty}}),Object.defineProperty(t,"PipelineTopicExpression",{enumerable:!0,get:function(){return n.pipelineTopicExpression}}),Object.defineProperty(t,"PipelineBareFunction",{enumerable:!0,get:function(){return n.pipelineBareFunction}}),Object.defineProperty(t,"PipelinePrimaryTopicReference",{enumerable:!0,get:function(){return n.pipelinePrimaryTopicReference}}),Object.defineProperty(t,"ClassPrivateProperty",{enumerable:!0,get:function(){return n.classPrivateProperty}}),Object.defineProperty(t,"ClassPrivateMethod",{enumerable:!0,get:function(){return n.classPrivateMethod}}),Object.defineProperty(t,"ImportAttribute",{enumerable:!0,get:function(){return n.importAttribute}}),Object.defineProperty(t,"Decorator",{enumerable:!0,get:function(){return n.decorator}}),Object.defineProperty(t,"DoExpression",{enumerable:!0,get:function(){return n.doExpression}}),Object.defineProperty(t,"ExportDefaultSpecifier",{enumerable:!0,get:function(){return n.exportDefaultSpecifier}}),Object.defineProperty(t,"PrivateName",{enumerable:!0,get:function(){return n.privateName}}),Object.defineProperty(t,"RecordExpression",{enumerable:!0,get:function(){return n.recordExpression}}),Object.defineProperty(t,"TupleExpression",{enumerable:!0,get:function(){return n.tupleExpression}}),Object.defineProperty(t,"DecimalLiteral",{enumerable:!0,get:function(){return n.decimalLiteral}}),Object.defineProperty(t,"StaticBlock",{enumerable:!0,get:function(){return n.staticBlock}}),Object.defineProperty(t,"ModuleExpression",{enumerable:!0,get:function(){return n.moduleExpression}}),Object.defineProperty(t,"TSParameterProperty",{enumerable:!0,get:function(){return n.tsParameterProperty}}),Object.defineProperty(t,"TSDeclareFunction",{enumerable:!0,get:function(){return n.tsDeclareFunction}}),Object.defineProperty(t,"TSDeclareMethod",{enumerable:!0,get:function(){return n.tsDeclareMethod}}),Object.defineProperty(t,"TSQualifiedName",{enumerable:!0,get:function(){return n.tsQualifiedName}}),Object.defineProperty(t,"TSCallSignatureDeclaration",{enumerable:!0,get:function(){return n.tsCallSignatureDeclaration}}),Object.defineProperty(t,"TSConstructSignatureDeclaration",{enumerable:!0,get:function(){return n.tsConstructSignatureDeclaration}}),Object.defineProperty(t,"TSPropertySignature",{enumerable:!0,get:function(){return n.tsPropertySignature}}),Object.defineProperty(t,"TSMethodSignature",{enumerable:!0,get:function(){return n.tsMethodSignature}}),Object.defineProperty(t,"TSIndexSignature",{enumerable:!0,get:function(){return n.tsIndexSignature}}),Object.defineProperty(t,"TSAnyKeyword",{enumerable:!0,get:function(){return n.tsAnyKeyword}}),Object.defineProperty(t,"TSBooleanKeyword",{enumerable:!0,get:function(){return n.tsBooleanKeyword}}),Object.defineProperty(t,"TSBigIntKeyword",{enumerable:!0,get:function(){return n.tsBigIntKeyword}}),Object.defineProperty(t,"TSIntrinsicKeyword",{enumerable:!0,get:function(){return n.tsIntrinsicKeyword}}),Object.defineProperty(t,"TSNeverKeyword",{enumerable:!0,get:function(){return n.tsNeverKeyword}}),Object.defineProperty(t,"TSNullKeyword",{enumerable:!0,get:function(){return n.tsNullKeyword}}),Object.defineProperty(t,"TSNumberKeyword",{enumerable:!0,get:function(){return n.tsNumberKeyword}}),Object.defineProperty(t,"TSObjectKeyword",{enumerable:!0,get:function(){return n.tsObjectKeyword}}),Object.defineProperty(t,"TSStringKeyword",{enumerable:!0,get:function(){return n.tsStringKeyword}}),Object.defineProperty(t,"TSSymbolKeyword",{enumerable:!0,get:function(){return n.tsSymbolKeyword}}),Object.defineProperty(t,"TSUndefinedKeyword",{enumerable:!0,get:function(){return n.tsUndefinedKeyword}}),Object.defineProperty(t,"TSUnknownKeyword",{enumerable:!0,get:function(){return n.tsUnknownKeyword}}),Object.defineProperty(t,"TSVoidKeyword",{enumerable:!0,get:function(){return n.tsVoidKeyword}}),Object.defineProperty(t,"TSThisType",{enumerable:!0,get:function(){return n.tsThisType}}),Object.defineProperty(t,"TSFunctionType",{enumerable:!0,get:function(){return n.tsFunctionType}}),Object.defineProperty(t,"TSConstructorType",{enumerable:!0,get:function(){return n.tsConstructorType}}),Object.defineProperty(t,"TSTypeReference",{enumerable:!0,get:function(){return n.tsTypeReference}}),Object.defineProperty(t,"TSTypePredicate",{enumerable:!0,get:function(){return n.tsTypePredicate}}),Object.defineProperty(t,"TSTypeQuery",{enumerable:!0,get:function(){return n.tsTypeQuery}}),Object.defineProperty(t,"TSTypeLiteral",{enumerable:!0,get:function(){return n.tsTypeLiteral}}),Object.defineProperty(t,"TSArrayType",{enumerable:!0,get:function(){return n.tsArrayType}}),Object.defineProperty(t,"TSTupleType",{enumerable:!0,get:function(){return n.tsTupleType}}),Object.defineProperty(t,"TSOptionalType",{enumerable:!0,get:function(){return n.tsOptionalType}}),Object.defineProperty(t,"TSRestType",{enumerable:!0,get:function(){return n.tsRestType}}),Object.defineProperty(t,"TSNamedTupleMember",{enumerable:!0,get:function(){return n.tsNamedTupleMember}}),Object.defineProperty(t,"TSUnionType",{enumerable:!0,get:function(){return n.tsUnionType}}),Object.defineProperty(t,"TSIntersectionType",{enumerable:!0,get:function(){return n.tsIntersectionType}}),Object.defineProperty(t,"TSConditionalType",{enumerable:!0,get:function(){return n.tsConditionalType}}),Object.defineProperty(t,"TSInferType",{enumerable:!0,get:function(){return n.tsInferType}}),Object.defineProperty(t,"TSParenthesizedType",{enumerable:!0,get:function(){return n.tsParenthesizedType}}),Object.defineProperty(t,"TSTypeOperator",{enumerable:!0,get:function(){return n.tsTypeOperator}}),Object.defineProperty(t,"TSIndexedAccessType",{enumerable:!0,get:function(){return n.tsIndexedAccessType}}),Object.defineProperty(t,"TSMappedType",{enumerable:!0,get:function(){return n.tsMappedType}}),Object.defineProperty(t,"TSLiteralType",{enumerable:!0,get:function(){return n.tsLiteralType}}),Object.defineProperty(t,"TSExpressionWithTypeArguments",{enumerable:!0,get:function(){return n.tsExpressionWithTypeArguments}}),Object.defineProperty(t,"TSInterfaceDeclaration",{enumerable:!0,get:function(){return n.tsInterfaceDeclaration}}),Object.defineProperty(t,"TSInterfaceBody",{enumerable:!0,get:function(){return n.tsInterfaceBody}}),Object.defineProperty(t,"TSTypeAliasDeclaration",{enumerable:!0,get:function(){return n.tsTypeAliasDeclaration}}),Object.defineProperty(t,"TSAsExpression",{enumerable:!0,get:function(){return n.tsAsExpression}}),Object.defineProperty(t,"TSTypeAssertion",{enumerable:!0,get:function(){return n.tsTypeAssertion}}),Object.defineProperty(t,"TSEnumDeclaration",{enumerable:!0,get:function(){return n.tsEnumDeclaration}}),Object.defineProperty(t,"TSEnumMember",{enumerable:!0,get:function(){return n.tsEnumMember}}),Object.defineProperty(t,"TSModuleDeclaration",{enumerable:!0,get:function(){return n.tsModuleDeclaration}}),Object.defineProperty(t,"TSModuleBlock",{enumerable:!0,get:function(){return n.tsModuleBlock}}),Object.defineProperty(t,"TSImportType",{enumerable:!0,get:function(){return n.tsImportType}}),Object.defineProperty(t,"TSImportEqualsDeclaration",{enumerable:!0,get:function(){return n.tsImportEqualsDeclaration}}),Object.defineProperty(t,"TSExternalModuleReference",{enumerable:!0,get:function(){return n.tsExternalModuleReference}}),Object.defineProperty(t,"TSNonNullExpression",{enumerable:!0,get:function(){return n.tsNonNullExpression}}),Object.defineProperty(t,"TSExportAssignment",{enumerable:!0,get:function(){return n.tsExportAssignment}}),Object.defineProperty(t,"TSNamespaceExportDeclaration",{enumerable:!0,get:function(){return n.tsNamespaceExportDeclaration}}),Object.defineProperty(t,"TSTypeAnnotation",{enumerable:!0,get:function(){return n.tsTypeAnnotation}}),Object.defineProperty(t,"TSTypeParameterInstantiation",{enumerable:!0,get:function(){return n.tsTypeParameterInstantiation}}),Object.defineProperty(t,"TSTypeParameterDeclaration",{enumerable:!0,get:function(){return n.tsTypeParameterDeclaration}}),Object.defineProperty(t,"TSTypeParameter",{enumerable:!0,get:function(){return n.tsTypeParameter}}),Object.defineProperty(t,"NumberLiteral",{enumerable:!0,get:function(){return n.numberLiteral}}),Object.defineProperty(t,"RegexLiteral",{enumerable:!0,get:function(){return n.regexLiteral}}),Object.defineProperty(t,"RestProperty",{enumerable:!0,get:function(){return n.restProperty}}),Object.defineProperty(t,"SpreadProperty",{enumerable:!0,get:function(){return n.spreadProperty}});var n=r("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/builders/react/buildChildren.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){const t=[];for(let r=0;r<e.children.length;r++){let i=e.children[r];(0, n.isJSXText)(i)?(0, s.default)(i,t):((0, n.isJSXExpressionContainer)(i)&&(i=i.expression),(0, n.isJSXEmptyExpression)(i)||t.push(i));}return t};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js"),s=r("./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js");},"./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){const t=e.map((e=>e.typeAnnotation)),r=(0, s.default)(t);return 1===r.length?r[0]:(0, n.tsUnionType)(r)};var n=r("./node_modules/@babel/types/lib/builders/generated/index.js"),s=r("./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js");},"./node_modules/@babel/types/lib/clone/clone.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return (0, n.default)(e,!1)};var n=r("./node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/@babel/types/lib/clone/cloneDeep.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return (0, n.default)(e)};var n=r("./node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return (0, n.default)(e,!0,!0)};var n=r("./node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/@babel/types/lib/clone/cloneNode.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=l;var n=r("./node_modules/@babel/types/lib/definitions/index.js"),s=r("./node_modules/@babel/types/lib/validators/generated/index.js");const i=Function.call.bind(Object.prototype.hasOwnProperty);function o(e,t,r){return e&&"string"==typeof e.type?l(e,t,r):e}function a(e,t,r){return Array.isArray(e)?e.map((e=>o(e,t,r))):o(e,t,r)}function l(e,t=!0,r=!1){if(!e)return e;const{type:o}=e,l={type:e.type};if((0, s.isIdentifier)(e))l.name=e.name,i(e,"optional")&&"boolean"==typeof e.optional&&(l.optional=e.optional),i(e,"typeAnnotation")&&(l.typeAnnotation=t?a(e.typeAnnotation,!0,r):e.typeAnnotation);else {if(!i(n.NODE_FIELDS,o))throw new Error(`Unknown node type: "${o}"`);for(const c of Object.keys(n.NODE_FIELDS[o]))i(e,c)&&(l[c]=t?(0, s.isFile)(e)&&"comments"===c?u(e.comments,t,r):a(e[c],!0,r):e[c]);}return i(e,"loc")&&(l.loc=r?null:e.loc),i(e,"leadingComments")&&(l.leadingComments=u(e.leadingComments,t,r)),i(e,"innerComments")&&(l.innerComments=u(e.innerComments,t,r)),i(e,"trailingComments")&&(l.trailingComments=u(e.trailingComments,t,r)),i(e,"extra")&&(l.extra=Object.assign({},e.extra)),l}function u(e,t,r){return e&&t?e.map((({type:e,value:t,loc:n})=>r?{type:e,value:t,loc:null}:{type:e,value:t,loc:n})):e}},"./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return (0, n.default)(e,!1,!0)};var n=r("./node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/@babel/types/lib/comments/addComment.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r,s){return (0, n.default)(e,t,[{type:s?"CommentLine":"CommentBlock",value:r}])};var n=r("./node_modules/@babel/types/lib/comments/addComments.js");},"./node_modules/@babel/types/lib/comments/addComments.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(!r||!e)return e;const n=`${t}Comments`;return e[n]?e[n]="leading"===t?r.concat(e[n]):e[n].concat(r):e[n]=r,e};},"./node_modules/@babel/types/lib/comments/inheritInnerComments.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){(0, n.default)("innerComments",e,t);};var n=r("./node_modules/@babel/types/lib/utils/inherit.js");},"./node_modules/@babel/types/lib/comments/inheritLeadingComments.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){(0, n.default)("leadingComments",e,t);};var n=r("./node_modules/@babel/types/lib/utils/inherit.js");},"./node_modules/@babel/types/lib/comments/inheritTrailingComments.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){(0, n.default)("trailingComments",e,t);};var n=r("./node_modules/@babel/types/lib/utils/inherit.js");},"./node_modules/@babel/types/lib/comments/inheritsComments.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){return (0, n.default)(e,t),(0, s.default)(e,t),(0, i.default)(e,t),e};var n=r("./node_modules/@babel/types/lib/comments/inheritTrailingComments.js"),s=r("./node_modules/@babel/types/lib/comments/inheritLeadingComments.js"),i=r("./node_modules/@babel/types/lib/comments/inheritInnerComments.js");},"./node_modules/@babel/types/lib/comments/removeComments.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return n.COMMENT_KEYS.forEach((t=>{e[t]=null;})),e};var n=r("./node_modules/@babel/types/lib/constants/index.js");},"./node_modules/@babel/types/lib/constants/generated/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TSBASETYPE_TYPES=t.TSTYPE_TYPES=t.TSTYPEELEMENT_TYPES=t.PRIVATE_TYPES=t.JSX_TYPES=t.ENUMMEMBER_TYPES=t.ENUMBODY_TYPES=t.FLOWPREDICATE_TYPES=t.FLOWDECLARATION_TYPES=t.FLOWBASEANNOTATION_TYPES=t.FLOWTYPE_TYPES=t.FLOW_TYPES=t.MODULESPECIFIER_TYPES=t.EXPORTDECLARATION_TYPES=t.MODULEDECLARATION_TYPES=t.CLASS_TYPES=t.PATTERN_TYPES=t.UNARYLIKE_TYPES=t.PROPERTY_TYPES=t.OBJECTMEMBER_TYPES=t.METHOD_TYPES=t.USERWHITESPACABLE_TYPES=t.IMMUTABLE_TYPES=t.LITERAL_TYPES=t.TSENTITYNAME_TYPES=t.LVAL_TYPES=t.PATTERNLIKE_TYPES=t.DECLARATION_TYPES=t.PUREISH_TYPES=t.FUNCTIONPARENT_TYPES=t.FUNCTION_TYPES=t.FORXSTATEMENT_TYPES=t.FOR_TYPES=t.EXPRESSIONWRAPPER_TYPES=t.WHILE_TYPES=t.LOOP_TYPES=t.CONDITIONAL_TYPES=t.COMPLETIONSTATEMENT_TYPES=t.TERMINATORLESS_TYPES=t.STATEMENT_TYPES=t.BLOCK_TYPES=t.BLOCKPARENT_TYPES=t.SCOPABLE_TYPES=t.BINARY_TYPES=t.EXPRESSION_TYPES=void 0;var n=r("./node_modules/@babel/types/lib/definitions/index.js");const s=n.FLIPPED_ALIAS_KEYS.Expression;t.EXPRESSION_TYPES=s;const i=n.FLIPPED_ALIAS_KEYS.Binary;t.BINARY_TYPES=i;const o=n.FLIPPED_ALIAS_KEYS.Scopable;t.SCOPABLE_TYPES=o;const a=n.FLIPPED_ALIAS_KEYS.BlockParent;t.BLOCKPARENT_TYPES=a;const l=n.FLIPPED_ALIAS_KEYS.Block;t.BLOCK_TYPES=l;const u=n.FLIPPED_ALIAS_KEYS.Statement;t.STATEMENT_TYPES=u;const c=n.FLIPPED_ALIAS_KEYS.Terminatorless;t.TERMINATORLESS_TYPES=c;const p=n.FLIPPED_ALIAS_KEYS.CompletionStatement;t.COMPLETIONSTATEMENT_TYPES=p;const d=n.FLIPPED_ALIAS_KEYS.Conditional;t.CONDITIONAL_TYPES=d;const f=n.FLIPPED_ALIAS_KEYS.Loop;t.LOOP_TYPES=f;const h=n.FLIPPED_ALIAS_KEYS.While;t.WHILE_TYPES=h;const m=n.FLIPPED_ALIAS_KEYS.ExpressionWrapper;t.EXPRESSIONWRAPPER_TYPES=m;const y=n.FLIPPED_ALIAS_KEYS.For;t.FOR_TYPES=y;const b=n.FLIPPED_ALIAS_KEYS.ForXStatement;t.FORXSTATEMENT_TYPES=b;const g=n.FLIPPED_ALIAS_KEYS.Function;t.FUNCTION_TYPES=g;const E=n.FLIPPED_ALIAS_KEYS.FunctionParent;t.FUNCTIONPARENT_TYPES=E;const v=n.FLIPPED_ALIAS_KEYS.Pureish;t.PUREISH_TYPES=v;const x=n.FLIPPED_ALIAS_KEYS.Declaration;t.DECLARATION_TYPES=x;const T=n.FLIPPED_ALIAS_KEYS.PatternLike;t.PATTERNLIKE_TYPES=T;const S=n.FLIPPED_ALIAS_KEYS.LVal;t.LVAL_TYPES=S;const P=n.FLIPPED_ALIAS_KEYS.TSEntityName;t.TSENTITYNAME_TYPES=P;const A=n.FLIPPED_ALIAS_KEYS.Literal;t.LITERAL_TYPES=A;const w=n.FLIPPED_ALIAS_KEYS.Immutable;t.IMMUTABLE_TYPES=w;const C=n.FLIPPED_ALIAS_KEYS.UserWhitespacable;t.USERWHITESPACABLE_TYPES=C;const D=n.FLIPPED_ALIAS_KEYS.Method;t.METHOD_TYPES=D;const _=n.FLIPPED_ALIAS_KEYS.ObjectMember;t.OBJECTMEMBER_TYPES=_;const O=n.FLIPPED_ALIAS_KEYS.Property;t.PROPERTY_TYPES=O;const j=n.FLIPPED_ALIAS_KEYS.UnaryLike;t.UNARYLIKE_TYPES=j;const I=n.FLIPPED_ALIAS_KEYS.Pattern;t.PATTERN_TYPES=I;const N=n.FLIPPED_ALIAS_KEYS.Class;t.CLASS_TYPES=N;const k=n.FLIPPED_ALIAS_KEYS.ModuleDeclaration;t.MODULEDECLARATION_TYPES=k;const F=n.FLIPPED_ALIAS_KEYS.ExportDeclaration;t.EXPORTDECLARATION_TYPES=F;const L=n.FLIPPED_ALIAS_KEYS.ModuleSpecifier;t.MODULESPECIFIER_TYPES=L;const M=n.FLIPPED_ALIAS_KEYS.Flow;t.FLOW_TYPES=M;const B=n.FLIPPED_ALIAS_KEYS.FlowType;t.FLOWTYPE_TYPES=B;const R=n.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;t.FLOWBASEANNOTATION_TYPES=R;const U=n.FLIPPED_ALIAS_KEYS.FlowDeclaration;t.FLOWDECLARATION_TYPES=U;const V=n.FLIPPED_ALIAS_KEYS.FlowPredicate;t.FLOWPREDICATE_TYPES=V;const W=n.FLIPPED_ALIAS_KEYS.EnumBody;t.ENUMBODY_TYPES=W;const $=n.FLIPPED_ALIAS_KEYS.EnumMember;t.ENUMMEMBER_TYPES=$;const K=n.FLIPPED_ALIAS_KEYS.JSX;t.JSX_TYPES=K;const q=n.FLIPPED_ALIAS_KEYS.Private;t.PRIVATE_TYPES=q;const G=n.FLIPPED_ALIAS_KEYS.TSTypeElement;t.TSTYPEELEMENT_TYPES=G;const H=n.FLIPPED_ALIAS_KEYS.TSType;t.TSTYPE_TYPES=H;const J=n.FLIPPED_ALIAS_KEYS.TSBaseType;t.TSBASETYPE_TYPES=J;},"./node_modules/@babel/types/lib/constants/index.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.NOT_LOCAL_BINDING=t.BLOCK_SCOPED_SYMBOL=t.INHERIT_KEYS=t.UNARY_OPERATORS=t.STRING_UNARY_OPERATORS=t.NUMBER_UNARY_OPERATORS=t.BOOLEAN_UNARY_OPERATORS=t.ASSIGNMENT_OPERATORS=t.BINARY_OPERATORS=t.NUMBER_BINARY_OPERATORS=t.BOOLEAN_BINARY_OPERATORS=t.COMPARISON_BINARY_OPERATORS=t.EQUALITY_BINARY_OPERATORS=t.BOOLEAN_NUMBER_BINARY_OPERATORS=t.UPDATE_OPERATORS=t.LOGICAL_OPERATORS=t.COMMENT_KEYS=t.FOR_INIT_KEYS=t.FLATTENABLE_KEYS=t.STATEMENT_OR_BLOCK_KEYS=void 0,t.STATEMENT_OR_BLOCK_KEYS=["consequent","body","alternate"],t.FLATTENABLE_KEYS=["body","expressions"],t.FOR_INIT_KEYS=["left","init"],t.COMMENT_KEYS=["leadingComments","trailingComments","innerComments"];const r=["||","&&","??"];t.LOGICAL_OPERATORS=r,t.UPDATE_OPERATORS=["++","--"];const n=[">","<",">=","<="];t.BOOLEAN_NUMBER_BINARY_OPERATORS=n;const s=["==","===","!=","!=="];t.EQUALITY_BINARY_OPERATORS=s;const i=[...s,"in","instanceof"];t.COMPARISON_BINARY_OPERATORS=i;const o=[...i,...n];t.BOOLEAN_BINARY_OPERATORS=o;const a=["-","/","%","*","**","&","|",">>",">>>","<<","^"];t.NUMBER_BINARY_OPERATORS=a;const l=["+",...a,...o];t.BINARY_OPERATORS=l;const u=["=","+=",...a.map((e=>e+"=")),...r.map((e=>e+"="))];t.ASSIGNMENT_OPERATORS=u;const c=["delete","!"];t.BOOLEAN_UNARY_OPERATORS=c;const p=["+","-","~"];t.NUMBER_UNARY_OPERATORS=p;const d=["typeof"];t.STRING_UNARY_OPERATORS=d;const f=["void","throw",...c,...p,...d];t.UNARY_OPERATORS=f,t.INHERIT_KEYS={optional:["typeAnnotation","typeParameters","returnType"],force:["start","loc","end"]};const h=Symbol.for("var used to be block scoped");t.BLOCK_SCOPED_SYMBOL=h;const m=Symbol.for("should not be considered a local binding");t.NOT_LOCAL_BINDING=m;},"./node_modules/@babel/types/lib/converters/ensureBlock.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t="body"){return e[t]=(0, n.default)(e[t],e)};var n=r("./node_modules/@babel/types/lib/converters/toBlock.js");},"./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function e(t,r,a){const l=[];let u=!0;for(const c of t)if((0, s.isEmptyStatement)(c)||(u=!1),(0, s.isExpression)(c))l.push(c);else if((0, s.isExpressionStatement)(c))l.push(c.expression);else if((0, s.isVariableDeclaration)(c)){if("var"!==c.kind)return;for(const e of c.declarations){const t=(0, n.default)(e);for(const e of Object.keys(t))a.push({kind:c.kind,id:(0, o.default)(t[e])});e.init&&l.push((0, i.assignmentExpression)("=",e.id,e.init));}u=!0;}else if((0, s.isIfStatement)(c)){const t=c.consequent?e([c.consequent],r,a):r.buildUndefinedNode(),n=c.alternate?e([c.alternate],r,a):r.buildUndefinedNode();if(!t||!n)return;l.push((0, i.conditionalExpression)(c.test,t,n));}else if((0, s.isBlockStatement)(c)){const t=e(c.body,r,a);if(!t)return;l.push(t);}else {if(!(0, s.isEmptyStatement)(c))return;0===t.indexOf(c)&&(u=!0);}return u&&l.push(r.buildUndefinedNode()),1===l.length?l[0]:(0, i.sequenceExpression)(l)};var n=r("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"),s=r("./node_modules/@babel/types/lib/validators/generated/index.js"),i=r("./node_modules/@babel/types/lib/builders/generated/index.js"),o=r("./node_modules/@babel/types/lib/clone/cloneNode.js");},"./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return "eval"!==(e=(0, n.default)(e))&&"arguments"!==e||(e="_"+e),e};var n=r("./node_modules/@babel/types/lib/converters/toIdentifier.js");},"./node_modules/@babel/types/lib/converters/toBlock.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if((0, n.isBlockStatement)(e))return e;let r=[];return (0, n.isEmptyStatement)(e)?r=[]:((0, n.isStatement)(e)||(e=(0, n.isFunction)(t)?(0, s.returnStatement)(e):(0, s.expressionStatement)(e)),r=[e]),(0, s.blockStatement)(r)};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js"),s=r("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/converters/toComputedKey.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t=e.key||e.property){return !e.computed&&(0, n.isIdentifier)(t)&&(t=(0, s.stringLiteral)(t.name)),t};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js"),s=r("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/converters/toExpression.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/types/lib/validators/generated/index.js");t.default=function(e){if((0, n.isExpressionStatement)(e)&&(e=e.expression),(0, n.isExpression)(e))return e;if((0, n.isClass)(e)?e.type="ClassExpression":(0, n.isFunction)(e)&&(e.type="FunctionExpression"),!(0, n.isExpression)(e))throw new Error(`cannot turn ${e.type} to an expression`);return e};},"./node_modules/@babel/types/lib/converters/toIdentifier.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){e+="";let t="";for(const r of e)t+=(0, s.isIdentifierChar)(r.codePointAt(0))?r:"-";return t=t.replace(/^[-0-9]+/,""),t=t.replace(/[-\s]+(.)?/g,(function(e,t){return t?t.toUpperCase():""})),(0, n.default)(t)||(t=`_${t}`),t||"_"};var n=r("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"),s=r("./node_modules/@babel/helper-validator-identifier/lib/index.js");},"./node_modules/@babel/types/lib/converters/toKeyAlias.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;var n=r("./node_modules/@babel/types/lib/validators/generated/index.js"),s=r("./node_modules/@babel/types/lib/clone/cloneNode.js"),i=r("./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js");function o(e,t=e.key){let r;return "method"===e.kind?o.increment()+"":(r=(0, n.isIdentifier)(t)?t.name:(0, n.isStringLiteral)(t)?JSON.stringify(t.value):JSON.stringify((0, i.default)((0, s.default)(t))),e.computed&&(r=`[${r}]`),e.static&&(r=`static:${r}`),r)}o.uid=0,o.increment=function(){return o.uid>=Number.MAX_SAFE_INTEGER?o.uid=0:o.uid++};},"./node_modules/@babel/types/lib/converters/toSequenceExpression.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(null==e||!e.length)return;const r=[],s=(0, n.default)(e,t,r);if(s){for(const e of r)t.push(e);return s}};var n=r("./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js");},"./node_modules/@babel/types/lib/converters/toStatement.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/types/lib/validators/generated/index.js"),s=r("./node_modules/@babel/types/lib/builders/generated/index.js");t.default=function(e,t){if((0, n.isStatement)(e))return e;let r,i=!1;if((0, n.isClass)(e))i=!0,r="ClassDeclaration";else if((0, n.isFunction)(e))i=!0,r="FunctionDeclaration";else if((0, n.isAssignmentExpression)(e))return (0, s.expressionStatement)(e);if(i&&!e.id&&(r=!1),!r){if(t)return !1;throw new Error(`cannot turn ${e.type} to a statement`)}return e.type=r,e};},"./node_modules/@babel/types/lib/converters/valueToNode.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"),s=r("./node_modules/@babel/types/lib/builders/generated/index.js");t.default=function e(t){if(void 0===t)return (0, s.identifier)("undefined");if(!0===t||!1===t)return (0, s.booleanLiteral)(t);if(null===t)return (0, s.nullLiteral)();if("string"==typeof t)return (0, s.stringLiteral)(t);if("number"==typeof t){let e;if(Number.isFinite(t))e=(0, s.numericLiteral)(Math.abs(t));else {let r;r=Number.isNaN(t)?(0, s.numericLiteral)(0):(0, s.numericLiteral)(1),e=(0, s.binaryExpression)("/",r,(0, s.numericLiteral)(0));}return (t<0||Object.is(t,-0))&&(e=(0, s.unaryExpression)("-",e)),e}if(function(e){return "[object RegExp]"===i(e)}(t)){const e=t.source,r=t.toString().match(/\/([a-z]+|)$/)[1];return (0, s.regExpLiteral)(e,r)}if(Array.isArray(t))return (0, s.arrayExpression)(t.map(e));if(function(e){if("object"!=typeof e||null===e||"[object Object]"!==Object.prototype.toString.call(e))return !1;const t=Object.getPrototypeOf(e);return null===t||null===Object.getPrototypeOf(t)}(t)){const r=[];for(const i of Object.keys(t)){let o;o=(0, n.default)(i)?(0, s.identifier)(i):(0, s.stringLiteral)(i),r.push((0, s.objectProperty)(o,e(t[i])));}return (0, s.objectExpression)(r)}throw new Error("don't know how to turn this value into a node")};const i=Function.call.bind(Object.prototype.toString);},"./node_modules/@babel/types/lib/definitions/core.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.classMethodOrDeclareMethodCommon=t.classMethodOrPropertyCommon=t.patternLikeCommon=t.functionDeclarationCommon=t.functionTypeAnnotationCommon=t.functionCommon=void 0;var n=r("./node_modules/@babel/types/lib/validators/is.js"),s=r("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"),i=r("./node_modules/@babel/helper-validator-identifier/lib/index.js"),o=r("./node_modules/@babel/types/lib/constants/index.js"),a=r("./node_modules/@babel/types/lib/definitions/utils.js");(0, a.default)("ArrayExpression",{fields:{elements:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeOrValueType)("null","Expression","SpreadElement"))),default:process.env.BABEL_TYPES_8_BREAKING?void 0:[]}},visitor:["elements"],aliases:["Expression"]}),(0, a.default)("AssignmentExpression",{fields:{operator:{validate:function(){if(!process.env.BABEL_TYPES_8_BREAKING)return (0, a.assertValueType)("string");const e=(0, a.assertOneOf)(...o.ASSIGNMENT_OPERATORS),t=(0, a.assertOneOf)("=");return function(r,s,i){((0, n.default)("Pattern",r.left)?t:e)(r,s,i);}}()},left:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, a.assertNodeType)("Identifier","MemberExpression","ArrayPattern","ObjectPattern"):(0, a.assertNodeType)("LVal")},right:{validate:(0, a.assertNodeType)("Expression")}},builder:["operator","left","right"],visitor:["left","right"],aliases:["Expression"]}),(0, a.default)("BinaryExpression",{builder:["operator","left","right"],fields:{operator:{validate:(0, a.assertOneOf)(...o.BINARY_OPERATORS)},left:{validate:function(){const e=(0, a.assertNodeType)("Expression"),t=(0, a.assertNodeType)("Expression","PrivateName"),r=function(r,n,s){("in"===r.operator?t:e)(r,n,s);};return r.oneOfNodeTypes=["Expression","PrivateName"],r}()},right:{validate:(0, a.assertNodeType)("Expression")}},visitor:["left","right"],aliases:["Binary","Expression"]}),(0, a.default)("InterpreterDirective",{builder:["value"],fields:{value:{validate:(0, a.assertValueType)("string")}}}),(0, a.default)("Directive",{visitor:["value"],fields:{value:{validate:(0, a.assertNodeType)("DirectiveLiteral")}}}),(0, a.default)("DirectiveLiteral",{builder:["value"],fields:{value:{validate:(0, a.assertValueType)("string")}}}),(0, a.default)("BlockStatement",{builder:["body","directives"],visitor:["directives","body"],fields:{directives:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Directive"))),default:[]},body:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Statement")))}},aliases:["Scopable","BlockParent","Block","Statement"]}),(0, a.default)("BreakStatement",{visitor:["label"],fields:{label:{validate:(0, a.assertNodeType)("Identifier"),optional:!0}},aliases:["Statement","Terminatorless","CompletionStatement"]}),(0, a.default)("CallExpression",{visitor:["callee","arguments","typeParameters","typeArguments"],builder:["callee","arguments"],aliases:["Expression"],fields:Object.assign({callee:{validate:(0, a.assertNodeType)("Expression","V8IntrinsicIdentifier")},arguments:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Expression","SpreadElement","JSXNamespacedName","ArgumentPlaceholder")))}},process.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0, a.assertOneOf)(!0,!1),optional:!0}},{typeArguments:{validate:(0, a.assertNodeType)("TypeParameterInstantiation"),optional:!0},typeParameters:{validate:(0, a.assertNodeType)("TSTypeParameterInstantiation"),optional:!0}})}),(0, a.default)("CatchClause",{visitor:["param","body"],fields:{param:{validate:(0, a.assertNodeType)("Identifier","ArrayPattern","ObjectPattern"),optional:!0},body:{validate:(0, a.assertNodeType)("BlockStatement")}},aliases:["Scopable","BlockParent"]}),(0, a.default)("ConditionalExpression",{visitor:["test","consequent","alternate"],fields:{test:{validate:(0, a.assertNodeType)("Expression")},consequent:{validate:(0, a.assertNodeType)("Expression")},alternate:{validate:(0, a.assertNodeType)("Expression")}},aliases:["Expression","Conditional"]}),(0, a.default)("ContinueStatement",{visitor:["label"],fields:{label:{validate:(0, a.assertNodeType)("Identifier"),optional:!0}},aliases:["Statement","Terminatorless","CompletionStatement"]}),(0, a.default)("DebuggerStatement",{aliases:["Statement"]}),(0, a.default)("DoWhileStatement",{visitor:["test","body"],fields:{test:{validate:(0, a.assertNodeType)("Expression")},body:{validate:(0, a.assertNodeType)("Statement")}},aliases:["Statement","BlockParent","Loop","While","Scopable"]}),(0, a.default)("EmptyStatement",{aliases:["Statement"]}),(0, a.default)("ExpressionStatement",{visitor:["expression"],fields:{expression:{validate:(0, a.assertNodeType)("Expression")}},aliases:["Statement","ExpressionWrapper"]}),(0, a.default)("File",{builder:["program","comments","tokens"],visitor:["program"],fields:{program:{validate:(0, a.assertNodeType)("Program")},comments:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, a.assertEach)((0, a.assertNodeType)("CommentBlock","CommentLine")):Object.assign((()=>{}),{each:{oneOfNodeTypes:["CommentBlock","CommentLine"]}}),optional:!0},tokens:{validate:(0, a.assertEach)(Object.assign((()=>{}),{type:"any"})),optional:!0}}}),(0, a.default)("ForInStatement",{visitor:["left","right","body"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, a.assertNodeType)("VariableDeclaration","Identifier","MemberExpression","ArrayPattern","ObjectPattern"):(0, a.assertNodeType)("VariableDeclaration","LVal")},right:{validate:(0, a.assertNodeType)("Expression")},body:{validate:(0, a.assertNodeType)("Statement")}}}),(0, a.default)("ForStatement",{visitor:["init","test","update","body"],aliases:["Scopable","Statement","For","BlockParent","Loop"],fields:{init:{validate:(0, a.assertNodeType)("VariableDeclaration","Expression"),optional:!0},test:{validate:(0, a.assertNodeType)("Expression"),optional:!0},update:{validate:(0, a.assertNodeType)("Expression"),optional:!0},body:{validate:(0, a.assertNodeType)("Statement")}}});const l={params:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Identifier","Pattern","RestElement","TSParameterProperty")))},generator:{default:!1},async:{default:!1}};t.functionCommon=l;const u={returnType:{validate:(0, a.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},typeParameters:{validate:(0, a.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0}};t.functionTypeAnnotationCommon=u;const c=Object.assign({},l,{declare:{validate:(0, a.assertValueType)("boolean"),optional:!0},id:{validate:(0, a.assertNodeType)("Identifier"),optional:!0}});t.functionDeclarationCommon=c,(0, a.default)("FunctionDeclaration",{builder:["id","params","body","generator","async"],visitor:["id","params","body","returnType","typeParameters"],fields:Object.assign({},c,u,{body:{validate:(0, a.assertNodeType)("BlockStatement")}}),aliases:["Scopable","Function","BlockParent","FunctionParent","Statement","Pureish","Declaration"],validate:function(){if(!process.env.BABEL_TYPES_8_BREAKING)return ()=>{};const e=(0, a.assertNodeType)("Identifier");return function(t,r,s){(0, n.default)("ExportDefaultDeclaration",t)||e(s,"id",s.id);}}()}),(0, a.default)("FunctionExpression",{inherits:"FunctionDeclaration",aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:Object.assign({},l,u,{id:{validate:(0, a.assertNodeType)("Identifier"),optional:!0},body:{validate:(0, a.assertNodeType)("BlockStatement")}})});const p={typeAnnotation:{validate:(0, a.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},decorators:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Decorator")))}};t.patternLikeCommon=p,(0, a.default)("Identifier",{builder:["name"],visitor:["typeAnnotation","decorators"],aliases:["Expression","PatternLike","LVal","TSEntityName"],fields:Object.assign({},p,{name:{validate:(0, a.chain)((0, a.assertValueType)("string"),Object.assign((function(e,t,r){if(process.env.BABEL_TYPES_8_BREAKING&&!(0, s.default)(r,!1))throw new TypeError(`"${r}" is not a valid identifier name`)}),{type:"string"}))},optional:{validate:(0, a.assertValueType)("boolean"),optional:!0}}),validate(e,t,r){if(!process.env.BABEL_TYPES_8_BREAKING)return;const s=/\.(\w+)$/.exec(t);if(!s)return;const[,o]=s,a={computed:!1};if("property"===o){if((0, n.default)("MemberExpression",e,a))return;if((0, n.default)("OptionalMemberExpression",e,a))return}else if("key"===o){if((0, n.default)("Property",e,a))return;if((0, n.default)("Method",e,a))return}else if("exported"===o){if((0, n.default)("ExportSpecifier",e))return}else if("imported"===o){if((0, n.default)("ImportSpecifier",e,{imported:r}))return}else if("meta"===o&&(0, n.default)("MetaProperty",e,{meta:r}))return;if(((0, i.isKeyword)(r.name)||(0, i.isReservedWord)(r.name,!1))&&"this"!==r.name)throw new TypeError(`"${r.name}" is not a valid identifier`)}}),(0, a.default)("IfStatement",{visitor:["test","consequent","alternate"],aliases:["Statement","Conditional"],fields:{test:{validate:(0, a.assertNodeType)("Expression")},consequent:{validate:(0, a.assertNodeType)("Statement")},alternate:{optional:!0,validate:(0, a.assertNodeType)("Statement")}}}),(0, a.default)("LabeledStatement",{visitor:["label","body"],aliases:["Statement"],fields:{label:{validate:(0, a.assertNodeType)("Identifier")},body:{validate:(0, a.assertNodeType)("Statement")}}}),(0, a.default)("StringLiteral",{builder:["value"],fields:{value:{validate:(0, a.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0, a.default)("NumericLiteral",{builder:["value"],deprecatedAlias:"NumberLiteral",fields:{value:{validate:(0, a.assertValueType)("number")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0, a.default)("NullLiteral",{aliases:["Expression","Pureish","Literal","Immutable"]}),(0, a.default)("BooleanLiteral",{builder:["value"],fields:{value:{validate:(0, a.assertValueType)("boolean")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0, a.default)("RegExpLiteral",{builder:["pattern","flags"],deprecatedAlias:"RegexLiteral",aliases:["Expression","Pureish","Literal"],fields:{pattern:{validate:(0, a.assertValueType)("string")},flags:{validate:(0, a.chain)((0, a.assertValueType)("string"),Object.assign((function(e,t,r){if(!process.env.BABEL_TYPES_8_BREAKING)return;const n=/[^gimsuy]/.exec(r);if(n)throw new TypeError(`"${n[0]}" is not a valid RegExp flag`)}),{type:"string"})),default:""}}}),(0, a.default)("LogicalExpression",{builder:["operator","left","right"],visitor:["left","right"],aliases:["Binary","Expression"],fields:{operator:{validate:(0, a.assertOneOf)(...o.LOGICAL_OPERATORS)},left:{validate:(0, a.assertNodeType)("Expression")},right:{validate:(0, a.assertNodeType)("Expression")}}}),(0, a.default)("MemberExpression",{builder:["object","property","computed","optional"],visitor:["object","property"],aliases:["Expression","LVal"],fields:Object.assign({object:{validate:(0, a.assertNodeType)("Expression")},property:{validate:function(){const e=(0, a.assertNodeType)("Identifier","PrivateName"),t=(0, a.assertNodeType)("Expression"),r=function(r,n,s){(r.computed?t:e)(r,n,s);};return r.oneOfNodeTypes=["Expression","Identifier","PrivateName"],r}()},computed:{default:!1}},process.env.BABEL_TYPES_8_BREAKING?{}:{optional:{validate:(0, a.assertOneOf)(!0,!1),optional:!0}})}),(0, a.default)("NewExpression",{inherits:"CallExpression"}),(0, a.default)("Program",{visitor:["directives","body"],builder:["body","directives","sourceType","interpreter"],fields:{sourceFile:{validate:(0, a.assertValueType)("string")},sourceType:{validate:(0, a.assertOneOf)("script","module"),default:"script"},interpreter:{validate:(0, a.assertNodeType)("InterpreterDirective"),default:null,optional:!0},directives:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Directive"))),default:[]},body:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Statement")))}},aliases:["Scopable","BlockParent","Block"]}),(0, a.default)("ObjectExpression",{visitor:["properties"],aliases:["Expression"],fields:{properties:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("ObjectMethod","ObjectProperty","SpreadElement")))}}}),(0, a.default)("ObjectMethod",{builder:["kind","key","params","body","computed","generator","async"],fields:Object.assign({},l,u,{kind:Object.assign({validate:(0, a.assertOneOf)("method","get","set")},process.env.BABEL_TYPES_8_BREAKING?{}:{default:"method"}),computed:{default:!1},key:{validate:function(){const e=(0, a.assertNodeType)("Identifier","StringLiteral","NumericLiteral"),t=(0, a.assertNodeType)("Expression"),r=function(r,n,s){(r.computed?t:e)(r,n,s);};return r.oneOfNodeTypes=["Expression","Identifier","StringLiteral","NumericLiteral"],r}()},decorators:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Decorator"))),optional:!0},body:{validate:(0, a.assertNodeType)("BlockStatement")}}),visitor:["key","params","body","decorators","returnType","typeParameters"],aliases:["UserWhitespacable","Function","Scopable","BlockParent","FunctionParent","Method","ObjectMember"]}),(0, a.default)("ObjectProperty",{builder:["key","value","computed","shorthand",...process.env.BABEL_TYPES_8_BREAKING?[]:["decorators"]],fields:{computed:{default:!1},key:{validate:function(){const e=(0, a.assertNodeType)("Identifier","StringLiteral","NumericLiteral"),t=(0, a.assertNodeType)("Expression"),r=function(r,n,s){(r.computed?t:e)(r,n,s);};return r.oneOfNodeTypes=["Expression","Identifier","StringLiteral","NumericLiteral"],r}()},value:{validate:(0, a.assertNodeType)("Expression","PatternLike")},shorthand:{validate:(0, a.chain)((0, a.assertValueType)("boolean"),Object.assign((function(e,t,r){if(process.env.BABEL_TYPES_8_BREAKING&&r&&e.computed)throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true")}),{type:"boolean"}),(function(e,t,r){if(process.env.BABEL_TYPES_8_BREAKING&&r&&!(0, n.default)("Identifier",e.key))throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier")})),default:!1},decorators:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Decorator"))),optional:!0}},visitor:["key","value","decorators"],aliases:["UserWhitespacable","Property","ObjectMember"],validate:function(){const e=(0, a.assertNodeType)("Identifier","Pattern"),t=(0, a.assertNodeType)("Expression");return function(r,s,i){process.env.BABEL_TYPES_8_BREAKING&&((0, n.default)("ObjectPattern",r)?e:t)(i,"value",i.value);}}()}),(0, a.default)("RestElement",{visitor:["argument","typeAnnotation"],builder:["argument"],aliases:["LVal","PatternLike"],deprecatedAlias:"RestProperty",fields:Object.assign({},p,{argument:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, a.assertNodeType)("Identifier","Pattern","MemberExpression"):(0, a.assertNodeType)("LVal")}}),validate(e,t){if(!process.env.BABEL_TYPES_8_BREAKING)return;const r=/(\w+)\[(\d+)\]/.exec(t);if(!r)throw new Error("Internal Babel error: malformed key.");const[,n,s]=r;if(e[n].length>s+1)throw new TypeError(`RestElement must be last element of ${n}`)}}),(0, a.default)("ReturnStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0, a.assertNodeType)("Expression"),optional:!0}}}),(0, a.default)("SequenceExpression",{visitor:["expressions"],fields:{expressions:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Expression")))}},aliases:["Expression"]}),(0, a.default)("ParenthesizedExpression",{visitor:["expression"],aliases:["Expression","ExpressionWrapper"],fields:{expression:{validate:(0, a.assertNodeType)("Expression")}}}),(0, a.default)("SwitchCase",{visitor:["test","consequent"],fields:{test:{validate:(0, a.assertNodeType)("Expression"),optional:!0},consequent:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Statement")))}}}),(0, a.default)("SwitchStatement",{visitor:["discriminant","cases"],aliases:["Statement","BlockParent","Scopable"],fields:{discriminant:{validate:(0, a.assertNodeType)("Expression")},cases:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("SwitchCase")))}}}),(0, a.default)("ThisExpression",{aliases:["Expression"]}),(0, a.default)("ThrowStatement",{visitor:["argument"],aliases:["Statement","Terminatorless","CompletionStatement"],fields:{argument:{validate:(0, a.assertNodeType)("Expression")}}}),(0, a.default)("TryStatement",{visitor:["block","handler","finalizer"],aliases:["Statement"],fields:{block:{validate:(0, a.chain)((0, a.assertNodeType)("BlockStatement"),Object.assign((function(e){if(process.env.BABEL_TYPES_8_BREAKING&&!e.handler&&!e.finalizer)throw new TypeError("TryStatement expects either a handler or finalizer, or both")}),{oneOfNodeTypes:["BlockStatement"]}))},handler:{optional:!0,validate:(0, a.assertNodeType)("CatchClause")},finalizer:{optional:!0,validate:(0, a.assertNodeType)("BlockStatement")}}}),(0, a.default)("UnaryExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:!0},argument:{validate:(0, a.assertNodeType)("Expression")},operator:{validate:(0, a.assertOneOf)(...o.UNARY_OPERATORS)}},visitor:["argument"],aliases:["UnaryLike","Expression"]}),(0, a.default)("UpdateExpression",{builder:["operator","argument","prefix"],fields:{prefix:{default:!1},argument:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, a.assertNodeType)("Identifier","MemberExpression"):(0, a.assertNodeType)("Expression")},operator:{validate:(0, a.assertOneOf)(...o.UPDATE_OPERATORS)}},visitor:["argument"],aliases:["Expression"]}),(0, a.default)("VariableDeclaration",{builder:["kind","declarations"],visitor:["declarations"],aliases:["Statement","Declaration"],fields:{declare:{validate:(0, a.assertValueType)("boolean"),optional:!0},kind:{validate:(0, a.assertOneOf)("var","let","const")},declarations:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("VariableDeclarator")))}},validate(e,t,r){if(process.env.BABEL_TYPES_8_BREAKING&&(0, n.default)("ForXStatement",e,{left:r})&&1!==r.declarations.length)throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`)}}),(0, a.default)("VariableDeclarator",{visitor:["id","init"],fields:{id:{validate:function(){if(!process.env.BABEL_TYPES_8_BREAKING)return (0, a.assertNodeType)("LVal");const e=(0, a.assertNodeType)("Identifier","ArrayPattern","ObjectPattern"),t=(0, a.assertNodeType)("Identifier");return function(r,n,s){(r.init?e:t)(r,n,s);}}()},definite:{optional:!0,validate:(0, a.assertValueType)("boolean")},init:{optional:!0,validate:(0, a.assertNodeType)("Expression")}}}),(0, a.default)("WhileStatement",{visitor:["test","body"],aliases:["Statement","BlockParent","Loop","While","Scopable"],fields:{test:{validate:(0, a.assertNodeType)("Expression")},body:{validate:(0, a.assertNodeType)("Statement")}}}),(0, a.default)("WithStatement",{visitor:["object","body"],aliases:["Statement"],fields:{object:{validate:(0, a.assertNodeType)("Expression")},body:{validate:(0, a.assertNodeType)("Statement")}}}),(0, a.default)("AssignmentPattern",{visitor:["left","right","decorators"],builder:["left","right"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},p,{left:{validate:(0, a.assertNodeType)("Identifier","ObjectPattern","ArrayPattern","MemberExpression")},right:{validate:(0, a.assertNodeType)("Expression")},decorators:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Decorator"))),optional:!0}})}),(0, a.default)("ArrayPattern",{visitor:["elements","typeAnnotation"],builder:["elements"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},p,{elements:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeOrValueType)("null","PatternLike")))},decorators:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Decorator"))),optional:!0}})}),(0, a.default)("ArrowFunctionExpression",{builder:["params","body","async"],visitor:["params","body","returnType","typeParameters"],aliases:["Scopable","Function","BlockParent","FunctionParent","Expression","Pureish"],fields:Object.assign({},l,u,{expression:{validate:(0, a.assertValueType)("boolean")},body:{validate:(0, a.assertNodeType)("BlockStatement","Expression")}})}),(0, a.default)("ClassBody",{visitor:["body"],fields:{body:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("ClassMethod","ClassPrivateMethod","ClassProperty","ClassPrivateProperty","TSDeclareMethod","TSIndexSignature")))}}}),(0, a.default)("ClassExpression",{builder:["id","superClass","body","decorators"],visitor:["id","body","superClass","mixins","typeParameters","superTypeParameters","implements","decorators"],aliases:["Scopable","Class","Expression"],fields:{id:{validate:(0, a.assertNodeType)("Identifier"),optional:!0},typeParameters:{validate:(0, a.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0},body:{validate:(0, a.assertNodeType)("ClassBody")},superClass:{optional:!0,validate:(0, a.assertNodeType)("Expression")},superTypeParameters:{validate:(0, a.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0},implements:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("TSExpressionWithTypeArguments","ClassImplements"))),optional:!0},decorators:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Decorator"))),optional:!0},mixins:{validate:(0, a.assertNodeType)("InterfaceExtends"),optional:!0}}}),(0, a.default)("ClassDeclaration",{inherits:"ClassExpression",aliases:["Scopable","Class","Statement","Declaration"],fields:{id:{validate:(0, a.assertNodeType)("Identifier")},typeParameters:{validate:(0, a.assertNodeType)("TypeParameterDeclaration","TSTypeParameterDeclaration","Noop"),optional:!0},body:{validate:(0, a.assertNodeType)("ClassBody")},superClass:{optional:!0,validate:(0, a.assertNodeType)("Expression")},superTypeParameters:{validate:(0, a.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0},implements:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("TSExpressionWithTypeArguments","ClassImplements"))),optional:!0},decorators:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Decorator"))),optional:!0},mixins:{validate:(0, a.assertNodeType)("InterfaceExtends"),optional:!0},declare:{validate:(0, a.assertValueType)("boolean"),optional:!0},abstract:{validate:(0, a.assertValueType)("boolean"),optional:!0}},validate:function(){const e=(0, a.assertNodeType)("Identifier");return function(t,r,s){process.env.BABEL_TYPES_8_BREAKING&&((0, n.default)("ExportDefaultDeclaration",t)||e(s,"id",s.id));}}()}),(0, a.default)("ExportAllDeclaration",{visitor:["source"],aliases:["Statement","Declaration","ModuleDeclaration","ExportDeclaration"],fields:{source:{validate:(0, a.assertNodeType)("StringLiteral")},exportKind:(0, a.validateOptional)((0, a.assertOneOf)("type","value")),assertions:{optional:!0,validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("ImportAttribute")))}}}),(0, a.default)("ExportDefaultDeclaration",{visitor:["declaration"],aliases:["Statement","Declaration","ModuleDeclaration","ExportDeclaration"],fields:{declaration:{validate:(0, a.assertNodeType)("FunctionDeclaration","TSDeclareFunction","ClassDeclaration","Expression")}}}),(0, a.default)("ExportNamedDeclaration",{visitor:["declaration","specifiers","source"],aliases:["Statement","Declaration","ModuleDeclaration","ExportDeclaration"],fields:{declaration:{optional:!0,validate:(0, a.chain)((0, a.assertNodeType)("Declaration"),Object.assign((function(e,t,r){if(process.env.BABEL_TYPES_8_BREAKING&&r&&e.specifiers.length)throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration")}),{oneOfNodeTypes:["Declaration"]}),(function(e,t,r){if(process.env.BABEL_TYPES_8_BREAKING&&r&&e.source)throw new TypeError("Cannot export a declaration from a source")}))},assertions:{optional:!0,validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("ImportAttribute")))},specifiers:{default:[],validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)(function(){const e=(0, a.assertNodeType)("ExportSpecifier","ExportDefaultSpecifier","ExportNamespaceSpecifier"),t=(0, a.assertNodeType)("ExportSpecifier");return process.env.BABEL_TYPES_8_BREAKING?function(r,n,s){(r.source?e:t)(r,n,s);}:e}()))},source:{validate:(0, a.assertNodeType)("StringLiteral"),optional:!0},exportKind:(0, a.validateOptional)((0, a.assertOneOf)("type","value"))}}),(0, a.default)("ExportSpecifier",{visitor:["local","exported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, a.assertNodeType)("Identifier")},exported:{validate:(0, a.assertNodeType)("Identifier","StringLiteral")}}}),(0, a.default)("ForOfStatement",{visitor:["left","right","body"],builder:["left","right","body","await"],aliases:["Scopable","Statement","For","BlockParent","Loop","ForXStatement"],fields:{left:{validate:function(){if(!process.env.BABEL_TYPES_8_BREAKING)return (0, a.assertNodeType)("VariableDeclaration","LVal");const e=(0, a.assertNodeType)("VariableDeclaration"),t=(0, a.assertNodeType)("Identifier","MemberExpression","ArrayPattern","ObjectPattern");return function(r,s,i){(0, n.default)("VariableDeclaration",i)?e(r,s,i):t(r,s,i);}}()},right:{validate:(0, a.assertNodeType)("Expression")},body:{validate:(0, a.assertNodeType)("Statement")},await:{default:!1}}}),(0, a.default)("ImportDeclaration",{visitor:["specifiers","source"],aliases:["Statement","Declaration","ModuleDeclaration"],fields:{assertions:{optional:!0,validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("ImportAttribute")))},specifiers:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier")))},source:{validate:(0, a.assertNodeType)("StringLiteral")},importKind:{validate:(0, a.assertOneOf)("type","typeof","value"),optional:!0}}}),(0, a.default)("ImportDefaultSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, a.assertNodeType)("Identifier")}}}),(0, a.default)("ImportNamespaceSpecifier",{visitor:["local"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, a.assertNodeType)("Identifier")}}}),(0, a.default)("ImportSpecifier",{visitor:["local","imported"],aliases:["ModuleSpecifier"],fields:{local:{validate:(0, a.assertNodeType)("Identifier")},imported:{validate:(0, a.assertNodeType)("Identifier","StringLiteral")},importKind:{validate:(0, a.assertOneOf)("type","typeof"),optional:!0}}}),(0, a.default)("MetaProperty",{visitor:["meta","property"],aliases:["Expression"],fields:{meta:{validate:(0, a.chain)((0, a.assertNodeType)("Identifier"),Object.assign((function(e,t,r){if(!process.env.BABEL_TYPES_8_BREAKING)return;let s;switch(r.name){case"function":s="sent";break;case"new":s="target";break;case"import":s="meta";}if(!(0, n.default)("Identifier",e.property,{name:s}))throw new TypeError("Unrecognised MetaProperty")}),{oneOfNodeTypes:["Identifier"]}))},property:{validate:(0, a.assertNodeType)("Identifier")}}});const d={abstract:{validate:(0, a.assertValueType)("boolean"),optional:!0},accessibility:{validate:(0, a.assertOneOf)("public","private","protected"),optional:!0},static:{default:!1},override:{default:!1},computed:{default:!1},optional:{validate:(0, a.assertValueType)("boolean"),optional:!0},key:{validate:(0, a.chain)(function(){const e=(0, a.assertNodeType)("Identifier","StringLiteral","NumericLiteral"),t=(0, a.assertNodeType)("Expression");return function(r,n,s){(r.computed?t:e)(r,n,s);}}(),(0, a.assertNodeType)("Identifier","StringLiteral","NumericLiteral","Expression"))}};t.classMethodOrPropertyCommon=d;const f=Object.assign({},l,d,{kind:{validate:(0, a.assertOneOf)("get","set","method","constructor"),default:"method"},access:{validate:(0, a.chain)((0, a.assertValueType)("string"),(0, a.assertOneOf)("public","private","protected")),optional:!0},decorators:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Decorator"))),optional:!0}});t.classMethodOrDeclareMethodCommon=f,(0, a.default)("ClassMethod",{aliases:["Function","Scopable","BlockParent","FunctionParent","Method"],builder:["kind","key","params","body","computed","static","generator","async"],visitor:["key","params","body","decorators","returnType","typeParameters"],fields:Object.assign({},f,u,{body:{validate:(0, a.assertNodeType)("BlockStatement")}})}),(0, a.default)("ObjectPattern",{visitor:["properties","typeAnnotation","decorators"],builder:["properties"],aliases:["Pattern","PatternLike","LVal"],fields:Object.assign({},p,{properties:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("RestElement","ObjectProperty")))}})}),(0, a.default)("SpreadElement",{visitor:["argument"],aliases:["UnaryLike"],deprecatedAlias:"SpreadProperty",fields:{argument:{validate:(0, a.assertNodeType)("Expression")}}}),(0, a.default)("Super",{aliases:["Expression"]}),(0, a.default)("TaggedTemplateExpression",{visitor:["tag","quasi"],aliases:["Expression"],fields:{tag:{validate:(0, a.assertNodeType)("Expression")},quasi:{validate:(0, a.assertNodeType)("TemplateLiteral")},typeParameters:{validate:(0, a.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0}}}),(0, a.default)("TemplateElement",{builder:["value","tail"],fields:{value:{validate:(0, a.assertShape)({raw:{validate:(0, a.assertValueType)("string")},cooked:{validate:(0, a.assertValueType)("string"),optional:!0}})},tail:{default:!1}}}),(0, a.default)("TemplateLiteral",{visitor:["quasis","expressions"],aliases:["Expression","Literal"],fields:{quasis:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("TemplateElement")))},expressions:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Expression","TSType")),(function(e,t,r){if(e.quasis.length!==r.length+1)throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.\nExpected ${r.length+1} quasis but got ${e.quasis.length}`)}))}}}),(0, a.default)("YieldExpression",{builder:["argument","delegate"],visitor:["argument"],aliases:["Expression","Terminatorless"],fields:{delegate:{validate:(0, a.chain)((0, a.assertValueType)("boolean"),Object.assign((function(e,t,r){if(process.env.BABEL_TYPES_8_BREAKING&&r&&!e.argument)throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument")}),{type:"boolean"})),default:!1},argument:{optional:!0,validate:(0, a.assertNodeType)("Expression")}}}),(0, a.default)("AwaitExpression",{builder:["argument"],visitor:["argument"],aliases:["Expression","Terminatorless"],fields:{argument:{validate:(0, a.assertNodeType)("Expression")}}}),(0, a.default)("Import",{aliases:["Expression"]}),(0, a.default)("BigIntLiteral",{builder:["value"],fields:{value:{validate:(0, a.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0, a.default)("ExportNamespaceSpecifier",{visitor:["exported"],aliases:["ModuleSpecifier"],fields:{exported:{validate:(0, a.assertNodeType)("Identifier")}}}),(0, a.default)("OptionalMemberExpression",{builder:["object","property","computed","optional"],visitor:["object","property"],aliases:["Expression"],fields:{object:{validate:(0, a.assertNodeType)("Expression")},property:{validate:function(){const e=(0, a.assertNodeType)("Identifier"),t=(0, a.assertNodeType)("Expression"),r=function(r,n,s){(r.computed?t:e)(r,n,s);};return r.oneOfNodeTypes=["Expression","Identifier"],r}()},computed:{default:!1},optional:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, a.chain)((0, a.assertValueType)("boolean"),(0, a.assertOptionalChainStart)()):(0, a.assertValueType)("boolean")}}}),(0, a.default)("OptionalCallExpression",{visitor:["callee","arguments","typeParameters","typeArguments"],builder:["callee","arguments","optional"],aliases:["Expression"],fields:{callee:{validate:(0, a.assertNodeType)("Expression")},arguments:{validate:(0, a.chain)((0, a.assertValueType)("array"),(0, a.assertEach)((0, a.assertNodeType)("Expression","SpreadElement","JSXNamespacedName","ArgumentPlaceholder")))},optional:{validate:process.env.BABEL_TYPES_8_BREAKING?(0, a.chain)((0, a.assertValueType)("boolean"),(0, a.assertOptionalChainStart)()):(0, a.assertValueType)("boolean")},typeArguments:{validate:(0, a.assertNodeType)("TypeParameterInstantiation"),optional:!0},typeParameters:{validate:(0, a.assertNodeType)("TSTypeParameterInstantiation"),optional:!0}}});},"./node_modules/@babel/types/lib/definitions/experimental.js":(e,t,r)=>{var n=r("./node_modules/@babel/types/lib/definitions/utils.js"),s=r("./node_modules/@babel/types/lib/definitions/core.js");(0, n.default)("ArgumentPlaceholder",{}),(0, n.default)("BindExpression",{visitor:["object","callee"],aliases:["Expression"],fields:process.env.BABEL_TYPES_8_BREAKING?{object:{validate:(0, n.assertNodeType)("Expression")},callee:{validate:(0, n.assertNodeType)("Expression")}}:{object:{validate:Object.assign((()=>{}),{oneOfNodeTypes:["Expression"]})},callee:{validate:Object.assign((()=>{}),{oneOfNodeTypes:["Expression"]})}}}),(0, n.default)("ClassProperty",{visitor:["key","value","typeAnnotation","decorators"],builder:["key","value","typeAnnotation","decorators","computed","static"],aliases:["Property"],fields:Object.assign({},s.classMethodOrPropertyCommon,{value:{validate:(0, n.assertNodeType)("Expression"),optional:!0},definite:{validate:(0, n.assertValueType)("boolean"),optional:!0},typeAnnotation:{validate:(0, n.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},decorators:{validate:(0, n.chain)((0, n.assertValueType)("array"),(0, n.assertEach)((0, n.assertNodeType)("Decorator"))),optional:!0},readonly:{validate:(0, n.assertValueType)("boolean"),optional:!0},declare:{validate:(0, n.assertValueType)("boolean"),optional:!0}})}),(0, n.default)("PipelineTopicExpression",{builder:["expression"],visitor:["expression"],fields:{expression:{validate:(0, n.assertNodeType)("Expression")}}}),(0, n.default)("PipelineBareFunction",{builder:["callee"],visitor:["callee"],fields:{callee:{validate:(0, n.assertNodeType)("Expression")}}}),(0, n.default)("PipelinePrimaryTopicReference",{aliases:["Expression"]}),(0, n.default)("ClassPrivateProperty",{visitor:["key","value","decorators"],builder:["key","value","decorators","static"],aliases:["Property","Private"],fields:{key:{validate:(0, n.assertNodeType)("PrivateName")},value:{validate:(0, n.assertNodeType)("Expression"),optional:!0},typeAnnotation:{validate:(0, n.assertNodeType)("TypeAnnotation","TSTypeAnnotation","Noop"),optional:!0},decorators:{validate:(0, n.chain)((0, n.assertValueType)("array"),(0, n.assertEach)((0, n.assertNodeType)("Decorator"))),optional:!0}}}),(0, n.default)("ClassPrivateMethod",{builder:["kind","key","params","body","static"],visitor:["key","params","body","decorators","returnType","typeParameters"],aliases:["Function","Scopable","BlockParent","FunctionParent","Method","Private"],fields:Object.assign({},s.classMethodOrDeclareMethodCommon,s.functionTypeAnnotationCommon,{key:{validate:(0, n.assertNodeType)("PrivateName")},body:{validate:(0, n.assertNodeType)("BlockStatement")}})}),(0, n.default)("ImportAttribute",{visitor:["key","value"],fields:{key:{validate:(0, n.assertNodeType)("Identifier","StringLiteral")},value:{validate:(0, n.assertNodeType)("StringLiteral")}}}),(0, n.default)("Decorator",{visitor:["expression"],fields:{expression:{validate:(0, n.assertNodeType)("Expression")}}}),(0, n.default)("DoExpression",{visitor:["body"],builder:["body","async"],aliases:["Expression"],fields:{body:{validate:(0, n.assertNodeType)("BlockStatement")},async:{validate:(0, n.assertValueType)("boolean"),default:!1}}}),(0, n.default)("ExportDefaultSpecifier",{visitor:["exported"],aliases:["ModuleSpecifier"],fields:{exported:{validate:(0, n.assertNodeType)("Identifier")}}}),(0, n.default)("PrivateName",{visitor:["id"],aliases:["Private"],fields:{id:{validate:(0, n.assertNodeType)("Identifier")}}}),(0, n.default)("RecordExpression",{visitor:["properties"],aliases:["Expression"],fields:{properties:{validate:(0, n.chain)((0, n.assertValueType)("array"),(0, n.assertEach)((0, n.assertNodeType)("ObjectProperty","SpreadElement")))}}}),(0, n.default)("TupleExpression",{fields:{elements:{validate:(0, n.chain)((0, n.assertValueType)("array"),(0, n.assertEach)((0, n.assertNodeType)("Expression","SpreadElement"))),default:[]}},visitor:["elements"],aliases:["Expression"]}),(0, n.default)("DecimalLiteral",{builder:["value"],fields:{value:{validate:(0, n.assertValueType)("string")}},aliases:["Expression","Pureish","Literal","Immutable"]}),(0, n.default)("StaticBlock",{visitor:["body"],fields:{body:{validate:(0, n.chain)((0, n.assertValueType)("array"),(0, n.assertEach)((0, n.assertNodeType)("Statement")))}},aliases:["Scopable","BlockParent"]}),(0, n.default)("ModuleExpression",{visitor:["body"],fields:{body:{validate:(0, n.assertNodeType)("Program")}},aliases:["Expression"]});},"./node_modules/@babel/types/lib/definitions/flow.js":(e,t,r)=>{var n=r("./node_modules/@babel/types/lib/definitions/utils.js");const s=(e,t="TypeParameterDeclaration")=>{(0, n.default)(e,{builder:["id","typeParameters","extends","body"],visitor:["id","typeParameters","extends","mixins","implements","body"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{id:(0, n.validateType)("Identifier"),typeParameters:(0, n.validateOptionalType)(t),extends:(0, n.validateOptional)((0, n.arrayOfType)("InterfaceExtends")),mixins:(0, n.validateOptional)((0, n.arrayOfType)("InterfaceExtends")),implements:(0, n.validateOptional)((0, n.arrayOfType)("ClassImplements")),body:(0, n.validateType)("ObjectTypeAnnotation")}});};(0, n.default)("AnyTypeAnnotation",{aliases:["Flow","FlowType","FlowBaseAnnotation"]}),(0, n.default)("ArrayTypeAnnotation",{visitor:["elementType"],aliases:["Flow","FlowType"],fields:{elementType:(0, n.validateType)("FlowType")}}),(0, n.default)("BooleanTypeAnnotation",{aliases:["Flow","FlowType","FlowBaseAnnotation"]}),(0, n.default)("BooleanLiteralTypeAnnotation",{builder:["value"],aliases:["Flow","FlowType"],fields:{value:(0, n.validate)((0, n.assertValueType)("boolean"))}}),(0, n.default)("NullLiteralTypeAnnotation",{aliases:["Flow","FlowType","FlowBaseAnnotation"]}),(0, n.default)("ClassImplements",{visitor:["id","typeParameters"],aliases:["Flow"],fields:{id:(0, n.validateType)("Identifier"),typeParameters:(0, n.validateOptionalType)("TypeParameterInstantiation")}}),s("DeclareClass"),(0, n.default)("DeclareFunction",{visitor:["id"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{id:(0, n.validateType)("Identifier"),predicate:(0, n.validateOptionalType)("DeclaredPredicate")}}),s("DeclareInterface"),(0, n.default)("DeclareModule",{builder:["id","body","kind"],visitor:["id","body"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{id:(0, n.validateType)(["Identifier","StringLiteral"]),body:(0, n.validateType)("BlockStatement"),kind:(0, n.validateOptional)((0, n.assertOneOf)("CommonJS","ES"))}}),(0, n.default)("DeclareModuleExports",{visitor:["typeAnnotation"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{typeAnnotation:(0, n.validateType)("TypeAnnotation")}}),(0, n.default)("DeclareTypeAlias",{visitor:["id","typeParameters","right"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{id:(0, n.validateType)("Identifier"),typeParameters:(0, n.validateOptionalType)("TypeParameterDeclaration"),right:(0, n.validateType)("FlowType")}}),(0, n.default)("DeclareOpaqueType",{visitor:["id","typeParameters","supertype"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{id:(0, n.validateType)("Identifier"),typeParameters:(0, n.validateOptionalType)("TypeParameterDeclaration"),supertype:(0, n.validateOptionalType)("FlowType")}}),(0, n.default)("DeclareVariable",{visitor:["id"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{id:(0, n.validateType)("Identifier")}}),(0, n.default)("DeclareExportDeclaration",{visitor:["declaration","specifiers","source"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{declaration:(0, n.validateOptionalType)("Flow"),specifiers:(0, n.validateOptional)((0, n.arrayOfType)(["ExportSpecifier","ExportNamespaceSpecifier"])),source:(0, n.validateOptionalType)("StringLiteral"),default:(0, n.validateOptional)((0, n.assertValueType)("boolean"))}}),(0, n.default)("DeclareExportAllDeclaration",{visitor:["source"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{source:(0, n.validateType)("StringLiteral"),exportKind:(0, n.validateOptional)((0, n.assertOneOf)("type","value"))}}),(0, n.default)("DeclaredPredicate",{visitor:["value"],aliases:["Flow","FlowPredicate"],fields:{value:(0, n.validateType)("Flow")}}),(0, n.default)("ExistsTypeAnnotation",{aliases:["Flow","FlowType"]}),(0, n.default)("FunctionTypeAnnotation",{visitor:["typeParameters","params","rest","returnType"],aliases:["Flow","FlowType"],fields:{typeParameters:(0, n.validateOptionalType)("TypeParameterDeclaration"),params:(0, n.validate)((0, n.arrayOfType)("FunctionTypeParam")),rest:(0, n.validateOptionalType)("FunctionTypeParam"),this:(0, n.validateOptionalType)("FunctionTypeParam"),returnType:(0, n.validateType)("FlowType")}}),(0, n.default)("FunctionTypeParam",{visitor:["name","typeAnnotation"],aliases:["Flow"],fields:{name:(0, n.validateOptionalType)("Identifier"),typeAnnotation:(0, n.validateType)("FlowType"),optional:(0, n.validateOptional)((0, n.assertValueType)("boolean"))}}),(0, n.default)("GenericTypeAnnotation",{visitor:["id","typeParameters"],aliases:["Flow","FlowType"],fields:{id:(0, n.validateType)(["Identifier","QualifiedTypeIdentifier"]),typeParameters:(0, n.validateOptionalType)("TypeParameterInstantiation")}}),(0, n.default)("InferredPredicate",{aliases:["Flow","FlowPredicate"]}),(0, n.default)("InterfaceExtends",{visitor:["id","typeParameters"],aliases:["Flow"],fields:{id:(0, n.validateType)(["Identifier","QualifiedTypeIdentifier"]),typeParameters:(0, n.validateOptionalType)("TypeParameterInstantiation")}}),s("InterfaceDeclaration"),(0, n.default)("InterfaceTypeAnnotation",{visitor:["extends","body"],aliases:["Flow","FlowType"],fields:{extends:(0, n.validateOptional)((0, n.arrayOfType)("InterfaceExtends")),body:(0, n.validateType)("ObjectTypeAnnotation")}}),(0, n.default)("IntersectionTypeAnnotation",{visitor:["types"],aliases:["Flow","FlowType"],fields:{types:(0, n.validate)((0, n.arrayOfType)("FlowType"))}}),(0, n.default)("MixedTypeAnnotation",{aliases:["Flow","FlowType","FlowBaseAnnotation"]}),(0, n.default)("EmptyTypeAnnotation",{aliases:["Flow","FlowType","FlowBaseAnnotation"]}),(0, n.default)("NullableTypeAnnotation",{visitor:["typeAnnotation"],aliases:["Flow","FlowType"],fields:{typeAnnotation:(0, n.validateType)("FlowType")}}),(0, n.default)("NumberLiteralTypeAnnotation",{builder:["value"],aliases:["Flow","FlowType"],fields:{value:(0, n.validate)((0, n.assertValueType)("number"))}}),(0, n.default)("NumberTypeAnnotation",{aliases:["Flow","FlowType","FlowBaseAnnotation"]}),(0, n.default)("ObjectTypeAnnotation",{visitor:["properties","indexers","callProperties","internalSlots"],aliases:["Flow","FlowType"],builder:["properties","indexers","callProperties","internalSlots","exact"],fields:{properties:(0, n.validate)((0, n.arrayOfType)(["ObjectTypeProperty","ObjectTypeSpreadProperty"])),indexers:(0, n.validateOptional)((0, n.arrayOfType)("ObjectTypeIndexer")),callProperties:(0, n.validateOptional)((0, n.arrayOfType)("ObjectTypeCallProperty")),internalSlots:(0, n.validateOptional)((0, n.arrayOfType)("ObjectTypeInternalSlot")),exact:{validate:(0, n.assertValueType)("boolean"),default:!1},inexact:(0, n.validateOptional)((0, n.assertValueType)("boolean"))}}),(0, n.default)("ObjectTypeInternalSlot",{visitor:["id","value","optional","static","method"],aliases:["Flow","UserWhitespacable"],fields:{id:(0, n.validateType)("Identifier"),value:(0, n.validateType)("FlowType"),optional:(0, n.validate)((0, n.assertValueType)("boolean")),static:(0, n.validate)((0, n.assertValueType)("boolean")),method:(0, n.validate)((0, n.assertValueType)("boolean"))}}),(0, n.default)("ObjectTypeCallProperty",{visitor:["value"],aliases:["Flow","UserWhitespacable"],fields:{value:(0, n.validateType)("FlowType"),static:(0, n.validate)((0, n.assertValueType)("boolean"))}}),(0, n.default)("ObjectTypeIndexer",{visitor:["id","key","value","variance"],aliases:["Flow","UserWhitespacable"],fields:{id:(0, n.validateOptionalType)("Identifier"),key:(0, n.validateType)("FlowType"),value:(0, n.validateType)("FlowType"),static:(0, n.validate)((0, n.assertValueType)("boolean")),variance:(0, n.validateOptionalType)("Variance")}}),(0, n.default)("ObjectTypeProperty",{visitor:["key","value","variance"],aliases:["Flow","UserWhitespacable"],fields:{key:(0, n.validateType)(["Identifier","StringLiteral"]),value:(0, n.validateType)("FlowType"),kind:(0, n.validate)((0, n.assertOneOf)("init","get","set")),static:(0, n.validate)((0, n.assertValueType)("boolean")),proto:(0, n.validate)((0, n.assertValueType)("boolean")),optional:(0, n.validate)((0, n.assertValueType)("boolean")),variance:(0, n.validateOptionalType)("Variance"),method:(0, n.validate)((0, n.assertValueType)("boolean"))}}),(0, n.default)("ObjectTypeSpreadProperty",{visitor:["argument"],aliases:["Flow","UserWhitespacable"],fields:{argument:(0, n.validateType)("FlowType")}}),(0, n.default)("OpaqueType",{visitor:["id","typeParameters","supertype","impltype"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{id:(0, n.validateType)("Identifier"),typeParameters:(0, n.validateOptionalType)("TypeParameterDeclaration"),supertype:(0, n.validateOptionalType)("FlowType"),impltype:(0, n.validateType)("FlowType")}}),(0, n.default)("QualifiedTypeIdentifier",{visitor:["id","qualification"],aliases:["Flow"],fields:{id:(0, n.validateType)("Identifier"),qualification:(0, n.validateType)(["Identifier","QualifiedTypeIdentifier"])}}),(0, n.default)("StringLiteralTypeAnnotation",{builder:["value"],aliases:["Flow","FlowType"],fields:{value:(0, n.validate)((0, n.assertValueType)("string"))}}),(0, n.default)("StringTypeAnnotation",{aliases:["Flow","FlowType","FlowBaseAnnotation"]}),(0, n.default)("SymbolTypeAnnotation",{aliases:["Flow","FlowType","FlowBaseAnnotation"]}),(0, n.default)("ThisTypeAnnotation",{aliases:["Flow","FlowType","FlowBaseAnnotation"]}),(0, n.default)("TupleTypeAnnotation",{visitor:["types"],aliases:["Flow","FlowType"],fields:{types:(0, n.validate)((0, n.arrayOfType)("FlowType"))}}),(0, n.default)("TypeofTypeAnnotation",{visitor:["argument"],aliases:["Flow","FlowType"],fields:{argument:(0, n.validateType)("FlowType")}}),(0, n.default)("TypeAlias",{visitor:["id","typeParameters","right"],aliases:["Flow","FlowDeclaration","Statement","Declaration"],fields:{id:(0, n.validateType)("Identifier"),typeParameters:(0, n.validateOptionalType)("TypeParameterDeclaration"),right:(0, n.validateType)("FlowType")}}),(0, n.default)("TypeAnnotation",{aliases:["Flow"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0, n.validateType)("FlowType")}}),(0, n.default)("TypeCastExpression",{visitor:["expression","typeAnnotation"],aliases:["Flow","ExpressionWrapper","Expression"],fields:{expression:(0, n.validateType)("Expression"),typeAnnotation:(0, n.validateType)("TypeAnnotation")}}),(0, n.default)("TypeParameter",{aliases:["Flow"],visitor:["bound","default","variance"],fields:{name:(0, n.validate)((0, n.assertValueType)("string")),bound:(0, n.validateOptionalType)("TypeAnnotation"),default:(0, n.validateOptionalType)("FlowType"),variance:(0, n.validateOptionalType)("Variance")}}),(0, n.default)("TypeParameterDeclaration",{aliases:["Flow"],visitor:["params"],fields:{params:(0, n.validate)((0, n.arrayOfType)("TypeParameter"))}}),(0, n.default)("TypeParameterInstantiation",{aliases:["Flow"],visitor:["params"],fields:{params:(0, n.validate)((0, n.arrayOfType)("FlowType"))}}),(0, n.default)("UnionTypeAnnotation",{visitor:["types"],aliases:["Flow","FlowType"],fields:{types:(0, n.validate)((0, n.arrayOfType)("FlowType"))}}),(0, n.default)("Variance",{aliases:["Flow"],builder:["kind"],fields:{kind:(0, n.validate)((0, n.assertOneOf)("minus","plus"))}}),(0, n.default)("VoidTypeAnnotation",{aliases:["Flow","FlowType","FlowBaseAnnotation"]}),(0, n.default)("EnumDeclaration",{aliases:["Statement","Declaration"],visitor:["id","body"],fields:{id:(0, n.validateType)("Identifier"),body:(0, n.validateType)(["EnumBooleanBody","EnumNumberBody","EnumStringBody","EnumSymbolBody"])}}),(0, n.default)("EnumBooleanBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0, n.validate)((0, n.assertValueType)("boolean")),members:(0, n.validateArrayOfType)("EnumBooleanMember"),hasUnknownMembers:(0, n.validate)((0, n.assertValueType)("boolean"))}}),(0, n.default)("EnumNumberBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0, n.validate)((0, n.assertValueType)("boolean")),members:(0, n.validateArrayOfType)("EnumNumberMember"),hasUnknownMembers:(0, n.validate)((0, n.assertValueType)("boolean"))}}),(0, n.default)("EnumStringBody",{aliases:["EnumBody"],visitor:["members"],fields:{explicitType:(0, n.validate)((0, n.assertValueType)("boolean")),members:(0, n.validateArrayOfType)(["EnumStringMember","EnumDefaultedMember"]),hasUnknownMembers:(0, n.validate)((0, n.assertValueType)("boolean"))}}),(0, n.default)("EnumSymbolBody",{aliases:["EnumBody"],visitor:["members"],fields:{members:(0, n.validateArrayOfType)("EnumDefaultedMember"),hasUnknownMembers:(0, n.validate)((0, n.assertValueType)("boolean"))}}),(0, n.default)("EnumBooleanMember",{aliases:["EnumMember"],visitor:["id"],fields:{id:(0, n.validateType)("Identifier"),init:(0, n.validateType)("BooleanLiteral")}}),(0, n.default)("EnumNumberMember",{aliases:["EnumMember"],visitor:["id","init"],fields:{id:(0, n.validateType)("Identifier"),init:(0, n.validateType)("NumericLiteral")}}),(0, n.default)("EnumStringMember",{aliases:["EnumMember"],visitor:["id","init"],fields:{id:(0, n.validateType)("Identifier"),init:(0, n.validateType)("StringLiteral")}}),(0, n.default)("EnumDefaultedMember",{aliases:["EnumMember"],visitor:["id"],fields:{id:(0, n.validateType)("Identifier")}}),(0, n.default)("IndexedAccessType",{visitor:["objectType","indexType"],aliases:["Flow","FlowType"],fields:{objectType:(0, n.validateType)("FlowType"),indexType:(0, n.validateType)("FlowType")}}),(0, n.default)("OptionalIndexedAccessType",{visitor:["objectType","indexType"],aliases:["Flow","FlowType"],fields:{objectType:(0, n.validateType)("FlowType"),indexType:(0, n.validateType)("FlowType"),optional:(0, n.validate)((0, n.assertValueType)("boolean"))}});},"./node_modules/@babel/types/lib/definitions/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"VISITOR_KEYS",{enumerable:!0,get:function(){return s.VISITOR_KEYS}}),Object.defineProperty(t,"ALIAS_KEYS",{enumerable:!0,get:function(){return s.ALIAS_KEYS}}),Object.defineProperty(t,"FLIPPED_ALIAS_KEYS",{enumerable:!0,get:function(){return s.FLIPPED_ALIAS_KEYS}}),Object.defineProperty(t,"NODE_FIELDS",{enumerable:!0,get:function(){return s.NODE_FIELDS}}),Object.defineProperty(t,"BUILDER_KEYS",{enumerable:!0,get:function(){return s.BUILDER_KEYS}}),Object.defineProperty(t,"DEPRECATED_KEYS",{enumerable:!0,get:function(){return s.DEPRECATED_KEYS}}),Object.defineProperty(t,"NODE_PARENT_VALIDATIONS",{enumerable:!0,get:function(){return s.NODE_PARENT_VALIDATIONS}}),Object.defineProperty(t,"PLACEHOLDERS",{enumerable:!0,get:function(){return i.PLACEHOLDERS}}),Object.defineProperty(t,"PLACEHOLDERS_ALIAS",{enumerable:!0,get:function(){return i.PLACEHOLDERS_ALIAS}}),Object.defineProperty(t,"PLACEHOLDERS_FLIPPED_ALIAS",{enumerable:!0,get:function(){return i.PLACEHOLDERS_FLIPPED_ALIAS}}),t.TYPES=void 0;var n=r("./node_modules/to-fast-properties/index.js");r("./node_modules/@babel/types/lib/definitions/core.js"),r("./node_modules/@babel/types/lib/definitions/flow.js"),r("./node_modules/@babel/types/lib/definitions/jsx.js"),r("./node_modules/@babel/types/lib/definitions/misc.js"),r("./node_modules/@babel/types/lib/definitions/experimental.js"),r("./node_modules/@babel/types/lib/definitions/typescript.js");var s=r("./node_modules/@babel/types/lib/definitions/utils.js"),i=r("./node_modules/@babel/types/lib/definitions/placeholders.js");n(s.VISITOR_KEYS),n(s.ALIAS_KEYS),n(s.FLIPPED_ALIAS_KEYS),n(s.NODE_FIELDS),n(s.BUILDER_KEYS),n(s.DEPRECATED_KEYS),n(i.PLACEHOLDERS_ALIAS),n(i.PLACEHOLDERS_FLIPPED_ALIAS);const o=Object.keys(s.VISITOR_KEYS).concat(Object.keys(s.FLIPPED_ALIAS_KEYS)).concat(Object.keys(s.DEPRECATED_KEYS));t.TYPES=o;},"./node_modules/@babel/types/lib/definitions/jsx.js":(e,t,r)=>{var n=r("./node_modules/@babel/types/lib/definitions/utils.js");(0, n.default)("JSXAttribute",{visitor:["name","value"],aliases:["JSX","Immutable"],fields:{name:{validate:(0, n.assertNodeType)("JSXIdentifier","JSXNamespacedName")},value:{optional:!0,validate:(0, n.assertNodeType)("JSXElement","JSXFragment","StringLiteral","JSXExpressionContainer")}}}),(0, n.default)("JSXClosingElement",{visitor:["name"],aliases:["JSX","Immutable"],fields:{name:{validate:(0, n.assertNodeType)("JSXIdentifier","JSXMemberExpression","JSXNamespacedName")}}}),(0, n.default)("JSXElement",{builder:["openingElement","closingElement","children","selfClosing"],visitor:["openingElement","children","closingElement"],aliases:["JSX","Immutable","Expression"],fields:{openingElement:{validate:(0, n.assertNodeType)("JSXOpeningElement")},closingElement:{optional:!0,validate:(0, n.assertNodeType)("JSXClosingElement")},children:{validate:(0, n.chain)((0, n.assertValueType)("array"),(0, n.assertEach)((0, n.assertNodeType)("JSXText","JSXExpressionContainer","JSXSpreadChild","JSXElement","JSXFragment")))},selfClosing:{validate:(0, n.assertValueType)("boolean"),optional:!0}}}),(0, n.default)("JSXEmptyExpression",{aliases:["JSX"]}),(0, n.default)("JSXExpressionContainer",{visitor:["expression"],aliases:["JSX","Immutable"],fields:{expression:{validate:(0, n.assertNodeType)("Expression","JSXEmptyExpression")}}}),(0, n.default)("JSXSpreadChild",{visitor:["expression"],aliases:["JSX","Immutable"],fields:{expression:{validate:(0, n.assertNodeType)("Expression")}}}),(0, n.default)("JSXIdentifier",{builder:["name"],aliases:["JSX"],fields:{name:{validate:(0, n.assertValueType)("string")}}}),(0, n.default)("JSXMemberExpression",{visitor:["object","property"],aliases:["JSX"],fields:{object:{validate:(0, n.assertNodeType)("JSXMemberExpression","JSXIdentifier")},property:{validate:(0, n.assertNodeType)("JSXIdentifier")}}}),(0, n.default)("JSXNamespacedName",{visitor:["namespace","name"],aliases:["JSX"],fields:{namespace:{validate:(0, n.assertNodeType)("JSXIdentifier")},name:{validate:(0, n.assertNodeType)("JSXIdentifier")}}}),(0, n.default)("JSXOpeningElement",{builder:["name","attributes","selfClosing"],visitor:["name","attributes"],aliases:["JSX","Immutable"],fields:{name:{validate:(0, n.assertNodeType)("JSXIdentifier","JSXMemberExpression","JSXNamespacedName")},selfClosing:{default:!1},attributes:{validate:(0, n.chain)((0, n.assertValueType)("array"),(0, n.assertEach)((0, n.assertNodeType)("JSXAttribute","JSXSpreadAttribute")))},typeParameters:{validate:(0, n.assertNodeType)("TypeParameterInstantiation","TSTypeParameterInstantiation"),optional:!0}}}),(0, n.default)("JSXSpreadAttribute",{visitor:["argument"],aliases:["JSX"],fields:{argument:{validate:(0, n.assertNodeType)("Expression")}}}),(0, n.default)("JSXText",{aliases:["JSX","Immutable"],builder:["value"],fields:{value:{validate:(0, n.assertValueType)("string")}}}),(0, n.default)("JSXFragment",{builder:["openingFragment","closingFragment","children"],visitor:["openingFragment","children","closingFragment"],aliases:["JSX","Immutable","Expression"],fields:{openingFragment:{validate:(0, n.assertNodeType)("JSXOpeningFragment")},closingFragment:{validate:(0, n.assertNodeType)("JSXClosingFragment")},children:{validate:(0, n.chain)((0, n.assertValueType)("array"),(0, n.assertEach)((0, n.assertNodeType)("JSXText","JSXExpressionContainer","JSXSpreadChild","JSXElement","JSXFragment")))}}}),(0, n.default)("JSXOpeningFragment",{aliases:["JSX","Immutable"]}),(0, n.default)("JSXClosingFragment",{aliases:["JSX","Immutable"]});},"./node_modules/@babel/types/lib/definitions/misc.js":(e,t,r)=>{var n=r("./node_modules/@babel/types/lib/definitions/utils.js"),s=r("./node_modules/@babel/types/lib/definitions/placeholders.js");(0, n.default)("Noop",{visitor:[]}),(0, n.default)("Placeholder",{visitor:[],builder:["expectedNode","name"],fields:{name:{validate:(0, n.assertNodeType)("Identifier")},expectedNode:{validate:(0, n.assertOneOf)(...s.PLACEHOLDERS)}}}),(0, n.default)("V8IntrinsicIdentifier",{builder:["name"],fields:{name:{validate:(0, n.assertValueType)("string")}}});},"./node_modules/@babel/types/lib/definitions/placeholders.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.PLACEHOLDERS_FLIPPED_ALIAS=t.PLACEHOLDERS_ALIAS=t.PLACEHOLDERS=void 0;var n=r("./node_modules/@babel/types/lib/definitions/utils.js");const s=["Identifier","StringLiteral","Expression","Statement","Declaration","BlockStatement","ClassBody","Pattern"];t.PLACEHOLDERS=s;const i={Declaration:["Statement"],Pattern:["PatternLike","LVal"]};t.PLACEHOLDERS_ALIAS=i;for(const e of s){const t=n.ALIAS_KEYS[e];null!=t&&t.length&&(i[e]=t);}const o={};t.PLACEHOLDERS_FLIPPED_ALIAS=o,Object.keys(i).forEach((e=>{i[e].forEach((t=>{Object.hasOwnProperty.call(o,t)||(o[t]=[]),o[t].push(e);}));}));},"./node_modules/@babel/types/lib/definitions/typescript.js":(e,t,r)=>{var n=r("./node_modules/@babel/types/lib/definitions/utils.js"),s=r("./node_modules/@babel/types/lib/definitions/core.js");const i=(0, n.assertValueType)("boolean"),o={returnType:{validate:(0, n.assertNodeType)("TSTypeAnnotation","Noop"),optional:!0},typeParameters:{validate:(0, n.assertNodeType)("TSTypeParameterDeclaration","Noop"),optional:!0}};(0, n.default)("TSParameterProperty",{aliases:["LVal"],visitor:["parameter"],fields:{accessibility:{validate:(0, n.assertOneOf)("public","private","protected"),optional:!0},readonly:{validate:(0, n.assertValueType)("boolean"),optional:!0},parameter:{validate:(0, n.assertNodeType)("Identifier","AssignmentPattern")}}}),(0, n.default)("TSDeclareFunction",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","params","returnType"],fields:Object.assign({},s.functionDeclarationCommon,o)}),(0, n.default)("TSDeclareMethod",{visitor:["decorators","key","typeParameters","params","returnType"],fields:Object.assign({},s.classMethodOrDeclareMethodCommon,o)}),(0, n.default)("TSQualifiedName",{aliases:["TSEntityName"],visitor:["left","right"],fields:{left:(0, n.validateType)("TSEntityName"),right:(0, n.validateType)("Identifier")}});const a={typeParameters:(0, n.validateOptionalType)("TSTypeParameterDeclaration"),parameters:(0, n.validateArrayOfType)(["Identifier","RestElement"]),typeAnnotation:(0, n.validateOptionalType)("TSTypeAnnotation")},l={aliases:["TSTypeElement"],visitor:["typeParameters","parameters","typeAnnotation"],fields:a};(0, n.default)("TSCallSignatureDeclaration",l),(0, n.default)("TSConstructSignatureDeclaration",l);const u={key:(0, n.validateType)("Expression"),computed:(0, n.validate)(i),optional:(0, n.validateOptional)(i)};(0, n.default)("TSPropertySignature",{aliases:["TSTypeElement"],visitor:["key","typeAnnotation","initializer"],fields:Object.assign({},u,{readonly:(0, n.validateOptional)(i),typeAnnotation:(0, n.validateOptionalType)("TSTypeAnnotation"),initializer:(0, n.validateOptionalType)("Expression")})}),(0, n.default)("TSMethodSignature",{aliases:["TSTypeElement"],visitor:["key","typeParameters","parameters","typeAnnotation"],fields:Object.assign({},a,u,{kind:{validate:(0, n.assertOneOf)("method","get","set")}})}),(0, n.default)("TSIndexSignature",{aliases:["TSTypeElement"],visitor:["parameters","typeAnnotation"],fields:{readonly:(0, n.validateOptional)(i),static:(0, n.validateOptional)(i),parameters:(0, n.validateArrayOfType)("Identifier"),typeAnnotation:(0, n.validateOptionalType)("TSTypeAnnotation")}});const c=["TSAnyKeyword","TSBooleanKeyword","TSBigIntKeyword","TSIntrinsicKeyword","TSNeverKeyword","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSStringKeyword","TSSymbolKeyword","TSUndefinedKeyword","TSUnknownKeyword","TSVoidKeyword"];for(const e of c)(0, n.default)(e,{aliases:["TSType","TSBaseType"],visitor:[],fields:{}});(0, n.default)("TSThisType",{aliases:["TSType","TSBaseType"],visitor:[],fields:{}});const p={aliases:["TSType"],visitor:["typeParameters","parameters","typeAnnotation"]};(0, n.default)("TSFunctionType",Object.assign({},p,{fields:a})),(0, n.default)("TSConstructorType",Object.assign({},p,{fields:Object.assign({},a,{abstract:(0, n.validateOptional)(i)})})),(0, n.default)("TSTypeReference",{aliases:["TSType"],visitor:["typeName","typeParameters"],fields:{typeName:(0, n.validateType)("TSEntityName"),typeParameters:(0, n.validateOptionalType)("TSTypeParameterInstantiation")}}),(0, n.default)("TSTypePredicate",{aliases:["TSType"],visitor:["parameterName","typeAnnotation"],builder:["parameterName","typeAnnotation","asserts"],fields:{parameterName:(0, n.validateType)(["Identifier","TSThisType"]),typeAnnotation:(0, n.validateOptionalType)("TSTypeAnnotation"),asserts:(0, n.validateOptional)(i)}}),(0, n.default)("TSTypeQuery",{aliases:["TSType"],visitor:["exprName"],fields:{exprName:(0, n.validateType)(["TSEntityName","TSImportType"])}}),(0, n.default)("TSTypeLiteral",{aliases:["TSType"],visitor:["members"],fields:{members:(0, n.validateArrayOfType)("TSTypeElement")}}),(0, n.default)("TSArrayType",{aliases:["TSType"],visitor:["elementType"],fields:{elementType:(0, n.validateType)("TSType")}}),(0, n.default)("TSTupleType",{aliases:["TSType"],visitor:["elementTypes"],fields:{elementTypes:(0, n.validateArrayOfType)(["TSType","TSNamedTupleMember"])}}),(0, n.default)("TSOptionalType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0, n.validateType)("TSType")}}),(0, n.default)("TSRestType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0, n.validateType)("TSType")}}),(0, n.default)("TSNamedTupleMember",{visitor:["label","elementType"],builder:["label","elementType","optional"],fields:{label:(0, n.validateType)("Identifier"),optional:{validate:i,default:!1},elementType:(0, n.validateType)("TSType")}});const d={aliases:["TSType"],visitor:["types"],fields:{types:(0, n.validateArrayOfType)("TSType")}};(0, n.default)("TSUnionType",d),(0, n.default)("TSIntersectionType",d),(0, n.default)("TSConditionalType",{aliases:["TSType"],visitor:["checkType","extendsType","trueType","falseType"],fields:{checkType:(0, n.validateType)("TSType"),extendsType:(0, n.validateType)("TSType"),trueType:(0, n.validateType)("TSType"),falseType:(0, n.validateType)("TSType")}}),(0, n.default)("TSInferType",{aliases:["TSType"],visitor:["typeParameter"],fields:{typeParameter:(0, n.validateType)("TSTypeParameter")}}),(0, n.default)("TSParenthesizedType",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{typeAnnotation:(0, n.validateType)("TSType")}}),(0, n.default)("TSTypeOperator",{aliases:["TSType"],visitor:["typeAnnotation"],fields:{operator:(0, n.validate)((0, n.assertValueType)("string")),typeAnnotation:(0, n.validateType)("TSType")}}),(0, n.default)("TSIndexedAccessType",{aliases:["TSType"],visitor:["objectType","indexType"],fields:{objectType:(0, n.validateType)("TSType"),indexType:(0, n.validateType)("TSType")}}),(0, n.default)("TSMappedType",{aliases:["TSType"],visitor:["typeParameter","typeAnnotation","nameType"],fields:{readonly:(0, n.validateOptional)(i),typeParameter:(0, n.validateType)("TSTypeParameter"),optional:(0, n.validateOptional)(i),typeAnnotation:(0, n.validateOptionalType)("TSType"),nameType:(0, n.validateOptionalType)("TSType")}}),(0, n.default)("TSLiteralType",{aliases:["TSType","TSBaseType"],visitor:["literal"],fields:{literal:(0, n.validateType)(["NumericLiteral","StringLiteral","BooleanLiteral","BigIntLiteral"])}}),(0, n.default)("TSExpressionWithTypeArguments",{aliases:["TSType"],visitor:["expression","typeParameters"],fields:{expression:(0, n.validateType)("TSEntityName"),typeParameters:(0, n.validateOptionalType)("TSTypeParameterInstantiation")}}),(0, n.default)("TSInterfaceDeclaration",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","extends","body"],fields:{declare:(0, n.validateOptional)(i),id:(0, n.validateType)("Identifier"),typeParameters:(0, n.validateOptionalType)("TSTypeParameterDeclaration"),extends:(0, n.validateOptional)((0, n.arrayOfType)("TSExpressionWithTypeArguments")),body:(0, n.validateType)("TSInterfaceBody")}}),(0, n.default)("TSInterfaceBody",{visitor:["body"],fields:{body:(0, n.validateArrayOfType)("TSTypeElement")}}),(0, n.default)("TSTypeAliasDeclaration",{aliases:["Statement","Declaration"],visitor:["id","typeParameters","typeAnnotation"],fields:{declare:(0, n.validateOptional)(i),id:(0, n.validateType)("Identifier"),typeParameters:(0, n.validateOptionalType)("TSTypeParameterDeclaration"),typeAnnotation:(0, n.validateType)("TSType")}}),(0, n.default)("TSAsExpression",{aliases:["Expression"],visitor:["expression","typeAnnotation"],fields:{expression:(0, n.validateType)("Expression"),typeAnnotation:(0, n.validateType)("TSType")}}),(0, n.default)("TSTypeAssertion",{aliases:["Expression"],visitor:["typeAnnotation","expression"],fields:{typeAnnotation:(0, n.validateType)("TSType"),expression:(0, n.validateType)("Expression")}}),(0, n.default)("TSEnumDeclaration",{aliases:["Statement","Declaration"],visitor:["id","members"],fields:{declare:(0, n.validateOptional)(i),const:(0, n.validateOptional)(i),id:(0, n.validateType)("Identifier"),members:(0, n.validateArrayOfType)("TSEnumMember"),initializer:(0, n.validateOptionalType)("Expression")}}),(0, n.default)("TSEnumMember",{visitor:["id","initializer"],fields:{id:(0, n.validateType)(["Identifier","StringLiteral"]),initializer:(0, n.validateOptionalType)("Expression")}}),(0, n.default)("TSModuleDeclaration",{aliases:["Statement","Declaration"],visitor:["id","body"],fields:{declare:(0, n.validateOptional)(i),global:(0, n.validateOptional)(i),id:(0, n.validateType)(["Identifier","StringLiteral"]),body:(0, n.validateType)(["TSModuleBlock","TSModuleDeclaration"])}}),(0, n.default)("TSModuleBlock",{aliases:["Scopable","Block","BlockParent"],visitor:["body"],fields:{body:(0, n.validateArrayOfType)("Statement")}}),(0, n.default)("TSImportType",{aliases:["TSType"],visitor:["argument","qualifier","typeParameters"],fields:{argument:(0, n.validateType)("StringLiteral"),qualifier:(0, n.validateOptionalType)("TSEntityName"),typeParameters:(0, n.validateOptionalType)("TSTypeParameterInstantiation")}}),(0, n.default)("TSImportEqualsDeclaration",{aliases:["Statement"],visitor:["id","moduleReference"],fields:{isExport:(0, n.validate)(i),id:(0, n.validateType)("Identifier"),moduleReference:(0, n.validateType)(["TSEntityName","TSExternalModuleReference"])}}),(0, n.default)("TSExternalModuleReference",{visitor:["expression"],fields:{expression:(0, n.validateType)("StringLiteral")}}),(0, n.default)("TSNonNullExpression",{aliases:["Expression"],visitor:["expression"],fields:{expression:(0, n.validateType)("Expression")}}),(0, n.default)("TSExportAssignment",{aliases:["Statement"],visitor:["expression"],fields:{expression:(0, n.validateType)("Expression")}}),(0, n.default)("TSNamespaceExportDeclaration",{aliases:["Statement"],visitor:["id"],fields:{id:(0, n.validateType)("Identifier")}}),(0, n.default)("TSTypeAnnotation",{visitor:["typeAnnotation"],fields:{typeAnnotation:{validate:(0, n.assertNodeType)("TSType")}}}),(0, n.default)("TSTypeParameterInstantiation",{visitor:["params"],fields:{params:{validate:(0, n.chain)((0, n.assertValueType)("array"),(0, n.assertEach)((0, n.assertNodeType)("TSType")))}}}),(0, n.default)("TSTypeParameterDeclaration",{visitor:["params"],fields:{params:{validate:(0, n.chain)((0, n.assertValueType)("array"),(0, n.assertEach)((0, n.assertNodeType)("TSTypeParameter")))}}}),(0, n.default)("TSTypeParameter",{builder:["constraint","default","name"],visitor:["constraint","default"],fields:{name:{validate:(0, n.assertValueType)("string")},constraint:{validate:(0, n.assertNodeType)("TSType"),optional:!0},default:{validate:(0, n.assertNodeType)("TSType"),optional:!0}}});},"./node_modules/@babel/types/lib/definitions/utils.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.validate=f,t.typeIs=h,t.validateType=function(e){return f(h(e))},t.validateOptional=function(e){return {validate:e,optional:!0}},t.validateOptionalType=function(e){return {validate:h(e),optional:!0}},t.arrayOf=m,t.arrayOfType=y,t.validateArrayOfType=function(e){return f(y(e))},t.assertEach=b,t.assertOneOf=function(...e){function t(t,r,n){if(e.indexOf(n)<0)throw new TypeError(`Property ${r} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(n)}`)}return t.oneOf=e,t},t.assertNodeType=g,t.assertNodeOrValueType=function(...e){function t(t,r,i){for(const o of e)if(d(i)===o||(0, n.default)(o,i))return void(0, s.validateChild)(t,r,i);throw new TypeError(`Property ${r} of ${t.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(null==i?void 0:i.type)}`)}return t.oneOfNodeOrValueTypes=e,t},t.assertValueType=E,t.assertShape=function(e){function t(t,r,n){const i=[];for(const r of Object.keys(e))try{(0,s.validateField)(t,r,n[r],e[r]);}catch(e){if(e instanceof TypeError){i.push(e.message);continue}throw e}if(i.length)throw new TypeError(`Property ${r} of ${t.type} expected to have the following:\n${i.join("\n")}`)}return t.shapeOf=e,t},t.assertOptionalChainStart=function(){return function(e){var t;let r=e;for(;e;){const{type:e}=r;if("OptionalCallExpression"!==e){if("OptionalMemberExpression"!==e)break;if(r.optional)return;r=r.object;}else {if(r.optional)return;r=r.callee;}}throw new TypeError(`Non-optional ${e.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null==(t=r)?void 0:t.type}`)}},t.chain=v,t.default=function(e,t={}){const r=t.inherits&&S[t.inherits]||{};let n=t.fields;if(!n&&(n={},r.fields)){const e=Object.getOwnPropertyNames(r.fields);for(const t of e){const e=r.fields[t],s=e.default;if(Array.isArray(s)?s.length>0:s&&"object"==typeof s)throw new Error("field defaults can only be primitives or empty arrays currently");n[t]={default:Array.isArray(s)?[]:s,optional:e.optional,validate:e.validate};}}const s=t.visitor||r.visitor||[],f=t.aliases||r.aliases||[],h=t.builder||r.builder||t.visitor||[];for(const r of Object.keys(t))if(-1===x.indexOf(r))throw new Error(`Unknown type option "${r}" on ${e}`);t.deprecatedAlias&&(c[t.deprecatedAlias]=e);for(const e of s.concat(h))n[e]=n[e]||{};for(const t of Object.keys(n)){const r=n[t];void 0!==r.default&&-1===h.indexOf(t)&&(r.optional=!0),void 0===r.default?r.default=null:r.validate||null==r.default||(r.validate=E(d(r.default)));for(const n of Object.keys(r))if(-1===T.indexOf(n))throw new Error(`Unknown field key "${n}" on ${e}.${t}`)}i[e]=t.visitor=s,u[e]=t.builder=h,l[e]=t.fields=n,o[e]=t.aliases=f,f.forEach((t=>{a[t]=a[t]||[],a[t].push(e);})),t.validate&&(p[e]=t.validate),S[e]=t;},t.NODE_PARENT_VALIDATIONS=t.DEPRECATED_KEYS=t.BUILDER_KEYS=t.NODE_FIELDS=t.FLIPPED_ALIAS_KEYS=t.ALIAS_KEYS=t.VISITOR_KEYS=void 0;var n=r("./node_modules/@babel/types/lib/validators/is.js"),s=r("./node_modules/@babel/types/lib/validators/validate.js");const i={};t.VISITOR_KEYS=i;const o={};t.ALIAS_KEYS=o;const a={};t.FLIPPED_ALIAS_KEYS=a;const l={};t.NODE_FIELDS=l;const u={};t.BUILDER_KEYS=u;const c={};t.DEPRECATED_KEYS=c;const p={};function d(e){return Array.isArray(e)?"array":null===e?"null":typeof e}function f(e){return {validate:e}}function h(e){return "string"==typeof e?g(e):g(...e)}function m(e){return v(E("array"),b(e))}function y(e){return m(h(e))}function b(e){function t(t,r,n){if(Array.isArray(n))for(let i=0;i<n.length;i++){const o=`${r}[${i}]`,a=n[i];e(t,o,a),process.env.BABEL_TYPES_8_BREAKING&&(0, s.validateChild)(t,o,a);}}return t.each=e,t}function g(...e){function t(t,r,i){for(const o of e)if((0, n.default)(o,i))return void(0, s.validateChild)(t,r,i);throw new TypeError(`Property ${r} of ${t.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(null==i?void 0:i.type)}`)}return t.oneOfNodeTypes=e,t}function E(e){function t(t,r,n){if(d(n)!==e)throw new TypeError(`Property ${r} expected type of ${e} but got ${d(n)}`)}return t.type=e,t}function v(...e){function t(...t){for(const r of e)r(...t);}if(t.chainOf=e,e.length>=2&&"type"in e[0]&&"array"===e[0].type&&!("each"in e[1]))throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');return t}t.NODE_PARENT_VALIDATIONS=p;const x=["aliases","builder","deprecatedAlias","fields","inherits","visitor","validate"],T=["default","optional","validate"],S={};},"./node_modules/@babel/types/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0});var n={react:!0,assertNode:!0,createTypeAnnotationBasedOnTypeof:!0,createUnionTypeAnnotation:!0,createFlowUnionType:!0,createTSUnionType:!0,cloneNode:!0,clone:!0,cloneDeep:!0,cloneDeepWithoutLoc:!0,cloneWithoutLoc:!0,addComment:!0,addComments:!0,inheritInnerComments:!0,inheritLeadingComments:!0,inheritsComments:!0,inheritTrailingComments:!0,removeComments:!0,ensureBlock:!0,toBindingIdentifierName:!0,toBlock:!0,toComputedKey:!0,toExpression:!0,toIdentifier:!0,toKeyAlias:!0,toSequenceExpression:!0,toStatement:!0,valueToNode:!0,appendToMemberExpression:!0,inherits:!0,prependToMemberExpression:!0,removeProperties:!0,removePropertiesDeep:!0,removeTypeDuplicates:!0,getBindingIdentifiers:!0,getOuterBindingIdentifiers:!0,traverse:!0,traverseFast:!0,shallowEqual:!0,is:!0,isBinding:!0,isBlockScoped:!0,isImmutable:!0,isLet:!0,isNode:!0,isNodesEquivalent:!0,isPlaceholderType:!0,isReferenced:!0,isScope:!0,isSpecifierDefault:!0,isType:!0,isValidES3Identifier:!0,isValidIdentifier:!0,isVar:!0,matchesPattern:!0,validate:!0,buildMatchMemberExpression:!0};Object.defineProperty(t,"assertNode",{enumerable:!0,get:function(){return a.default}}),Object.defineProperty(t,"createTypeAnnotationBasedOnTypeof",{enumerable:!0,get:function(){return u.default}}),Object.defineProperty(t,"createUnionTypeAnnotation",{enumerable:!0,get:function(){return c.default}}),Object.defineProperty(t,"createFlowUnionType",{enumerable:!0,get:function(){return c.default}}),Object.defineProperty(t,"createTSUnionType",{enumerable:!0,get:function(){return p.default}}),Object.defineProperty(t,"cloneNode",{enumerable:!0,get:function(){return h.default}}),Object.defineProperty(t,"clone",{enumerable:!0,get:function(){return m.default}}),Object.defineProperty(t,"cloneDeep",{enumerable:!0,get:function(){return y.default}}),Object.defineProperty(t,"cloneDeepWithoutLoc",{enumerable:!0,get:function(){return b.default}}),Object.defineProperty(t,"cloneWithoutLoc",{enumerable:!0,get:function(){return g.default}}),Object.defineProperty(t,"addComment",{enumerable:!0,get:function(){return E.default}}),Object.defineProperty(t,"addComments",{enumerable:!0,get:function(){return v.default}}),Object.defineProperty(t,"inheritInnerComments",{enumerable:!0,get:function(){return x.default}}),Object.defineProperty(t,"inheritLeadingComments",{enumerable:!0,get:function(){return T.default}}),Object.defineProperty(t,"inheritsComments",{enumerable:!0,get:function(){return S.default}}),Object.defineProperty(t,"inheritTrailingComments",{enumerable:!0,get:function(){return P.default}}),Object.defineProperty(t,"removeComments",{enumerable:!0,get:function(){return A.default}}),Object.defineProperty(t,"ensureBlock",{enumerable:!0,get:function(){return D.default}}),Object.defineProperty(t,"toBindingIdentifierName",{enumerable:!0,get:function(){return _.default}}),Object.defineProperty(t,"toBlock",{enumerable:!0,get:function(){return O.default}}),Object.defineProperty(t,"toComputedKey",{enumerable:!0,get:function(){return j.default}}),Object.defineProperty(t,"toExpression",{enumerable:!0,get:function(){return I.default}}),Object.defineProperty(t,"toIdentifier",{enumerable:!0,get:function(){return N.default}}),Object.defineProperty(t,"toKeyAlias",{enumerable:!0,get:function(){return k.default}}),Object.defineProperty(t,"toSequenceExpression",{enumerable:!0,get:function(){return F.default}}),Object.defineProperty(t,"toStatement",{enumerable:!0,get:function(){return L.default}}),Object.defineProperty(t,"valueToNode",{enumerable:!0,get:function(){return M.default}}),Object.defineProperty(t,"appendToMemberExpression",{enumerable:!0,get:function(){return R.default}}),Object.defineProperty(t,"inherits",{enumerable:!0,get:function(){return U.default}}),Object.defineProperty(t,"prependToMemberExpression",{enumerable:!0,get:function(){return V.default}}),Object.defineProperty(t,"removeProperties",{enumerable:!0,get:function(){return W.default}}),Object.defineProperty(t,"removePropertiesDeep",{enumerable:!0,get:function(){return $.default}}),Object.defineProperty(t,"removeTypeDuplicates",{enumerable:!0,get:function(){return K.default}}),Object.defineProperty(t,"getBindingIdentifiers",{enumerable:!0,get:function(){return q.default}}),Object.defineProperty(t,"getOuterBindingIdentifiers",{enumerable:!0,get:function(){return G.default}}),Object.defineProperty(t,"traverse",{enumerable:!0,get:function(){return H.default}}),Object.defineProperty(t,"traverseFast",{enumerable:!0,get:function(){return J.default}}),Object.defineProperty(t,"shallowEqual",{enumerable:!0,get:function(){return Y.default}}),Object.defineProperty(t,"is",{enumerable:!0,get:function(){return X.default}}),Object.defineProperty(t,"isBinding",{enumerable:!0,get:function(){return z.default}}),Object.defineProperty(t,"isBlockScoped",{enumerable:!0,get:function(){return Q.default}}),Object.defineProperty(t,"isImmutable",{enumerable:!0,get:function(){return Z.default}}),Object.defineProperty(t,"isLet",{enumerable:!0,get:function(){return ee.default}}),Object.defineProperty(t,"isNode",{enumerable:!0,get:function(){return te.default}}),Object.defineProperty(t,"isNodesEquivalent",{enumerable:!0,get:function(){return re.default}}),Object.defineProperty(t,"isPlaceholderType",{enumerable:!0,get:function(){return ne.default}}),Object.defineProperty(t,"isReferenced",{enumerable:!0,get:function(){return se.default}}),Object.defineProperty(t,"isScope",{enumerable:!0,get:function(){return ie.default}}),Object.defineProperty(t,"isSpecifierDefault",{enumerable:!0,get:function(){return oe.default}}),Object.defineProperty(t,"isType",{enumerable:!0,get:function(){return ae.default}}),Object.defineProperty(t,"isValidES3Identifier",{enumerable:!0,get:function(){return le.default}}),Object.defineProperty(t,"isValidIdentifier",{enumerable:!0,get:function(){return ue.default}}),Object.defineProperty(t,"isVar",{enumerable:!0,get:function(){return ce.default}}),Object.defineProperty(t,"matchesPattern",{enumerable:!0,get:function(){return pe.default}}),Object.defineProperty(t,"validate",{enumerable:!0,get:function(){return de.default}}),Object.defineProperty(t,"buildMatchMemberExpression",{enumerable:!0,get:function(){return fe.default}}),t.react=void 0;var s=r("./node_modules/@babel/types/lib/validators/react/isReactComponent.js"),i=r("./node_modules/@babel/types/lib/validators/react/isCompatTag.js"),o=r("./node_modules/@babel/types/lib/builders/react/buildChildren.js"),a=r("./node_modules/@babel/types/lib/asserts/assertNode.js"),l=r("./node_modules/@babel/types/lib/asserts/generated/index.js");Object.keys(l).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(n,e)||e in t&&t[e]===l[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return l[e]}}));}));var u=r("./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"),c=r("./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"),p=r("./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"),d=r("./node_modules/@babel/types/lib/builders/generated/index.js");Object.keys(d).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(n,e)||e in t&&t[e]===d[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return d[e]}}));}));var f=r("./node_modules/@babel/types/lib/builders/generated/uppercase.js");Object.keys(f).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(n,e)||e in t&&t[e]===f[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return f[e]}}));}));var h=r("./node_modules/@babel/types/lib/clone/cloneNode.js"),m=r("./node_modules/@babel/types/lib/clone/clone.js"),y=r("./node_modules/@babel/types/lib/clone/cloneDeep.js"),b=r("./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"),g=r("./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"),E=r("./node_modules/@babel/types/lib/comments/addComment.js"),v=r("./node_modules/@babel/types/lib/comments/addComments.js"),x=r("./node_modules/@babel/types/lib/comments/inheritInnerComments.js"),T=r("./node_modules/@babel/types/lib/comments/inheritLeadingComments.js"),S=r("./node_modules/@babel/types/lib/comments/inheritsComments.js"),P=r("./node_modules/@babel/types/lib/comments/inheritTrailingComments.js"),A=r("./node_modules/@babel/types/lib/comments/removeComments.js"),w=r("./node_modules/@babel/types/lib/constants/generated/index.js");Object.keys(w).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(n,e)||e in t&&t[e]===w[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return w[e]}}));}));var C=r("./node_modules/@babel/types/lib/constants/index.js");Object.keys(C).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(n,e)||e in t&&t[e]===C[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return C[e]}}));}));var D=r("./node_modules/@babel/types/lib/converters/ensureBlock.js"),_=r("./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"),O=r("./node_modules/@babel/types/lib/converters/toBlock.js"),j=r("./node_modules/@babel/types/lib/converters/toComputedKey.js"),I=r("./node_modules/@babel/types/lib/converters/toExpression.js"),N=r("./node_modules/@babel/types/lib/converters/toIdentifier.js"),k=r("./node_modules/@babel/types/lib/converters/toKeyAlias.js"),F=r("./node_modules/@babel/types/lib/converters/toSequenceExpression.js"),L=r("./node_modules/@babel/types/lib/converters/toStatement.js"),M=r("./node_modules/@babel/types/lib/converters/valueToNode.js"),B=r("./node_modules/@babel/types/lib/definitions/index.js");Object.keys(B).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(n,e)||e in t&&t[e]===B[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return B[e]}}));}));var R=r("./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"),U=r("./node_modules/@babel/types/lib/modifications/inherits.js"),V=r("./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"),W=r("./node_modules/@babel/types/lib/modifications/removeProperties.js"),$=r("./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"),K=r("./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"),q=r("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"),G=r("./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"),H=r("./node_modules/@babel/types/lib/traverse/traverse.js");Object.keys(H).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(n,e)||e in t&&t[e]===H[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return H[e]}}));}));var J=r("./node_modules/@babel/types/lib/traverse/traverseFast.js"),Y=r("./node_modules/@babel/types/lib/utils/shallowEqual.js"),X=r("./node_modules/@babel/types/lib/validators/is.js"),z=r("./node_modules/@babel/types/lib/validators/isBinding.js"),Q=r("./node_modules/@babel/types/lib/validators/isBlockScoped.js"),Z=r("./node_modules/@babel/types/lib/validators/isImmutable.js"),ee=r("./node_modules/@babel/types/lib/validators/isLet.js"),te=r("./node_modules/@babel/types/lib/validators/isNode.js"),re=r("./node_modules/@babel/types/lib/validators/isNodesEquivalent.js"),ne=r("./node_modules/@babel/types/lib/validators/isPlaceholderType.js"),se=r("./node_modules/@babel/types/lib/validators/isReferenced.js"),ie=r("./node_modules/@babel/types/lib/validators/isScope.js"),oe=r("./node_modules/@babel/types/lib/validators/isSpecifierDefault.js"),ae=r("./node_modules/@babel/types/lib/validators/isType.js"),le=r("./node_modules/@babel/types/lib/validators/isValidES3Identifier.js"),ue=r("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"),ce=r("./node_modules/@babel/types/lib/validators/isVar.js"),pe=r("./node_modules/@babel/types/lib/validators/matchesPattern.js"),de=r("./node_modules/@babel/types/lib/validators/validate.js"),fe=r("./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"),he=r("./node_modules/@babel/types/lib/validators/generated/index.js");Object.keys(he).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(n,e)||e in t&&t[e]===he[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return he[e]}}));}));var me=r("./node_modules/@babel/types/lib/ast-types/generated/index.js");Object.keys(me).forEach((function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(n,e)||e in t&&t[e]===me[e]||Object.defineProperty(t,e,{enumerable:!0,get:function(){return me[e]}}));}));const ye={isReactComponent:s.default,isCompatTag:i.default,buildChildren:o.default};t.react=ye;},"./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r=!1){return e.object=(0, n.memberExpression)(e.object,e.property,e.computed),e.property=t,e.computed=!!r,e};var n=r("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function e(t){const r={},i={},o=[],a=[];for(let l=0;l<t.length;l++){const u=t[l];if(u&&!(a.indexOf(u)>=0)){if((0, n.isAnyTypeAnnotation)(u))return [u];if((0, n.isFlowBaseAnnotation)(u))i[u.type]=u;else if((0, n.isUnionTypeAnnotation)(u))o.indexOf(u.types)<0&&(t=t.concat(u.types),o.push(u.types));else if((0, n.isGenericTypeAnnotation)(u)){const t=s(u.id);if(r[t]){let n=r[t];n.typeParameters?u.typeParameters&&(n.typeParameters.params=e(n.typeParameters.params.concat(u.typeParameters.params))):n=u.typeParameters;}else r[t]=u;}else a.push(u);}}for(const e of Object.keys(i))a.push(i[e]);for(const e of Object.keys(r))a.push(r[e]);return a};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js");function s(e){return (0, n.isIdentifier)(e)?e.name:`${e.id.name}.${s(e.qualification)}`}},"./node_modules/@babel/types/lib/modifications/inherits.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(!e||!t)return e;for(const r of n.INHERIT_KEYS.optional)null==e[r]&&(e[r]=t[r]);for(const r of Object.keys(t))"_"===r[0]&&"__clone"!==r&&(e[r]=t[r]);for(const r of n.INHERIT_KEYS.force)e[r]=t[r];return (0, s.default)(e,t),e};var n=r("./node_modules/@babel/types/lib/constants/index.js"),s=r("./node_modules/@babel/types/lib/comments/inheritsComments.js");},"./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){return e.object=(0, n.memberExpression)(t,e.object),e};var n=r("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/modifications/removeProperties.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t={}){const r=t.preserveComments?s:i;for(const t of r)null!=e[t]&&(e[t]=void 0);for(const t of Object.keys(e))"_"===t[0]&&null!=e[t]&&(e[t]=void 0);const n=Object.getOwnPropertySymbols(e);for(const t of n)e[t]=null;};var n=r("./node_modules/@babel/types/lib/constants/index.js");const s=["tokens","start","end","loc","raw","rawValue"],i=n.COMMENT_KEYS.concat(["comments"]).concat(s);},"./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){return (0, n.default)(e,s.default,t),e};var n=r("./node_modules/@babel/types/lib/traverse/traverseFast.js"),s=r("./node_modules/@babel/types/lib/modifications/removeProperties.js");},"./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){const t={},r={},s=[],i=[];for(let t=0;t<e.length;t++){const o=e[t];if(o&&!(i.indexOf(o)>=0)){if((0, n.isTSAnyKeyword)(o))return [o];(0, n.isTSBaseType)(o)?r[o.type]=o:(0, n.isTSUnionType)(o)?s.indexOf(o.types)<0&&(e=e.concat(o.types),s.push(o.types)):i.push(o);}}for(const e of Object.keys(r))i.push(r[e]);for(const e of Object.keys(t))i.push(t[e]);return i};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=s;var n=r("./node_modules/@babel/types/lib/validators/generated/index.js");function s(e,t,r){let i=[].concat(e);const o=Object.create(null);for(;i.length;){const e=i.shift();if(!e)continue;const a=s.keys[e.type];if((0, n.isIdentifier)(e))t?(o[e.name]=o[e.name]||[]).push(e):o[e.name]=e;else if(!(0, n.isExportDeclaration)(e)||(0, n.isExportAllDeclaration)(e)){if(r){if((0, n.isFunctionDeclaration)(e)){i.push(e.id);continue}if((0, n.isFunctionExpression)(e))continue}if(a)for(let t=0;t<a.length;t++){const r=a[t];e[r]&&(i=i.concat(e[r]));}}else (0, n.isDeclaration)(e.declaration)&&i.push(e.declaration);}return o}s.keys={DeclareClass:["id"],DeclareFunction:["id"],DeclareModule:["id"],DeclareVariable:["id"],DeclareInterface:["id"],DeclareTypeAlias:["id"],DeclareOpaqueType:["id"],InterfaceDeclaration:["id"],TypeAlias:["id"],OpaqueType:["id"],CatchClause:["param"],LabeledStatement:["label"],UnaryExpression:["argument"],AssignmentExpression:["left"],ImportSpecifier:["local"],ImportNamespaceSpecifier:["local"],ImportDefaultSpecifier:["local"],ImportDeclaration:["specifiers"],ExportSpecifier:["exported"],ExportNamespaceSpecifier:["exported"],ExportDefaultSpecifier:["exported"],FunctionDeclaration:["id","params"],FunctionExpression:["id","params"],ArrowFunctionExpression:["params"],ObjectMethod:["params"],ClassMethod:["params"],ForInStatement:["left"],ForOfStatement:["left"],ClassDeclaration:["id"],ClassExpression:["id"],RestElement:["argument"],UpdateExpression:["argument"],ObjectProperty:["value"],AssignmentPattern:["left"],ArrayPattern:["elements"],ObjectPattern:["properties"],VariableDeclaration:["declarations"],VariableDeclarator:["id"]};},"./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");t.default=function(e,t){return (0, n.default)(e,t,!0)};},"./node_modules/@babel/types/lib/traverse/traverse.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){"function"==typeof t&&(t={enter:t});const{enter:n,exit:i}=t;s(e,n,i,r,[]);};var n=r("./node_modules/@babel/types/lib/definitions/index.js");function s(e,t,r,i,o){const a=n.VISITOR_KEYS[e.type];if(a){t&&t(e,o,i);for(const n of a){const a=e[n];if(Array.isArray(a))for(let l=0;l<a.length;l++){const u=a[l];u&&(o.push({node:e,key:n,index:l}),s(u,t,r,i,o),o.pop());}else a&&(o.push({node:e,key:n}),s(a,t,r,i,o),o.pop());}r&&r(e,o,i);}}},"./node_modules/@babel/types/lib/traverse/traverseFast.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function e(t,r,s){if(!t)return;const i=n.VISITOR_KEYS[t.type];if(i){r(t,s=s||{});for(const n of i){const i=t[n];if(Array.isArray(i))for(const t of i)e(t,r,s);else e(i,r,s);}}};var n=r("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/utils/inherit.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){t&&r&&(t[e]=Array.from(new Set([].concat(t[e],r[e]).filter(Boolean))));};},"./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){const r=e.value.split(/\r\n|\n|\r/);let s=0;for(let e=0;e<r.length;e++)r[e].match(/[^ \t]/)&&(s=e);let i="";for(let e=0;e<r.length;e++){const t=r[e],n=0===e,o=e===r.length-1,a=e===s;let l=t.replace(/\t/g," ");n||(l=l.replace(/^[ ]+/,"")),o||(l=l.replace(/[ ]+$/,"")),l&&(a||(l+=" "),i+=l);}i&&t.push((0, n.stringLiteral)(i));};var n=r("./node_modules/@babel/types/lib/builders/generated/index.js");},"./node_modules/@babel/types/lib/utils/shallowEqual.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){const r=Object.keys(t);for(const n of r)if(e[n]!==t[n])return !1;return !0};},"./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){const r=e.split(".");return e=>(0, n.default)(e,r,t)};var n=r("./node_modules/@babel/types/lib/validators/matchesPattern.js");},"./node_modules/@babel/types/lib/validators/generated/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isArrayExpression=function(e,t){return !!e&&("ArrayExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isAssignmentExpression=function(e,t){return !!e&&("AssignmentExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isBinaryExpression=function(e,t){return !!e&&("BinaryExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isInterpreterDirective=function(e,t){return !!e&&("InterpreterDirective"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDirective=function(e,t){return !!e&&("Directive"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDirectiveLiteral=function(e,t){return !!e&&("DirectiveLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isBlockStatement=function(e,t){return !!e&&("BlockStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isBreakStatement=function(e,t){return !!e&&("BreakStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isCallExpression=function(e,t){return !!e&&("CallExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isCatchClause=function(e,t){return !!e&&("CatchClause"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isConditionalExpression=function(e,t){return !!e&&("ConditionalExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isContinueStatement=function(e,t){return !!e&&("ContinueStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDebuggerStatement=function(e,t){return !!e&&("DebuggerStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDoWhileStatement=function(e,t){return !!e&&("DoWhileStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEmptyStatement=function(e,t){return !!e&&("EmptyStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isExpressionStatement=function(e,t){return !!e&&("ExpressionStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isFile=function(e,t){return !!e&&("File"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isForInStatement=function(e,t){return !!e&&("ForInStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isForStatement=function(e,t){return !!e&&("ForStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isFunctionDeclaration=function(e,t){return !!e&&("FunctionDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isFunctionExpression=function(e,t){return !!e&&("FunctionExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isIdentifier=function(e,t){return !!e&&("Identifier"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isIfStatement=function(e,t){return !!e&&("IfStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isLabeledStatement=function(e,t){return !!e&&("LabeledStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isStringLiteral=function(e,t){return !!e&&("StringLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isNumericLiteral=function(e,t){return !!e&&("NumericLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isNullLiteral=function(e,t){return !!e&&("NullLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isBooleanLiteral=function(e,t){return !!e&&("BooleanLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isRegExpLiteral=function(e,t){return !!e&&("RegExpLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isLogicalExpression=function(e,t){return !!e&&("LogicalExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isMemberExpression=function(e,t){return !!e&&("MemberExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isNewExpression=function(e,t){return !!e&&("NewExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isProgram=function(e,t){return !!e&&("Program"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isObjectExpression=function(e,t){return !!e&&("ObjectExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isObjectMethod=function(e,t){return !!e&&("ObjectMethod"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isObjectProperty=function(e,t){return !!e&&("ObjectProperty"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isRestElement=function(e,t){return !!e&&("RestElement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isReturnStatement=function(e,t){return !!e&&("ReturnStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isSequenceExpression=function(e,t){return !!e&&("SequenceExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isParenthesizedExpression=function(e,t){return !!e&&("ParenthesizedExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isSwitchCase=function(e,t){return !!e&&("SwitchCase"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isSwitchStatement=function(e,t){return !!e&&("SwitchStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isThisExpression=function(e,t){return !!e&&("ThisExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isThrowStatement=function(e,t){return !!e&&("ThrowStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTryStatement=function(e,t){return !!e&&("TryStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isUnaryExpression=function(e,t){return !!e&&("UnaryExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isUpdateExpression=function(e,t){return !!e&&("UpdateExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isVariableDeclaration=function(e,t){return !!e&&("VariableDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isVariableDeclarator=function(e,t){return !!e&&("VariableDeclarator"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isWhileStatement=function(e,t){return !!e&&("WhileStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isWithStatement=function(e,t){return !!e&&("WithStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isAssignmentPattern=function(e,t){return !!e&&("AssignmentPattern"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isArrayPattern=function(e,t){return !!e&&("ArrayPattern"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isArrowFunctionExpression=function(e,t){return !!e&&("ArrowFunctionExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isClassBody=function(e,t){return !!e&&("ClassBody"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isClassExpression=function(e,t){return !!e&&("ClassExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isClassDeclaration=function(e,t){return !!e&&("ClassDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isExportAllDeclaration=function(e,t){return !!e&&("ExportAllDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isExportDefaultDeclaration=function(e,t){return !!e&&("ExportDefaultDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isExportNamedDeclaration=function(e,t){return !!e&&("ExportNamedDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isExportSpecifier=function(e,t){return !!e&&("ExportSpecifier"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isForOfStatement=function(e,t){return !!e&&("ForOfStatement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isImportDeclaration=function(e,t){return !!e&&("ImportDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isImportDefaultSpecifier=function(e,t){return !!e&&("ImportDefaultSpecifier"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isImportNamespaceSpecifier=function(e,t){return !!e&&("ImportNamespaceSpecifier"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isImportSpecifier=function(e,t){return !!e&&("ImportSpecifier"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isMetaProperty=function(e,t){return !!e&&("MetaProperty"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isClassMethod=function(e,t){return !!e&&("ClassMethod"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isObjectPattern=function(e,t){return !!e&&("ObjectPattern"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isSpreadElement=function(e,t){return !!e&&("SpreadElement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isSuper=function(e,t){return !!e&&("Super"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTaggedTemplateExpression=function(e,t){return !!e&&("TaggedTemplateExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTemplateElement=function(e,t){return !!e&&("TemplateElement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTemplateLiteral=function(e,t){return !!e&&("TemplateLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isYieldExpression=function(e,t){return !!e&&("YieldExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isAwaitExpression=function(e,t){return !!e&&("AwaitExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isImport=function(e,t){return !!e&&("Import"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isBigIntLiteral=function(e,t){return !!e&&("BigIntLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isExportNamespaceSpecifier=function(e,t){return !!e&&("ExportNamespaceSpecifier"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isOptionalMemberExpression=function(e,t){return !!e&&("OptionalMemberExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isOptionalCallExpression=function(e,t){return !!e&&("OptionalCallExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isAnyTypeAnnotation=function(e,t){return !!e&&("AnyTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isArrayTypeAnnotation=function(e,t){return !!e&&("ArrayTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isBooleanTypeAnnotation=function(e,t){return !!e&&("BooleanTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isBooleanLiteralTypeAnnotation=function(e,t){return !!e&&("BooleanLiteralTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isNullLiteralTypeAnnotation=function(e,t){return !!e&&("NullLiteralTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isClassImplements=function(e,t){return !!e&&("ClassImplements"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclareClass=function(e,t){return !!e&&("DeclareClass"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclareFunction=function(e,t){return !!e&&("DeclareFunction"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclareInterface=function(e,t){return !!e&&("DeclareInterface"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclareModule=function(e,t){return !!e&&("DeclareModule"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclareModuleExports=function(e,t){return !!e&&("DeclareModuleExports"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclareTypeAlias=function(e,t){return !!e&&("DeclareTypeAlias"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclareOpaqueType=function(e,t){return !!e&&("DeclareOpaqueType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclareVariable=function(e,t){return !!e&&("DeclareVariable"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclareExportDeclaration=function(e,t){return !!e&&("DeclareExportDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclareExportAllDeclaration=function(e,t){return !!e&&("DeclareExportAllDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDeclaredPredicate=function(e,t){return !!e&&("DeclaredPredicate"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isExistsTypeAnnotation=function(e,t){return !!e&&("ExistsTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isFunctionTypeAnnotation=function(e,t){return !!e&&("FunctionTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isFunctionTypeParam=function(e,t){return !!e&&("FunctionTypeParam"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isGenericTypeAnnotation=function(e,t){return !!e&&("GenericTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isInferredPredicate=function(e,t){return !!e&&("InferredPredicate"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isInterfaceExtends=function(e,t){return !!e&&("InterfaceExtends"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isInterfaceDeclaration=function(e,t){return !!e&&("InterfaceDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isInterfaceTypeAnnotation=function(e,t){return !!e&&("InterfaceTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isIntersectionTypeAnnotation=function(e,t){return !!e&&("IntersectionTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isMixedTypeAnnotation=function(e,t){return !!e&&("MixedTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEmptyTypeAnnotation=function(e,t){return !!e&&("EmptyTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isNullableTypeAnnotation=function(e,t){return !!e&&("NullableTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isNumberLiteralTypeAnnotation=function(e,t){return !!e&&("NumberLiteralTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isNumberTypeAnnotation=function(e,t){return !!e&&("NumberTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isObjectTypeAnnotation=function(e,t){return !!e&&("ObjectTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isObjectTypeInternalSlot=function(e,t){return !!e&&("ObjectTypeInternalSlot"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isObjectTypeCallProperty=function(e,t){return !!e&&("ObjectTypeCallProperty"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isObjectTypeIndexer=function(e,t){return !!e&&("ObjectTypeIndexer"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isObjectTypeProperty=function(e,t){return !!e&&("ObjectTypeProperty"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isObjectTypeSpreadProperty=function(e,t){return !!e&&("ObjectTypeSpreadProperty"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isOpaqueType=function(e,t){return !!e&&("OpaqueType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isQualifiedTypeIdentifier=function(e,t){return !!e&&("QualifiedTypeIdentifier"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isStringLiteralTypeAnnotation=function(e,t){return !!e&&("StringLiteralTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isStringTypeAnnotation=function(e,t){return !!e&&("StringTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isSymbolTypeAnnotation=function(e,t){return !!e&&("SymbolTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isThisTypeAnnotation=function(e,t){return !!e&&("ThisTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTupleTypeAnnotation=function(e,t){return !!e&&("TupleTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTypeofTypeAnnotation=function(e,t){return !!e&&("TypeofTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTypeAlias=function(e,t){return !!e&&("TypeAlias"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTypeAnnotation=function(e,t){return !!e&&("TypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTypeCastExpression=function(e,t){return !!e&&("TypeCastExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTypeParameter=function(e,t){return !!e&&("TypeParameter"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTypeParameterDeclaration=function(e,t){return !!e&&("TypeParameterDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTypeParameterInstantiation=function(e,t){return !!e&&("TypeParameterInstantiation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isUnionTypeAnnotation=function(e,t){return !!e&&("UnionTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isVariance=function(e,t){return !!e&&("Variance"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isVoidTypeAnnotation=function(e,t){return !!e&&("VoidTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEnumDeclaration=function(e,t){return !!e&&("EnumDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEnumBooleanBody=function(e,t){return !!e&&("EnumBooleanBody"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEnumNumberBody=function(e,t){return !!e&&("EnumNumberBody"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEnumStringBody=function(e,t){return !!e&&("EnumStringBody"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEnumSymbolBody=function(e,t){return !!e&&("EnumSymbolBody"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEnumBooleanMember=function(e,t){return !!e&&("EnumBooleanMember"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEnumNumberMember=function(e,t){return !!e&&("EnumNumberMember"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEnumStringMember=function(e,t){return !!e&&("EnumStringMember"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isEnumDefaultedMember=function(e,t){return !!e&&("EnumDefaultedMember"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isIndexedAccessType=function(e,t){return !!e&&("IndexedAccessType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isOptionalIndexedAccessType=function(e,t){return !!e&&("OptionalIndexedAccessType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXAttribute=function(e,t){return !!e&&("JSXAttribute"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXClosingElement=function(e,t){return !!e&&("JSXClosingElement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXElement=function(e,t){return !!e&&("JSXElement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXEmptyExpression=function(e,t){return !!e&&("JSXEmptyExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXExpressionContainer=function(e,t){return !!e&&("JSXExpressionContainer"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXSpreadChild=function(e,t){return !!e&&("JSXSpreadChild"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXIdentifier=function(e,t){return !!e&&("JSXIdentifier"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXMemberExpression=function(e,t){return !!e&&("JSXMemberExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXNamespacedName=function(e,t){return !!e&&("JSXNamespacedName"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXOpeningElement=function(e,t){return !!e&&("JSXOpeningElement"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXSpreadAttribute=function(e,t){return !!e&&("JSXSpreadAttribute"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXText=function(e,t){return !!e&&("JSXText"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXFragment=function(e,t){return !!e&&("JSXFragment"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXOpeningFragment=function(e,t){return !!e&&("JSXOpeningFragment"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isJSXClosingFragment=function(e,t){return !!e&&("JSXClosingFragment"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isNoop=function(e,t){return !!e&&("Noop"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isPlaceholder=function(e,t){return !!e&&("Placeholder"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isV8IntrinsicIdentifier=function(e,t){return !!e&&("V8IntrinsicIdentifier"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isArgumentPlaceholder=function(e,t){return !!e&&("ArgumentPlaceholder"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isBindExpression=function(e,t){return !!e&&("BindExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isClassProperty=function(e,t){return !!e&&("ClassProperty"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isPipelineTopicExpression=function(e,t){return !!e&&("PipelineTopicExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isPipelineBareFunction=function(e,t){return !!e&&("PipelineBareFunction"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isPipelinePrimaryTopicReference=function(e,t){return !!e&&("PipelinePrimaryTopicReference"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isClassPrivateProperty=function(e,t){return !!e&&("ClassPrivateProperty"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isClassPrivateMethod=function(e,t){return !!e&&("ClassPrivateMethod"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isImportAttribute=function(e,t){return !!e&&("ImportAttribute"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDecorator=function(e,t){return !!e&&("Decorator"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDoExpression=function(e,t){return !!e&&("DoExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isExportDefaultSpecifier=function(e,t){return !!e&&("ExportDefaultSpecifier"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isPrivateName=function(e,t){return !!e&&("PrivateName"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isRecordExpression=function(e,t){return !!e&&("RecordExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTupleExpression=function(e,t){return !!e&&("TupleExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isDecimalLiteral=function(e,t){return !!e&&("DecimalLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isStaticBlock=function(e,t){return !!e&&("StaticBlock"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isModuleExpression=function(e,t){return !!e&&("ModuleExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSParameterProperty=function(e,t){return !!e&&("TSParameterProperty"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSDeclareFunction=function(e,t){return !!e&&("TSDeclareFunction"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSDeclareMethod=function(e,t){return !!e&&("TSDeclareMethod"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSQualifiedName=function(e,t){return !!e&&("TSQualifiedName"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSCallSignatureDeclaration=function(e,t){return !!e&&("TSCallSignatureDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSConstructSignatureDeclaration=function(e,t){return !!e&&("TSConstructSignatureDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSPropertySignature=function(e,t){return !!e&&("TSPropertySignature"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSMethodSignature=function(e,t){return !!e&&("TSMethodSignature"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSIndexSignature=function(e,t){return !!e&&("TSIndexSignature"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSAnyKeyword=function(e,t){return !!e&&("TSAnyKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSBooleanKeyword=function(e,t){return !!e&&("TSBooleanKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSBigIntKeyword=function(e,t){return !!e&&("TSBigIntKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSIntrinsicKeyword=function(e,t){return !!e&&("TSIntrinsicKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSNeverKeyword=function(e,t){return !!e&&("TSNeverKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSNullKeyword=function(e,t){return !!e&&("TSNullKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSNumberKeyword=function(e,t){return !!e&&("TSNumberKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSObjectKeyword=function(e,t){return !!e&&("TSObjectKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSStringKeyword=function(e,t){return !!e&&("TSStringKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSSymbolKeyword=function(e,t){return !!e&&("TSSymbolKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSUndefinedKeyword=function(e,t){return !!e&&("TSUndefinedKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSUnknownKeyword=function(e,t){return !!e&&("TSUnknownKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSVoidKeyword=function(e,t){return !!e&&("TSVoidKeyword"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSThisType=function(e,t){return !!e&&("TSThisType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSFunctionType=function(e,t){return !!e&&("TSFunctionType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSConstructorType=function(e,t){return !!e&&("TSConstructorType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypeReference=function(e,t){return !!e&&("TSTypeReference"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypePredicate=function(e,t){return !!e&&("TSTypePredicate"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypeQuery=function(e,t){return !!e&&("TSTypeQuery"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypeLiteral=function(e,t){return !!e&&("TSTypeLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSArrayType=function(e,t){return !!e&&("TSArrayType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTupleType=function(e,t){return !!e&&("TSTupleType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSOptionalType=function(e,t){return !!e&&("TSOptionalType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSRestType=function(e,t){return !!e&&("TSRestType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSNamedTupleMember=function(e,t){return !!e&&("TSNamedTupleMember"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSUnionType=function(e,t){return !!e&&("TSUnionType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSIntersectionType=function(e,t){return !!e&&("TSIntersectionType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSConditionalType=function(e,t){return !!e&&("TSConditionalType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSInferType=function(e,t){return !!e&&("TSInferType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSParenthesizedType=function(e,t){return !!e&&("TSParenthesizedType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypeOperator=function(e,t){return !!e&&("TSTypeOperator"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSIndexedAccessType=function(e,t){return !!e&&("TSIndexedAccessType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSMappedType=function(e,t){return !!e&&("TSMappedType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSLiteralType=function(e,t){return !!e&&("TSLiteralType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSExpressionWithTypeArguments=function(e,t){return !!e&&("TSExpressionWithTypeArguments"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSInterfaceDeclaration=function(e,t){return !!e&&("TSInterfaceDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSInterfaceBody=function(e,t){return !!e&&("TSInterfaceBody"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypeAliasDeclaration=function(e,t){return !!e&&("TSTypeAliasDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSAsExpression=function(e,t){return !!e&&("TSAsExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypeAssertion=function(e,t){return !!e&&("TSTypeAssertion"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSEnumDeclaration=function(e,t){return !!e&&("TSEnumDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSEnumMember=function(e,t){return !!e&&("TSEnumMember"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSModuleDeclaration=function(e,t){return !!e&&("TSModuleDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSModuleBlock=function(e,t){return !!e&&("TSModuleBlock"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSImportType=function(e,t){return !!e&&("TSImportType"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSImportEqualsDeclaration=function(e,t){return !!e&&("TSImportEqualsDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSExternalModuleReference=function(e,t){return !!e&&("TSExternalModuleReference"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSNonNullExpression=function(e,t){return !!e&&("TSNonNullExpression"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSExportAssignment=function(e,t){return !!e&&("TSExportAssignment"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSNamespaceExportDeclaration=function(e,t){return !!e&&("TSNamespaceExportDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypeAnnotation=function(e,t){return !!e&&("TSTypeAnnotation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypeParameterInstantiation=function(e,t){return !!e&&("TSTypeParameterInstantiation"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypeParameterDeclaration=function(e,t){return !!e&&("TSTypeParameterDeclaration"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isTSTypeParameter=function(e,t){return !!e&&("TSTypeParameter"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isExpression=function(e,t){if(!e)return !1;const r=e.type;return ("ArrayExpression"===r||"AssignmentExpression"===r||"BinaryExpression"===r||"CallExpression"===r||"ConditionalExpression"===r||"FunctionExpression"===r||"Identifier"===r||"StringLiteral"===r||"NumericLiteral"===r||"NullLiteral"===r||"BooleanLiteral"===r||"RegExpLiteral"===r||"LogicalExpression"===r||"MemberExpression"===r||"NewExpression"===r||"ObjectExpression"===r||"SequenceExpression"===r||"ParenthesizedExpression"===r||"ThisExpression"===r||"UnaryExpression"===r||"UpdateExpression"===r||"ArrowFunctionExpression"===r||"ClassExpression"===r||"MetaProperty"===r||"Super"===r||"TaggedTemplateExpression"===r||"TemplateLiteral"===r||"YieldExpression"===r||"AwaitExpression"===r||"Import"===r||"BigIntLiteral"===r||"OptionalMemberExpression"===r||"OptionalCallExpression"===r||"TypeCastExpression"===r||"JSXElement"===r||"JSXFragment"===r||"BindExpression"===r||"PipelinePrimaryTopicReference"===r||"DoExpression"===r||"RecordExpression"===r||"TupleExpression"===r||"DecimalLiteral"===r||"ModuleExpression"===r||"TSAsExpression"===r||"TSTypeAssertion"===r||"TSNonNullExpression"===r||"Placeholder"===r&&("Expression"===e.expectedNode||"Identifier"===e.expectedNode||"StringLiteral"===e.expectedNode))&&(void 0===t||(0, n.default)(e,t))},t.isBinary=function(e,t){if(!e)return !1;const r=e.type;return ("BinaryExpression"===r||"LogicalExpression"===r)&&(void 0===t||(0, n.default)(e,t))},t.isScopable=function(e,t){if(!e)return !1;const r=e.type;return ("BlockStatement"===r||"CatchClause"===r||"DoWhileStatement"===r||"ForInStatement"===r||"ForStatement"===r||"FunctionDeclaration"===r||"FunctionExpression"===r||"Program"===r||"ObjectMethod"===r||"SwitchStatement"===r||"WhileStatement"===r||"ArrowFunctionExpression"===r||"ClassExpression"===r||"ClassDeclaration"===r||"ForOfStatement"===r||"ClassMethod"===r||"ClassPrivateMethod"===r||"StaticBlock"===r||"TSModuleBlock"===r||"Placeholder"===r&&"BlockStatement"===e.expectedNode)&&(void 0===t||(0, n.default)(e,t))},t.isBlockParent=function(e,t){if(!e)return !1;const r=e.type;return ("BlockStatement"===r||"CatchClause"===r||"DoWhileStatement"===r||"ForInStatement"===r||"ForStatement"===r||"FunctionDeclaration"===r||"FunctionExpression"===r||"Program"===r||"ObjectMethod"===r||"SwitchStatement"===r||"WhileStatement"===r||"ArrowFunctionExpression"===r||"ForOfStatement"===r||"ClassMethod"===r||"ClassPrivateMethod"===r||"StaticBlock"===r||"TSModuleBlock"===r||"Placeholder"===r&&"BlockStatement"===e.expectedNode)&&(void 0===t||(0, n.default)(e,t))},t.isBlock=function(e,t){if(!e)return !1;const r=e.type;return ("BlockStatement"===r||"Program"===r||"TSModuleBlock"===r||"Placeholder"===r&&"BlockStatement"===e.expectedNode)&&(void 0===t||(0, n.default)(e,t))},t.isStatement=function(e,t){if(!e)return !1;const r=e.type;return ("BlockStatement"===r||"BreakStatement"===r||"ContinueStatement"===r||"DebuggerStatement"===r||"DoWhileStatement"===r||"EmptyStatement"===r||"ExpressionStatement"===r||"ForInStatement"===r||"ForStatement"===r||"FunctionDeclaration"===r||"IfStatement"===r||"LabeledStatement"===r||"ReturnStatement"===r||"SwitchStatement"===r||"ThrowStatement"===r||"TryStatement"===r||"VariableDeclaration"===r||"WhileStatement"===r||"WithStatement"===r||"ClassDeclaration"===r||"ExportAllDeclaration"===r||"ExportDefaultDeclaration"===r||"ExportNamedDeclaration"===r||"ForOfStatement"===r||"ImportDeclaration"===r||"DeclareClass"===r||"DeclareFunction"===r||"DeclareInterface"===r||"DeclareModule"===r||"DeclareModuleExports"===r||"DeclareTypeAlias"===r||"DeclareOpaqueType"===r||"DeclareVariable"===r||"DeclareExportDeclaration"===r||"DeclareExportAllDeclaration"===r||"InterfaceDeclaration"===r||"OpaqueType"===r||"TypeAlias"===r||"EnumDeclaration"===r||"TSDeclareFunction"===r||"TSInterfaceDeclaration"===r||"TSTypeAliasDeclaration"===r||"TSEnumDeclaration"===r||"TSModuleDeclaration"===r||"TSImportEqualsDeclaration"===r||"TSExportAssignment"===r||"TSNamespaceExportDeclaration"===r||"Placeholder"===r&&("Statement"===e.expectedNode||"Declaration"===e.expectedNode||"BlockStatement"===e.expectedNode))&&(void 0===t||(0, n.default)(e,t))},t.isTerminatorless=function(e,t){if(!e)return !1;const r=e.type;return ("BreakStatement"===r||"ContinueStatement"===r||"ReturnStatement"===r||"ThrowStatement"===r||"YieldExpression"===r||"AwaitExpression"===r)&&(void 0===t||(0, n.default)(e,t))},t.isCompletionStatement=function(e,t){if(!e)return !1;const r=e.type;return ("BreakStatement"===r||"ContinueStatement"===r||"ReturnStatement"===r||"ThrowStatement"===r)&&(void 0===t||(0, n.default)(e,t))},t.isConditional=function(e,t){if(!e)return !1;const r=e.type;return ("ConditionalExpression"===r||"IfStatement"===r)&&(void 0===t||(0, n.default)(e,t))},t.isLoop=function(e,t){if(!e)return !1;const r=e.type;return ("DoWhileStatement"===r||"ForInStatement"===r||"ForStatement"===r||"WhileStatement"===r||"ForOfStatement"===r)&&(void 0===t||(0, n.default)(e,t))},t.isWhile=function(e,t){if(!e)return !1;const r=e.type;return ("DoWhileStatement"===r||"WhileStatement"===r)&&(void 0===t||(0, n.default)(e,t))},t.isExpressionWrapper=function(e,t){if(!e)return !1;const r=e.type;return ("ExpressionStatement"===r||"ParenthesizedExpression"===r||"TypeCastExpression"===r)&&(void 0===t||(0, n.default)(e,t))},t.isFor=function(e,t){if(!e)return !1;const r=e.type;return ("ForInStatement"===r||"ForStatement"===r||"ForOfStatement"===r)&&(void 0===t||(0, n.default)(e,t))},t.isForXStatement=function(e,t){if(!e)return !1;const r=e.type;return ("ForInStatement"===r||"ForOfStatement"===r)&&(void 0===t||(0, n.default)(e,t))},t.isFunction=function(e,t){if(!e)return !1;const r=e.type;return ("FunctionDeclaration"===r||"FunctionExpression"===r||"ObjectMethod"===r||"ArrowFunctionExpression"===r||"ClassMethod"===r||"ClassPrivateMethod"===r)&&(void 0===t||(0, n.default)(e,t))},t.isFunctionParent=function(e,t){if(!e)return !1;const r=e.type;return ("FunctionDeclaration"===r||"FunctionExpression"===r||"ObjectMethod"===r||"ArrowFunctionExpression"===r||"ClassMethod"===r||"ClassPrivateMethod"===r)&&(void 0===t||(0, n.default)(e,t))},t.isPureish=function(e,t){if(!e)return !1;const r=e.type;return ("FunctionDeclaration"===r||"FunctionExpression"===r||"StringLiteral"===r||"NumericLiteral"===r||"NullLiteral"===r||"BooleanLiteral"===r||"RegExpLiteral"===r||"ArrowFunctionExpression"===r||"BigIntLiteral"===r||"DecimalLiteral"===r||"Placeholder"===r&&"StringLiteral"===e.expectedNode)&&(void 0===t||(0, n.default)(e,t))},t.isDeclaration=function(e,t){if(!e)return !1;const r=e.type;return ("FunctionDeclaration"===r||"VariableDeclaration"===r||"ClassDeclaration"===r||"ExportAllDeclaration"===r||"ExportDefaultDeclaration"===r||"ExportNamedDeclaration"===r||"ImportDeclaration"===r||"DeclareClass"===r||"DeclareFunction"===r||"DeclareInterface"===r||"DeclareModule"===r||"DeclareModuleExports"===r||"DeclareTypeAlias"===r||"DeclareOpaqueType"===r||"DeclareVariable"===r||"DeclareExportDeclaration"===r||"DeclareExportAllDeclaration"===r||"InterfaceDeclaration"===r||"OpaqueType"===r||"TypeAlias"===r||"EnumDeclaration"===r||"TSDeclareFunction"===r||"TSInterfaceDeclaration"===r||"TSTypeAliasDeclaration"===r||"TSEnumDeclaration"===r||"TSModuleDeclaration"===r||"Placeholder"===r&&"Declaration"===e.expectedNode)&&(void 0===t||(0, n.default)(e,t))},t.isPatternLike=function(e,t){if(!e)return !1;const r=e.type;return ("Identifier"===r||"RestElement"===r||"AssignmentPattern"===r||"ArrayPattern"===r||"ObjectPattern"===r||"Placeholder"===r&&("Pattern"===e.expectedNode||"Identifier"===e.expectedNode))&&(void 0===t||(0, n.default)(e,t))},t.isLVal=function(e,t){if(!e)return !1;const r=e.type;return ("Identifier"===r||"MemberExpression"===r||"RestElement"===r||"AssignmentPattern"===r||"ArrayPattern"===r||"ObjectPattern"===r||"TSParameterProperty"===r||"Placeholder"===r&&("Pattern"===e.expectedNode||"Identifier"===e.expectedNode))&&(void 0===t||(0, n.default)(e,t))},t.isTSEntityName=function(e,t){if(!e)return !1;const r=e.type;return ("Identifier"===r||"TSQualifiedName"===r||"Placeholder"===r&&"Identifier"===e.expectedNode)&&(void 0===t||(0, n.default)(e,t))},t.isLiteral=function(e,t){if(!e)return !1;const r=e.type;return ("StringLiteral"===r||"NumericLiteral"===r||"NullLiteral"===r||"BooleanLiteral"===r||"RegExpLiteral"===r||"TemplateLiteral"===r||"BigIntLiteral"===r||"DecimalLiteral"===r||"Placeholder"===r&&"StringLiteral"===e.expectedNode)&&(void 0===t||(0, n.default)(e,t))},t.isImmutable=function(e,t){if(!e)return !1;const r=e.type;return ("StringLiteral"===r||"NumericLiteral"===r||"NullLiteral"===r||"BooleanLiteral"===r||"BigIntLiteral"===r||"JSXAttribute"===r||"JSXClosingElement"===r||"JSXElement"===r||"JSXExpressionContainer"===r||"JSXSpreadChild"===r||"JSXOpeningElement"===r||"JSXText"===r||"JSXFragment"===r||"JSXOpeningFragment"===r||"JSXClosingFragment"===r||"DecimalLiteral"===r||"Placeholder"===r&&"StringLiteral"===e.expectedNode)&&(void 0===t||(0, n.default)(e,t))},t.isUserWhitespacable=function(e,t){if(!e)return !1;const r=e.type;return ("ObjectMethod"===r||"ObjectProperty"===r||"ObjectTypeInternalSlot"===r||"ObjectTypeCallProperty"===r||"ObjectTypeIndexer"===r||"ObjectTypeProperty"===r||"ObjectTypeSpreadProperty"===r)&&(void 0===t||(0, n.default)(e,t))},t.isMethod=function(e,t){if(!e)return !1;const r=e.type;return ("ObjectMethod"===r||"ClassMethod"===r||"ClassPrivateMethod"===r)&&(void 0===t||(0, n.default)(e,t))},t.isObjectMember=function(e,t){if(!e)return !1;const r=e.type;return ("ObjectMethod"===r||"ObjectProperty"===r)&&(void 0===t||(0, n.default)(e,t))},t.isProperty=function(e,t){if(!e)return !1;const r=e.type;return ("ObjectProperty"===r||"ClassProperty"===r||"ClassPrivateProperty"===r)&&(void 0===t||(0, n.default)(e,t))},t.isUnaryLike=function(e,t){if(!e)return !1;const r=e.type;return ("UnaryExpression"===r||"SpreadElement"===r)&&(void 0===t||(0, n.default)(e,t))},t.isPattern=function(e,t){if(!e)return !1;const r=e.type;return ("AssignmentPattern"===r||"ArrayPattern"===r||"ObjectPattern"===r||"Placeholder"===r&&"Pattern"===e.expectedNode)&&(void 0===t||(0, n.default)(e,t))},t.isClass=function(e,t){if(!e)return !1;const r=e.type;return ("ClassExpression"===r||"ClassDeclaration"===r)&&(void 0===t||(0, n.default)(e,t))},t.isModuleDeclaration=function(e,t){if(!e)return !1;const r=e.type;return ("ExportAllDeclaration"===r||"ExportDefaultDeclaration"===r||"ExportNamedDeclaration"===r||"ImportDeclaration"===r)&&(void 0===t||(0, n.default)(e,t))},t.isExportDeclaration=function(e,t){if(!e)return !1;const r=e.type;return ("ExportAllDeclaration"===r||"ExportDefaultDeclaration"===r||"ExportNamedDeclaration"===r)&&(void 0===t||(0, n.default)(e,t))},t.isModuleSpecifier=function(e,t){if(!e)return !1;const r=e.type;return ("ExportSpecifier"===r||"ImportDefaultSpecifier"===r||"ImportNamespaceSpecifier"===r||"ImportSpecifier"===r||"ExportNamespaceSpecifier"===r||"ExportDefaultSpecifier"===r)&&(void 0===t||(0, n.default)(e,t))},t.isFlow=function(e,t){if(!e)return !1;const r=e.type;return ("AnyTypeAnnotation"===r||"ArrayTypeAnnotation"===r||"BooleanTypeAnnotation"===r||"BooleanLiteralTypeAnnotation"===r||"NullLiteralTypeAnnotation"===r||"ClassImplements"===r||"DeclareClass"===r||"DeclareFunction"===r||"DeclareInterface"===r||"DeclareModule"===r||"DeclareModuleExports"===r||"DeclareTypeAlias"===r||"DeclareOpaqueType"===r||"DeclareVariable"===r||"DeclareExportDeclaration"===r||"DeclareExportAllDeclaration"===r||"DeclaredPredicate"===r||"ExistsTypeAnnotation"===r||"FunctionTypeAnnotation"===r||"FunctionTypeParam"===r||"GenericTypeAnnotation"===r||"InferredPredicate"===r||"InterfaceExtends"===r||"InterfaceDeclaration"===r||"InterfaceTypeAnnotation"===r||"IntersectionTypeAnnotation"===r||"MixedTypeAnnotation"===r||"EmptyTypeAnnotation"===r||"NullableTypeAnnotation"===r||"NumberLiteralTypeAnnotation"===r||"NumberTypeAnnotation"===r||"ObjectTypeAnnotation"===r||"ObjectTypeInternalSlot"===r||"ObjectTypeCallProperty"===r||"ObjectTypeIndexer"===r||"ObjectTypeProperty"===r||"ObjectTypeSpreadProperty"===r||"OpaqueType"===r||"QualifiedTypeIdentifier"===r||"StringLiteralTypeAnnotation"===r||"StringTypeAnnotation"===r||"SymbolTypeAnnotation"===r||"ThisTypeAnnotation"===r||"TupleTypeAnnotation"===r||"TypeofTypeAnnotation"===r||"TypeAlias"===r||"TypeAnnotation"===r||"TypeCastExpression"===r||"TypeParameter"===r||"TypeParameterDeclaration"===r||"TypeParameterInstantiation"===r||"UnionTypeAnnotation"===r||"Variance"===r||"VoidTypeAnnotation"===r||"IndexedAccessType"===r||"OptionalIndexedAccessType"===r)&&(void 0===t||(0, n.default)(e,t))},t.isFlowType=function(e,t){if(!e)return !1;const r=e.type;return ("AnyTypeAnnotation"===r||"ArrayTypeAnnotation"===r||"BooleanTypeAnnotation"===r||"BooleanLiteralTypeAnnotation"===r||"NullLiteralTypeAnnotation"===r||"ExistsTypeAnnotation"===r||"FunctionTypeAnnotation"===r||"GenericTypeAnnotation"===r||"InterfaceTypeAnnotation"===r||"IntersectionTypeAnnotation"===r||"MixedTypeAnnotation"===r||"EmptyTypeAnnotation"===r||"NullableTypeAnnotation"===r||"NumberLiteralTypeAnnotation"===r||"NumberTypeAnnotation"===r||"ObjectTypeAnnotation"===r||"StringLiteralTypeAnnotation"===r||"StringTypeAnnotation"===r||"SymbolTypeAnnotation"===r||"ThisTypeAnnotation"===r||"TupleTypeAnnotation"===r||"TypeofTypeAnnotation"===r||"UnionTypeAnnotation"===r||"VoidTypeAnnotation"===r||"IndexedAccessType"===r||"OptionalIndexedAccessType"===r)&&(void 0===t||(0, n.default)(e,t))},t.isFlowBaseAnnotation=function(e,t){if(!e)return !1;const r=e.type;return ("AnyTypeAnnotation"===r||"BooleanTypeAnnotation"===r||"NullLiteralTypeAnnotation"===r||"MixedTypeAnnotation"===r||"EmptyTypeAnnotation"===r||"NumberTypeAnnotation"===r||"StringTypeAnnotation"===r||"SymbolTypeAnnotation"===r||"ThisTypeAnnotation"===r||"VoidTypeAnnotation"===r)&&(void 0===t||(0, n.default)(e,t))},t.isFlowDeclaration=function(e,t){if(!e)return !1;const r=e.type;return ("DeclareClass"===r||"DeclareFunction"===r||"DeclareInterface"===r||"DeclareModule"===r||"DeclareModuleExports"===r||"DeclareTypeAlias"===r||"DeclareOpaqueType"===r||"DeclareVariable"===r||"DeclareExportDeclaration"===r||"DeclareExportAllDeclaration"===r||"InterfaceDeclaration"===r||"OpaqueType"===r||"TypeAlias"===r)&&(void 0===t||(0, n.default)(e,t))},t.isFlowPredicate=function(e,t){if(!e)return !1;const r=e.type;return ("DeclaredPredicate"===r||"InferredPredicate"===r)&&(void 0===t||(0, n.default)(e,t))},t.isEnumBody=function(e,t){if(!e)return !1;const r=e.type;return ("EnumBooleanBody"===r||"EnumNumberBody"===r||"EnumStringBody"===r||"EnumSymbolBody"===r)&&(void 0===t||(0, n.default)(e,t))},t.isEnumMember=function(e,t){if(!e)return !1;const r=e.type;return ("EnumBooleanMember"===r||"EnumNumberMember"===r||"EnumStringMember"===r||"EnumDefaultedMember"===r)&&(void 0===t||(0, n.default)(e,t))},t.isJSX=function(e,t){if(!e)return !1;const r=e.type;return ("JSXAttribute"===r||"JSXClosingElement"===r||"JSXElement"===r||"JSXEmptyExpression"===r||"JSXExpressionContainer"===r||"JSXSpreadChild"===r||"JSXIdentifier"===r||"JSXMemberExpression"===r||"JSXNamespacedName"===r||"JSXOpeningElement"===r||"JSXSpreadAttribute"===r||"JSXText"===r||"JSXFragment"===r||"JSXOpeningFragment"===r||"JSXClosingFragment"===r)&&(void 0===t||(0, n.default)(e,t))},t.isPrivate=function(e,t){if(!e)return !1;const r=e.type;return ("ClassPrivateProperty"===r||"ClassPrivateMethod"===r||"PrivateName"===r)&&(void 0===t||(0, n.default)(e,t))},t.isTSTypeElement=function(e,t){if(!e)return !1;const r=e.type;return ("TSCallSignatureDeclaration"===r||"TSConstructSignatureDeclaration"===r||"TSPropertySignature"===r||"TSMethodSignature"===r||"TSIndexSignature"===r)&&(void 0===t||(0, n.default)(e,t))},t.isTSType=function(e,t){if(!e)return !1;const r=e.type;return ("TSAnyKeyword"===r||"TSBooleanKeyword"===r||"TSBigIntKeyword"===r||"TSIntrinsicKeyword"===r||"TSNeverKeyword"===r||"TSNullKeyword"===r||"TSNumberKeyword"===r||"TSObjectKeyword"===r||"TSStringKeyword"===r||"TSSymbolKeyword"===r||"TSUndefinedKeyword"===r||"TSUnknownKeyword"===r||"TSVoidKeyword"===r||"TSThisType"===r||"TSFunctionType"===r||"TSConstructorType"===r||"TSTypeReference"===r||"TSTypePredicate"===r||"TSTypeQuery"===r||"TSTypeLiteral"===r||"TSArrayType"===r||"TSTupleType"===r||"TSOptionalType"===r||"TSRestType"===r||"TSUnionType"===r||"TSIntersectionType"===r||"TSConditionalType"===r||"TSInferType"===r||"TSParenthesizedType"===r||"TSTypeOperator"===r||"TSIndexedAccessType"===r||"TSMappedType"===r||"TSLiteralType"===r||"TSExpressionWithTypeArguments"===r||"TSImportType"===r)&&(void 0===t||(0, n.default)(e,t))},t.isTSBaseType=function(e,t){if(!e)return !1;const r=e.type;return ("TSAnyKeyword"===r||"TSBooleanKeyword"===r||"TSBigIntKeyword"===r||"TSIntrinsicKeyword"===r||"TSNeverKeyword"===r||"TSNullKeyword"===r||"TSNumberKeyword"===r||"TSObjectKeyword"===r||"TSStringKeyword"===r||"TSSymbolKeyword"===r||"TSUndefinedKeyword"===r||"TSUnknownKeyword"===r||"TSVoidKeyword"===r||"TSThisType"===r||"TSLiteralType"===r)&&(void 0===t||(0, n.default)(e,t))},t.isNumberLiteral=function(e,t){return console.trace("The node type NumberLiteral has been renamed to NumericLiteral"),!!e&&("NumberLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isRegexLiteral=function(e,t){return console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"),!!e&&("RegexLiteral"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isRestProperty=function(e,t){return console.trace("The node type RestProperty has been renamed to RestElement"),!!e&&("RestProperty"===e.type&&(void 0===t||(0, n.default)(e,t)))},t.isSpreadProperty=function(e,t){return console.trace("The node type SpreadProperty has been renamed to SpreadElement"),!!e&&("SpreadProperty"===e.type&&(void 0===t||(0, n.default)(e,t)))};var n=r("./node_modules/@babel/types/lib/utils/shallowEqual.js");},"./node_modules/@babel/types/lib/validators/is.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){return !!t&&((0, s.default)(t.type,e)?void 0===r||(0, n.default)(t,r):!r&&"Placeholder"===t.type&&e in o.FLIPPED_ALIAS_KEYS&&(0, i.default)(t.expectedNode,e))};var n=r("./node_modules/@babel/types/lib/utils/shallowEqual.js"),s=r("./node_modules/@babel/types/lib/validators/isType.js"),i=r("./node_modules/@babel/types/lib/validators/isPlaceholderType.js"),o=r("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/validators/isBinding.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(r&&"Identifier"===e.type&&"ObjectProperty"===t.type&&"ObjectExpression"===r.type)return !1;const s=n.default.keys[t.type];if(s)for(let r=0;r<s.length;r++){const n=t[s[r]];if(Array.isArray(n)){if(n.indexOf(e)>=0)return !0}else if(n===e)return !0}return !1};var n=r("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");},"./node_modules/@babel/types/lib/validators/isBlockScoped.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return (0, n.isFunctionDeclaration)(e)||(0, n.isClassDeclaration)(e)||(0, s.default)(e)};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js"),s=r("./node_modules/@babel/types/lib/validators/isLet.js");},"./node_modules/@babel/types/lib/validators/isImmutable.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return !!(0, n.default)(e.type,"Immutable")||!!(0, s.isIdentifier)(e)&&"undefined"===e.name};var n=r("./node_modules/@babel/types/lib/validators/isType.js"),s=r("./node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/@babel/types/lib/validators/isLet.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return (0, n.isVariableDeclaration)(e)&&("var"!==e.kind||e[s.BLOCK_SCOPED_SYMBOL])};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js"),s=r("./node_modules/@babel/types/lib/constants/index.js");},"./node_modules/@babel/types/lib/validators/isNode.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return !(!e||!n.VISITOR_KEYS[e.type])};var n=r("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/validators/isNodesEquivalent.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function e(t,r){if("object"!=typeof t||"object"!=typeof r||null==t||null==r)return t===r;if(t.type!==r.type)return !1;const s=Object.keys(n.NODE_FIELDS[t.type]||t.type),i=n.VISITOR_KEYS[t.type];for(const n of s){if(typeof t[n]!=typeof r[n])return !1;if(null!=t[n]||null!=r[n]){if(null==t[n]||null==r[n])return !1;if(Array.isArray(t[n])){if(!Array.isArray(r[n]))return !1;if(t[n].length!==r[n].length)return !1;for(let s=0;s<t[n].length;s++)if(!e(t[n][s],r[n][s]))return !1}else if("object"!=typeof t[n]||null!=i&&i.includes(n)){if(!e(t[n],r[n]))return !1}else for(const e of Object.keys(t[n]))if(t[n][e]!==r[n][e])return !1}}return !0};var n=r("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/validators/isPlaceholderType.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(e===t)return !0;const r=n.PLACEHOLDERS_ALIAS[e];if(r)for(const e of r)if(t===e)return !0;return !1};var n=r("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/validators/isReferenced.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){switch(t.type){case"MemberExpression":case"JSXMemberExpression":case"OptionalMemberExpression":return t.property===e?!!t.computed:t.object===e;case"VariableDeclarator":return t.init===e;case"ArrowFunctionExpression":return t.body===e;case"PrivateName":return !1;case"ClassMethod":case"ClassPrivateMethod":case"ObjectMethod":if(t.params.includes(e))return !1;case"ObjectProperty":case"ClassProperty":case"ClassPrivateProperty":return t.key===e?!!t.computed:t.value!==e||!r||"ObjectPattern"!==r.type;case"ClassDeclaration":case"ClassExpression":return t.superClass===e;case"AssignmentExpression":case"AssignmentPattern":return t.right===e;case"LabeledStatement":case"CatchClause":case"RestElement":return !1;case"BreakStatement":case"ContinueStatement":return !1;case"FunctionDeclaration":case"FunctionExpression":return !1;case"ExportNamespaceSpecifier":case"ExportDefaultSpecifier":return !1;case"ExportSpecifier":return (null==r||!r.source)&&t.local===e;case"ImportDefaultSpecifier":case"ImportNamespaceSpecifier":case"ImportSpecifier":case"JSXAttribute":return !1;case"ObjectPattern":case"ArrayPattern":case"MetaProperty":return !1;case"ObjectTypeProperty":return t.key!==e;case"TSEnumMember":return t.id!==e;case"TSPropertySignature":return t.key!==e||!!t.computed}return !0};},"./node_modules/@babel/types/lib/validators/isScope.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){return (!(0, n.isBlockStatement)(e)||!(0, n.isFunction)(t)&&!(0, n.isCatchClause)(t))&&(!(!(0, n.isPattern)(e)||!(0, n.isFunction)(t)&&!(0, n.isCatchClause)(t))||(0, n.isScopable)(e))};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/@babel/types/lib/validators/isSpecifierDefault.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return (0, n.isImportDefaultSpecifier)(e)||(0, n.isIdentifier)(e.imported||e.exported,{name:"default"})};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/@babel/types/lib/validators/isType.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(e===t)return !0;if(n.ALIAS_KEYS[t])return !1;const r=n.FLIPPED_ALIAS_KEYS[t];if(r){if(r[0]===e)return !0;for(const t of r)if(e===t)return !0}return !1};var n=r("./node_modules/@babel/types/lib/definitions/index.js");},"./node_modules/@babel/types/lib/validators/isValidES3Identifier.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return (0, n.default)(e)&&!s.has(e)};var n=r("./node_modules/@babel/types/lib/validators/isValidIdentifier.js");const s=new Set(["abstract","boolean","byte","char","double","enum","final","float","goto","implements","int","interface","long","native","package","private","protected","public","short","static","synchronized","throws","transient","volatile"]);},"./node_modules/@babel/types/lib/validators/isValidIdentifier.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t=!0){return "string"==typeof e&&((!t||!(0, n.isKeyword)(e)&&!(0, n.isStrictReservedWord)(e,!0))&&(0, n.isIdentifierName)(e))};var n=r("./node_modules/@babel/helper-validator-identifier/lib/index.js");},"./node_modules/@babel/types/lib/validators/isVar.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return (0, n.isVariableDeclaration)(e,{kind:"var"})&&!e[s.BLOCK_SCOPED_SYMBOL]};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js"),s=r("./node_modules/@babel/types/lib/constants/index.js");},"./node_modules/@babel/types/lib/validators/matchesPattern.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(!(0, n.isMemberExpression)(e))return !1;const s=Array.isArray(t)?t:t.split("."),i=[];let o;for(o=e;(0, n.isMemberExpression)(o);o=o.object)i.push(o.property);if(i.push(o),i.length<s.length)return !1;if(!r&&i.length>s.length)return !1;for(let e=0,t=i.length-1;e<s.length;e++,t--){const r=i[t];let o;if((0, n.isIdentifier)(r))o=r.name;else if((0, n.isStringLiteral)(r))o=r.value;else {if(!(0, n.isThisExpression)(r))return !1;o="this";}if(s[e]!==o)return !1}return !0};var n=r("./node_modules/@babel/types/lib/validators/generated/index.js");},"./node_modules/@babel/types/lib/validators/react/isCompatTag.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return !!e&&/^[a-z]/.test(e)};},"./node_modules/@babel/types/lib/validators/react/isReactComponent.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=(0, r("./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js").default)("React.Component");t.default=n;},"./node_modules/@babel/types/lib/validators/validate.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){if(!e)return;const o=n.NODE_FIELDS[e.type];if(!o)return;s(e,t,r,o[t]),i(e,t,r);},t.validateField=s,t.validateChild=i;var n=r("./node_modules/@babel/types/lib/definitions/index.js");function s(e,t,r,n){null!=n&&n.validate&&(n.optional&&null==r||n.validate(e,t,r));}function i(e,t,r){if(null==r)return;const s=n.NODE_PARENT_VALIDATIONS[r.type];s&&s(e,t,r);}},"./node_modules/babel-plugin-dynamic-import-node/lib/index.js":(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=(0, n.createDynamicImportTransform)(e);return {manipulateOptions:function(e,t){t.plugins.push("dynamicImport");},visitor:{Import:function(e){t(this,e);}}}};var n=r("./node_modules/babel-plugin-dynamic-import-node/lib/utils.js");e.exports=t.default;},"./node_modules/babel-plugin-dynamic-import-node/lib/utils.js":(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0});function r(e,t){var r=t.arguments,n=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var r=[],n=!0,s=!1,i=void 0;try{for(var o,a=e[Symbol.iterator]();!(n=(o=a.next()).done)&&(r.push(o.value),!t||r.length!==t);n=!0);}catch(e){s=!0,i=e;}finally{try{!n&&a.return&&a.return();}finally{if(s)throw i}}return r}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")}(r,1)[0];return e.isStringLiteral(n)||e.isTemplateLiteral(n)?(e.removeComments(n),n):e.templateLiteral([e.templateElement({raw:"",cooked:""}),e.templateElement({raw:"",cooked:""},!0)],r)}t.getImportSource=r,t.createDynamicImportTransform=function(e){var t=e.template,n=e.types,s={static:{interop:t("Promise.resolve().then(() => INTEROP(require(SOURCE)))"),noInterop:t("Promise.resolve().then(() => require(SOURCE))")},dynamic:{interop:t("Promise.resolve(SOURCE).then(s => INTEROP(require(s)))"),noInterop:t("Promise.resolve(SOURCE).then(s => require(s))")}},i="function"==typeof WeakSet&&new WeakSet;return function(e,t){if(i){if(i.has(t))return;i.add(t);}var o,a=r(n,t.parent),l=(o=a,n.isStringLiteral(o)||n.isTemplateLiteral(o)&&0===o.expressions.length?s.static:s.dynamic),u=e.opts.noInterop?l.noInterop({SOURCE:a}):l.interop({SOURCE:a,INTEROP:e.addHelper("interopRequireWildcard")});t.parentPath.replaceWith(u);}};},"./node_modules/babel-plugin-dynamic-import-node/utils.js":(e,t,r)=>{e.exports=r("./node_modules/babel-plugin-dynamic-import-node/lib/utils.js");},"./node_modules/babel-plugin-parameter-decorator/lib/index.js":(e,t,r)=>{var n=r("path");function s(e){switch(e.parent.type){case"TSTypeReference":case"TSQualifiedName":case"TSExpressionWithTypeArguments":case"TSTypeQuery":return !0;default:return !1}}e.exports=function(e){var t=e.types,r=function(e,r){return function(n){var s=t.callExpression(e.expression,[t.Identifier(n),t.Identifier("undefined"),t.NumericLiteral(r.key)]),i=t.logicalExpression("||",s,t.Identifier(n)),o=t.assignmentExpression("=",t.Identifier(n),i);return t.expressionStatement(o)}},i=function(e,r){return function(n,s){var i=t.callExpression(e.expression,[t.Identifier("".concat(n,".prototype")),t.StringLiteral(s),t.NumericLiteral(r.key)]);return t.expressionStatement(i)}};return {visitor:{Program:function(e,t){var r=(0, n.extname)(t.file.opts.filename);".ts"!==r&&".tsx"!==r||function(){var t=Object.create(null);e.node.body.filter((function(e){var t=e.type,r=e.declaration;switch(t){case"ClassDeclaration":return !0;case"ExportNamedDeclaration":case"ExportDefaultDeclaration":return r&&"ClassDeclaration"===r.type;default:return !1}})).map((function(e){return "ClassDeclaration"===e.type?e:e.declaration})).forEach((function(e){e.body.body.forEach((function(e){(e.params||[]).forEach((function(e){(e.decorators||[]).forEach((function(e){e.expression.callee?t[e.expression.callee.name]=e:t[e.expression.name]=e;}));}));}));}));var r=!0,n=!1,i=void 0;try{for(var o,a=e.get("body")[Symbol.iterator]();!(r=(o=a.next()).done);r=!0){var l=o.value;if("ImportDeclaration"===l.node.type){if(0===l.node.specifiers.length)continue;var u=!0,c=!1,p=void 0;try{for(var d,f=function(){var e=d.value,r=l.scope.getBinding(e.local.name);r.referencePaths.length?r.referencePaths.reduce((function(e,t){return e||s(t)}),!1)&&Object.keys(t).forEach((function(n){var s=t[n];(s.expression.arguments||[]).forEach((function(t){t.name===e.local.name&&r.referencePaths.push({parent:s.expression});}));})):t[e.local.name]&&r.referencePaths.push({parent:t[e.local.name]});},h=l.node.specifiers[Symbol.iterator]();!(u=(d=h.next()).done);u=!0)f();}catch(e){c=!0,p=e;}finally{try{u||null==h.return||h.return();}finally{if(c)throw p}}}}}catch(e){n=!0,i=e;}finally{try{r||null==a.return||a.return();}finally{if(n)throw i}}}();},Function:function(e){var n="";e.node.id?n=e.node.id.name:e.node.key&&(n=e.node.key.name),(e.get("params")||[]).slice().forEach((function(s){var o=s.node.decorators||[],a=o.length;if(o.slice().forEach((function(t){if("ClassMethod"===e.type){var o,a=e.parentPath.parentPath,l=e.findParent((function(e){return "ClassDeclaration"===e.type}));if(l?o=l.node.id.name:(a.insertAfter(null),o=function(e){var t=e.findParent((function(e){return "AssignmentExpression"===e.node.type}));return "SequenceExpression"===t.node.right.type?t.node.right.expressions[1].name:"ClassExpression"===t.node.right.type?t.node.left.name:null}(e)),"constructor"===n){var u=r(t,s)(o);a.insertAfter(u);}else {var c=i(t,s)(o,n);a.insertAfter(c);}}else {var p=e.findParent((function(e){return "VariableDeclarator"===e.node.type})).node.id.name;if(n===p){var d=r(t,s)(p);"body"===e.parentKey?e.insertAfter(d):e.findParent((function(e){return "body"===e.parentKey})).insertAfter(d);}else {var f=e.findParent((function(e){return "CallExpression"===e.node.type})),h=i(t,s)(p,n);f.insertAfter(h);}}})),a){var l=function(e){switch(e.node.type){case"ObjectPattern":return t.ObjectPattern(e.node.properties);case"AssignmentPattern":return t.AssignmentPattern(e.node.left,e.node.right);case"TSParameterProperty":return t.Identifier(e.node.parameter.name);default:return t.Identifier(e.node.name)}}(s);s.replaceWith(l);}}));}}}};},"./node_modules/babel-plugin-transform-import-meta/lib/index.esm.js":(e,t,r)=>{r.r(t),r.d(t,{default:()=>i});var n,s=r("./node_modules/@babel/template/lib/index.js").default.ast;const i=function(){return {name:"transform-import-meta",visitor:{Program:function(e){var t,r,i=[];if(e.traverse({MemberExpression:function(e){var t=e.node;"MetaProperty"===t.object.type&&"import"===t.object.meta.name&&"meta"===t.object.property.name&&"Identifier"===t.property.type&&"url"===t.property.name&&i.push(e);}}),0!==i.length)for(var o=0,a=i;o<a.length;o++)a[o].replaceWith(s(n||(t=["require('url').pathToFileURL(__filename).toString()"],r=["require('url').pathToFileURL(__filename).toString()"],Object.defineProperty?Object.defineProperty(t,"raw",{value:r}):t.raw=r,n=t)));}}}};},"./node_modules/convert-source-map/index.js":(e,t,r)=>{var n=r("fs"),s=r("path"),i=r("./node_modules/safe-buffer/index.js");function o(e,r){var o;(r=r||{}).isFileComment&&(e=function(e,r){var i=t.mapFileCommentRegex.exec(e),o=i[1]||i[2],a=s.resolve(r,o);try{return n.readFileSync(a,"utf8")}catch(e){throw new Error("An error occurred while trying to read the map file at "+a+"\n"+e)}}(e,r.commentFileDir)),r.hasComment&&(e=function(e){return e.split(",").pop()}(e)),r.isEncoded&&(o=e,e=i.Buffer.from(o,"base64").toString()),(r.isJSON||r.isEncoded)&&(e=JSON.parse(e)),this.sourcemap=e;}Object.defineProperty(t,"commentRegex",{get:function(){return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/gm}}),Object.defineProperty(t,"mapFileCommentRegex",{get:function(){return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/gm}}),o.prototype.toJSON=function(e){return JSON.stringify(this.sourcemap,null,e)},o.prototype.toBase64=function(){var e=this.toJSON();return i.Buffer.from(e,"utf8").toString("base64")},o.prototype.toComment=function(e){var t="sourceMappingURL=data:application/json;charset=utf-8;base64,"+this.toBase64();return e&&e.multiline?"/*# "+t+" */":"//# "+t},o.prototype.toObject=function(){return JSON.parse(this.toJSON())},o.prototype.addProperty=function(e,t){if(this.sourcemap.hasOwnProperty(e))throw new Error('property "'+e+'" already exists on the sourcemap, use set property instead');return this.setProperty(e,t)},o.prototype.setProperty=function(e,t){return this.sourcemap[e]=t,this},o.prototype.getProperty=function(e){return this.sourcemap[e]},t.fromObject=function(e){return new o(e)},t.fromJSON=function(e){return new o(e,{isJSON:!0})},t.fromBase64=function(e){return new o(e,{isEncoded:!0})},t.fromComment=function(e){return new o(e=e.replace(/^\/\*/g,"//").replace(/\*\/$/g,""),{isEncoded:!0,hasComment:!0})},t.fromMapFileComment=function(e,t){return new o(e,{commentFileDir:t,isFileComment:!0,isJSON:!0})},t.fromSource=function(e){var r=e.match(t.commentRegex);return r?t.fromComment(r.pop()):null},t.fromMapFileSource=function(e,r){var n=e.match(t.mapFileCommentRegex);return n?t.fromMapFileComment(n.pop(),r):null},t.removeComments=function(e){return e.replace(t.commentRegex,"")},t.removeMapFileComments=function(e){return e.replace(t.mapFileCommentRegex,"")},t.generateMapFileComment=function(e,t){var r="sourceMappingURL="+e;return t&&t.multiline?"/*# "+r+" */":"//# "+r};},"./node_modules/debug/src/browser.js":(e,t,r)=>{t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const r="color: "+this.color;t.splice(1,0,r,"color: inherit");let n=0,s=0;t[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(n++,"%c"===e&&(s=n));})),t.splice(s,0,r);},t.save=function(e){try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug");}catch(e){}},t.load=function(){let e;try{e=t.storage.getItem("debug");}catch(e){}return !e&&"undefined"!=typeof process&&"env"in process&&(e=process.env.DEBUG),e},t.useColors=function(){return !("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},t.storage=function(){try{return localStorage}catch(e){}}(),t.destroy=(()=>{let e=!1;return ()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=r("./node_modules/debug/src/common.js")(t);const{formatters:n}=e.exports;n.j=function(e){try{return JSON.stringify(e)}catch(e){return "[UnexpectedJSONParseError]: "+e.message}};},"./node_modules/debug/src/common.js":(e,t,r)=>{e.exports=function(e){function t(e){let r,s=null;function i(...e){if(!i.enabled)return;const n=i,s=Number(new Date),o=s-(r||s);n.diff=o,n.prev=r,n.curr=s,r=s,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let a=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((r,s)=>{if("%%"===r)return "%";a++;const i=t.formatters[s];if("function"==typeof i){const t=e[a];r=i.call(n,t),e.splice(a,1),a--;}return r})),t.formatArgs.call(n,e),(n.log||t.log).apply(n,e);}return i.namespace=e,i.useColors=t.useColors(),i.color=t.selectColor(e),i.extend=n,i.destroy=t.destroy,Object.defineProperty(i,"enabled",{enumerable:!0,configurable:!1,get:()=>null===s?t.enabled(e):s,set:e=>{s=e;}}),"function"==typeof t.init&&t.init(i),i}function n(e,r){const n=t(this.namespace+(void 0===r?":":r)+e);return n.log=this.log,n}function s(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){return e instanceof Error?e.stack||e.message:e},t.disable=function(){const e=[...t.names.map(s),...t.skips.map(s).map((e=>"-"+e))].join(",");return t.enable(""),e},t.enable=function(e){let r;t.save(e),t.names=[],t.skips=[];const n=("string"==typeof e?e:"").split(/[\s,]+/),s=n.length;for(r=0;r<s;r++)n[r]&&("-"===(e=n[r].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.substr(1)+"$")):t.names.push(new RegExp("^"+e+"$")));},t.enabled=function(e){if("*"===e[e.length-1])return !0;let r,n;for(r=0,n=t.skips.length;r<n;r++)if(t.skips[r].test(e))return !1;for(r=0,n=t.names.length;r<n;r++)if(t.names[r].test(e))return !0;return !1},t.humanize=r("./node_modules/ms/index.js"),t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");},Object.keys(e).forEach((r=>{t[r]=e[r];})),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let r=0;for(let t=0;t<e.length;t++)r=(r<<5)-r+e.charCodeAt(t),r|=0;return t.colors[Math.abs(r)%t.colors.length]},t.enable(t.load()),t};},"./node_modules/debug/src/index.js":(e,t,r)=>{"undefined"==typeof process||"renderer"===process.type||!0===process.browser||process.__nwjs?e.exports=r("./node_modules/debug/src/browser.js"):e.exports=r("./node_modules/debug/src/node.js");},"./node_modules/debug/src/node.js":(e,t,r)=>{const n=r("tty"),s=r("util");t.init=function(e){e.inspectOpts={};const r=Object.keys(t.inspectOpts);for(let n=0;n<r.length;n++)e.inspectOpts[r[n]]=t.inspectOpts[r[n]];},t.log=function(...e){return process.stderr.write(s.format(...e)+"\n")},t.formatArgs=function(r){const{namespace:n,useColors:s}=this;if(s){const t=this.color,s="[3"+(t<8?t:"8;5;"+t),i=`  ${s};1m${n} [0m`;r[0]=i+r[0].split("\n").join("\n"+i),r.push(s+"m+"+e.exports.humanize(this.diff)+"[0m");}else r[0]=(t.inspectOpts.hideDate?"":(new Date).toISOString()+" ")+n+" "+r[0];},t.save=function(e){e?process.env.DEBUG=e:delete process.env.DEBUG;},t.load=function(){return process.env.DEBUG},t.useColors=function(){return "colors"in t.inspectOpts?Boolean(t.inspectOpts.colors):n.isatty(process.stderr.fd)},t.destroy=s.deprecate((()=>{}),"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."),t.colors=[6,2,3,4,5,1];try{const e=r("./node_modules/supports-color/index.js");e&&(e.stderr||e).level>=2&&(t.colors=[20,21,26,27,32,33,38,39,40,41,42,43,44,45,56,57,62,63,68,69,74,75,76,77,78,79,80,81,92,93,98,99,112,113,128,129,134,135,148,149,160,161,162,163,164,165,166,167,168,169,170,171,172,173,178,179,184,185,196,197,198,199,200,201,202,203,204,205,206,207,208,209,214,215,220,221]);}catch(e){}t.inspectOpts=Object.keys(process.env).filter((e=>/^debug_/i.test(e))).reduce(((e,t)=>{const r=t.substring(6).toLowerCase().replace(/_([a-z])/g,((e,t)=>t.toUpperCase()));let n=process.env[t];return n=!!/^(yes|on|true|enabled)$/i.test(n)||!/^(no|off|false|disabled)$/i.test(n)&&("null"===n?null:Number(n)),e[r]=n,e}),{}),e.exports=r("./node_modules/debug/src/common.js")(t);const{formatters:i}=e.exports;i.o=function(e){return this.inspectOpts.colors=this.useColors,s.inspect(e,this.inspectOpts).split("\n").map((e=>e.trim())).join(" ")},i.O=function(e){return this.inspectOpts.colors=this.useColors,s.inspect(e,this.inspectOpts)};},"./node_modules/gensync/index.js":e=>{const t=Symbol.for("gensync:v1:start"),r=Symbol.for("gensync:v1:suspend"),n="GENSYNC_OPTIONS_ERROR",s="GENSYNC_RACE_NONEMPTY";function i(e,t,r,s){if(typeof r===e||s&&void 0===r)return;let i;throw i=s?`Expected opts.${t} to be either a ${e}, or undefined.`:`Expected opts.${t} to be a ${e}.`,o(i,n)}function o(e,t){return Object.assign(new Error(e),{code:t})}function a({name:e,arity:n,sync:s,async:i}){return f(e,n,(function*(...e){const n=yield t;if(!n)return s.call(this,e);let o;try{i.call(this,e,(e=>{o||(o={value:e},n());}),(e=>{o||(o={err:e},n());}));}catch(e){o={err:e},n();}if(yield r,o.hasOwnProperty("err"))throw o.err;return o.value}))}function l(e){let t;for(;!({value:t}=e.next()).done;)c(t,e);return t}function u(e,t,r){!function n(){try{let r;for(;!({value:r}=e.next()).done;){c(r,e);let t=!0,s=!1;const i=e.next((()=>{t?s=!0:n();}));if(t=!1,p(i,e),!s)return}return t(r)}catch(e){return r(e)}}();}function c(e,r){e!==t&&d(r,o(`Got unexpected yielded value in gensync generator: ${JSON.stringify(e)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,"GENSYNC_EXPECTED_START"));}function p({value:e,done:t},n){(t||e!==r)&&d(n,o(t?"Unexpected generator completion. If you get this, it is probably a gensync bug.":`Expected GENSYNC_SUSPEND, got ${JSON.stringify(e)}. If you get this, it is probably a gensync bug.`,"GENSYNC_EXPECTED_SUSPEND"));}function d(e,t){throw e.throw&&e.throw(t),t}function f(e,t,r){if("string"==typeof e){const t=Object.getOwnPropertyDescriptor(r,"name");t&&!t.configurable||Object.defineProperty(r,"name",Object.assign(t||{},{configurable:!0,value:e}));}if("number"==typeof t){const e=Object.getOwnPropertyDescriptor(r,"length");e&&!e.configurable||Object.defineProperty(r,"length",Object.assign(e||{},{configurable:!0,value:t}));}return r}e.exports=Object.assign((function(e){let t=e;return t="function"!=typeof e?function({name:e,arity:t,sync:r,async:s,errback:l}){if(i("string","name",e,!0),i("number","arity",t,!0),i("function","sync",r),i("function","async",s,!0),i("function","errback",l,!0),s&&l)throw o("Expected one of either opts.async or opts.errback, but got _both_.",n);if("string"!=typeof e){let t;l&&l.name&&"errback"!==l.name&&(t=l.name),s&&s.name&&"async"!==s.name&&(t=s.name.replace(/Async$/,"")),r&&r.name&&"sync"!==r.name&&(t=r.name.replace(/Sync$/,"")),"string"==typeof t&&(e=t);}return "number"!=typeof t&&(t=r.length),a({name:e,arity:t,sync:function(e){return r.apply(this,e)},async:function(e,t,n){s?s.apply(this,e).then(t,n):l?l.call(this,...e,((e,r)=>{null==e?t(r):n(e);})):t(r.apply(this,e));}})}(e):function(e){return f(e.name,e.length,(function(...t){return e.apply(this,t)}))}(e),Object.assign(t,function(e){return {sync:function(...t){return l(e.apply(this,t))},async:function(...t){return new Promise(((r,n)=>{u(e.apply(this,t),r,n);}))},errback:function(...t){const r=t.pop();if("function"!=typeof r)throw o("Asynchronous function called without callback","GENSYNC_ERRBACK_NO_CALLBACK");let n;try{n=e.apply(this,t);}catch(e){return void r(e)}u(n,(e=>r(void 0,e)),(e=>r(e)));}}}(t))}),{all:a({name:"all",arity:1,sync:function(e){return Array.from(e[0]).map((e=>l(e)))},async:function(e,t,r){const n=Array.from(e[0]);if(0===n.length)return void Promise.resolve().then((()=>t([])));let s=0;const i=n.map((()=>{}));n.forEach(((e,n)=>{u(e,(e=>{i[n]=e,s+=1,s===i.length&&t(i);}),r);}));}}),race:a({name:"race",arity:1,sync:function(e){const t=Array.from(e[0]);if(0===t.length)throw o("Must race at least 1 item",s);return l(t[0])},async:function(e,t,r){const n=Array.from(e[0]);if(0===n.length)throw o("Must race at least 1 item",s);for(const e of n)u(e,t,r);}})});},"./node_modules/has-flag/index.js":e=>{e.exports=(e,t=process.argv)=>{const r=e.startsWith("-")?"":1===e.length?"-":"--",n=t.indexOf(r+e),s=t.indexOf("--");return -1!==n&&(-1===s||n<s)};},"./node_modules/jsesc/jsesc.js":e=>{const t={},r=t.hasOwnProperty,n=(e,t)=>{for(const n in e)r.call(e,n)&&t(n,e[n]);},s=t.toString,i=Array.isArray,o=Buffer.isBuffer,a={'"':'\\"',"'":"\\'","\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"},l=/["'\\\b\f\n\r\t]/,u=/[0-9]/,c=/[ !#-&\(-\[\]-_a-~]/,p=(e,t)=>{const r=()=>{v=E,++t.indentLevel,E=t.indent.repeat(t.indentLevel);},d={escapeEverything:!1,minimal:!1,isScriptContext:!1,quotes:"single",wrap:!1,es6:!1,json:!1,compact:!0,lowercaseHex:!1,numbers:"decimal",indent:"\t",indentLevel:0,__inline1__:!1,__inline2__:!1},f=t&&t.json;var h,m;f&&(d.quotes="double",d.wrap=!0),h=d,"single"!=(t=(m=t)?(n(m,((e,t)=>{h[e]=t;})),h):h).quotes&&"double"!=t.quotes&&"backtick"!=t.quotes&&(t.quotes="single");const y="double"==t.quotes?'"':"backtick"==t.quotes?"`":"'",b=t.compact,g=t.lowercaseHex;let E=t.indent.repeat(t.indentLevel),v="";const x=t.__inline1__,T=t.__inline2__,S=b?"":"\n";let P,A=!0;const w="binary"==t.numbers,C="octal"==t.numbers,D="decimal"==t.numbers,_="hexadecimal"==t.numbers;if(f&&e&&"function"==typeof e.toJSON&&(e=e.toJSON()),"string"!=typeof(O=e)&&"[object String]"!=s.call(O)){if((e=>"[object Map]"==s.call(e))(e))return 0==e.size?"new Map()":(b||(t.__inline1__=!0,t.__inline2__=!1),"new Map("+p(Array.from(e),t)+")");if((e=>"[object Set]"==s.call(e))(e))return 0==e.size?"new Set()":"new Set("+p(Array.from(e),t)+")";if(o(e))return 0==e.length?"Buffer.from([])":"Buffer.from("+p(Array.from(e),t)+")";if(i(e))return P=[],t.wrap=!0,x&&(t.__inline1__=!1,t.__inline2__=!0),T||r(),((e,t)=>{const r=e.length;let n=-1;for(;++n<r;)t(e[n]);})(e,(e=>{A=!1,T&&(t.__inline2__=!1),P.push((b||T?"":E)+p(e,t));})),A?"[]":T?"["+P.join(", ")+"]":"["+S+P.join(","+S)+S+(b?"":v)+"]";if(!(e=>"number"==typeof e||"[object Number]"==s.call(e))(e))return (e=>"[object Object]"==s.call(e))(e)?(P=[],t.wrap=!0,r(),n(e,((e,r)=>{A=!1,P.push((b?"":E)+p(e,t)+":"+(b?"":" ")+p(r,t));})),A?"{}":"{"+S+P.join(","+S)+S+(b?"":v)+"}"):f?JSON.stringify(e)||"null":String(e);if(f)return JSON.stringify(e);if(D)return String(e);if(_){let t=e.toString(16);return g||(t=t.toUpperCase()),"0x"+t}if(w)return "0b"+e.toString(2);if(C)return "0o"+e.toString(8)}var O;const j=e;let I=-1;const N=j.length;for(P="";++I<N;){const e=j.charAt(I);if(t.es6){const e=j.charCodeAt(I);if(e>=55296&&e<=56319&&N>I+1){const t=j.charCodeAt(I+1);if(t>=56320&&t<=57343){let r=(1024*(e-55296)+t-56320+65536).toString(16);g||(r=r.toUpperCase()),P+="\\u{"+r+"}",++I;continue}}}if(!t.escapeEverything){if(c.test(e)){P+=e;continue}if('"'==e){P+=y==e?'\\"':e;continue}if("`"==e){P+=y==e?"\\`":e;continue}if("'"==e){P+=y==e?"\\'":e;continue}}if("\0"==e&&!f&&!u.test(j.charAt(I+1))){P+="\\0";continue}if(l.test(e)){P+=a[e];continue}const r=e.charCodeAt(0);if(t.minimal&&8232!=r&&8233!=r){P+=e;continue}let n=r.toString(16);g||(n=n.toUpperCase());const s=n.length>2||f,i="\\"+(s?"u":"x")+("0000"+n).slice(s?-4:-2);P+=i;}return t.wrap&&(P=y+P+y),"`"==y&&(P=P.replace(/\$\{/g,"\\${")),t.isScriptContext?P.replace(/<\/(script|style)/gi,"<\\/$1").replace(/<!--/g,f?"\\u003C!--":"\\x3C!--"):P};p.version="2.5.2",e.exports=p;},"./node_modules/json5/dist/index.mjs":(e,t,r)=>{r.r(t),r.d(t,{default:()=>R});var n={Space_Separator:/[\u1680\u2000-\u200A\u202F\u205F\u3000]/,ID_Start:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/,ID_Continue:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/},s=e=>"string"==typeof e&&n.Space_Separator.test(e),i=e=>"string"==typeof e&&(e>="a"&&e<="z"||e>="A"&&e<="Z"||"$"===e||"_"===e||n.ID_Start.test(e)),o=e=>"string"==typeof e&&(e>="a"&&e<="z"||e>="A"&&e<="Z"||e>="0"&&e<="9"||"$"===e||"_"===e||"‌"===e||"‍"===e||n.ID_Continue.test(e)),a=e=>"string"==typeof e&&/[0-9]/.test(e),l=e=>"string"==typeof e&&/[0-9A-Fa-f]/.test(e);let u,c,p,d,f,h,m,y,b,g,E,v,x,T;function S(e,t,r){const n=e[t];if(null!=n&&"object"==typeof n)for(const e in n){const t=S(n,e,r);void 0===t?delete n[e]:n[e]=t;}return r.call(e,t,n)}function P(){for(g="default",E="",v=!1,x=1;;){T=A();const e=C[g]();if(e)return e}}function A(){if(u[d])return String.fromCodePoint(u.codePointAt(d))}function w(){const e=A();return "\n"===e?(f++,h=0):e?h+=e.length:h++,e&&(d+=e.length),e}const C={default(){switch(T){case"\t":case"\v":case"\f":case" ":case" ":case"\ufeff":case"\n":case"\r":case"\u2028":case"\u2029":return void w();case"/":return w(),void(g="comment");case void 0:return w(),D("eof")}if(!s(T))return C[c]();w();},comment(){switch(T){case"*":return w(),void(g="multiLineComment");case"/":return w(),void(g="singleLineComment")}throw k(w())},multiLineComment(){switch(T){case"*":return w(),void(g="multiLineCommentAsterisk");case void 0:throw k(w())}w();},multiLineCommentAsterisk(){switch(T){case"*":return void w();case"/":return w(),void(g="default");case void 0:throw k(w())}w(),g="multiLineComment";},singleLineComment(){switch(T){case"\n":case"\r":case"\u2028":case"\u2029":return w(),void(g="default");case void 0:return w(),D("eof")}w();},value(){switch(T){case"{":case"[":return D("punctuator",w());case"n":return w(),_("ull"),D("null",null);case"t":return w(),_("rue"),D("boolean",!0);case"f":return w(),_("alse"),D("boolean",!1);case"-":case"+":return "-"===w()&&(x=-1),void(g="sign");case".":return E=w(),void(g="decimalPointLeading");case"0":return E=w(),void(g="zero");case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":return E=w(),void(g="decimalInteger");case"I":return w(),_("nfinity"),D("numeric",1/0);case"N":return w(),_("aN"),D("numeric",NaN);case'"':case"'":return v='"'===w(),E="",void(g="string")}throw k(w())},identifierNameStartEscape(){if("u"!==T)throw k(w());w();const e=O();switch(e){case"$":case"_":break;default:if(!i(e))throw L()}E+=e,g="identifierName";},identifierName(){switch(T){case"$":case"_":case"‌":case"‍":return void(E+=w());case"\\":return w(),void(g="identifierNameEscape")}if(!o(T))return D("identifier",E);E+=w();},identifierNameEscape(){if("u"!==T)throw k(w());w();const e=O();switch(e){case"$":case"_":case"‌":case"‍":break;default:if(!o(e))throw L()}E+=e,g="identifierName";},sign(){switch(T){case".":return E=w(),void(g="decimalPointLeading");case"0":return E=w(),void(g="zero");case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":return E=w(),void(g="decimalInteger");case"I":return w(),_("nfinity"),D("numeric",x*(1/0));case"N":return w(),_("aN"),D("numeric",NaN)}throw k(w())},zero(){switch(T){case".":return E+=w(),void(g="decimalPoint");case"e":case"E":return E+=w(),void(g="decimalExponent");case"x":case"X":return E+=w(),void(g="hexadecimal")}return D("numeric",0*x)},decimalInteger(){switch(T){case".":return E+=w(),void(g="decimalPoint");case"e":case"E":return E+=w(),void(g="decimalExponent")}if(!a(T))return D("numeric",x*Number(E));E+=w();},decimalPointLeading(){if(a(T))return E+=w(),void(g="decimalFraction");throw k(w())},decimalPoint(){switch(T){case"e":case"E":return E+=w(),void(g="decimalExponent")}return a(T)?(E+=w(),void(g="decimalFraction")):D("numeric",x*Number(E))},decimalFraction(){switch(T){case"e":case"E":return E+=w(),void(g="decimalExponent")}if(!a(T))return D("numeric",x*Number(E));E+=w();},decimalExponent(){switch(T){case"+":case"-":return E+=w(),void(g="decimalExponentSign")}if(a(T))return E+=w(),void(g="decimalExponentInteger");throw k(w())},decimalExponentSign(){if(a(T))return E+=w(),void(g="decimalExponentInteger");throw k(w())},decimalExponentInteger(){if(!a(T))return D("numeric",x*Number(E));E+=w();},hexadecimal(){if(l(T))return E+=w(),void(g="hexadecimalInteger");throw k(w())},hexadecimalInteger(){if(!l(T))return D("numeric",x*Number(E));E+=w();},string(){switch(T){case"\\":return w(),void(E+=function(){switch(A()){case"b":return w(),"\b";case"f":return w(),"\f";case"n":return w(),"\n";case"r":return w(),"\r";case"t":return w(),"\t";case"v":return w(),"\v";case"0":if(w(),a(A()))throw k(w());return "\0";case"x":return w(),function(){let e="",t=A();if(!l(t))throw k(w());if(e+=w(),t=A(),!l(t))throw k(w());return e+=w(),String.fromCodePoint(parseInt(e,16))}();case"u":return w(),O();case"\n":case"\u2028":case"\u2029":return w(),"";case"\r":return w(),"\n"===A()&&w(),"";case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case void 0:throw k(w())}return w()}());case'"':return v?(w(),D("string",E)):void(E+=w());case"'":return v?void(E+=w()):(w(),D("string",E));case"\n":case"\r":throw k(w());case"\u2028":case"\u2029":!function(e){console.warn(`JSON5: '${M(e)}' in strings is not valid ECMAScript; consider escaping`);}(T);break;case void 0:throw k(w())}E+=w();},start(){switch(T){case"{":case"[":return D("punctuator",w())}g="value";},beforePropertyName(){switch(T){case"$":case"_":return E=w(),void(g="identifierName");case"\\":return w(),void(g="identifierNameStartEscape");case"}":return D("punctuator",w());case'"':case"'":return v='"'===w(),void(g="string")}if(i(T))return E+=w(),void(g="identifierName");throw k(w())},afterPropertyName(){if(":"===T)return D("punctuator",w());throw k(w())},beforePropertyValue(){g="value";},afterPropertyValue(){switch(T){case",":case"}":return D("punctuator",w())}throw k(w())},beforeArrayValue(){if("]"===T)return D("punctuator",w());g="value";},afterArrayValue(){switch(T){case",":case"]":return D("punctuator",w())}throw k(w())},end(){throw k(w())}};function D(e,t){return {type:e,value:t,line:f,column:h}}function _(e){for(const t of e){if(A()!==t)throw k(w());w();}}function O(){let e="",t=4;for(;t-- >0;){const t=A();if(!l(t))throw k(w());e+=w();}return String.fromCodePoint(parseInt(e,16))}const j={start(){if("eof"===m.type)throw F();I();},beforePropertyName(){switch(m.type){case"identifier":case"string":return y=m.value,void(c="afterPropertyName");case"punctuator":return void N();case"eof":throw F()}},afterPropertyName(){if("eof"===m.type)throw F();c="beforePropertyValue";},beforePropertyValue(){if("eof"===m.type)throw F();I();},beforeArrayValue(){if("eof"===m.type)throw F();"punctuator"!==m.type||"]"!==m.value?I():N();},afterPropertyValue(){if("eof"===m.type)throw F();switch(m.value){case",":return void(c="beforePropertyName");case"}":N();}},afterArrayValue(){if("eof"===m.type)throw F();switch(m.value){case",":return void(c="beforeArrayValue");case"]":N();}},end(){}};function I(){let e;switch(m.type){case"punctuator":switch(m.value){case"{":e={};break;case"[":e=[];}break;case"null":case"boolean":case"numeric":case"string":e=m.value;}if(void 0===b)b=e;else {const t=p[p.length-1];Array.isArray(t)?t.push(e):t[y]=e;}if(null!==e&&"object"==typeof e)p.push(e),c=Array.isArray(e)?"beforeArrayValue":"beforePropertyName";else {const e=p[p.length-1];c=null==e?"end":Array.isArray(e)?"afterArrayValue":"afterPropertyValue";}}function N(){p.pop();const e=p[p.length-1];c=null==e?"end":Array.isArray(e)?"afterArrayValue":"afterPropertyValue";}function k(e){return B(void 0===e?`JSON5: invalid end of input at ${f}:${h}`:`JSON5: invalid character '${M(e)}' at ${f}:${h}`)}function F(){return B(`JSON5: invalid end of input at ${f}:${h}`)}function L(){return h-=5,B(`JSON5: invalid identifier character at ${f}:${h}`)}function M(e){const t={"'":"\\'",'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\v":"\\v","\0":"\\0","\u2028":"\\u2028","\u2029":"\\u2029"};if(t[e])return t[e];if(e<" "){const t=e.charCodeAt(0).toString(16);return "\\x"+("00"+t).substring(t.length)}return e}function B(e){const t=new SyntaxError(e);return t.lineNumber=f,t.columnNumber=h,t}const R={parse:function(e,t){u=String(e),c="start",p=[],d=0,f=1,h=0,m=void 0,y=void 0,b=void 0;do{m=P(),j[c]();}while("eof"!==m.type);return "function"==typeof t?S({"":b},"",t):b},stringify:function(e,t,r){const n=[];let s,l,u,c="",p="";if(null==t||"object"!=typeof t||Array.isArray(t)||(r=t.space,u=t.quote,t=t.replacer),"function"==typeof t)l=t;else if(Array.isArray(t)){s=[];for(const e of t){let t;"string"==typeof e?t=e:("number"==typeof e||e instanceof String||e instanceof Number)&&(t=String(e)),void 0!==t&&s.indexOf(t)<0&&s.push(t);}}return r instanceof Number?r=Number(r):r instanceof String&&(r=String(r)),"number"==typeof r?r>0&&(r=Math.min(10,Math.floor(r)),p="          ".substr(0,r)):"string"==typeof r&&(p=r.substr(0,10)),function e(t,r){let i=r[t];switch(null!=i&&("function"==typeof i.toJSON5?i=i.toJSON5(t):"function"==typeof i.toJSON&&(i=i.toJSON(t))),l&&(i=l.call(r,t,i)),i instanceof Number?i=Number(i):i instanceof String?i=String(i):i instanceof Boolean&&(i=i.valueOf()),i){case null:return "null";case!0:return "true";case!1:return "false"}return "string"==typeof i?d(i):"number"==typeof i?String(i):"object"==typeof i?Array.isArray(i)?function(t){if(n.indexOf(t)>=0)throw TypeError("Converting circular structure to JSON5");n.push(t);let r=c;c+=p;let s,i=[];for(let r=0;r<t.length;r++){const n=e(String(r),t);i.push(void 0!==n?n:"null");}if(0===i.length)s="[]";else if(""===p)s="["+i.join(",")+"]";else {let e=",\n"+c,t=i.join(e);s="[\n"+c+t+",\n"+r+"]";}return n.pop(),c=r,s}(i):function(t){if(n.indexOf(t)>=0)throw TypeError("Converting circular structure to JSON5");n.push(t);let r=c;c+=p;let i,o=s||Object.keys(t),a=[];for(const r of o){const n=e(r,t);if(void 0!==n){let e=f(r)+":";""!==p&&(e+=" "),e+=n,a.push(e);}}if(0===a.length)i="{}";else {let e;if(""===p)e=a.join(","),i="{"+e+"}";else {let t=",\n"+c;e=a.join(t),i="{\n"+c+e+",\n"+r+"}";}}return n.pop(),c=r,i}(i):void 0}("",{"":e});function d(e){const t={"'":.1,'"':.2},r={"'":"\\'",'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\v":"\\v","\0":"\\0","\u2028":"\\u2028","\u2029":"\\u2029"};let n="";for(let s=0;s<e.length;s++){const i=e[s];switch(i){case"'":case'"':t[i]++,n+=i;continue;case"\0":if(a(e[s+1])){n+="\\x00";continue}}if(r[i])n+=r[i];else if(i<" "){let e=i.charCodeAt(0).toString(16);n+="\\x"+("00"+e).substring(e.length);}else n+=i;}const s=u||Object.keys(t).reduce(((e,r)=>t[e]<t[r]?e:r));return n=n.replace(new RegExp(s,"g"),r[s]),s+n+s}function f(e){if(0===e.length)return d(e);const t=String.fromCodePoint(e.codePointAt(0));if(!i(t))return d(e);for(let r=t.length;r<e.length;r++)if(!o(String.fromCodePoint(e.codePointAt(r))))return d(e);return e}}};},"./node_modules/ms/index.js":e=>{var t=1e3,r=60*t,n=60*r,s=24*n;function i(e,t,r,n){var s=t>=1.5*r;return Math.round(e/r)+" "+n+(s?"s":"")}e.exports=function(e,o){o=o||{};var a,l,u=typeof e;if("string"===u&&e.length>0)return function(e){if(!((e=String(e)).length>100)){var i=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(i){var o=parseFloat(i[1]);switch((i[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*o;case"weeks":case"week":case"w":return 6048e5*o;case"days":case"day":case"d":return o*s;case"hours":case"hour":case"hrs":case"hr":case"h":return o*n;case"minutes":case"minute":case"mins":case"min":case"m":return o*r;case"seconds":case"second":case"secs":case"sec":case"s":return o*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return o;default:return}}}}(e);if("number"===u&&isFinite(e))return o.long?(a=e,(l=Math.abs(a))>=s?i(a,l,s,"day"):l>=n?i(a,l,n,"hour"):l>=r?i(a,l,r,"minute"):l>=t?i(a,l,t,"second"):a+" ms"):function(e){var i=Math.abs(e);return i>=s?Math.round(e/s)+"d":i>=n?Math.round(e/n)+"h":i>=r?Math.round(e/r)+"m":i>=t?Math.round(e/t)+"s":e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))};},"./node_modules/safe-buffer/index.js":(e,t,r)=>{var n=r("buffer"),s=n.Buffer;function i(e,t){for(var r in e)t[r]=e[r];}function o(e,t,r){return s(e,t,r)}s.from&&s.alloc&&s.allocUnsafe&&s.allocUnsafeSlow?e.exports=n:(i(n,t),t.Buffer=o),i(s,o),o.from=function(e,t,r){if("number"==typeof e)throw new TypeError("Argument must not be a number");return s(e,t,r)},o.alloc=function(e,t,r){if("number"!=typeof e)throw new TypeError("Argument must be a number");var n=s(e);return void 0!==t?"string"==typeof r?n.fill(t,r):n.fill(t):n.fill(0),n},o.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return s(e)},o.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return n.SlowBuffer(e)};},"./node_modules/supports-color/index.js":(e,t,r)=>{const n=r("os"),s=r("tty"),i=r("./node_modules/has-flag/index.js"),{env:o}=process;let a;function l(e){return 0!==e&&{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}function u(e,t){if(0===a)return 0;if(i("color=16m")||i("color=full")||i("color=truecolor"))return 3;if(i("color=256"))return 2;if(e&&!t&&void 0===a)return 0;const r=a||0;if("dumb"===o.TERM)return r;if("win32"===process.platform){const e=n.release().split(".");return Number(e[0])>=10&&Number(e[2])>=10586?Number(e[2])>=14931?3:2:1}if("CI"in o)return ["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some((e=>e in o))||"codeship"===o.CI_NAME?1:r;if("TEAMCITY_VERSION"in o)return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(o.TEAMCITY_VERSION)?1:0;if("truecolor"===o.COLORTERM)return 3;if("TERM_PROGRAM"in o){const e=parseInt((o.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(o.TERM_PROGRAM){case"iTerm.app":return e>=3?3:2;case"Apple_Terminal":return 2}}return /-256(color)?$/i.test(o.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(o.TERM)||"COLORTERM"in o?1:r}i("no-color")||i("no-colors")||i("color=false")||i("color=never")?a=0:(i("color")||i("colors")||i("color=true")||i("color=always"))&&(a=1),"FORCE_COLOR"in o&&(a="true"===o.FORCE_COLOR?1:"false"===o.FORCE_COLOR?0:0===o.FORCE_COLOR.length?1:Math.min(parseInt(o.FORCE_COLOR,10),3)),e.exports={supportsColor:function(e){return l(u(e,e&&e.isTTY))},stdout:l(u(!0,s.isatty(1))),stderr:l(u(!0,s.isatty(2)))};},"./node_modules/to-fast-properties/index.js":e=>{let t=null;function r(e){if(null!==t&&(t.property,1)){const e=t;return t=r.prototype=null,e}return t=r.prototype=null==e?Object.create(null):e,new r}r(),e.exports=function(e){return r(e)};},"./stubs/babel_codeframe.js":(e,t,r)=>{function n(){return ""}r.r(t),r.d(t,{codeFrameColumns:()=>n});},"./stubs/helper_compilation_targets.js":(e,t,r)=>{function n(){return {}}r.r(t),r.d(t,{default:()=>n});},assert:e=>{e.exports=require$$0__default$2['default'];},buffer:e=>{e.exports=require$$1__default$1['default'];},fs:e=>{e.exports=fs__default['default'];},module:e=>{e.exports=require$$2__default['default'];},os:e=>{e.exports=require$$3__default['default'];},path:e=>{e.exports=require$$0__default$1['default'];},tty:e=>{e.exports=require$$0__default$3['default'];},url:e=>{e.exports=require$$7__default['default'];},util:e=>{e.exports=require$$1__default['default'];},v8:e=>{e.exports=require$$9__default['default'];}},t={};function r(n){var s=t[n];if(void 0!==s)return s.exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]});},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});};var n={};(()=>{r.d(n,{default:()=>t});var e=r("./node_modules/@babel/core/lib/index.js");function t(t){var n,s,i,o,a,l;const u=Object.assign(Object.assign({babelrc:!1,configFile:!1,compact:!1,retainLines:"boolean"!=typeof t.retainLines||t.retainLines,filename:"",cwd:"/"},t.babel),{plugins:[[r("./node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"),{allowTopLevelThis:!0}],[r("./node_modules/babel-plugin-dynamic-import-node/lib/index.js"),{noInterop:!0}],[r("./node_modules/babel-plugin-transform-import-meta/lib/index.esm.js")],[r("./node_modules/@babel/plugin-syntax-class-properties/lib/index.js")]]});t.ts&&(u.plugins.push([r("./node_modules/@babel/plugin-transform-typescript/lib/index.js"),{allowDeclareFields:!0}]),u.plugins.unshift([r("./node_modules/@babel/plugin-proposal-decorators/lib/index.js"),{legacy:!0}]),u.plugins.push(r("./node_modules/babel-plugin-parameter-decorator/lib/index.js"))),t.legacy&&(u.plugins.push(r("./node_modules/@babel/plugin-proposal-nullish-coalescing-operator/lib/index.js")),u.plugins.push(r("./node_modules/@babel/plugin-proposal-optional-chaining/lib/index.js"))),t.babel&&Array.isArray(t.babel.plugins)&&(null===(n=u.plugins)||void 0===n||n.push(...t.babel.plugins));try{return {code:(null===(s=(0,e.transformSync)(t.source,u))||void 0===s?void 0:s.code)||""}}catch(e){return {error:e,code:"exports.__JITI_ERROR__ = "+JSON.stringify({filename:t.filename,line:(null===(i=e.loc)||void 0===i?void 0:i.line)||0,column:(null===(o=e.loc)||void 0===o?void 0:o.column)||0,code:null===(a=e.code)||void 0===a?void 0:a.replace("BABEL_","").replace("PARSE_ERROR","ParseError"),message:null===(l=e.message)||void 0===l?void 0:l.replace("/: ","").replace(/\(.+\)\s*$/,"")})}}}})(),babel.exports=n.default;})();

let dynamicImport;
try {
  dynamicImport = esm.dynamicImport;
} catch (_err) {
  // Ignore since syntax is not supported in this environment
}

function onError (err) {
  throw err /* ↓ Check stack trace ↓ */
}

var lib$c = function (filename, opts) {
  
  const jiti = jiti$1.exports;

  opts = { dynamicImport, onError, ...opts };

  if (!opts.transform) {
    opts.transform = babel.exports;
  }

  return jiti(filename, opts)
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$3 = function(d, b) {
    extendStatics$3 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics$3(d, b);
};

function __extends$5(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$3(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$3 = function() {
    __assign$3 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$3.apply(this, arguments);
};

function __spreadArray$5(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

function toArray$4(v) {
    if (Array.isArray(v))
        return v;
    return [v];
}
function hash$2(str) {
    str = str.replace(/\r/g, '');
    var hash = 5381;
    var i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return (hash >>> 0).toString(36);
}
function indent$3(code, tab) {
    if (tab === void 0) { tab = 2; }
    var spaces = Array(tab).fill(' ').join('');
    return code
        .split('\n')
        .map(function (line) { return spaces + line; })
        .join('\n');
}
function wrapit$3(code, start, end, tab, minify) {
    if (start === void 0) { start = '{'; }
    if (end === void 0) { end = '}'; }
    if (tab === void 0) { tab = 2; }
    if (minify === void 0) { minify = false; }
    if (minify)
        return "" + start + code + end;
    return start + "\n" + indent$3(code, tab) + "\n" + end;
}
function isNumber$3(amount, start, end, type) {
    if (start === void 0) { start = -Infinity; }
    if (end === void 0) { end = Infinity; }
    if (type === void 0) { type = 'int'; }
    var isInt = /^-?\d+$/.test(amount);
    if (type === 'int') {
        if (!isInt)
            return false;
    }
    else {
        var isFloat = /^-?\d+\.\d+$/.test(amount);
        if (!(isInt || isFloat))
            return false;
    }
    var num = parseFloat(amount);
    return num >= start && num <= end;
}
function isFraction(amount) {
    return /^\d+\/\d+$/.test(amount);
}
function isSize(amount) {
    return /^-?(\d+(\.\d+)?)+(rem|em|px|rpx|vh|vw|ch|ex)$/.test(amount);
}
function isSpace$1(str) {
    return /^\s*$/.test(str);
}
function roundUp(num, precision) {
    if (precision === void 0) { precision = 0; }
    precision = Math.pow(10, precision);
    return Math.round(num * precision) / precision;
}
function fracToPercent(amount) {
    var matches = amount.match(/[^/]+/g);
    if (!matches || matches.length < 2)
        return;
    var a = +matches[0];
    var b = +matches[1];
    return roundUp((a / b) * 100, 6) + '%';
}
function hex2RGB$1(hex) {
    var RGB_HEX = /^#?(?:([\da-f]{3})[\da-f]?|([\da-f]{6})(?:[\da-f]{2})?)$/i;
    var _a = String(hex).match(RGB_HEX) || [], short = _a[1], long = _a[2];
    if (long) {
        var value = Number.parseInt(long, 16);
        return [value >> 16, (value >> 8) & 0xff, value & 0xff];
    }
    else if (short) {
        return Array.from(short, function (s) { return Number.parseInt(s, 16); }).map(function (n) { return (n << 4) | n; });
    }
}
function camelToDash$3(str) {
    // Use exact the same regex as Post CSS
    return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}
function dashToCamel(str) {
    if (!/-/.test(str))
        return str;
    return str.toLowerCase().replace(/-(.)/g, function (_, group) { return group.toUpperCase(); });
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getNestedValue(obj, key) {
    var topKey = key.match(/^[^.[]+/);
    if (!topKey)
        return;
    var topValue = obj[topKey[0]];
    if (!topValue)
        return;
    var index = topKey[0].length;
    while (index < key.length) {
        var square = key.slice(index).match(/\[[^\s\]]+?\]/);
        var dot = key.slice(index).match(/\.[^.[]+$|\.[^.[]+(?=\.)/);
        if ((!square && !dot) || ((square === null || square === void 0 ? void 0 : square.index) === undefined && (dot === null || dot === void 0 ? void 0 : dot.index) === undefined))
            return topValue;
        if (typeof topValue !== 'object')
            return;
        if (dot && dot.index !== undefined && ((square === null || square === void 0 ? void 0 : square.index) === undefined || dot.index < square.index)) {
            var arg = dot[0].slice(1);
            topValue = topValue[arg];
            index += dot.index + dot[0].length;
        }
        else if (square && square.index !== undefined) {
            var arg = square[0].slice(1, -1).trim().replace(/^['"]+|['"]+$/g, '');
            topValue = topValue[arg];
            index += square.index + square[0].length;
        }
    }
    return topValue;
}
function negateValue(value) {
    if (/(^0\w)|(^-)|(^0$)/.test(value))
        return value;
    return '-' + value;
}
function searchFrom$3(text, target, startIndex, endIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    // search from partial of string
    var subText = text.substring(startIndex, endIndex);
    var relativeIndex = subText.search(target);
    return relativeIndex === -1 ? -1 : startIndex + relativeIndex;
}
function connectList$3(a, b, append) {
    if (append === void 0) { append = true; }
    return append ? __spreadArray$5(__spreadArray$5([], (a !== null && a !== void 0 ? a : [])), (b !== null && b !== void 0 ? b : [])) : __spreadArray$5(__spreadArray$5([], (b !== null && b !== void 0 ? b : [])), (a !== null && a !== void 0 ? a : []));
}
function toType(value, type) {
    switch (type) {
        case 'object':
            return value && typeof value === 'object' ? value : {};
        case 'string':
            if (typeof value === 'string')
                return value;
            break;
        case 'number':
            if (typeof value === 'number')
                return value;
            break;
    }
}
function deepCopy$3(source) {
    return Array.isArray(source)
        ? source.map(function (item) { return deepCopy$3(item); })
        : source instanceof Date
            ? new Date(source.getTime())
            : source && typeof source === 'object'
                ? Object.getOwnPropertyNames(source).reduce(function (o, prop) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, prop);
                    if (descriptor) {
                        Object.defineProperty(o, prop, descriptor);
                        if (source && typeof source === 'object') {
                            o[prop] = deepCopy$3(source[prop]);
                        }
                    }
                    return o;
                }, Object.create(Object.getPrototypeOf(source)))
                : source;
}
function isTagName$3(name) {
    return ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embd', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].includes(name);
}
function flatColors$2(colors, head) {
    var flatten = {};
    for (var _i = 0, _a = Object.entries(colors); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        if (typeof value === 'string' || typeof value === 'function') {
            flatten[(head && key === 'DEFAULT') ? head : head ? head + "-" + key : key] = value;
        }
        else {
            flatten = __assign$3(__assign$3({}, flatten), flatColors$2(value, head ? head + "-" + key : key));
        }
    }
    return flatten;
}
function testRegexr(text, expressions) {
    for (var _i = 0, expressions_1 = expressions; _i < expressions_1.length; _i++) {
        var exp = expressions_1[_i];
        if (exp.test(text))
            return true;
    }
    return false;
}
function searchPropEnd$3(text, startIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    var index = startIndex;
    var output = -1;
    var openSingleQuote = false;
    var openDoubleQuote = false;
    var openBracket = false;
    var isEscaped = false;
    while (index < text.length) {
        switch (text.charAt(index)) {
            case '\\':
                isEscaped = !isEscaped;
                break;
            case '\'':
                if (!openDoubleQuote && !openBracket && !isEscaped)
                    openSingleQuote = !openSingleQuote;
                isEscaped = false;
                break;
            case '"':
                if (!openSingleQuote && !openBracket && !isEscaped)
                    openDoubleQuote = !openDoubleQuote;
                isEscaped = false;
                break;
            case '(':
                if (!openBracket && !openSingleQuote && !openDoubleQuote && !isEscaped)
                    openBracket = true;
                isEscaped = false;
                break;
            case ')':
                if (openBracket && !isEscaped)
                    openBracket = false;
                isEscaped = false;
                break;
            case ';':
                if (!isEscaped && !openSingleQuote && !openDoubleQuote && !openBracket)
                    output = index;
                isEscaped = false;
                break;
            default:
                isEscaped = false;
                break;
        }
        if (output !== -1)
            break;
        index++;
    }
    return output;
}
function searchNotEscape(text, chars) {
    if (chars === void 0) { chars = ['{']; }
    if (!Array.isArray(chars))
        chars = [chars];
    var i = 0;
    while (i < text.length) {
        if (chars.includes(text.charAt(i)) && text.charAt(i - 1) !== '\\') {
            return i;
        }
        i++;
    }
    return -1;
}
function splitSelectors(selectors) {
    var splitted = [];
    var parens = 0;
    var angulars = 0;
    var soFar = '';
    for (var i = 0, len = selectors.length; i < len; i++) {
        var char = selectors[i];
        if (char === '(') {
            parens += 1;
        }
        else if (char === ')') {
            parens -= 1;
        }
        else if (char === '[') {
            angulars += 1;
        }
        else if (char === ']') {
            angulars -= 1;
        }
        else if (char === ',') {
            if (!parens && !angulars) {
                splitted.push(soFar.trim());
                soFar = '';
                continue;
            }
        }
        soFar += char;
    }
    splitted.push(soFar.trim());
    return splitted;
}
function guessClassName(selector) {
    var _a;
    if (selector.indexOf(',') >= 0)
        return splitSelectors(selector).map(function (i) { return guessClassName(i); });
    // not classes, contains attribute selectors, nested selectors - treat as static
    if (selector.charAt(0) !== '.' || searchNotEscape(selector, ['[', '>', '+', '~']) >= 0 || selector.trim().indexOf(' ') >= 0 || searchNotEscape(selector.slice(1), '.') >= 0)
        return { selector: selector, isClass: false };
    var pseudo = searchNotEscape(selector, ':');
    var className = (((_a = selector.match(/^\.([\w-]|(\\\W))+/)) === null || _a === void 0 ? void 0 : _a[0].slice(1)) || '').replace(/\\/g, '');
    if (pseudo === -1)
        return { selector: className, isClass: true };
    return { selector: className, isClass: true, pseudo: selector.slice(pseudo) };
}
function increaseWithUnit(target, delta) {
    var _a;
    if (typeof target === 'number')
        return target + delta;
    var value = ((_a = target.match(/^-?[0-9]+\.?[0-9]*/)) === null || _a === void 0 ? void 0 : _a[0]) || '';
    var unit = target.slice(value.length);
    var result = (parseFloat(value) + delta);
    if (Number.isNaN(result))
        return target;
    return result + unit;
}
function splitColorGroup(color) {
    var sep = color.indexOf('/');
    if (sep === -1)
        return [color, undefined];
    return [color.slice(0, sep), color.slice(sep + 1)];
}

var Property$3 = /** @class */ (function () {
    function Property(name, value, comment, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'utilities', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.name = name;
        this.value = value;
        this.comment = comment;
        this.important = important;
    }
    Property._singleParse = function (css) {
        css = css.trim();
        if (!css)
            return;
        if (css.charAt(0) === '@')
            return InlineAtRule$3.parse(css);
        var split = css.search(':');
        var end = searchPropEnd$3(css);
        if (split === -1)
            return;
        var important = false;
        var prop = css.substring(split + 1, end === -1 ? undefined : end).trim();
        if (/!important;?$/.test(prop)) {
            important = true;
            prop = prop.replace(/!important/, '').trimRight();
        }
        return new Property(css.substring(0, split).trim(), prop, undefined, important);
    };
    Property.parse = function (css) {
        if (!/;\s*$/.test(css))
            css += ';'; // Fix for the situation where the last semicolon is omitted
        var properties = [];
        var index = 0;
        var end = searchPropEnd$3(css, index);
        while (end !== -1) {
            var parsed = this._singleParse(css.substring(searchFrom$3(css, /\S/, index), end + 1));
            if (parsed)
                properties.push(parsed);
            index = end + 1;
            end = searchPropEnd$3(css, index);
        }
        var count = properties.length;
        if (count > 1)
            return properties;
        if (count === 1)
            return properties[0];
    };
    Property.prototype.clone = function () {
        return deepCopy$3(this);
    };
    Property.prototype.toStyle = function (selector) {
        var style = new Style$3(selector, this, this.important);
        style.meta = this.meta;
        return style;
    };
    Property.prototype.build = function (minify) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        var createProperty = function (name, value) {
            if (minify) {
                return name + ":" + value + (_this.important ? '!important' : '') + ";";
            }
            else {
                var p = name + ": " + value + (_this.important ? ' !important' : '') + ";";
                return _this.comment ? p + (" /* " + _this.comment + " */") : p;
            }
        };
        if (!this.value)
            return '';
        return typeof this.name === 'string'
            ? createProperty(this.name, this.value)
            : this.name
                .map(function (i) { return createProperty(i, _this.value); })
                .join(minify ? '' : '\n');
    };
    Property.prototype.updateMeta = function (type, group, order, offset, corePlugin) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
        };
        return this;
    };
    return Property;
}());
var InlineAtRule$3 = /** @class */ (function (_super) {
    __extends$5(InlineAtRule, _super);
    function InlineAtRule(name, value, important) {
        if (important === void 0) { important = false; }
        var _this = _super.call(this, name, value, undefined, important) || this;
        _this.name = name;
        return _this;
    }
    InlineAtRule.parse = function (css) {
        var _a;
        var matchName = css.match(/@[^\s;{}]+/);
        if (matchName) {
            var name_1 = matchName[0].substring(1);
            var important = false;
            var expression = matchName.index !== undefined
                ? (_a = css
                    .substring(matchName.index + name_1.length + 1)
                    .match(/(?:(['"]).*?\1|[^;])*/)) === null || _a === void 0 ? void 0 : _a[0].trim()
                : undefined;
            if (expression && /!important;?$/.test(expression)) {
                important = true;
                expression = expression.replace(/!important/, '').trimRight();
            }
            return new InlineAtRule(name_1, expression === '' ? undefined : expression, important);
        }
    };
    InlineAtRule.prototype.build = function () {
        return this.value
            ? "@" + this.name + " " + this.value + (this.important ? ' !important' : '') + ";"
            : "@" + this.name + (this.important ? ' !important' : '') + ";";
    };
    return InlineAtRule;
}(Property$3));
var Style$3 = /** @class */ (function () {
    function Style(selector, property, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'components', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.selector = selector;
        this.important = important;
        this.property = toArray$4(property || []);
    }
    Object.defineProperty(Style.prototype, "rule", {
        get: function () {
            var _this = this;
            var _a, _b, _c;
            var selectors = ((_a = this.selector) !== null && _a !== void 0 ? _a : '').trim().split(/\s*,\s*/g);
            this._parentSelectors && (selectors = selectors.map(function (i) { var _a; return ((_a = _this._parentSelectors) === null || _a === void 0 ? void 0 : _a.join(' ')) + " " + i; }));
            ((_b = this._wrapSelectors) !== null && _b !== void 0 ? _b : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            this._pseudoClasses && (selectors = selectors.map(function (i) { var _a; return i + (":" + ((_a = _this._pseudoClasses) === null || _a === void 0 ? void 0 : _a.join(':'))); }));
            this._pseudoElements && (selectors = selectors.map(function (i) { var _a; return i + ("::" + ((_a = _this._pseudoElements) === null || _a === void 0 ? void 0 : _a.join('::'))); }));
            this._brotherSelectors && (selectors = selectors.map(function (i) { var _a; return i + ("." + ((_a = _this._brotherSelectors) === null || _a === void 0 ? void 0 : _a.join('.'))); }));
            this._childSelectors && (selectors = selectors.map(function (i) { var _a; return i + (" " + ((_a = _this._childSelectors) === null || _a === void 0 ? void 0 : _a.join(' '))); }));
            ((_c = this._wrapRules) !== null && _c !== void 0 ? _c : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            return selectors.join(', ');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoClasses", {
        get: function () {
            return this._pseudoClasses;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoElements", {
        get: function () {
            return this._pseudoElements;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "parentSelectors", {
        get: function () {
            return this._parentSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "childSelectors", {
        get: function () {
            return this._childSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "brotherSelectors", {
        get: function () {
            return this._brotherSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapProperties", {
        get: function () {
            return this._wrapProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapSelectors", {
        get: function () {
            return this._wrapSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapRules", {
        get: function () {
            return this._wrapRules;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "simple", {
        get: function () {
            // is this style only has property and no wrap?
            return !(this.atRules || this._pseudoClasses || this._pseudoElements || this._parentSelectors || this._childSelectors || this._brotherSelectors || this._wrapProperties || this._wrapSelectors || this._wrapRules);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "isAtrule", {
        get: function () {
            return !(this.atRules === undefined || this.atRules.length === 0);
        },
        enumerable: false,
        configurable: true
    });
    Style.generate = function (parent, property, root) {
        if (!root)
            root = (parent === null || parent === void 0 ? void 0 : parent.startsWith('@'))
                ? new Style().atRule(parent)
                : new Style(parent);
        var output = [];
        var _loop_1 = function (key, value) {
            if (typeof value === 'string') {
                root.add(new Property$3(camelToDash$3(key), value));
            }
            else if (Array.isArray(value)) {
                value.map(function (i) { return root === null || root === void 0 ? void 0 : root.add(new Property$3(camelToDash$3(key), i)); });
            }
            else {
                var wrap = deepCopy$3(root);
                wrap.property = [];
                var child = void 0;
                if (key.startsWith('@')) {
                    child = wrap.atRule(key, false);
                }
                else {
                    if (wrap.selector === undefined) {
                        wrap.selector = key;
                        child = wrap;
                    }
                    else {
                        if (/^[a-z]+$/.test(key) && !isTagName$3(key)) {
                            wrap.wrapProperty(function (property) { return key + "-" + property; });
                            child = wrap;
                        }
                        else {
                            var _hKey_1 = function (selector, key) { return (/&/.test(key) ? key : "& " + key).replace('&', selector); };
                            wrap.wrapSelector(function (selector) {
                                return selector
                                    .trim()
                                    .split(/\s*,\s*/g)
                                    .map(function (s) {
                                    return key
                                        .split(/\s*,\s*/g)
                                        .map(function (i) { return _hKey_1(s, i); })
                                        .join(', ');
                                })
                                    .join(', ');
                            });
                            child = wrap;
                        }
                    }
                }
                output = output.concat(Style.generate(key.startsWith('@') ? undefined : key, value, child));
            }
        };
        for (var _i = 0, _a = Object.entries(property !== null && property !== void 0 ? property : {}); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
        if (root.property.length > 0)
            output.unshift(root);
        return output;
    };
    Style.prototype.atRule = function (atrule, append) {
        if (append === void 0) { append = true; }
        if (!atrule)
            return this;
        if (this.atRules) {
            append ? this.atRules.push(atrule) : this.atRules.unshift(atrule);
        }
        else {
            this.atRules = [atrule];
        }
        return this;
    };
    Style.prototype.pseudoClass = function (string) {
        if (this._pseudoClasses) {
            this._pseudoClasses.push(string);
        }
        else {
            this._pseudoClasses = [string];
        }
        return this;
    };
    Style.prototype.pseudoElement = function (string) {
        if (this._pseudoElements) {
            this._pseudoElements.push(string);
        }
        else {
            this._pseudoElements = [string];
        }
        return this;
    };
    Style.prototype.brother = function (string) {
        if (this._brotherSelectors) {
            this._brotherSelectors.push(string);
        }
        else {
            this._brotherSelectors = [string];
        }
        return this;
    };
    Style.prototype.parent = function (string) {
        if (this._parentSelectors) {
            this._parentSelectors.push(string);
        }
        else {
            this._parentSelectors = [string];
        }
        return this;
    };
    Style.prototype.child = function (string) {
        if (this._childSelectors) {
            this._childSelectors.push(string);
        }
        else {
            this._childSelectors = [string];
        }
        return this;
    };
    Style.prototype.wrapProperty = function (func) {
        if (this._wrapProperties) {
            this._wrapProperties.push(func);
        }
        else {
            this._wrapProperties = [func];
        }
        return this;
    };
    Style.prototype.wrapSelector = function (func) {
        if (this._wrapSelectors) {
            this._wrapSelectors.push(func);
        }
        else {
            this._wrapSelectors = [func];
        }
        return this;
    };
    Style.prototype.wrapRule = function (func) {
        if (this._wrapRules) {
            this._wrapRules.push(func);
        }
        else {
            this._wrapRules = [func];
        }
        return this;
    };
    Style.prototype.add = function (item) {
        item = toArray$4(item);
        if (this.important)
            item.forEach(function (i) { return (i.important = true); });
        this.property = __spreadArray$5(__spreadArray$5([], this.property), item);
        return this;
    };
    Style.prototype.extend = function (item, onlyProperty, append) {
        if (onlyProperty === void 0) { onlyProperty = false; }
        if (append === void 0) { append = true; }
        if (!item)
            return this;
        if (item.wrapProperties) {
            var props_1 = [];
            item.property.forEach(function (p) {
                var _a;
                var pc = new Property$3(p.name, p.value, p.comment);
                (_a = item.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) {
                    pc.name = Array.isArray(pc.name)
                        ? pc.name.map(function (i) { return wrap(i); })
                        : wrap(pc.name);
                });
                if (item.important)
                    pc.important = true;
                props_1.push(pc);
            });
            this.property = connectList$3(this.property, props_1, append);
        }
        else {
            if (item.important)
                item.property.forEach(function (i) { return (i.important = true); });
            this.property = connectList$3(this.property, item.property, append);
        }
        if (onlyProperty)
            return this;
        item.selector && (this.selector = item.selector);
        this.meta = item.meta;
        item.atRules &&
            (this.atRules = connectList$3(item.atRules, this.atRules, append)); // atrule is build in reverse
        item._brotherSelectors &&
            (this._brotherSelectors = connectList$3(this._brotherSelectors, item._brotherSelectors, append));
        item._childSelectors &&
            (this._childSelectors = connectList$3(this._childSelectors, item._childSelectors, append));
        item._parentSelectors &&
            (this._parentSelectors = connectList$3(this._parentSelectors, item._parentSelectors, append));
        item._pseudoClasses &&
            (this._pseudoClasses = connectList$3(this._pseudoClasses, item._pseudoClasses, append));
        item._pseudoElements &&
            (this._pseudoElements = connectList$3(this._pseudoElements, item._pseudoElements, append));
        item._wrapRules &&
            (this._wrapRules = connectList$3(this._wrapRules, item._wrapRules, append));
        item._wrapSelectors &&
            (this._wrapSelectors = connectList$3(this._wrapSelectors, item._wrapSelectors, append));
        return this;
    };
    Style.prototype.clean = function () {
        // remove duplicated property
        var property = [];
        var cache = [];
        this.property.forEach(function (i) {
            var inline = i.build();
            if (!cache.includes(inline)) {
                cache.push(inline);
                property.push(i);
            }
        });
        this.property = property;
        return this;
    };
    Style.prototype.flat = function () {
        var properties = [];
        this.property.forEach(function (p) {
            if (Array.isArray(p.name)) {
                p.name.forEach(function (i) {
                    properties.push(new Property$3(i, p.value, p.comment));
                });
            }
            else {
                properties.push(p);
            }
        });
        this.property = properties;
        return this;
    };
    Style.prototype.clone = function (selector, property) {
        var newStyle = deepCopy$3(this);
        if (selector)
            newStyle.selector = selector;
        if (property)
            newStyle.property = Array.isArray(property) ? property : [property];
        return newStyle;
    };
    Style.prototype.sort = function () {
        // sort property
        this.property = this.property.sort(function (a, b) {
            return ("" + a.name).substring(0, 2) > ("" + b.name).substring(0, 2) ? 1 : -1;
        });
        return this;
    };
    Style.prototype.build = function (minify, prefixer) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        if (prefixer === void 0) { prefixer = true; }
        var properties = this.property;
        if (!prefixer)
            properties = properties.filter(function (p) {
                if (p.value && /-(webkit|ms|moz|o)-/.test(p.value))
                    return false;
                if (Array.isArray(p.name)) {
                    p.name = p.name.filter(function (i) { return !/^-(webkit|ms|moz|o)-/.test(i); });
                    return true;
                }
                return !/^-(webkit|ms|moz|o)-/.test(p.name);
            });
        var result = properties.map(function (p) {
            if (_this._wrapProperties) {
                var name_2 = p.name;
                _this._wrapProperties.forEach(function (w) { return (name_2 = Array.isArray(name_2) ? name_2.map(function (n) { return w(n); }) : w(name_2)); });
                return new Property$3(name_2, p.value, p.comment, _this.important ? true : p.important).build(minify);
            }
            return _this.important ? new Property$3(p.name, p.value, p.comment, true).build(minify) : p.build(minify);
        }).join(minify ? '' : '\n');
        if (!this.selector && !this.atRules)
            return result.replace(/;}/g, '}');
        if (this.selector)
            result = (minify ? this.rule.replace(/,\s/g, ',') : this.rule + ' ') + wrapit$3(result, undefined, undefined, undefined, result !== '' ? minify : true);
        if (this.atRules) {
            for (var _i = 0, _a = this.atRules; _i < _a.length; _i++) {
                var rule = _a[_i];
                result = minify ? "" + rule.replace(/\s/g, '') + wrapit$3(result, undefined, undefined, undefined, minify) : rule + " " + wrapit$3(result, undefined, undefined, undefined, result !== '' ? minify : true);
            }
        }
        return minify ? result.replace(/;}/g, '}') : result;
    };
    Style.prototype.updateMeta = function (type, group, order, offset, corePlugin, respectSelector) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        if (respectSelector === void 0) { respectSelector = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
            respectSelector: respectSelector,
        };
        return this;
    };
    return Style;
}());
/** @class */ ((function (_super) {
    __extends$5(GlobalStyle, _super);
    function GlobalStyle(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return GlobalStyle;
})(Style$3));
var Keyframes$1 = /** @class */ (function (_super) {
    __extends$5(Keyframes, _super);
    function Keyframes(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    // root param only for consist with style
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Keyframes.generate = function (name, children, root, prefixer) {
        if (prefixer === void 0) { prefixer = true; }
        var styles = [];
        var webkitStyles = [];
        for (var _i = 0, _a = Object.entries(children); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var style = new Keyframes(key).atRule("@keyframes " + name);
            var webkitStyle = new Keyframes(key).atRule("@-webkit-keyframes " + name);
            for (var _c = 0, _d = Object.entries(value); _c < _d.length; _c++) {
                var _e = _d[_c], pkey = _e[0], pvalue = _e[1];
                var prop = pkey;
                if (pkey === 'transform') {
                    prop = prefixer ? ['-webkit-transform', 'transform'] : 'transform';
                }
                else if (['animationTimingFunction', 'animation-timing-function'].includes(pkey)) {
                    prop = prefixer ? [
                        '-webkit-animation-timing-function',
                        'animation-timing-function',
                    ] : 'animation-timing-function';
                }
                style.add(new Property$3(prop, pvalue));
                webkitStyle.add(new Property$3(prop, pvalue));
            }
            styles.push(style);
            if (prefixer)
                webkitStyles.push(webkitStyle);
        }
        return __spreadArray$5(__spreadArray$5([], styles), webkitStyles);
    };
    return Keyframes;
}(Style$3));
var Container = /** @class */ (function (_super) {
    __extends$5(Container, _super);
    function Container(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return Container;
}(Style$3));

var minMaxWidth$2 = /(!?\(\s*min(-device-)?-width).+\(\s*max(-device)?-width/i;
var minWidth$2 = /\(\s*min(-device)?-width/i;
var maxMinWidth$2 = /(!?\(\s*max(-device)?-width).+\(\s*min(-device)?-width/i;
var maxWidth$2 = /\(\s*max(-device)?-width/i;
var isMinWidth$2 = _testQuery$2(minMaxWidth$2, maxMinWidth$2, minWidth$2);
var isMaxWidth$2 = _testQuery$2(maxMinWidth$2, minMaxWidth$2, maxWidth$2);
var minMaxHeight$2 = /(!?\(\s*min(-device)?-height).+\(\s*max(-device)?-height/i;
var minHeight$2 = /\(\s*min(-device)?-height/i;
var maxMinHeight$2 = /(!?\(\s*max(-device)?-height).+\(\s*min(-device)?-height/i;
var maxHeight$2 = /\(\s*max(-device)?-height/i;
var isMinHeight$2 = _testQuery$2(minMaxHeight$2, maxMinHeight$2, minHeight$2);
var isMaxHeight$2 = _testQuery$2(maxMinHeight$2, minMaxHeight$2, maxHeight$2);
var isPrint$2 = /print/i;
var isPrintOnly$2 = /^print\$/i;
var isAtRule$2 = /^\s*@/i;
var isMedia$2 = /^\s*@media/i;
var maxValue$2 = Number.MAX_VALUE;
function _getQueryLength$2(length) {
    var result = /(-?\d*\.?\d+)(ch|em|ex|px|rpx|rem)/.exec(length);
    if (result === null) {
        return maxValue$2;
    }
    var number = result[1];
    var unit = result[2];
    switch (unit) {
        case 'ch':
            return parseFloat(number) * 8.8984375;
        case 'em':
        case 'rem':
            return parseFloat(number) * 16;
        case 'ex':
            return parseFloat(number) * 8.296875;
        case 'px':
        case 'rpx':
            return parseFloat(number);
    }
    return +number;
}
function _testQuery$2(doubleTestTrue, doubleTestFalse, singleTest) {
    return function (query) {
        if (doubleTestTrue.test(query)) {
            return true;
        }
        else if (doubleTestFalse.test(query)) {
            return false;
        }
        return singleTest.test(query);
    };
}
function _testAtRule$2(a, b) {
    var isMediaA = isMedia$2.test(a);
    var isMediaB = isMedia$2.test(b);
    if (isMediaA && isMediaB)
        return null;
    var isAtRuleA = isAtRule$2.test(a);
    var isAtRuleB = isAtRule$2.test(b);
    if (isAtRuleA)
        return 1;
    if (isAtRuleB)
        return -1;
    return 0; // don't sort selector name, may cause overwrite bug.
}
function _testIsPrint$2(a, b) {
    var isPrintA = isPrint$2.test(a);
    var isPrintOnlyA = isPrintOnly$2.test(a);
    var isPrintB = isPrint$2.test(b);
    var isPrintOnlyB = isPrintOnly$2.test(b);
    if (isPrintA && isPrintB) {
        if (!isPrintOnlyA && isPrintOnlyB) {
            return 1;
        }
        if (isPrintOnlyA && !isPrintOnlyB) {
            return -1;
        }
        return a.localeCompare(b);
    }
    if (isPrintA) {
        return 1;
    }
    if (isPrintB) {
        return -1;
    }
    return null;
}
function sortMediaQuery$2(a, b) {
    var testAtRule = _testAtRule$2(a, b);
    if (testAtRule !== null)
        return testAtRule;
    var testIsPrint = _testIsPrint$2(a, b);
    if (testIsPrint !== null)
        return testIsPrint;
    var minA = isMinWidth$2(a) || isMinHeight$2(a);
    var maxA = isMaxWidth$2(a) || isMaxHeight$2(a);
    var minB = isMinWidth$2(b) || isMinHeight$2(b);
    var maxB = isMaxWidth$2(b) || isMaxHeight$2(b);
    if (minA && maxB) {
        return -1;
    }
    if (maxA && minB) {
        return 1;
    }
    var lengthA = _getQueryLength$2(a);
    var lengthB = _getQueryLength$2(b);
    if (lengthA === maxValue$2 && lengthB === maxValue$2) {
        return a.localeCompare(b);
    }
    else if (lengthA === maxValue$2) {
        return 1;
    }
    else if (lengthB === maxValue$2) {
        return -1;
    }
    if (lengthA > lengthB) {
        if (maxA) {
            return -1;
        }
        return 1;
    }
    if (lengthA < lengthB) {
        if (maxA) {
            return 1;
        }
        return -1;
    }
    return a.localeCompare(b);
}

function getWeights$2(a) {
    var first = a.charAt(0);
    var second = a.charAt(1);
    if (first === ':' && second === ':')
        return 59; // ::moz ...
    if (first === '#')
        return 500; // #id ...
    if (first !== '.')
        return first.charCodeAt(0); // html, body ...
    return 499;
}
function sortMeta$2(a, b) {
    var _a, _b, _c, _d;
    if (a.meta.type === 'base' && b.meta.type === 'base')
        return getWeights$2((_a = a.selector) !== null && _a !== void 0 ? _a : '') - getWeights$2((_b = b.selector) !== null && _b !== void 0 ? _b : '');
    return sortMediaQuery$2(((_c = a.meta.variants) === null || _c === void 0 ? void 0 : _c[0]) || '', ((_d = b.meta.variants) === null || _d === void 0 ? void 0 : _d[0]) || '') || (a.meta.order - b.meta.order) || (a.meta.offset - b.meta.offset) || +b.meta.corePlugin - +a.meta.corePlugin;
}
function sortGroup(a, b) {
    var _a, _b;
    return sortMediaQuery$2(((_a = a.meta.variants) === null || _a === void 0 ? void 0 : _a[0]) || '', ((_b = b.meta.variants) === null || _b === void 0 ? void 0 : _b[0]) || '') || (a.meta.order - b.meta.order);
}

function _buildAtrule$2(atrule, children, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return "" + atrule + (minify ? '' : ' ') + wrapit$3(_buildStyleList$2(children, minify, prefixer), undefined, undefined, undefined, minify);
}
function _buildStyleList$2(styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    var currentAtrule;
    var currentStyle;
    var styleStack = [];
    var output = [];
    var _loop_1 = function (style) {
        if (style.isAtrule) {
            if (currentStyle) {
                output.push(currentStyle.clean().build(minify, prefixer));
                currentStyle = undefined;
            }
            var newAtrule = style.atRules.pop();
            if (currentAtrule) {
                if (currentAtrule === newAtrule && newAtrule !== '@font-face') { // @font-face shouldn't been combined
                    styleStack.push(style);
                }
                else {
                    output.push(_buildAtrule$2(currentAtrule, styleStack, minify, prefixer));
                    currentAtrule = newAtrule;
                    styleStack = [style];
                }
            }
            else {
                currentAtrule = newAtrule;
                styleStack = [style];
            }
        }
        else {
            if (currentAtrule) {
                output.push(_buildAtrule$2(currentAtrule, styleStack, minify, prefixer));
                currentAtrule = undefined;
                styleStack = [];
            }
            if (currentStyle) {
                if (style.rule === currentStyle.rule) {
                    if (style.important)
                        style.property.forEach(function (p) { return p.important = true; });
                    if (style.wrapProperties)
                        style.property.forEach(function (p) { var _a; return (_a = style.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) { return p.name = Array.isArray(p.name) ? p.name.map(function (i) { return wrap(i); }) : wrap(p.name); }); });
                    currentStyle.add(style.property);
                }
                else {
                    output.push(currentStyle.clean().build(minify, prefixer));
                    currentStyle = style;
                }
            }
            else {
                currentStyle = style;
            }
        }
    };
    for (var _i = 0, styleList_1 = styleList; _i < styleList_1.length; _i++) {
        var style = styleList_1[_i];
        _loop_1(style);
    }
    if (currentAtrule)
        output.push(_buildAtrule$2(currentAtrule, styleStack, minify, prefixer));
    if (currentStyle)
        output.push(currentStyle.clean().build(minify, prefixer));
    return output.join(minify ? '' : '\n');
}
function compileStyleSheet$2 (styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return _buildStyleList$2(deepCopy$3(styleList), minify, prefixer);
}

var StyleSheet$2 = /** @class */ (function () {
    function StyleSheet(children) {
        this.prefixer = true;
        this.children = children || [];
    }
    StyleSheet.prototype.add = function (item) {
        if (!item)
            return this;
        if (Array.isArray(item)) {
            this.children = __spreadArray$5(__spreadArray$5([], this.children), item);
        }
        else {
            this.children.push(item);
        }
        return this;
    };
    StyleSheet.prototype.extend = function (styleSheet, append, dedup) {
        if (append === void 0) { append = true; }
        if (dedup === void 0) { dedup = false; }
        if (styleSheet) {
            var extended = styleSheet.children;
            if (dedup) {
                var hashes_1 = extended.map(function (i) { return hash$2(i.build()); });
                extended = extended.filter(function (i) { return !hashes_1.includes(hash$2(i.build())); });
            }
            this.prefixer = styleSheet.prefixer;
            this.children = append ? __spreadArray$5(__spreadArray$5([], this.children), extended) : __spreadArray$5(__spreadArray$5([], extended), this.children);
        }
        return this;
    };
    StyleSheet.prototype.combine = function () {
        var styleMap = {};
        this.children.forEach(function (style, index) {
            var _a;
            var hashValue = hash$2(style.atRules + style.rule);
            if (hashValue in styleMap) {
                if ((_a = style.atRules) === null || _a === void 0 ? void 0 : _a.includes('@font-face')) {
                    // keeps multiple @font-face
                    styleMap[hashValue + index] = style;
                }
                else {
                    styleMap[hashValue] = styleMap[hashValue].extend(style, true);
                }
            }
            else {
                styleMap[hashValue] = style;
            }
        });
        this.children = Object.values(styleMap).map(function (i) { return i.clean(); });
        return this;
    };
    StyleSheet.prototype.layer = function (type) {
        var styleSheet = new StyleSheet(this.children.filter(function (i) { return i.meta.type === type; }));
        styleSheet.prefixer = this.prefixer;
        return styleSheet;
    };
    StyleSheet.prototype.split = function () {
        return {
            base: this.layer('base'),
            components: this.layer('components'),
            utilities: this.layer('utilities'),
        };
    };
    StyleSheet.prototype.clone = function () {
        return deepCopy$3(this);
    };
    StyleSheet.prototype.sort = function () {
        this.children = this.children.sort(sortMeta$2);
        return this;
    };
    StyleSheet.prototype.sortby = function (compareFn) {
        this.children = this.children.sort(compareFn);
        return this;
    };
    StyleSheet.prototype.build = function (minify) {
        if (minify === void 0) { minify = false; }
        return compileStyleSheet$2(this.children, minify, this.prefixer);
    };
    return StyleSheet;
}());

function linearGradient(value) {
    // Stupid method, will be changed in the next version...
    var map = {
        'linear-gradient(to top, var(--tw-gradient-stops))': [
            '-o-linear-gradient(bottom, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, left bottom, left top, from(var(--tw-gradient-stops)))',
            'linear-gradient(to top, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to top right, var(--tw-gradient-stops))': [
            '-o-linear-gradient(bottom left, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, left bottom, right top, from(var(--tw-gradient-stops)))',
            'linear-gradient(to top right, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to right, var(--tw-gradient-stops))': [
            '-o-linear-gradient(left, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, left top, right top, from(var(--tw-gradient-stops)))',
            'linear-gradient(to right, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to bottom right, var(--tw-gradient-stops))': [
            '-o-linear-gradient(top left, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, left top, right bottom, from(var(--tw-gradient-stops)))',
            'linear-gradient(to bottom right, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to bottom, var(--tw-gradient-stops))': [
            '-o-linear-gradient(top, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, left top, left bottom, from(var(--tw-gradient-stops)))',
            'linear-gradient(to bottom, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to bottom left, var(--tw-gradient-stops))': [
            '-o-linear-gradient(top right, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, right top, left bottom, from(var(--tw-gradient-stops)))',
            'linear-gradient(to bottom left, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to left, var(--tw-gradient-stops))': [
            '-o-linear-gradient(right, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, right top, left top, from(var(--tw-gradient-stops)))',
            'linear-gradient(to left, var(--tw-gradient-stops))',
        ],
        'linear-gradient(to top left, var(--tw-gradient-stops))': [
            '-o-linear-gradient(bottom right, var(--tw-gradient-stops))',
            '-webkit-gradient(linear, right bottom, left top, from(var(--tw-gradient-stops)))',
            'linear-gradient(to top left, var(--tw-gradient-stops))',
        ],
    };
    if (Object.keys(map).includes(value))
        return map[value];
    return value;
}
function minMaxContent(value) {
    if (value === 'min-content') {
        return ['-webkit-min-content', 'min-content'];
    }
    else if (value === 'max-content') {
        return ['-webkit-max-content', 'max-content'];
    }
    return value;
}

function isString$1(value) {
    return typeof value === 'string';
}
function negative$1(scale) {
    return Object.keys(scale)
        .filter(function (key) { return scale[key] !== '0'; })
        .reduce(function (negativeScale, key) {
        var _a;
        return (__assign$3(__assign$3({}, negativeScale), (_a = {}, _a["-" + key] = negateValue(scale[key]), _a)));
    }, {});
}
function breakpoints(screens) {
    if (screens === void 0) { screens = {}; }
    return Object.keys(screens)
        .filter(function (key) { return typeof screens[key] === 'string'; })
        .reduce(function (breakpoints, key) {
        var _a;
        return (__assign$3(__assign$3({}, breakpoints), (_a = {}, _a["screen-" + key] = screens[key], _a)));
    }, {});
}
function generateFontSize(font) {
    if (typeof font === 'string')
        return [new Property$3('font-size', font)];
    var properties = [];
    if (font[0])
        properties.push(new Property$3('font-size', font[0]));
    if (typeof font[1] === 'string') {
        properties.push(new Property$3('line-height', font[1]));
    }
    else if (font[1]) {
        if (font[1].lineHeight)
            properties.push(new Property$3('line-height', font[1].lineHeight));
        if (font[1].letterSpacing)
            properties.push(new Property$3('letter-spacing', font[1].letterSpacing));
    }
    return properties;
}
function expandDirection(value, divide) {
    if (divide === void 0) { divide = false; }
    var map = {
        '': ['*'],
        y: ['top', 'bottom'],
        x: ['left', 'right'],
        t: divide ? ['top-left', 'top-right'] : ['top'],
        r: divide ? ['top-right', 'bottom-right'] : ['right'],
        b: divide ? ['bottom-right', 'bottom-left'] : ['bottom'],
        l: divide ? ['top-left', 'bottom-left'] : ['left'],
        tl: ['top-left'],
        tr: ['top-right'],
        br: ['bottom-right'],
        bl: ['bottom-left'],
    };
    if (value in map)
        return map[value];
}
function generatePlaceholder(selector, property, prefixer) {
    if (prefixer === void 0) { prefixer = false; }
    if (!prefixer)
        return [new Style$3(selector, property).pseudoElement('placeholder')];
    return [
        new Style$3(selector, property).pseudoElement('-webkit-input-placeholder'),
        new Style$3(selector, property).pseudoElement('-moz-placeholder'),
        new Style$3(selector, property).pseudoClass('-ms-input-placeholder'),
        new Style$3(selector, property).pseudoElement('-ms-input-placeholder'),
        new Style$3(selector, property).pseudoElement('placeholder'),
    ];
}

function createCommonjsModule$1(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var colorName$1 = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var isArrayish$1 = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var simpleSwizzle$1 = createCommonjsModule$1(function (module) {



var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish$1(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};
});

/* MIT license */

var colorString = createCommonjsModule$1(function (module) {
var reverseNames = {};

// create a list of reverse color names
for (var name in colorName$1) {
	if (colorName$1.hasOwnProperty(name)) {
		reverseNames[colorName$1[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorName$1[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = (parseFloat(match[1]) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = simpleSwizzle$1(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = simpleSwizzle$1(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = simpleSwizzle$1(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = simpleSwizzle$1(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = simpleSwizzle$1(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}
});

function hsl2rgb(h, s, l) {
    s = s / 100,
        l = l / 100;
    if (h >= 360)
        h %= 360;
    var c = (1 - Math.abs(2 * l - 1)) * s;
    var x = c * (1 - Math.abs((h / 60) % 2 - 1));
    var m = l - c / 2;
    var r = 0;
    var g = 0;
    var b = 0;
    if (0 <= h && h < 60) {
        r = c;
        g = x;
        b = 0;
    }
    else if (60 <= h && h < 120) {
        r = x;
        g = c;
        b = 0;
    }
    else if (120 <= h && h < 180) {
        r = 0;
        g = c;
        b = x;
    }
    else if (180 <= h && h < 240) {
        r = 0;
        g = x;
        b = c;
    }
    else if (240 <= h && h < 300) {
        r = x;
        g = 0;
        b = c;
    }
    else if (300 <= h && h < 360) {
        r = c;
        g = 0;
        b = x;
    }
    // having obtained RGB, convert channels to hex
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return [r, g, b];
}
function hwb2rgb(h, w, b) {
    var rgb = hsl2rgb(h, 100, 50);
    for (var i = 0; i < 3; ++i) {
        var c = rgb[i] / 255;
        c *= 1 - w / 100 - b / 100;
        c += w / 100;
        rgb[i] = Math.round(c * 255);
    }
    return rgb;
}
function toRGBA(color) {
    var _a;
    if (/^hsla?/.test(color)) {
        var colorTuple = colorString.get.hsl(color);
        if (!colorTuple)
            return;
        return __spreadArray$5(__spreadArray$5([], hsl2rgb(colorTuple[0], colorTuple[1], colorTuple[2])), [colorTuple[3]]);
    }
    else if (/^rgba?/.test(color)) {
        var colorTuple = colorString.get.rgb(color);
        if (!colorTuple)
            return;
        return colorTuple;
    }
    else if (color.startsWith('hwb')) {
        var colorTuple = colorString.get.hwb(color);
        if (!colorTuple)
            return;
        return __spreadArray$5(__spreadArray$5([], hwb2rgb(colorTuple[0], colorTuple[1], colorTuple[2])), [colorTuple[3]]);
    }
    return (_a = colorString.get(color)) === null || _a === void 0 ? void 0 : _a.value;
}
function toColor(colorStr) {
    var rgba = toRGBA(colorStr);
    var color = rgba ? rgba.slice(0, 3).join(', ') : colorStr;
    var opacity = rgba ? rgba[3].toString() : '1';
    return {
        color: color,
        opacity: opacity,
    };
}

function generateScreens(screens) {
    var variants = {};
    var breakpoints = Object.entries(screens).sort(function (_a, _b) {
        var sizeA = _a[1];
        var sizeB = _b[1];
        return sortWeight(sizeA) - sortWeight(sizeB);
    });
    breakpoints.forEach(function (_a, index) {
        var name = _a[0], size = _a[1];
        if (isString$1(size)) {
            var _b = breakpoints[index + 1] || [], nextSize = _b[1];
            variants[name] = styleForBreakpoint({ min: size });
            variants["<" + name] = styleForBreakpoint({ max: increaseWithUnit(size, -0.1) });
            variants["@" + name] = styleForBreakpoint(nextSize ? { min: size, max: increaseWithUnit(nextSize, -0.1) } : { min: size });
            variants["-" + name] = styleForBreakpoint({ max: size });
            variants["+" + name] = styleForBreakpoint(nextSize ? { min: size, max: nextSize } : { min: size });
        }
        else {
            variants[name] = styleForBreakpoint(size);
        }
    });
    return variants;
}
function styleForBreakpoint(rule) {
    var mediaConditions = 'raw' in rule ? rule.raw : [
        rule.min && "(min-width: " + rule.min + ")",
        rule.max && "(max-width: " + rule.max + ")",
    ].filter(function (condition) { return condition; }).join(' and ');
    return function () { return new Style$3().atRule("@media " + mediaConditions); };
}
// NOTE: Non-size breakpoints should come first, to avoid using them in the
// +breakpoint definition.
function sortWeight(breakpoint) {
    return isString$1(breakpoint) ? parseInt(breakpoint) : Number.NEGATIVE_INFINITY;
}

function generateThemes(darkMode) {
    if (!darkMode)
        return {};
    return {
        '@dark': function () { return new Style$3().atRule('@media (prefers-color-scheme: dark)'); },
        '@light': function () { return new Style$3().atRule('@media (prefers-color-scheme: light)'); },
        '.dark': function () { return new Style$3().parent('.dark'); },
        '.light': function () { return new Style$3().parent('.light'); },
        dark: function () { return darkMode === 'media' ? new Style$3().atRule('@media (prefers-color-scheme: dark)') : new Style$3().parent('.dark'); },
        light: function () { return darkMode === 'media' ? new Style$3().atRule('@media (prefers-color-scheme: light)') : new Style$3().parent('.light'); },
    };
}

/*
 * See MDN web docs for more information
 * https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes
 */
function generateStates(variantOrder) {
    var states = {
        // Interactive links/buttons
        hover: function () { return new Style$3().pseudoClass('hover'); },
        focus: function () { return new Style$3().pseudoClass('focus'); },
        active: function () { return new Style$3().pseudoClass('active'); },
        visited: function () { return new Style$3().pseudoClass('visited'); },
        link: function () { return new Style$3().pseudoClass('link'); },
        target: function () { return new Style$3().pseudoClass('target'); },
        'focus-visible': function () { return new Style$3().pseudoClass('focus-visible'); },
        'focus-within': function () { return new Style$3().pseudoClass('focus-within'); },
        // Form element states
        checked: function () { return new Style$3().pseudoClass('checked'); },
        'not-checked': function () { return new Style$3().pseudoClass('not(:checked)'); },
        default: function () { return new Style$3().pseudoClass('default'); },
        disabled: function () { return new Style$3().pseudoClass('disabled'); },
        enabled: function () { return new Style$3().pseudoClass('enabled'); },
        indeterminate: function () { return new Style$3().pseudoClass('indeterminate'); },
        invalid: function () { return new Style$3().pseudoClass('invalid'); },
        valid: function () { return new Style$3().pseudoClass('valid'); },
        optional: function () { return new Style$3().pseudoClass('optional'); },
        required: function () { return new Style$3().pseudoClass('required'); },
        'placeholder-shown': function () { return new Style$3().pseudoClass('placeholder-shown'); },
        'read-only': function () { return new Style$3().pseudoClass('read-only'); },
        'read-write': function () { return new Style$3().pseudoClass('read-write'); },
        // Child selectors
        'not-disabled': function () { return new Style$3().pseudoClass('not(:disabled)'); },
        'first-of-type': function () { return new Style$3().pseudoClass('first-of-type'); },
        'not-first-of-type': function () { return new Style$3().pseudoClass('not(:first-of-type)'); },
        'last-of-type': function () { return new Style$3().pseudoClass('last-of-type'); },
        'not-last-of-type': function () { return new Style$3().pseudoClass('not(:last-of-type)'); },
        first: function () { return new Style$3().pseudoClass('first-child'); },
        last: function () { return new Style$3().pseudoClass('last-child'); },
        'not-first': function () { return new Style$3().pseudoClass('not(:first-child)'); },
        'not-last': function () { return new Style$3().pseudoClass('not(:last-child)'); },
        'only-child': function () { return new Style$3().pseudoClass('only-child'); },
        'not-only-child': function () { return new Style$3().pseudoClass('not(:only-child)'); },
        'only-of-type': function () { return new Style$3().pseudoClass('only-of-type'); },
        'not-only-of-type': function () { return new Style$3().pseudoClass('not(:only-of-type)'); },
        even: function () { return new Style$3().pseudoClass('nth-child(even)'); },
        odd: function () { return new Style$3().pseudoClass('nth-child(odd)'); },
        'even-of-type': function () { return new Style$3().pseudoClass('nth-of-type(even)'); },
        'odd-of-type': function () { return new Style$3().pseudoClass('nth-of-type(odd)'); },
        root: function () { return new Style$3().pseudoClass('root'); },
        empty: function () { return new Style$3().pseudoClass('empty'); },
        // Pseudo elements
        before: function () { return new Style$3().pseudoElement('before'); },
        after: function () { return new Style$3().pseudoElement('after'); },
        'first-letter': function () { return new Style$3().pseudoElement('first-letter'); },
        'first-line': function () { return new Style$3().pseudoElement('first-line'); },
        'file-selector-button': function () { return new Style$3().pseudoElement('file-selector-button'); },
        selection: function () { return new Style$3().pseudoElement('selection'); },
        svg: function () { return new Style$3().child('svg'); },
        all: function () { return new Style$3().child('*'); },
        children: function () { return new Style$3().child('> *'); },
        siblings: function () { return new Style$3().child('~ *'); },
        sibling: function () { return new Style$3().child('+ *'); },
        // https://www.w3schools.com/CSS/css_pseudo_elements.asp
        // Directions
        ltr: function () { return new Style$3().wrapSelector(function (selector) { return "[dir='ltr'] " + selector + ", [dir='ltr']" + selector; }); },
        rtl: function () { return new Style$3().wrapSelector(function (selector) { return "[dir='rtl'] " + selector + ", [dir='rtl']" + selector; }); },
        // Group states
        // You'll need to add className="group" to an ancestor to make these work
        // https://github.com/ben-rogerson/twin.macro/blob/master/docs/group.md
        'group-hover': function () { return new Style$3().parent('.group:hover'); },
        'group-focus': function () { return new Style$3().parent('.group:focus'); },
        'group-active': function () { return new Style$3().parent('.group:active'); },
        'group-visited': function () { return new Style$3().parent('.group:visited'); },
        // Motion control
        // https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion
        'motion-safe': function () { return new Style$3().atRule('@media (prefers-reduced-motion: no-preference)'); },
        'motion-reduce': function () { return new Style$3().atRule('@media (prefers-reduced-motion: reduce)'); },
    };
    var orderedStates = {};
    variantOrder.forEach(function (v) {
        if (v in states) {
            orderedStates[v] = states[v];
        }
    });
    return orderedStates;
}

function resolveVariants(config) {
    var _a, _b, _c;
    return {
        screen: generateScreens(((_b = (_a = config.theme) === null || _a === void 0 ? void 0 : _a.screens) !== null && _b !== void 0 ? _b : {})),
        theme: generateThemes(config.darkMode),
        state: generateStates((_c = config.variantOrder) !== null && _c !== void 0 ? _c : []),
    };
}

// (Last Update: Aug 22 2020) [https://github.com/sindresorhus/modern-normalize/blob/master/modern-normalize.css]
var preflights = [
    /*! modern-normalize v1.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */
    /*
  Document
  ========
  */
    /**
  Use a better box model (opinionated).
  */
    // {
    //   keys: ['*'],
    //   global: true,
    //   selector: '*, *::before, *::after',
    //   properties: {
    //     '-webkit-box-sizing': 'border-box',
    //     'box-sizing': 'border-box'
    //   }
    // },
    // overwrite by windi
    /**
  Use a more readable tab size (opinionated).
  */
    {
        keys: ['root'],
        global: true,
        selector: ':root',
        properties: {
            '-moz-tab-size': function (theme) { return theme('tabSize.DEFAULT', '4'); },
            '-o-tab-size': function (theme) { return theme('tabSize.DEFAULT', '4'); },
            'tab-size': function (theme) { return theme('tabSize.DEFAULT', '4'); },
        },
    },
    /**
  1. Correct the line height in all browsers.
  2. Prevent adjustments of font size after orientation changes in iOS.
  */
    {
        keys: ['html'],
        global: true,
        selector: 'html',
        properties: {
            // 'line-height': '1.15', /* 1 */ overwrite by windi
            '-webkit-text-size-adjust': '100%', /* 2 */
        },
    },
    /*
  Sections
  ========
  */
    /**
  Remove the margin in all browsers.
  */
    {
        keys: ['body'],
        global: true,
        selector: 'body',
        properties: {
            'margin': '0', /* 1 */
        },
    },
    /**
  Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)
  */
    // {
    //   keys: ['body'],
    //   global: true,
    //   selector: 'body',
    //   properties: {
    //     'font-family': "system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji'"
    //   }
    // },
    // overide by windi
    /*
  Grouping content
  ================
  */
    /**
  1. Add the correct height in Firefox.
  2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
  */
    {
        keys: ['hr'],
        properties: {
            'height': '0',
            'color': 'inherit', /* 2 */
        },
    },
    /*
  Text-level semantics
  ====================
  */
    /**
  Add the correct text decoration in Chrome, Edge, and Safari.
  */
    {
        keys: ['title'],
        global: true,
        selector: 'abbr[title]',
        properties: {
            '-webkit-text-decoration': 'underline dotted',
            'text-decoration': 'underline dotted',
        },
    },
    /**
  Add the correct font weight in Edge and Safari.
  */
    {
        keys: ['b', 'strong'],
        properties: {
            'font-weight': 'bolder',
        },
    },
    /**
  1. Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)
  2. Correct the odd 'em' font sizing in all browsers.
  */
    {
        keys: ['code', 'kbd', 'samp', 'pre'],
        properties: {
            // 'font-family': "ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace", /* 1 */ overwrite by windi
            'font-size': '1em', /* 2 */
        },
    },
    /**
  Add the correct font size in all browsers.
  */
    {
        keys: ['small'],
        properties: {
            'font-size': '80%',
        },
    },
    /**
  Prevent 'sub' and 'sup' elements from affecting the line height in all browsers.
  */
    {
        keys: ['sub', 'sup'],
        properties: {
            'font-size': '75%',
            'line-height': '0',
            'position': 'relative',
            'vertical-align': 'baseline',
        },
    },
    {
        keys: ['sub'],
        properties: {
            'bottom': '-0.25em',
        },
    },
    {
        keys: ['sup'],
        properties: {
            'top': '-0.5em',
        },
    },
    /*
  Tabular data
  ============
  */
    /**
  1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
  2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
  */
    {
        keys: ['table'],
        properties: {
            'text-indent': '0',
            'border-color': 'inherit', /* 2 */
        },
    },
    /*
  Forms
  =====
  */
    /**
  1. Change the font styles in all browsers.
  2. Remove the margin in Firefox and Safari.
  */
    {
        keys: ['button', 'input', 'optgroup', 'select', 'textarea'],
        properties: {
            'font-family': 'inherit',
            'font-size': '100%',
            'line-height': '1.15',
            'margin': '0', /* 2 */
        },
    },
    /**
  Remove the inheritance of text transform in Edge and Firefox.
  1. Remove the inheritance of text transform in Firefox.
  */
    {
        keys: ['button', 'select'],
        properties: {
            'text-transform': 'none', /* 1 */
        },
    },
    /**
  Correct the inability to style clickable types in iOS and Safari.
  */
    {
        keys: ['button'],
        selector: 'button, [type=\'button\'], [type=\'reset\'], [type=\'submit\']',
        properties: {
            '-webkit-appearance': 'button', /* 1 */
        },
    },
    /**
  Remove the inner border and padding in Firefox.
  */
    {
        keys: ['inner'],
        global: true,
        selector: '::moz-focus-inner',
        properties: {
            'border-style': 'none',
            'padding': '0',
        },
    },
    /**
  Restore the focus styles unset by the previous rule.
  */
    {
        keys: ['focusring'],
        global: true,
        selector: ':-moz-focusring',
        properties: {
            'outline': '1px dotted ButtonText',
        },
    },
    /**
  Remove the additional ':invalid' styles in Firefox.
  See: https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737
  */
    {
        keys: ['invalid'],
        global: true,
        selector: ':-moz-ui-invalid',
        properties: {
            'box-shadow': 'none',
        },
    },
    /**
  Remove the padding so developers are not caught out when they zero out 'fieldset' elements in all browsers.
  */
    {
        keys: ['legend'],
        properties: {
            'padding': '0',
        },
    },
    /**
  Add the correct vertical alignment in Chrome and Firefox.
  */
    {
        keys: ['progress'],
        properties: {
            'vertical-align': 'baseline',
        },
    },
    /**
  Correct the cursor style of increment and decrement buttons in Safari.
  */
    {
        keys: ['spin'],
        global: true,
        selector: '::-webkit-inner-spin-button, ::-webkit-outer-spin-button',
        properties: {
            'height': 'auto',
        },
    },
    /**
  1. Correct the odd appearance in Chrome and Safari.
  2. Correct the outline style in Safari.
  */
    {
        keys: ['search'],
        global: true,
        selector: '[type=\'search\']',
        properties: {
            '-webkit-appearance': 'textfield',
            'outline-offset': '-2px', /* 2 */
        },
    },
    /**
  Remove the inner padding in Chrome and Safari on macOS.
  */
    {
        keys: ['search'],
        global: true,
        selector: '::-webkit-search-decoration',
        properties: {
            '-webkit-appearance': 'none',
        },
    },
    /**
  1. Correct the inability to style clickable types in iOS and Safari.
  2. Change font properties to 'inherit' in Safari.
  */
    {
        keys: ['file'],
        global: true,
        selector: '::-webkit-file-upload-button',
        properties: {
            '-webkit-appearance': 'button',
            'font': 'inherit',
        },
    },
    /*
  Interactive
  ===========
  */
    /*
  Add the correct display in Chrome and Safari.
  */
    {
        keys: ['summary'],
        properties: {
            'display': 'list-item',
        },
    },
    /**
   * Manually forked from SUIT CSS Base: https://github.com/suitcss/base
   * A thin layer on top of normalize.css that provides a starting point more
   * suitable for web applications.
   */
    /**
   * Removes the default spacing and border for appropriate elements.
   */
    {
        keys: ['blockquote', 'dl', 'dd', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'figure', 'p', 'pre'],
        properties: {
            'margin': '0',
        },
    },
    {
        keys: ['button'],
        properties: {
            'background-color': 'transparent',
            'background-image': 'none'
        },
    },
    /**
   * Work around a Firefox/IE bug where the transparent `button` background
   * results in a loss of the default `button` focus styles.
   */
    {
        keys: ['button'],
        selector: 'button:focus',
        properties: {
            'outline': [
                '1px dotted',
                '5px auto -webkit-focus-ring-color',
            ],
        },
    },
    {
        keys: ['fieldset'],
        properties: {
            'margin': '0',
            'padding': '0',
        },
    },
    {
        keys: ['ol', 'ul'],
        properties: {
            'list-style': 'none',
            'margin': '0',
            'padding': '0',
        },
    },
    /**
   * Tailwind custom reset styles
   */
    /**
   * 1. Use the user's configured `sans` font-family (with Tailwind's default
   *    sans-serif font stack as a fallback) as a sane default.
   * 2. Use Tailwind's default "normal" line-height so the user isn't forced
   *    to override it to ensure consistency even when using the default theme.
   */
    {
        keys: ['html'],
        global: true,
        selector: 'html',
        properties: {
            'font-family': function (theme) { return theme('fontFamily.sans', 'ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"'); },
            'line-height': '1.5', /* 2 */
        },
    },
    /**
   * Inherit font-family and line-height from `html` so users can set them as
   * a class directly on the `html` element.
   */
    {
        keys: ['body'],
        global: true,
        selector: 'body',
        properties: {
            'font-family': 'inherit',
            'line-height': 'inherit',
        },
    },
    /**
   * 1. Prevent padding and border from affecting element width.
   *
   *    We used to set this in the html element and inherit from
   *    the parent element for everything else. This caused issues
   *    in shadow-dom-enhanced elements like <details> where the content
   *    is wrapped by a div with box-sizing set to `content-box`.
   *
   *    https://github.com/mozdevs/cssremedy/issues/4
   *
   *
   * 2. Allow adding a border to an element by just adding a border-width.
   *
   *    By default, the way the browser specifies that an element should have no
   *    border is by setting it's border-style to `none` in the user-agent
   *    stylesheet.
   *
   *    In order to easily add borders to elements by just setting the `border-width`
   *    property, we change the default border-style for all elements to `solid`, and
   *    use border-width to hide them instead. This way our `border` utilities only
   *    need to set the `border-width` property instead of the entire `border`
   *    shorthand, making our border utilities much more straightforward to compose.
   *
   */
    {
        keys: ['*'],
        global: true,
        selector: '*, ::before, ::after',
        properties: {
            '-webkit-box-sizing': 'border-box',
            'box-sizing': 'border-box',
            'border-width': '0',
            'border-style': 'solid',
            'border-color': function (theme) { return theme('borderColor.DEFAULT', 'currentColor'); },
        },
    },
    /*
   * Ensure horizontal rules are visible by default
   */
    {
        keys: ['hr'],
        properties: {
            'border-top-width': '1px',
        },
    },
    /**
   * Undo the `border-style: none` reset that Normalize applies to images so that
   * our `border-{width}` utilities have the expected effect.
   *
   * The Normalize reset is unnecessary for us since we default the border-width
   * to 0 on all elements.
   *
   */
    {
        keys: ['img'],
        properties: {
            'border-style': 'solid',
        },
    },
    {
        keys: ['textarea'],
        properties: {
            'resize': 'vertical',
        },
    },
    // input::placeholder,
    // textarea::placeholder {
    //   color: theme('colors.gray.400', #a1a1aa);
    // }
    // support prefixer
    {
        keys: ['input'],
        selector: 'input::placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['input'],
        selector: 'input::webkit-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['input'],
        selector: 'input::-moz-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['input'],
        selector: 'input:-ms-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['input'],
        selector: 'input::-ms-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['textarea'],
        selector: 'textarea::placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['textarea'],
        selector: 'textarea::webkit-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['textarea'],
        selector: 'textarea::-moz-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['textarea'],
        selector: 'textarea:-ms-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['textarea'],
        selector: 'textarea::-ms-input-placeholder',
        properties: {
            'opacity': '1',
            'color': function (theme) { return theme('colors.gray.400', '#a1a1aa'); },
        },
    },
    {
        keys: ['button'],
        selector: 'button, [role="button"]',
        properties: {
            'cursor': 'pointer',
        },
    },
    {
        keys: ['table'],
        properties: {
            'border-collapse': 'collapse',
        },
    },
    {
        keys: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
        properties: {
            'font-size': 'inherit',
            'font-weight': 'inherit',
        },
    },
    /**
   * Reset links to optimize for opt-in styling instead of
   * opt-out.
   */
    {
        keys: ['a'],
        properties: {
            'color': 'inherit',
            'text-decoration': 'inherit',
        },
    },
    /**
   * Reset form element properties that are easy to forget to
   * style explicitly so you don't inadvertently introduce
   * styles that deviate from your design system. These styles
   * supplement a partial reset that is already applied by
   * normalize.css.
   */
    {
        keys: ['button', 'input', 'optgroup', 'select', 'textarea'],
        properties: {
            'padding': '0',
            'line-height': 'inherit',
            'color': 'inherit',
        },
    },
    /**
   * Use the configured 'mono' font family for elements that
   * are expected to be rendered with a monospace font, falling
   * back to the system monospace stack if there is no configured
   * 'mono' font family.
   */
    {
        keys: ['pre', 'code', 'kbd', 'samp'],
        properties: {
            'font-family': function (theme) { return theme('fontFamily.mono', 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace'); },
        },
    },
    /**
   * Make replaced elements `display: block` by default as that's
   * the behavior you want almost all of the time. Inspired by
   * CSS Remedy, with `svg` added as well.
   *
   * https://github.com/mozdevs/cssremedy/issues/14
   */
    {
        keys: ['img', 'svg', 'video', 'canvas', 'audio', 'iframe', 'embed', 'object'],
        properties: {
            'display': 'block',
            'vertical-align': 'middle',
        },
    },
    /**
   * Constrain images and videos to the parent width and preserve
   * their instrinsic aspect ratio.
   *
   * https://github.com/mozdevs/cssremedy/issues/14
   */
    {
        keys: ['img', 'video'],
        properties: {
            'max-width': '100%',
            'height': 'auto',
        },
    },
    // added by ringWidth
    // https://windicss.org/utilities/borders.html#ring-width
    {
        keys: ['*'],
        global: true,
        selector: '*',
        properties: {
            '--tw-ring-inset': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-ring-offset-width': function (theme) { return theme('ringOffsetWidth.DEFAULT', '0px'); },
            '--tw-ring-offset-color': function (theme) { return theme('ringOffsetColor.DEFAULT', '#fff'); },
            '--tw-ring-color': function (theme) { var _a; return "rgba(" + ((_a = hex2RGB$1(theme('ringColor.DEFAULT', '#93C5FD'))) === null || _a === void 0 ? void 0 : _a.join(', ')) + ", " + theme('ringOpacity.DEFAULT', '0.5') + ")"; },
            '--tw-ring-offset-shadow': '0 0 #0000',
            '--tw-ring-shadow': '0 0 #0000',
        },
    },
    // added by boxShadow
    // https://windicss.org/utilities/effects.html#box-shadow
    {
        keys: ['*'],
        global: true,
        selector: '*',
        properties: {
            '--tw-shadow': '0 0 #0000',
        },
    },
];

var fontVariants = {
    '--tw-ordinal': 'var(--tw-empty,/*!*/ /*!*/)',
    '--tw-slashed-zero': 'var(--tw-empty,/*!*/ /*!*/)',
    '--tw-numeric-figure': 'var(--tw-empty,/*!*/ /*!*/)',
    '--tw-numeric-spacing': 'var(--tw-empty,/*!*/ /*!*/)',
    '--tw-numeric-fraction': 'var(--tw-empty,/*!*/ /*!*/)',
    'font-variant-numeric': 'var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)',
};
var staticUtilities$1 = {
    // https://windicss.org/utilities/behaviors.html#box-decoration-break
    'decoration-slice': {
        'utility': {
            '-webkit-box-decoration-break': 'slice',
            'box-decoration-break': 'slice',
        },
        'meta': {
            'group': 'boxDecorationBreak',
            'order': 1,
        },
    },
    'decoration-clone': {
        'utility': {
            '-webkit-box-decoration-break': 'clone',
            'box-decoration-break': 'clone',
        },
        'meta': {
            'group': 'boxDecorationBreak',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/sizing.html#box-sizing
    'box-border': {
        'utility': {
            '-webkit-box-sizing': 'border-box',
            'box-sizing': 'border-box',
        },
        'meta': {
            'group': 'boxSizing',
            'order': 1,
        },
    },
    'box-content': {
        'utility': {
            '-webkit-box-sizing': 'content-box',
            'box-sizing': 'content-box',
        },
        'meta': {
            'group': 'boxSizing',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/display.html
    'block': {
        'utility': {
            'display': 'block',
        },
        'meta': {
            'group': 'display',
            'order': 1,
        },
    },
    'inline-block': {
        'utility': {
            'display': 'inline-block',
        },
        'meta': {
            'group': 'display',
            'order': 2,
        },
    },
    'inline': {
        'utility': {
            'display': 'inline',
        },
        'meta': {
            'group': 'display',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/flexbox.html
    'flex': {
        'utility': {
            'display': [
                '-webkit-box',
                '-ms-flexbox',
                '-webkit-flex',
                'flex',
            ],
        },
        'meta': {
            'group': 'display',
            'order': 4,
        },
    },
    'inline-flex': {
        'utility': {
            'display': [
                '-webkit-inline-box',
                '-ms-inline-flexbox',
                '-webkit-inline-flex',
                'inline-flex',
            ],
        },
        'meta': {
            'group': 'display',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/tables.html
    'table': {
        'utility': {
            'display': 'table',
        },
        'meta': {
            'group': 'display',
            'order': 6,
        },
    },
    'inline-table': {
        'utility': {
            'display': 'inline-table',
        },
        'meta': {
            'group': 'display',
            'order': 7,
        },
    },
    'table-caption': {
        'utility': {
            'display': 'table-caption',
        },
        'meta': {
            'group': 'display',
            'order': 8,
        },
    },
    'table-cell': {
        'utility': {
            'display': 'table-cell',
        },
        'meta': {
            'group': 'display',
            'order': 9,
        },
    },
    'table-column': {
        'utility': {
            'display': 'table-column',
        },
        'meta': {
            'group': 'display',
            'order': 10,
        },
    },
    'table-column-group': {
        'utility': {
            'display': 'table-column-group',
        },
        'meta': {
            'group': 'display',
            'order': 11,
        },
    },
    'table-footer-group': {
        'utility': {
            'display': 'table-footer-group',
        },
        'meta': {
            'group': 'display',
            'order': 12,
        },
    },
    'table-header-group': {
        'utility': {
            'display': 'table-header-group',
        },
        'meta': {
            'group': 'display',
            'order': 13,
        },
    },
    'table-row-group': {
        'utility': {
            'display': 'table-row-group',
        },
        'meta': {
            'group': 'display',
            'order': 14,
        },
    },
    'table-row': {
        'utility': {
            'display': 'table-row',
        },
        'meta': {
            'group': 'display',
            'order': 15,
        },
    },
    'flow-root': {
        'utility': {
            'display': 'flow-root',
        },
        'meta': {
            'group': 'display',
            'order': 16,
        },
    },
    // https://windicss.org/utilities/grid.html
    'grid': {
        'utility': {
            'display': [
                '-ms-grid',
                'grid',
            ],
        },
        'meta': {
            'group': 'display',
            'order': 17,
        },
    },
    'inline-grid': {
        'utility': {
            'display': [
                '-ms-inline-grid',
                'inline-grid',
            ],
        },
        'meta': {
            'group': 'display',
            'order': 18,
        },
    },
    'contents': {
        'utility': {
            'display': 'contents',
        },
        'meta': {
            'group': 'display',
            'order': 19,
        },
    },
    'list-item': {
        'utility': {
            'display': 'list-item',
        },
        'meta': {
            'group': 'display',
            'order': 20,
        },
    },
    'hidden': {
        'utility': {
            'display': 'none',
        },
        'meta': {
            'group': 'display',
            'order': 21,
        },
    },
    // https://windicss.org/utilities/positioning.html#floats
    'float-right': {
        'utility': {
            'float': 'right',
        },
        'meta': {
            'group': 'float',
            'order': 1,
        },
    },
    'float-left': {
        'utility': {
            'float': 'left',
        },
        'meta': {
            'group': 'float',
            'order': 2,
        },
    },
    'float-none': {
        'utility': {
            'float': 'none',
        },
        'meta': {
            'group': 'float',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/positioning.html#clear
    'clear-left': {
        'utility': {
            'clear': 'left',
        },
        'meta': {
            'group': 'clear',
            'order': 1,
        },
    },
    'clear-right': {
        'utility': {
            'clear': 'right',
        },
        'meta': {
            'group': 'clear',
            'order': 2,
        },
    },
    'clear-both': {
        'utility': {
            'clear': 'both',
        },
        'meta': {
            'group': 'clear',
            'order': 3,
        },
    },
    'clear-none': {
        'utility': {
            'clear': 'none',
        },
        'meta': {
            'group': 'clear',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/positioning.html#isolation
    'isolate': {
        'utility': {
            'isolation': 'isolate',
        },
        'meta': {
            'group': 'isolation',
            'order': 1,
        },
    },
    'isolation-auto': {
        'utility': {
            'isolation': 'auto',
        },
        'meta': {
            'group': 'isolation',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/positioning.html#object-fit
    'object-contain': {
        'utility': {
            '-o-object-fit': 'contain',
            'object-fit': 'contain',
        },
        'meta': {
            'group': 'objectFit',
            'order': 1,
        },
    },
    'object-cover': {
        'utility': {
            '-o-object-fit': 'cover',
            'object-fit': 'cover',
        },
        'meta': {
            'group': 'objectFit',
            'order': 2,
        },
    },
    'object-fill': {
        'utility': {
            '-o-object-fit': 'fill',
            'object-fit': 'fill',
        },
        'meta': {
            'group': 'objectFit',
            'order': 3,
        },
    },
    'object-none': {
        'utility': {
            '-o-object-fit': 'none',
            'object-fit': 'none',
        },
        'meta': {
            'group': 'objectFit',
            'order': 4,
        },
    },
    'object-scale-down': {
        'utility': {
            '-o-object-fit': 'scale-down',
            'object-fit': 'scale-down',
        },
        'meta': {
            'group': 'objectFit',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/behaviors.html#overflow
    'overflow-auto': {
        'utility': {
            'overflow': 'auto',
        },
        'meta': {
            'group': 'overflow',
            'order': 1,
        },
    },
    'overflow-hidden': {
        'utility': {
            'overflow': 'hidden',
        },
        'meta': {
            'group': 'overflow',
            'order': 2,
        },
    },
    'overflow-visible': {
        'utility': {
            'overflow': 'visible',
        },
        'meta': {
            'group': 'overflow',
            'order': 3,
        },
    },
    'overflow-scroll': {
        'utility': {
            'overflow': 'scroll',
        },
        'meta': {
            'group': 'overflow',
            'order': 4,
        },
    },
    'overflow-x-auto': {
        'utility': {
            'overflow-x': 'auto',
        },
        'meta': {
            'group': 'overflow',
            'order': 5,
        },
    },
    'overflow-y-auto': {
        'utility': {
            'overflow-y': 'auto',
        },
        'meta': {
            'group': 'overflow',
            'order': 6,
        },
    },
    'overflow-x-hidden': {
        'utility': {
            'overflow-x': 'hidden',
        },
        'meta': {
            'group': 'overflow',
            'order': 7,
        },
    },
    'overflow-y-hidden': {
        'utility': {
            'overflow-y': 'hidden',
        },
        'meta': {
            'group': 'overflow',
            'order': 8,
        },
    },
    'overflow-x-visible': {
        'utility': {
            'overflow-x': 'visible',
        },
        'meta': {
            'group': 'overflow',
            'order': 9,
        },
    },
    'overflow-y-visible': {
        'utility': {
            'overflow-y': 'visible',
        },
        'meta': {
            'group': 'overflow',
            'order': 10,
        },
    },
    'overflow-x-scroll': {
        'utility': {
            'overflow-x': 'scroll',
        },
        'meta': {
            'group': 'overflow',
            'order': 11,
        },
    },
    'overflow-y-scroll': {
        'utility': {
            'overflow-y': 'scroll',
        },
        'meta': {
            'group': 'overflow',
            'order': 12,
        },
    },
    // https://windicss.org/utilities/behaviors.html#overscroll-behavior
    'overscroll-auto': {
        'utility': {
            'overscroll-behavior': 'auto',
            '-ms-scroll-chaining': 'chained',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 1,
        },
    },
    'overscroll-contain': {
        'utility': {
            'overscroll-behavior': 'contain',
            '-ms-scroll-chaining': 'none',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 2,
        },
    },
    'overscroll-none': {
        'utility': {
            'overscroll-behavior': 'none',
            '-ms-scroll-chaining': 'none',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 3,
        },
    },
    'overscroll-y-auto': {
        'utility': {
            'overscroll-behavior-y': 'auto',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 4,
        },
    },
    'overscroll-y-contain': {
        'utility': {
            'overscroll-behavior-y': 'contain',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 5,
        },
    },
    'overscroll-y-none': {
        'utility': {
            'overscroll-behavior-y': 'none',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 6,
        },
    },
    'overscroll-x-auto': {
        'utility': {
            'overscroll-behavior-x': 'auto',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 7,
        },
    },
    'overscroll-x-contain': {
        'utility': {
            'overscroll-behavior-x': 'contain',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 8,
        },
    },
    'overscroll-x-none': {
        'utility': {
            'overscroll-behavior-x': 'none',
        },
        'meta': {
            'group': 'overscrollBehavior',
            'order': 9,
        },
    },
    // https://windicss.org/utilities/positioning.html#position
    'static': {
        'utility': {
            'position': 'static',
        },
        'meta': {
            'group': 'position',
            'order': 1,
        },
    },
    'fixed': {
        'utility': {
            'position': 'fixed',
        },
        'meta': {
            'group': 'position',
            'order': 2,
        },
    },
    'absolute': {
        'utility': {
            'position': 'absolute',
        },
        'meta': {
            'group': 'position',
            'order': 3,
        },
    },
    'relative': {
        'utility': {
            'position': 'relative',
        },
        'meta': {
            'group': 'position',
            'order': 4,
        },
    },
    'sticky': {
        'utility': {
            'position': [
                'sticky',
                '-webkit-sticky',
            ],
        },
        'meta': {
            'group': 'position',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/display.html#visibility
    'visible': {
        'utility': {
            'visibility': 'visible',
        },
        'meta': {
            'group': 'visibility',
            'order': 1,
        },
    },
    'invisible': {
        'utility': {
            'visibility': 'hidden',
        },
        'meta': {
            'group': 'visibility',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/display.html#backface-visibility
    'backface-visible': {
        'utility': {
            '-webkit-backface-visibility': 'visible',
            'backface-visibility': 'visible',
        },
        'meta': {
            'group': 'backfaceVisibility',
            'order': 1,
        },
    },
    'backface-hidden': {
        'utility': {
            '-webkit-backface-visibility': 'hidden',
            'backface-visibility': 'hidden',
        },
        'meta': {
            'group': 'backfaceVisibility',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/flexbox.html#flex-direction
    'flex-row': {
        'utility': {
            '-webkit-box-orient': 'horizontal',
            '-webkit-box-direction': 'normal',
            '-ms-flex-direction': 'row',
            '-webkit-flex-direction': 'row',
            'flex-direction': 'row',
        },
        'meta': {
            'group': 'flexDirection',
            'order': 1,
        },
    },
    'flex-row-reverse': {
        'utility': {
            '-webkit-box-orient': 'horizontal',
            '-webkit-box-direction': 'reverse',
            '-ms-flex-direction': 'row-reverse',
            '-webkit-flex-direction': 'row-reverse',
            'flex-direction': 'row-reverse',
        },
        'meta': {
            'group': 'flexDirection',
            'order': 2,
        },
    },
    'flex-col': {
        'utility': {
            '-webkit-box-orient': 'vertical',
            '-webkit-box-direction': 'normal',
            '-ms-flex-direction': 'column',
            '-webkit-flex-direction': 'column',
            'flex-direction': 'column',
        },
        'meta': {
            'group': 'flexDirection',
            'order': 3,
        },
    },
    'flex-col-reverse': {
        'utility': {
            '-webkit-box-orient': 'vertical',
            '-webkit-box-direction': 'reverse',
            '-ms-flex-direction': 'column-reverse',
            '-webkit-flex-direction': 'column-reverse',
            'flex-direction': 'column-reverse',
        },
        'meta': {
            'group': 'flexDirection',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/flexbox.html#flex-wrap
    'flex-wrap': {
        'utility': {
            '-ms-flex-wrap': 'wrap',
            '-webkit-flex-wrap': 'wrap',
            'flex-wrap': 'wrap',
        },
        'meta': {
            'group': 'flexWrap',
            'order': 1,
        },
    },
    'flex-wrap-reverse': {
        'utility': {
            '-ms-flex-wrap': 'wrap-reverse',
            '-webkit-flex-wrap': 'wrap-reverse',
            'flex-wrap': 'wrap-reverse',
        },
        'meta': {
            'group': 'flexWrap',
            'order': 2,
        },
    },
    'flex-nowrap': {
        'utility': {
            '-ms-flex-wrap': 'nowrap',
            '-webkit-flex-wrap': 'nowrap',
            'flex-wrap': 'nowrap',
        },
        'meta': {
            'group': 'flexWrap',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/grid.html#grid-column-span
    'col-auto': {
        'utility': {
            'grid-column': 'auto',
        },
        'meta': {
            'group': 'gridColumn',
            'order': 1,
        },
    },
    // https://windicss.org/utilities/grid.html#grid-row-span
    'row-auto': {
        'utility': {
            'grid-row': 'auto',
        },
        'meta': {
            'group': 'gridRow',
            'order': 1,
        },
    },
    // https://windicss.org/utilities/grid.html#grid-auto-flow
    'grid-flow-row': {
        'utility': {
            'grid-auto-flow': 'row',
        },
        'meta': {
            'group': 'gridAutoFlow',
            'order': 1,
        },
    },
    'grid-flow-col': {
        'utility': {
            'grid-auto-flow': 'column',
        },
        'meta': {
            'group': 'gridAutoFlow',
            'order': 2,
        },
    },
    'grid-flow-row-dense': {
        'utility': {
            'grid-auto-flow': 'row dense',
        },
        'meta': {
            'group': 'gridAutoFlow',
            'order': 3,
        },
    },
    'grid-flow-col-dense': {
        'utility': {
            'grid-auto-flow': 'column dense',
        },
        'meta': {
            'group': 'gridAutoFlow',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/positioning.html#justify-content
    'justify-start': {
        'utility': {
            '-webkit-box-pack': 'start',
            '-ms-flex-pack': 'start',
            '-webkit-justify-content': 'flex-start',
            'justify-content': 'flex-start',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 1,
        },
    },
    'justify-end': {
        'utility': {
            '-webkit-box-pack': 'end',
            '-ms-flex-pack': 'end',
            '-webkit-justify-content': 'flex-end',
            'justify-content': 'flex-end',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 2,
        },
    },
    'justify-center': {
        'utility': {
            '-webkit-box-pack': 'center',
            '-ms-flex-pack': 'center',
            '-webkit-justify-content': 'center',
            'justify-content': 'center',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 3,
        },
    },
    'justify-between': {
        'utility': {
            '-webkit-box-pack': 'justify',
            '-ms-flex-pack': 'justify',
            '-webkit-justify-content': 'space-between',
            'justify-content': 'space-between',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 4,
        },
    },
    'justify-around': {
        'utility': {
            '-ms-flex-pack': 'distribute',
            '-webkit-justify-content': 'space-around',
            'justify-content': 'space-around',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 5,
        },
    },
    'justify-evenly': {
        'utility': {
            '-webkit-box-pack': 'space-evenly',
            '-ms-flex-pack': 'space-evenly',
            '-webkit-justify-content': 'space-evenly',
            'justify-content': 'space-evenly',
        },
        'meta': {
            'group': 'justifyContent',
            'order': 6,
        },
    },
    // https://windicss.org/utilities/positioning.html#justify-items
    'justify-items-auto': {
        'utility': {
            'justify-items': 'auto',
        },
        'meta': {
            'group': 'justifyItems',
            'order': 1,
        },
    },
    'justify-items-start': {
        'utility': {
            'justify-items': 'start',
        },
        'meta': {
            'group': 'justifyItems',
            'order': 2,
        },
    },
    'justify-items-end': {
        'utility': {
            'justify-items': 'end',
        },
        'meta': {
            'group': 'justifyItems',
            'order': 3,
        },
    },
    'justify-items-center': {
        'utility': {
            'justify-items': 'center',
        },
        'meta': {
            'group': 'justifyItems',
            'order': 4,
        },
    },
    'justify-items-stretch': {
        'utility': {
            'justify-items': 'stretch',
        },
        'meta': {
            'group': 'justifyItems',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/positioning.html#justify-self
    'justify-self-auto': {
        'utility': {
            '-ms-grid-column-align': 'auto',
            'justify-self': 'auto',
        },
        'meta': {
            'group': 'justifySelf',
            'order': 1,
        },
    },
    'justify-self-start': {
        'utility': {
            '-ms-grid-column-align': 'start',
            'justify-self': 'start',
        },
        'meta': {
            'group': 'justifySelf',
            'order': 2,
        },
    },
    'justify-self-end': {
        'utility': {
            '-ms-grid-column-align': 'end',
            'justify-self': 'end',
        },
        'meta': {
            'group': 'justifySelf',
            'order': 3,
        },
    },
    'justify-self-center': {
        'utility': {
            '-ms-grid-column-align': 'center',
            'justify-self': 'center',
        },
        'meta': {
            'group': 'justifySelf',
            'order': 4,
        },
    },
    'justify-self-stretch': {
        'utility': {
            '-ms-grid-column-align': 'stretch',
            'justify-self': 'stretch',
        },
        'meta': {
            'group': 'justifySelf',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/positioning.html#align-content
    'content-center': {
        'utility': {
            '-ms-flex-line-pack': 'center',
            '-webkit-align-content': 'center',
            'align-content': 'center',
        },
        'meta': {
            'group': 'alignContent',
            'order': 1,
        },
    },
    'content-start': {
        'utility': {
            '-ms-flex-line-pack': 'start',
            '-webkit-align-content': 'flex-start',
            'align-content': 'flex-start',
        },
        'meta': {
            'group': 'alignContent',
            'order': 2,
        },
    },
    'content-end': {
        'utility': {
            '-ms-flex-line-pack': 'end',
            '-webkit-align-content': 'flex-end',
            'align-content': 'flex-end',
        },
        'meta': {
            'group': 'alignContent',
            'order': 3,
        },
    },
    'content-between': {
        'utility': {
            '-ms-flex-line-pack': 'justify',
            '-webkit-align-content': 'space-between',
            'align-content': 'space-between',
        },
        'meta': {
            'group': 'alignContent',
            'order': 4,
        },
    },
    'content-around': {
        'utility': {
            '-ms-flex-line-pack': 'distribute',
            '-webkit-align-content': 'space-around',
            'align-content': 'space-around',
        },
        'meta': {
            'group': 'alignContent',
            'order': 5,
        },
    },
    'content-evenly': {
        'utility': {
            '-ms-flex-line-pack': 'space-evenly',
            '-webkit-align-content': 'space-evenly',
            'align-content': 'space-evenly',
        },
        'meta': {
            'group': 'alignContent',
            'order': 6,
        },
    },
    // https://windicss.org/utilities/positioning.html#align-items
    'items-start': {
        'utility': {
            '-webkit-box-align': 'start',
            '-ms-flex-align': 'start',
            '-webkit-align-items': 'flex-start',
            'align-items': 'flex-start',
        },
        'meta': {
            'group': 'alignItems',
            'order': 1,
        },
    },
    'items-end': {
        'utility': {
            '-webkit-box-align': 'end',
            '-ms-flex-align': 'end',
            '-webkit-align-items': 'flex-end',
            'align-items': 'flex-end',
        },
        'meta': {
            'group': 'alignItems',
            'order': 2,
        },
    },
    'items-center': {
        'utility': {
            '-webkit-box-align': 'center',
            '-ms-flex-align': 'center',
            '-webkit-align-items': 'center',
            'align-items': 'center',
        },
        'meta': {
            'group': 'alignItems',
            'order': 3,
        },
    },
    'items-baseline': {
        'utility': {
            '-webkit-box-align': 'baseline',
            '-ms-flex-align': 'baseline',
            '-webkit-align-items': 'baseline',
            'align-items': 'baseline',
        },
        'meta': {
            'group': 'alignItems',
            'order': 4,
        },
    },
    'items-stretch': {
        'utility': {
            '-webkit-box-align': 'stretch',
            '-ms-flex-align': 'stretch',
            '-webkit-align-items': 'stretch',
            'align-items': 'stretch',
        },
        'meta': {
            'group': 'alignItems',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/positioning.html#align-self
    'self-auto': {
        'utility': {
            '-ms-flex-item-align': 'auto',
            '-ms-grid-row-align': 'auto',
            '-webkit-align-self': 'auto',
            'align-self': 'auto',
        },
        'meta': {
            'group': 'alignSelf',
            'order': 1,
        },
    },
    'self-start': {
        'utility': {
            '-ms-flex-item-align': 'start',
            '-webkit-align-self': 'flex-start',
            'align-self': 'flex-start',
        },
        'meta': {
            'group': 'alignSelf',
            'order': 2,
        },
    },
    'self-end': {
        'utility': {
            '-ms-flex-item-align': 'end',
            '-webkit-align-self': 'flex-end',
            'align-self': 'flex-end',
        },
        'meta': {
            'group': 'alignSelf',
            'order': 3,
        },
    },
    'self-center': {
        'utility': {
            '-ms-flex-item-align': 'center',
            '-ms-grid-row-align': 'center',
            '-webkit-align-self': 'center',
            'align-self': 'center',
        },
        'meta': {
            'group': 'alignSelf',
            'order': 4,
        },
    },
    'self-stretch': {
        'utility': {
            '-ms-flex-item-align': 'stretch',
            '-ms-grid-row-align': 'stretch',
            '-webkit-align-self': 'stretch',
            'align-self': 'stretch',
        },
        'meta': {
            'group': 'alignSelf',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/positioning.html#place-content
    'place-content-center': {
        'utility': {
            'place-content': 'center',
        },
        'meta': {
            'group': 'placeContent',
            'order': 1,
        },
    },
    'place-content-start': {
        'utility': {
            'place-content': 'start',
        },
        'meta': {
            'group': 'placeContent',
            'order': 2,
        },
    },
    'place-content-end': {
        'utility': {
            'place-content': 'end',
        },
        'meta': {
            'group': 'placeContent',
            'order': 3,
        },
    },
    'place-content-between': {
        'utility': {
            'place-content': 'space-between',
        },
        'meta': {
            'group': 'placeContent',
            'order': 4,
        },
    },
    'place-content-around': {
        'utility': {
            'place-content': 'space-around',
        },
        'meta': {
            'group': 'placeContent',
            'order': 5,
        },
    },
    'place-content-evenly': {
        'utility': {
            'place-content': 'space-evenly',
        },
        'meta': {
            'group': 'placeContent',
            'order': 6,
        },
    },
    'place-content-stretch': {
        'utility': {
            'place-content': 'stretch',
        },
        'meta': {
            'group': 'placeContent',
            'order': 7,
        },
    },
    // https://windicss.org/utilities/positioning.html#place-items
    'place-items-auto': {
        'utility': {
            'place-items': 'auto',
        },
        'meta': {
            'group': 'placeItems',
            'order': 1,
        },
    },
    'place-items-start': {
        'utility': {
            'place-items': 'start',
        },
        'meta': {
            'group': 'placeItems',
            'order': 2,
        },
    },
    'place-items-end': {
        'utility': {
            'place-items': 'end',
        },
        'meta': {
            'group': 'placeItems',
            'order': 3,
        },
    },
    'place-items-center': {
        'utility': {
            'place-items': 'center',
        },
        'meta': {
            'group': 'placeItems',
            'order': 4,
        },
    },
    'place-items-stretch': {
        'utility': {
            'place-items': 'stretch',
        },
        'meta': {
            'group': 'placeItems',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/positioning.html#place-self
    'place-self-auto': {
        'utility': {
            '-ms-grid-row-align': 'auto',
            '-ms-grid-column-align': 'auto',
            'place-self': 'auto',
        },
        'meta': {
            'group': 'placeSelf',
            'order': 1,
        },
    },
    'place-self-start': {
        'utility': {
            '-ms-grid-row-align': 'start',
            '-ms-grid-column-align': 'start',
            'place-self': 'start',
        },
        'meta': {
            'group': 'placeSelf',
            'order': 2,
        },
    },
    'place-self-end': {
        'utility': {
            '-ms-grid-row-align': 'end',
            '-ms-grid-column-align': 'end',
            'place-self': 'end',
        },
        'meta': {
            'group': 'placeSelf',
            'order': 3,
        },
    },
    'place-self-center': {
        'utility': {
            '-ms-grid-row-align': 'center',
            '-ms-grid-column-align': 'center',
            'place-self': 'center',
        },
        'meta': {
            'group': 'placeSelf',
            'order': 4,
        },
    },
    'place-self-stretch': {
        'utility': {
            '-ms-grid-row-align': 'stretch',
            '-ms-grid-column-align': 'stretch',
            'place-self': 'stretch',
        },
        'meta': {
            'group': 'placeSelf',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/typography.html#font-smoothing
    'antialiased': {
        'utility': {
            '-webkit-font-smoothing': 'antialiased',
            '-moz-osx-font-smoothing': 'grayscale',
        },
        'meta': {
            'group': 'fontSmoothing',
            'order': 1,
        },
    },
    'subpixel-antialiased': {
        'utility': {
            '-webkit-font-smoothing': 'auto',
            '-moz-osx-font-smoothing': 'auto',
        },
        'meta': {
            'group': 'fontSmoothing',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/typography.html#font-style
    'italic': {
        'utility': {
            'font-style': 'italic',
        },
        'meta': {
            'group': 'fontStyle',
            'order': 1,
        },
    },
    'not-italic': {
        'utility': {
            'font-style': 'normal',
        },
        'meta': {
            'group': 'fontStyle',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/typography.html#font-variant-numeric
    'normal-nums': {
        'utility': {
            'font-variant-numeric': 'normal',
        },
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 1,
        },
    },
    'ordinal': {
        'utility': __assign$3(__assign$3({}, fontVariants), { '--tw-ordinal': 'ordinal' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 2,
        },
    },
    'slashed-zero': {
        'utility': __assign$3(__assign$3({}, fontVariants), { '--tw-slashed-zero': 'slashed-zero' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 3,
        },
    },
    'lining-nums': {
        'utility': __assign$3(__assign$3({}, fontVariants), { '--tw-numeric-figure': 'lining-nums' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 4,
        },
    },
    'oldstyle-nums': {
        'utility': __assign$3(__assign$3({}, fontVariants), { '--tw-numeric-figure': 'oldstyle-nums' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 5,
        },
    },
    'proportional-nums': {
        'utility': __assign$3(__assign$3({}, fontVariants), { '--tw-numeric-spacing': 'proportional-nums' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 6,
        },
    },
    'tabular-nums': {
        'utility': __assign$3(__assign$3({}, fontVariants), { '--tw-numeric-spacing': 'tabular-nums' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 7,
        },
    },
    'diagonal-fractions': {
        'utility': __assign$3(__assign$3({}, fontVariants), { '--tw-numeric-fraction': 'diagonal-fractions' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 8,
        },
    },
    'stacked-fractions': {
        'utility': __assign$3(__assign$3({}, fontVariants), { '--tw-numeric-fraction': 'stacked-fractions' }),
        'meta': {
            'group': 'fontVariantNumeric',
            'order': 9,
        },
    },
    // https://windicss.org/utilities/behaviors.html#list-style-position
    'list-inside': {
        'utility': {
            'list-style-position': 'inside',
        },
        'meta': {
            'group': 'listStylePosition',
            'order': 1,
        },
    },
    'list-outside': {
        'utility': {
            'list-style-position': 'outside',
        },
        'meta': {
            'group': 'listStylePosition',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/typography.html#text-alignment
    'text-left': {
        'utility': {
            'text-align': 'left',
        },
        'meta': {
            'group': 'textAlign',
            'order': 1,
        },
    },
    'text-center': {
        'utility': {
            'text-align': 'center',
        },
        'meta': {
            'group': 'textAlign',
            'order': 2,
        },
    },
    'text-right': {
        'utility': {
            'text-align': 'right',
        },
        'meta': {
            'group': 'textAlign',
            'order': 3,
        },
    },
    'text-justify': {
        'utility': {
            'text-align': 'justify',
        },
        'meta': {
            'group': 'textAlign',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/typography.html#text-decoration
    'underline': {
        'utility': {
            '-webkit-text-decoration-line': 'underline',
            'text-decoration-line': 'underline',
        },
        'meta': {
            'group': 'textDecoration',
            'order': 1,
        },
    },
    'line-through': {
        'utility': {
            '-webkit-text-decoration-line': 'line-through',
            'text-decoration-line': 'line-through',
        },
        'meta': {
            'group': 'textDecoration',
            'order': 2,
        },
    },
    'no-underline': {
        'utility': {
            'text-decoration': 'none',
        },
        'meta': {
            'group': 'textDecoration',
            'order': 3,
        },
    },
    // http://localhost:3001/utilities/typography.html#text-decoration-style
    'underline-solid': {
        'utility': {
            '-webkit-text-decoration-style': 'solid',
            'text-decoration-style': 'solid',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 1,
        },
    },
    'underline-double': {
        'utility': {
            '-webkit-text-decoration-style': 'double',
            'text-decoration-style': 'double',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 2,
        },
    },
    'underline-dotted': {
        'utility': {
            '-webkit-text-decoration-style': 'dotted',
            'text-decoration-style': 'dotted',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 3,
        },
    },
    'underline-dashed': {
        'utility': {
            '-webkit-text-decoration-style': 'dashed',
            'text-decoration-style': 'dashed',
        },
        'meta': {
            'group': 'textDecorationStyle',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/typography.html#text-transform
    'uppercase': {
        'utility': {
            'text-transform': 'uppercase',
        },
        'meta': {
            'group': 'textTransform',
            'order': 1,
        },
    },
    'lowercase': {
        'utility': {
            'text-transform': 'lowercase',
        },
        'meta': {
            'group': 'textTransform',
            'order': 2,
        },
    },
    'capitalize': {
        'utility': {
            'text-transform': 'capitalize',
        },
        'meta': {
            'group': 'textTransform',
            'order': 3,
        },
    },
    'normal-case': {
        'utility': {
            'text-transform': 'none',
        },
        'meta': {
            'group': 'textTransform',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/typography.html#text-overflow
    'truncate': {
        'utility': {
            'overflow': 'hidden',
            '-o-text-overflow': 'ellipsis',
            'text-overflow': 'ellipsis',
            'white-space': 'nowrap',
        },
        'meta': {
            'group': 'textOverflow',
            'order': 1,
        },
    },
    'overflow-ellipsis': {
        'utility': {
            '-o-text-overflow': 'ellipsis',
            'text-overflow': 'ellipsis',
        },
        'meta': {
            'group': 'textOverflow',
            'order': 2,
        },
    },
    'overflow-clip': {
        'utility': {
            '-o-text-overflow': 'clip',
            'text-overflow': 'clip',
        },
        'meta': {
            'group': 'textOverflow',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/typography.html#vertical-alignment
    'align-baseline': {
        'utility': {
            'vertical-align': 'baseline',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 1,
        },
    },
    'align-top': {
        'utility': {
            'vertical-align': 'top',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 2,
        },
    },
    'align-middle': {
        'utility': {
            'vertical-align': 'middle',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 3,
        },
    },
    'align-bottom': {
        'utility': {
            'vertical-align': 'bottom',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 4,
        },
    },
    'align-text-top': {
        'utility': {
            'vertical-align': 'text-top',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 5,
        },
    },
    'align-text-bottom': {
        'utility': {
            'vertical-align': 'text-bottom',
        },
        'meta': {
            'group': 'verticalAlign',
            'order': 6,
        },
    },
    // https://windicss.org/utilities/typography.html#whitespace
    'whitespace-normal': {
        'utility': {
            'white-space': 'normal',
        },
        'meta': {
            'group': 'whitespace',
            'order': 1,
        },
    },
    'whitespace-nowrap': {
        'utility': {
            'white-space': 'nowrap',
        },
        'meta': {
            'group': 'whitespace',
            'order': 2,
        },
    },
    'whitespace-pre': {
        'utility': {
            'white-space': 'pre',
        },
        'meta': {
            'group': 'whitespace',
            'order': 3,
        },
    },
    'whitespace-pre-line': {
        'utility': {
            'white-space': 'pre-line',
        },
        'meta': {
            'group': 'whitespace',
            'order': 4,
        },
    },
    'whitespace-pre-wrap': {
        'utility': {
            'white-space': 'pre-wrap',
        },
        'meta': {
            'group': 'whitespace',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/typography.html#word-break
    'break-normal': {
        'utility': {
            'word-break': 'normal',
            'overflow-wrap': 'normal',
        },
        'meta': {
            'group': 'wordBreak',
            'order': 1,
        },
    },
    'break-words': {
        'utility': {
            'overflow-wrap': 'break-word',
        },
        'meta': {
            'group': 'wordBreak',
            'order': 2,
        },
    },
    'break-all': {
        'utility': {
            'word-break': 'break-all',
        },
        'meta': {
            'group': 'wordBreak',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/typography.html#writing-mode
    'write-normal': {
        'utility': {
            '-webkit-writing-mode': 'horizontal-tb',
            '-ms-writing-mode': 'lr-tb',
            'writing-mode': 'horizontal-tb',
        },
        'meta': {
            'group': 'writingMode',
            'order': 1,
        },
    },
    'write-vertical-right': {
        'utility': {
            '-webkit-writing-mode': 'vertical-rl',
            '-ms-writing-mode': 'tb-rl',
            'writing-mode': 'vertical-rl',
        },
        'meta': {
            'group': 'writingMode',
            'order': 2,
        },
    },
    'write-vertical-left': {
        'utility': {
            '-webkit-writing-mode': 'vertical-lr',
            '-ms-writing-mode': 'tb-lr',
            'writing-mode': 'vertical-lr',
        },
        'meta': {
            'group': 'writingMode',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/typography.html#writing-orientation
    'write-orient-mixed': {
        'utility': {
            '-webkit-text-orientation': 'mixed',
            'text-orientation': 'mixed',
        },
        'meta': {
            'group': 'writingMode',
            'order': 4,
        },
    },
    'write-orient-upright': {
        'utility': {
            '-webkit-text-orientation': 'upright',
            'text-orientation': 'upright',
        },
        'meta': {
            'group': 'writingMode',
            'order': 5,
        },
    },
    'write-orient-sideways': {
        'utility': {
            '-webkit-text-orientation': 'sideways',
            'text-orientation': 'sideways',
        },
        'meta': {
            'group': 'writingMode',
            'order': 6,
        },
    },
    // https://windicss.org/utilities/typography.html#hyphens
    'hyphens-none': {
        'utility': {
            '-webkit-hyphens': 'none',
            '-ms-hyphens': 'none',
            'hyphens': 'none',
        },
        'meta': {
            'group': 'hyphens',
            'order': 1,
        },
    },
    'hyphens-manual': {
        'utility': {
            '-webkit-hyphens': 'manual',
            '-ms-hyphens': 'manual',
            'hyphens': 'manual',
        },
        'meta': {
            'group': 'hyphens',
            'order': 2,
        },
    },
    'hyphens-auto': {
        'utility': {
            '-webkit-hyphens': 'auto',
            '-ms-hyphens': 'auto',
            'hyphens': 'auto',
        },
        'meta': {
            'group': 'hyphens',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/backgrounds.html#background-attachment
    'bg-fixed': {
        'utility': {
            'background-attachment': 'fixed',
        },
        'meta': {
            'group': 'backgroundAttachment',
            'order': 1,
        },
    },
    'bg-local': {
        'utility': {
            'background-attachment': 'local',
        },
        'meta': {
            'group': 'backgroundAttachment',
            'order': 2,
        },
    },
    'bg-scroll': {
        'utility': {
            'background-attachment': 'scroll',
        },
        'meta': {
            'group': 'backgroundAttachment',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/backgrounds.html#background-clip
    'bg-clip-border': {
        'utility': {
            '-webkit-background-clip': 'border-box',
            'background-clip': 'border-box',
        },
        'meta': {
            'group': 'backgroundClip',
            'order': 1,
        },
    },
    'bg-clip-padding': {
        'utility': {
            '-webkit-background-clip': 'padding-box',
            'background-clip': 'padding-box',
        },
        'meta': {
            'group': 'backgroundClip',
            'order': 2,
        },
    },
    'bg-clip-content': {
        'utility': {
            '-webkit-background-clip': 'content-box',
            'background-clip': 'content-box',
        },
        'meta': {
            'group': 'backgroundClip',
            'order': 3,
        },
    },
    'bg-clip-text': {
        'utility': {
            '-webkit-background-clip': 'text',
            'background-clip': 'text',
        },
        'meta': {
            'group': 'backgroundClip',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/backgrounds.html#background-repeat
    'bg-repeat': {
        'utility': {
            'background-repeat': 'repeat',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 1,
        },
    },
    'bg-no-repeat': {
        'utility': {
            'background-repeat': 'no-repeat',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 2,
        },
    },
    'bg-repeat-x': {
        'utility': {
            'background-repeat': 'repeat-x',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 3,
        },
    },
    'bg-repeat-y': {
        'utility': {
            'background-repeat': 'repeat-y',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 4,
        },
    },
    'bg-repeat-round': {
        'utility': {
            'background-repeat': 'round',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 5,
        },
    },
    'bg-repeat-space': {
        'utility': {
            'background-repeat': 'space',
        },
        'meta': {
            'group': 'backgroundRepeat',
            'order': 6,
        },
    },
    // https://windicss.org/utilities/backgrounds.html#background-origin
    'bg-origin-border': {
        'utility': {
            'background-origin': 'border-box',
        },
        'meta': {
            'group': 'backgroundOrigin',
            'order': 1,
        },
    },
    'bg-origin-padding': {
        'utility': {
            'background-origin': 'padding-box',
        },
        'meta': {
            'group': 'backgroundOrigin',
            'order': 2,
        },
    },
    'bg-origin-content': {
        'utility': {
            'background-origin': 'content-box',
        },
        'meta': {
            'group': 'backgroundOrigin',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/borders.html#border-style
    'border-solid': {
        'utility': {
            'border-style': 'solid',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 1,
        },
    },
    'border-dashed': {
        'utility': {
            'border-style': 'dashed',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 2,
        },
    },
    'border-dotted': {
        'utility': {
            'border-style': 'dotted',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 3,
        },
    },
    'border-double': {
        'utility': {
            'border-style': 'double',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 4,
        },
    },
    'border-none': {
        'utility': {
            'border-style': 'none',
        },
        'meta': {
            'group': 'borderStyle',
            'order': 5,
        },
    },
    // https://windicss.org/utilities/behaviors.html#image-rendering
    'image-render-auto': {
        'utility': {
            'image-rendering': 'auto',
        },
        'meta': {
            'group': 'imageRendering',
            'order': 1,
        },
    },
    'image-render-pixel': {
        'utility': {
            '-ms-interpolation-mode': 'nearest-neighbor',
            'image-rendering': ['-webkit-optimize-contrast', '-moz-crisp-edges', '-o-pixelated', 'pixelated'],
        },
        'meta': {
            'group': 'imageRendering',
            'order': 2,
        },
    },
    'image-render-edge': {
        'utility': {
            'image-rendering': 'crisp-edges',
        },
        'meta': {
            'group': 'imageRendering',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/effects.html#mix-blend-mode
    'mix-blend-normal': {
        'utility': {
            'mix-blend-mode': 'normal',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 1,
        },
    },
    'mix-blend-multiply': {
        'utility': {
            'mix-blend-mode': 'multiply',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 2,
        },
    },
    'mix-blend-screen': {
        'utility': {
            'mix-blend-mode': 'screen',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 3,
        },
    },
    'mix-blend-overlay': {
        'utility': {
            'mix-blend-mode': 'overlay',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 4,
        },
    },
    'mix-blend-darken': {
        'utility': {
            'mix-blend-mode': 'darken',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 5,
        },
    },
    'mix-blend-lighten': {
        'utility': {
            'mix-blend-mode': 'lighten',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 6,
        },
    },
    'mix-blend-color-dodge': {
        'utility': {
            'mix-blend-mode': 'color-dodge',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 7,
        },
    },
    'mix-blend-color-burn': {
        'utility': {
            'mix-blend-mode': 'color-burn',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 8,
        },
    },
    'mix-blend-hard-light': {
        'utility': {
            'mix-blend-mode': 'hard-light',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 9,
        },
    },
    'mix-blend-soft-light': {
        'utility': {
            'mix-blend-mode': 'soft-light',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 10,
        },
    },
    'mix-blend-difference': {
        'utility': {
            'mix-blend-mode': 'difference',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 11,
        },
    },
    'mix-blend-exclusion': {
        'utility': {
            'mix-blend-mode': 'exclusion',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 12,
        },
    },
    'mix-blend-hue': {
        'utility': {
            'mix-blend-mode': 'hue',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 13,
        },
    },
    'mix-blend-saturation': {
        'utility': {
            'mix-blend-mode': 'saturation',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 14,
        },
    },
    'mix-blend-color': {
        'utility': {
            'mix-blend-mode': 'color',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 15,
        },
    },
    'mix-blend-luminosity': {
        'utility': {
            'mix-blend-mode': 'luminosity',
        },
        'meta': {
            'group': 'mixBlendMode',
            'order': 16,
        },
    },
    // https://windicss.org/utilities/backgrounds.html#background-blend-mode
    'bg-blend-normal': {
        'utility': {
            'background-blend-mode': 'normal',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 1,
        },
    },
    'bg-blend-multiply': {
        'utility': {
            'background-blend-mode': 'multiply',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 2,
        },
    },
    'bg-blend-screen': {
        'utility': {
            'background-blend-mode': 'screen',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 3,
        },
    },
    'bg-blend-overlay': {
        'utility': {
            'background-blend-mode': 'overlay',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 4,
        },
    },
    'bg-blend-darken': {
        'utility': {
            'background-blend-mode': 'darken',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 5,
        },
    },
    'bg-blend-lighten': {
        'utility': {
            'background-blend-mode': 'lighten',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 6,
        },
    },
    'bg-blend-color-dodge': {
        'utility': {
            'background-blend-mode': 'color-dodge',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 7,
        },
    },
    'bg-blend-color-burn': {
        'utility': {
            'background-blend-mode': 'color-burn',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 8,
        },
    },
    'bg-blend-hard-light': {
        'utility': {
            'background-blend-mode': 'hard-light',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 9,
        },
    },
    'bg-blend-soft-light': {
        'utility': {
            'background-blend-mode': 'soft-light',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 10,
        },
    },
    'bg-blend-difference': {
        'utility': {
            'background-blend-mode': 'difference',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 11,
        },
    },
    'bg-blend-exclusion': {
        'utility': {
            'background-blend-mode': 'exclusion',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 12,
        },
    },
    'bg-blend-hue': {
        'utility': {
            'background-blend-mode': 'hue',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 13,
        },
    },
    'bg-blend-saturation': {
        'utility': {
            'background-blend-mode': 'saturation',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 14,
        },
    },
    'bg-blend-color': {
        'utility': {
            'background-blend-mode': 'color',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 15,
        },
    },
    'bg-blend-luminosity': {
        'utility': {
            'background-blend-mode': 'luminosity',
        },
        'meta': {
            'group': 'backgroundBlendMode',
            'order': 16,
        },
    },
    // https://windicss.org/utilities/filters.html#filter
    'filter': {
        'utility': {
            '--tw-blur': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-brightness': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-contrast': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-grayscale': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-hue-rotate': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-invert': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-saturate': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-sepia': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-drop-shadow': 'var(--tw-empty,/*!*/ /*!*/)',
            '-webkit-filter': 'var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)',
            'filter': 'var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)',
        },
        'meta': {
            'group': 'filter',
            'order': 1,
        },
    },
    'filter-none': {
        'utility': {
            '-webkit-filter': 'none',
            'filter': 'none',
        },
        'meta': {
            'group': 'filter',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/filters.html#backdrop-filter
    'backdrop-filter': {
        'utility': {
            '--tw-backdrop-blur': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-brightness': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-contrast': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-grayscale': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-hue-rotate': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-invert': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-opacity': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-saturate': 'var(--tw-empty,/*!*/ /*!*/)',
            '--tw-backdrop-sepia': 'var(--tw-empty,/*!*/ /*!*/)',
            '-webkit-backdrop-filter': 'var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)',
            'backdrop-filter': 'var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)',
        },
        'meta': {
            'group': 'backdropFilter',
            'order': 1,
        },
    },
    'backdrop-filter-none': {
        'utility': {
            '-webkit-backdrop-filter': 'none',
            'backdrop-filter': 'none',
        },
        'meta': {
            'group': 'backdropFilter',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/tables.html#table-border-collapse
    'border-collapse': {
        'utility': {
            'border-collapse': 'collapse',
        },
        'meta': {
            'group': 'borderCollapse',
            'order': 1,
        },
    },
    'border-separate': {
        'utility': {
            'border-collapse': 'separate',
        },
        'meta': {
            'group': 'borderCollapse',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/tables.html#table-caption-side
    'caption-top': {
        'utility': {
            'caption-side': 'top',
        },
        'meta': {
            'group': 'captionSide',
            'order': 1,
        },
    },
    'caption-bottom': {
        'utility': {
            'caption-side': 'bottom',
        },
        'meta': {
            'group': 'captionSide',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/tables.html#table-empty-cells
    'empty-cells-visible': {
        'utility': {
            'empty-cells': 'show',
        },
        'meta': {
            'group': 'emptyCells',
            'order': 1,
        },
    },
    'empty-cells-hidden': {
        'utility': {
            'empty-cells': 'hide',
        },
        'meta': {
            'group': 'emptyCells',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/tables.html#table-layout
    'table-auto': {
        'utility': {
            'table-layout': 'auto',
        },
        'meta': {
            'group': 'tableLayout',
            'order': 1,
        },
    },
    'table-fixed': {
        'utility': {
            'table-layout': 'fixed',
        },
        'meta': {
            'group': 'tableLayout',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/transforms.html
    'transform': {
        'utility': {
            '--tw-rotate': '0',
            '--tw-rotate-x': '0',
            '--tw-rotate-y': '0',
            '--tw-rotate-z': '0',
            '--tw-scale-x': '1',
            '--tw-scale-y': '1',
            '--tw-scale-z': '1',
            '--tw-skew-x': '0',
            '--tw-skew-y': '0',
            '--tw-translate-x': '0',
            '--tw-translate-y': '0',
            '--tw-translate-z': '0',
            '-webkit-transform': 'rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) translateZ(var(--tw-translate-z))',
            '-ms-transform': 'rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) translateZ(var(--tw-translate-z))',
            'transform': 'rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y)) translateZ(var(--tw-translate-z))',
        },
        'meta': {
            'group': 'transform',
            'order': 1,
        },
    },
    'transform-gpu': {
        'utility': {
            '--tw-rotate': '0',
            '--tw-rotate-x': '0',
            '--tw-rotate-y': '0',
            '--tw-rotate-z': '0',
            '--tw-scale-x': '1',
            '--tw-scale-y': '1',
            '--tw-scale-z': '1',
            '--tw-skew-x': '0',
            '--tw-skew-y': '0',
            '--tw-translate-x': '0',
            '--tw-translate-y': '0',
            '--tw-translate-z': '0',
            '-webkit-transform': 'rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) translate3d(var(--tw-translate-x), var(--tw-translate-y), var(--tw-translate-z))',
            '-ms-transform': 'rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) translate3d(var(--tw-translate-x), var(--tw-translate-y), var(--tw-translate-z))',
            'transform': 'rotate(var(--tw-rotate)) rotateX(var(--tw-rotate-x)) rotateY(var(--tw-rotate-y)) rotateZ(var(--tw-rotate-z)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y)) scaleZ(var(--tw-scale-z)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) translate3d(var(--tw-translate-x), var(--tw-translate-y), var(--tw-translate-z))',
        },
        'meta': {
            'group': 'transform',
            'order': 2,
        },
    },
    'transform-none': {
        'utility': {
            '-webkit-transform': 'none',
            '-ms-transform': 'none',
            'transform': 'none',
        },
        'meta': {
            'group': 'transform',
            'order': 3,
        },
    },
    // https://windicss.org/utilities/transforms.html#transform-type
    'preserve-flat': {
        'utility': {
            '-webkit-transform-style': 'flat',
            'transform-style': 'flat',
        },
        'meta': {
            'group': 'transform',
            'order': 4,
        },
    },
    'preserve-3d': {
        'utility': {
            '-webkit-transform-style': 'preserve-3d',
            'transform-style': 'preserve-3d',
        },
        'meta': {
            'group': 'transform',
            'order': 5,
        },
    },
    'animated': {
        'utility': {
            '-webkit-animation-duration': '1000ms',
            '-webkit-animation-fill-mode': 'both',
            'animation-duration': '1000ms',
            'animation-fill-mode': 'both',
        },
        'meta': {
            'group': 'animation',
            'order': 3,
        },
    },
    'animate-reverse': {
        'utility': {
            '-webkit-animation-direction': 'reverse',
            'animation-direction': 'reverse',
        },
        'meta': {
            'group': 'animation',
            'order': 4,
        },
    },
    'animate-alternate': {
        'utility': {
            '-webkit-animation-direction': 'alternate',
            'animation-direction': 'alternate',
        },
        'meta': {
            'group': 'animation',
            'order': 5,
        },
    },
    'animate-alternate-reverse': {
        'utility': {
            '-webkit-animation-direction': 'alternate-reverse',
            'animation-direction': 'alternate-reverse',
        },
        'meta': {
            'group': 'animation',
            'order': 6,
        },
    },
    'animate-fill-none': {
        'utility': {
            '-webkit-animation-fill-mode': 'none',
            'animation-fill-mode': 'none',
        },
        'meta': {
            'group': 'animation',
            'order': 7,
        },
    },
    'animate-fill-forwards': {
        'utility': {
            '-webkit-animation-fill-mode': 'forwards',
            'animation-fill-mode': 'forwards',
        },
        'meta': {
            'group': 'animation',
            'order': 8,
        },
    },
    'animate-fill-backwards': {
        'utility': {
            '-webkit-animation-fill-mode': 'backwards',
            'animation-fill-mode': 'backwards',
        },
        'meta': {
            'group': 'animation',
            'order': 9,
        },
    },
    'animate-fill-both': {
        'utility': {
            '-webkit-animation-fill-mode': 'both',
            'animation-fill-mode': 'both',
        },
        'meta': {
            'group': 'animation',
            'order': 10,
        },
    },
    'animate-paused': {
        'utility': {
            '-webkit-animation-play-state': 'paused',
            'animation-play-state': 'paused',
        },
        'meta': {
            'group': 'animation',
            'order': 11,
        },
    },
    'animate-running': {
        'utility': {
            '-webkit-animation-play-state': 'running',
            'animation-play-state': 'running',
        },
        'meta': {
            'group': 'animation',
            'order': 12,
        },
    },
    // https://windicss.org/utilities/behaviors.html#appearance
    'appearance-none': {
        'utility': {
            '-webkit-appearance': 'none',
            '-moz-appearance': 'none',
            'appearance': 'none',
        },
        'meta': {
            'group': 'appearance',
            'order': 1,
        },
    },
    // https://windicss.org/utilities/behaviors.html#pointer-events
    'pointer-events-none': {
        'utility': {
            'pointer-events': 'none',
        },
        'meta': {
            'group': 'pointerEvents',
            'order': 1,
        },
    },
    'pointer-events-auto': {
        'utility': {
            'pointer-events': 'auto',
        },
        'meta': {
            'group': 'pointerEvents',
            'order': 2,
        },
    },
    // https://windicss.org/utilities/behaviors.html#resize
    'resize-none': {
        'utility': {
            'resize': 'none',
        },
        'meta': {
            'group': 'resize',
            'order': 1,
        },
    },
    'resize-y': {
        'utility': {
            'resize': 'vertical',
        },
        'meta': {
            'group': 'resize',
            'order': 2,
        },
    },
    'resize-x': {
        'utility': {
            'resize': 'horizontal',
        },
        'meta': {
            'group': 'resize',
            'order': 3,
        },
    },
    'resize': {
        'utility': {
            'resize': 'both',
        },
        'meta': {
            'group': 'resize',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/behaviors.html#user-select
    'select-none': {
        'utility': {
            '-webkit-user-select': 'none',
            '-moz-user-select': 'none',
            '-ms-user-select': 'none',
            'user-select': 'none',
        },
        'meta': {
            'group': 'userSelect',
            'order': 1,
        },
    },
    'select-text': {
        'utility': {
            '-webkit-user-select': 'text',
            '-moz-user-select': 'text',
            '-ms-user-select': 'text',
            'user-select': 'text',
        },
        'meta': {
            'group': 'userSelect',
            'order': 2,
        },
    },
    'select-all': {
        'utility': {
            '-webkit-user-select': 'all',
            '-moz-user-select': 'all',
            '-ms-user-select': 'all',
            'user-select': 'all',
        },
        'meta': {
            'group': 'userSelect',
            'order': 3,
        },
    },
    'select-auto': {
        'utility': {
            '-webkit-user-select': 'auto',
            '-moz-user-select': 'auto',
            '-ms-user-select': 'auto',
            'user-select': 'auto',
        },
        'meta': {
            'group': 'userSelect',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/svg.html#fill-color
    // https://windicss.org/utilities/svg.html#stroke-color
    'fill-current': {
        'utility': {
            'fill': 'currentColor',
        },
        'meta': {
            'group': 'fill',
            'order': 1,
        },
    },
    'stroke-current': {
        'utility': {
            'stroke': 'currentColor',
        },
        'meta': {
            'group': 'stroke',
            'order': 1,
        },
    },
    // https://windicss.org/utilities/svg.html#stroke-linecap
    'stroke-cap-auto': {
        'utility': {
            'stroke-linecap': 'butt',
        },
        'meta': {
            'group': 'stroke',
            'order': 2,
        },
    },
    'stroke-cap-square': {
        'utility': {
            'stroke-linecap': 'square',
        },
        'meta': {
            'group': 'stroke',
            'order': 3,
        },
    },
    'stroke-cap-round': {
        'utility': {
            'stroke-linecap': 'round',
        },
        'meta': {
            'group': 'stroke',
            'order': 4,
        },
    },
    // https://windicss.org/utilities/svg.html#stroke-linejoin
    'stroke-join-auto': {
        'utility': {
            'stroke-linejoin': 'miter',
        },
        'meta': {
            'group': 'stroke',
            'order': 5,
        },
    },
    'stroke-join-arcs': {
        'utility': {
            'stroke-linejoin': 'arcs',
        },
        'meta': {
            'group': 'stroke',
            'order': 6,
        },
    },
    'stroke-join-bevel': {
        'utility': {
            'stroke-linejoin': 'bevel',
        },
        'meta': {
            'group': 'stroke',
            'order': 7,
        },
    },
    'stroke-join-clip': {
        'utility': {
            'stroke-linejoin': 'miter-clip',
        },
        'meta': {
            'group': 'stroke',
            'order': 8,
        },
    },
    'stroke-join-round': {
        'utility': {
            'stroke-linejoin': 'round',
        },
        'meta': {
            'group': 'stroke',
            'order': 9,
        },
    },
    // https://windicss.org/utilities/behaviors.html#screen-readers-access
    'sr-only': {
        'utility': {
            'position': 'absolute',
            'width': '1px',
            'height': '1px',
            'padding': '0',
            'margin': '-1px',
            'overflow': 'hidden',
            'clip': 'rect(0, 0, 0, 0)',
            'white-space': 'nowrap',
            'border-width': '0',
        },
        'meta': {
            'group': 'accessibility',
            'order': 1,
        },
    },
    'not-sr-only': {
        'utility': {
            'position': 'static',
            'width': 'auto',
            'height': 'auto',
            'padding': '0',
            'margin': '0',
            'overflow': 'visible',
            'clip': 'auto',
            'white-space': 'normal',
        },
        'meta': {
            'group': 'accessibility',
            'order': 2,
        },
    },
};

var variantOrder = [
    'hover',
    'focus',
    'active',
    'visited',
    'link',
    'target',
    'focus-visible',
    'focus-within',
    'checked',
    'not-checked',
    'default',
    'disabled',
    'enabled',
    'indeterminate',
    'invalid',
    'valid',
    'optional',
    'required',
    'placeholder-shown',
    'read-only',
    'read-write',
    'not-disabled',
    'first-of-type',
    'not-first-of-type',
    'last-of-type',
    'not-last-of-type',
    'first',
    'last',
    'not-first',
    'not-last',
    'only-child',
    'not-only-child',
    'only-of-type',
    'not-only-of-type',
    'even',
    'odd',
    'even-of-type',
    'odd-of-type',
    'root',
    'empty',
    'before',
    'after',
    'first-letter',
    'first-line',
    'file-selector-button',
    'selection',
    'svg',
    'all',
    'children',
    'siblings',
    'sibling',
    'ltr',
    'rtl',
    'group-hover',
    'group-focus',
    'group-active',
    'group-visited',
    'motion-safe',
    'motion-reduce',
];
var layerOrder$1;
(function (layerOrder) {
    layerOrder[layerOrder["base"] = 10] = "base";
    layerOrder[layerOrder["components"] = 150] = "components";
    layerOrder[layerOrder["shortcuts"] = 160] = "shortcuts";
    layerOrder[layerOrder["utilities"] = 20000] = "utilities";
})(layerOrder$1 || (layerOrder$1 = {}));
var pluginOrder$1;
(function (pluginOrder) {
    pluginOrder[pluginOrder["container"] = 100] = "container";
    pluginOrder[pluginOrder["space"] = 200] = "space";
    pluginOrder[pluginOrder["divideWidth"] = 300] = "divideWidth";
    pluginOrder[pluginOrder["divideColor"] = 400] = "divideColor";
    pluginOrder[pluginOrder["divideStyle"] = 500] = "divideStyle";
    pluginOrder[pluginOrder["divideOpacity"] = 600] = "divideOpacity";
    pluginOrder[pluginOrder["accessibility"] = 700] = "accessibility";
    pluginOrder[pluginOrder["appearance"] = 800] = "appearance";
    pluginOrder[pluginOrder["backgroundAttachment"] = 900] = "backgroundAttachment";
    pluginOrder[pluginOrder["backgroundClip"] = 1000] = "backgroundClip";
    pluginOrder[pluginOrder["backgroundColor"] = 1100] = "backgroundColor";
    pluginOrder[pluginOrder["backgroundImage"] = 1200] = "backgroundImage";
    pluginOrder[pluginOrder["gradientColorStops"] = 1300] = "gradientColorStops";
    pluginOrder[pluginOrder["backgroundOpacity"] = 1400] = "backgroundOpacity";
    pluginOrder[pluginOrder["backgroundPosition"] = 1500] = "backgroundPosition";
    pluginOrder[pluginOrder["backgroundRepeat"] = 1600] = "backgroundRepeat";
    pluginOrder[pluginOrder["backgroundSize"] = 1700] = "backgroundSize";
    pluginOrder[pluginOrder["backgroundOrigin"] = 1750] = "backgroundOrigin";
    pluginOrder[pluginOrder["borderCollapse"] = 1800] = "borderCollapse";
    pluginOrder[pluginOrder["borderColor"] = 1900] = "borderColor";
    pluginOrder[pluginOrder["borderOpacity"] = 2000] = "borderOpacity";
    pluginOrder[pluginOrder["borderRadius"] = 2100] = "borderRadius";
    pluginOrder[pluginOrder["borderStyle"] = 2200] = "borderStyle";
    pluginOrder[pluginOrder["borderWidth"] = 2300] = "borderWidth";
    pluginOrder[pluginOrder["boxDecorationBreak"] = 2350] = "boxDecorationBreak";
    pluginOrder[pluginOrder["boxSizing"] = 2400] = "boxSizing";
    pluginOrder[pluginOrder["cursor"] = 2500] = "cursor";
    pluginOrder[pluginOrder["captionSide"] = 2550] = "captionSide";
    pluginOrder[pluginOrder["emptyCells"] = 2560] = "emptyCells";
    pluginOrder[pluginOrder["display"] = 2600] = "display";
    pluginOrder[pluginOrder["flexDirection"] = 2700] = "flexDirection";
    pluginOrder[pluginOrder["flexWrap"] = 2800] = "flexWrap";
    pluginOrder[pluginOrder["placeItems"] = 2900] = "placeItems";
    pluginOrder[pluginOrder["placeContent"] = 3000] = "placeContent";
    pluginOrder[pluginOrder["placeSelf"] = 3100] = "placeSelf";
    pluginOrder[pluginOrder["alignItems"] = 3200] = "alignItems";
    pluginOrder[pluginOrder["alignContent"] = 3300] = "alignContent";
    pluginOrder[pluginOrder["alignSelf"] = 3400] = "alignSelf";
    pluginOrder[pluginOrder["justifyItems"] = 3500] = "justifyItems";
    pluginOrder[pluginOrder["justifyContent"] = 3600] = "justifyContent";
    pluginOrder[pluginOrder["justifySelf"] = 3700] = "justifySelf";
    pluginOrder[pluginOrder["flex"] = 3800] = "flex";
    pluginOrder[pluginOrder["flexGrow"] = 3900] = "flexGrow";
    pluginOrder[pluginOrder["flexShrink"] = 4000] = "flexShrink";
    pluginOrder[pluginOrder["order"] = 4100] = "order";
    pluginOrder[pluginOrder["float"] = 4200] = "float";
    pluginOrder[pluginOrder["clear"] = 4300] = "clear";
    pluginOrder[pluginOrder["fontFamily"] = 4400] = "fontFamily";
    pluginOrder[pluginOrder["fontWeight"] = 4500] = "fontWeight";
    pluginOrder[pluginOrder["height"] = 4600] = "height";
    pluginOrder[pluginOrder["fontSize"] = 4700] = "fontSize";
    pluginOrder[pluginOrder["lineHeight"] = 4800] = "lineHeight";
    pluginOrder[pluginOrder["listStylePosition"] = 4900] = "listStylePosition";
    pluginOrder[pluginOrder["listStyleType"] = 5000] = "listStyleType";
    pluginOrder[pluginOrder["margin"] = 5100] = "margin";
    pluginOrder[pluginOrder["maxHeight"] = 5200] = "maxHeight";
    pluginOrder[pluginOrder["maxWidth"] = 5300] = "maxWidth";
    pluginOrder[pluginOrder["minHeight"] = 5400] = "minHeight";
    pluginOrder[pluginOrder["minWidth"] = 5500] = "minWidth";
    pluginOrder[pluginOrder["objectFit"] = 5600] = "objectFit";
    pluginOrder[pluginOrder["objectPosition"] = 5700] = "objectPosition";
    pluginOrder[pluginOrder["opacity"] = 5800] = "opacity";
    pluginOrder[pluginOrder["outline"] = 5900] = "outline";
    pluginOrder[pluginOrder["overflow"] = 6000] = "overflow";
    pluginOrder[pluginOrder["overscrollBehavior"] = 6100] = "overscrollBehavior";
    pluginOrder[pluginOrder["padding"] = 6200] = "padding";
    pluginOrder[pluginOrder["placeholderColor"] = 6300] = "placeholderColor";
    pluginOrder[pluginOrder["placeholderOpacity"] = 6400] = "placeholderOpacity";
    pluginOrder[pluginOrder["caretColor"] = 6450] = "caretColor";
    pluginOrder[pluginOrder["caretOpacity"] = 6460] = "caretOpacity";
    pluginOrder[pluginOrder["tabSize"] = 6470] = "tabSize";
    pluginOrder[pluginOrder["pointerEvents"] = 6500] = "pointerEvents";
    pluginOrder[pluginOrder["position"] = 6600] = "position";
    pluginOrder[pluginOrder["inset"] = 6700] = "inset";
    pluginOrder[pluginOrder["resize"] = 6800] = "resize";
    pluginOrder[pluginOrder["boxShadow"] = 6900] = "boxShadow";
    pluginOrder[pluginOrder["boxShadowColor"] = 6950] = "boxShadowColor";
    pluginOrder[pluginOrder["ringWidth"] = 7000] = "ringWidth";
    pluginOrder[pluginOrder["ringOffsetColor"] = 7100] = "ringOffsetColor";
    pluginOrder[pluginOrder["ringOffsetWidth"] = 7200] = "ringOffsetWidth";
    pluginOrder[pluginOrder["ringColor"] = 7300] = "ringColor";
    pluginOrder[pluginOrder["ringOpacity"] = 7400] = "ringOpacity";
    pluginOrder[pluginOrder["fill"] = 7500] = "fill";
    pluginOrder[pluginOrder["stroke"] = 7600] = "stroke";
    pluginOrder[pluginOrder["strokeWidth"] = 7700] = "strokeWidth";
    pluginOrder[pluginOrder["strokeDashArray"] = 7750] = "strokeDashArray";
    pluginOrder[pluginOrder["strokeDashOffset"] = 7760] = "strokeDashOffset";
    pluginOrder[pluginOrder["tableLayout"] = 7800] = "tableLayout";
    pluginOrder[pluginOrder["textAlign"] = 7900] = "textAlign";
    pluginOrder[pluginOrder["textColor"] = 8000] = "textColor";
    pluginOrder[pluginOrder["textOpacity"] = 8100] = "textOpacity";
    pluginOrder[pluginOrder["textOverflow"] = 8200] = "textOverflow";
    pluginOrder[pluginOrder["textShadow"] = 8250] = "textShadow";
    pluginOrder[pluginOrder["fontStyle"] = 8300] = "fontStyle";
    pluginOrder[pluginOrder["textTransform"] = 8400] = "textTransform";
    pluginOrder[pluginOrder["textDecorationStyle"] = 8450] = "textDecorationStyle";
    pluginOrder[pluginOrder["textDecorationLength"] = 8455] = "textDecorationLength";
    pluginOrder[pluginOrder["textDecorationColor"] = 8460] = "textDecorationColor";
    pluginOrder[pluginOrder["textDecorationOpacity"] = 8470] = "textDecorationOpacity";
    pluginOrder[pluginOrder["textDecorationOffset"] = 8480] = "textDecorationOffset";
    pluginOrder[pluginOrder["textDecoration"] = 8500] = "textDecoration";
    pluginOrder[pluginOrder["textIndent"] = 8550] = "textIndent";
    pluginOrder[pluginOrder["textStrokeColor"] = 8560] = "textStrokeColor";
    pluginOrder[pluginOrder["textStrokeWidth"] = 8570] = "textStrokeWidth";
    pluginOrder[pluginOrder["content"] = 8580] = "content";
    pluginOrder[pluginOrder["fontSmoothing"] = 8600] = "fontSmoothing";
    pluginOrder[pluginOrder["fontVariantNumeric"] = 8700] = "fontVariantNumeric";
    pluginOrder[pluginOrder["letterSpacing"] = 8800] = "letterSpacing";
    pluginOrder[pluginOrder["userSelect"] = 8900] = "userSelect";
    pluginOrder[pluginOrder["verticalAlign"] = 9000] = "verticalAlign";
    pluginOrder[pluginOrder["visibility"] = 9100] = "visibility";
    pluginOrder[pluginOrder["backfaceVisibility"] = 9150] = "backfaceVisibility";
    pluginOrder[pluginOrder["whitespace"] = 9200] = "whitespace";
    pluginOrder[pluginOrder["wordBreak"] = 9300] = "wordBreak";
    pluginOrder[pluginOrder["writingMode"] = 9340] = "writingMode";
    pluginOrder[pluginOrder["hyphens"] = 9350] = "hyphens";
    pluginOrder[pluginOrder["width"] = 9400] = "width";
    pluginOrder[pluginOrder["zIndex"] = 9500] = "zIndex";
    pluginOrder[pluginOrder["isolation"] = 9550] = "isolation";
    pluginOrder[pluginOrder["gap"] = 9600] = "gap";
    pluginOrder[pluginOrder["gridAutoFlow"] = 9700] = "gridAutoFlow";
    pluginOrder[pluginOrder["gridTemplateColumns"] = 9800] = "gridTemplateColumns";
    pluginOrder[pluginOrder["gridAutoColumns"] = 9900] = "gridAutoColumns";
    pluginOrder[pluginOrder["gridColumn"] = 10000] = "gridColumn";
    pluginOrder[pluginOrder["gridColumnStart"] = 10100] = "gridColumnStart";
    pluginOrder[pluginOrder["gridColumnEnd"] = 10200] = "gridColumnEnd";
    pluginOrder[pluginOrder["gridTemplateRows"] = 10300] = "gridTemplateRows";
    pluginOrder[pluginOrder["gridAutoRows"] = 10400] = "gridAutoRows";
    pluginOrder[pluginOrder["gridRow"] = 10500] = "gridRow";
    pluginOrder[pluginOrder["gridRowStart"] = 10600] = "gridRowStart";
    pluginOrder[pluginOrder["gridRowEnd"] = 10700] = "gridRowEnd";
    pluginOrder[pluginOrder["transform"] = 10800] = "transform";
    pluginOrder[pluginOrder["transformOrigin"] = 10900] = "transformOrigin";
    pluginOrder[pluginOrder["scale"] = 11000] = "scale";
    pluginOrder[pluginOrder["rotate"] = 11100] = "rotate";
    pluginOrder[pluginOrder["translate"] = 11200] = "translate";
    pluginOrder[pluginOrder["skew"] = 11300] = "skew";
    pluginOrder[pluginOrder["perspective"] = 11350] = "perspective";
    pluginOrder[pluginOrder["perspectiveOrigin"] = 11360] = "perspectiveOrigin";
    pluginOrder[pluginOrder["transitionProperty"] = 11400] = "transitionProperty";
    pluginOrder[pluginOrder["transitionTimingFunction"] = 11500] = "transitionTimingFunction";
    pluginOrder[pluginOrder["transitionDuration"] = 11600] = "transitionDuration";
    pluginOrder[pluginOrder["transitionDelay"] = 11700] = "transitionDelay";
    pluginOrder[pluginOrder["keyframes"] = 11800] = "keyframes";
    pluginOrder[pluginOrder["animation"] = 11900] = "animation";
    pluginOrder[pluginOrder["imageRendering"] = 11950] = "imageRendering";
    pluginOrder[pluginOrder["mixBlendMode"] = 12000] = "mixBlendMode";
    pluginOrder[pluginOrder["backgroundBlendMode"] = 12100] = "backgroundBlendMode";
    pluginOrder[pluginOrder["filter"] = 12200] = "filter";
    pluginOrder[pluginOrder["blur"] = 12300] = "blur";
    pluginOrder[pluginOrder["brightness"] = 12400] = "brightness";
    pluginOrder[pluginOrder["contrast"] = 12500] = "contrast";
    pluginOrder[pluginOrder["dropShadow"] = 12600] = "dropShadow";
    pluginOrder[pluginOrder["grayscale"] = 12700] = "grayscale";
    pluginOrder[pluginOrder["hueRotate"] = 12800] = "hueRotate";
    pluginOrder[pluginOrder["invert"] = 12900] = "invert";
    pluginOrder[pluginOrder["saturate"] = 13000] = "saturate";
    pluginOrder[pluginOrder["sepia"] = 13100] = "sepia";
    pluginOrder[pluginOrder["backdropFilter"] = 13200] = "backdropFilter";
    pluginOrder[pluginOrder["backdropBlur"] = 13300] = "backdropBlur";
    pluginOrder[pluginOrder["backdropBrightness"] = 13400] = "backdropBrightness";
    pluginOrder[pluginOrder["backdropContrast"] = 13500] = "backdropContrast";
    pluginOrder[pluginOrder["backdropGrayscale"] = 13600] = "backdropGrayscale";
    pluginOrder[pluginOrder["backdropHueRotate"] = 13700] = "backdropHueRotate";
    pluginOrder[pluginOrder["backdropInvert"] = 13800] = "backdropInvert";
    pluginOrder[pluginOrder["backdropOpacity"] = 13900] = "backdropOpacity";
    pluginOrder[pluginOrder["backdropSaturate"] = 14000] = "backdropSaturate";
    pluginOrder[pluginOrder["backdropSepia"] = 14100] = "backdropSepia";
})(pluginOrder$1 || (pluginOrder$1 = {}));

function isNumberLead(i) {
    return /^\d/.test(i) ? i : undefined;
}
function notNumberLead(i) {
    return /^\d/.test(i) ? undefined : i;
}
// https://windicss.org/utilities/container.html
function container(utility, _a) {
    var theme = _a.theme;
    if (utility.raw === 'container') {
        var className = utility.class;
        var baseStyle = new Container(utility.class, new Property$3('width', '100%'));
        var paddingDefault = toType(theme('container.padding'), 'string') ? toType(theme('container.padding'), 'string') : toType(theme('container.padding.DEFAULT'), 'string');
        if (paddingDefault) {
            baseStyle.add(new Property$3('padding-left', paddingDefault));
            baseStyle.add(new Property$3('padding-right', paddingDefault));
        }
        var center = theme('container.center');
        if (center && typeof center === 'boolean') {
            baseStyle.add(new Property$3(['margin-left', 'margin-right'], 'auto'));
        }
        var output = [baseStyle];
        var screens = toType(theme('container.screens', theme('screens')), 'object');
        for (var _i = 0, _b = Object.entries(screens); _i < _b.length; _i++) {
            var _c = _b[_i], screen_1 = _c[0], size_1 = _c[1];
            if (!isString$1(size_1))
                continue;
            var props = [new Property$3('max-width', "" + size_1)];
            var padding_1 = theme("container.padding." + screen_1);
            if (padding_1 && typeof padding_1 === 'string') {
                props.push(new Property$3('padding-left', padding_1));
                props.push(new Property$3('padding-right', padding_1));
            }
            output.push(new Container(className, props).atRule("@media (min-width: " + size_1 + ")"));
        }
        output.forEach(function (style) { return style.updateMeta('utilities', 'container', pluginOrder$1.container, 0, true); });
        return output;
    }
}
// https://windicss.org/utilities/positioning.html#object-position
function objectPosition(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('objectPosition'))
        .createProperty(['-o-object-position', 'object-position'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'objectPosition', pluginOrder$1.objectPosition, 0, true);
}
// https://windicss.org/utilities/positioning.html#top-right-bottom-left
function inset(utility, _a) {
    var theme = _a.theme;
    return utility.handler
        .handleStatic(theme('inset'))
        .handleSquareBrackets()
        .handleSpacing()
        .handleFraction()
        .handleSize()
        .handleNegative()
        .handleVariable()
        .callback(function (value) {
        switch (utility.identifier) {
            case 'top':
            case 'right':
            case 'bottom':
            case 'left':
                return new Property$3(utility.identifier, value).updateMeta('utilities', 'inset', pluginOrder$1.inset, 4, true);
            case 'inset':
                if (utility.raw.match(/^-?inset-x/))
                    return new Property$3(['right', 'left'], value).updateMeta('utilities', 'inset', pluginOrder$1.inset, 3, true);
                if (utility.raw.match(/^-?inset-y/))
                    return new Property$3(['top', 'bottom'], value).updateMeta('utilities', 'inset', pluginOrder$1.inset, 2, true);
                return new Property$3(['top', 'right', 'bottom', 'left'], value).updateMeta('utilities', 'inset', pluginOrder$1.inset, 1, true);
        }
    });
}
// https://windicss.org/utilities/positioning.html#z-index
function zIndex(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('zIndex'))
        .handleNumber(0, 99999, 'int')
        .handleNegative()
        .handleVariable()
        .createProperty('z-index')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'zIndex', pluginOrder$1.zIndex, 0, true);
}
// https://windicss.org/utilities/flexbox.html#flex
// https://windicss.org/utilities/flexbox.html#flex-grow
// https://windicss.org/utilities/flexbox.html#flex-shrink
function flex(utility, _a) {
    var _b, _c, _d;
    var theme = _a.theme;
    var className = utility.raw;
    if (className.startsWith('flex-grow')) {
        var map = toType(theme('flexGrow'), 'object');
        var amount = className.replace(/flex-grow-?/, '') || 'DEFAULT';
        if (Object.keys(map).includes(amount))
            return new Property$3(['-webkit-box-flex', '-ms-flex-positive', '-webkit-flex-grow', 'flex-grow'], map[amount]).toStyle(utility.class).updateMeta('utilities', 'flexGrow', pluginOrder$1.flexGrow, 0, true);
        return (_b = utility.handler.handleSquareBrackets().createProperty(['-webkit-box-flex', '-ms-flex-positive', '-webkit-flex-grow', 'flex-grow'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'flexGrow', pluginOrder$1.flexGrow, 1, true);
    }
    else if (className.startsWith('flex-shrink')) {
        var map = toType(theme('flexShrink'), 'object');
        var amount = className.replace(/flex-shrink-?/, '') || 'DEFAULT';
        if (Object.keys(map).includes(amount))
            return new Property$3(['-ms-flex-negative', '-webkit-flex-shrink', 'flex-shrink'], map[amount]).toStyle(utility.class).updateMeta('utilities', 'flexShrink', pluginOrder$1.flexShrink, 0, true);
        return (_c = utility.handler.handleSquareBrackets().createProperty(['-ms-flex-negative', '-webkit-flex-shrink', 'flex-shrink'])) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'flexShrink', pluginOrder$1.flexShrink, 1, true);
    }
    else {
        return (_d = utility.handler.handleStatic(theme('flex')).handleSquareBrackets().createStyle(utility.class, function (value) {
            value = value.trim();
            return [
                new Property$3('-webkit-box-flex', value.startsWith('0') || value === 'none' ? '0' : '1'),
                new Property$3(['-ms-flex', '-webkit-flex', 'flex'], value),
            ];
        })) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'flex', pluginOrder$1.flex, 0, true);
    }
}
// https://windicss.org/utilities/positioning.html#order
function order$1(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('order'))
        .handleNumber(1, 9999, 'int')
        .handleNegative()
        .handleVariable()
        .createStyle(utility.class, function (value) { return [
        new Property$3('-webkit-box-ordinal-group', value.includes('var') ? "calc(" + value + "+1)" : (parseInt(value) + 1).toString()),
        new Property$3(['-webkit-order', '-ms-flex-order', 'order'], value),
    ]; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'order', pluginOrder$1.order, utility.raw.charAt(0) === '-' ? 2 : 1, true);
}
// https://windicss.org/utilities/grid.html#grid-template-columns
// https://windicss.org/utilities/grid.html#grid-template-rows
function gridTemplate(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var type = utility.raw.match(/^grid-rows-/) ? 'rows' : utility.raw.match(/^grid-cols-/) ? 'columns' : undefined;
    if (!type)
        return;
    var group = type === 'rows' ? 'gridTemplateRows' : 'gridTemplateColumns';
    return ((_b = utility.handler
        .handleStatic(theme(group))
        .handleSquareBrackets(function (i) { return i.replace(/\(.*?\)|,/g, function (r) { return r === ',' ? ' ' : r; } /* ignore content inside nested-brackets */); })
        .createProperty("grid-template-" + type, function (value) { return value === 'none' ? 'none' : value; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', group, pluginOrder$1[group], 1, true))
        || ((_c = utility.handler
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty("grid-template-" + type, function (value) { return "repeat(" + value + ", minmax(0, 1fr))"; })) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', group, pluginOrder$1[group], 2, true));
}
// https://windicss.org/utilities/grid.html#grid-column-span
// https://windicss.org/utilities/grid.html#grid-column-start
// https://windicss.org/utilities/grid.html#grid-column-end
function gridColumn(utility, _a) {
    var _b, _c, _d, _e;
    var theme = _a.theme;
    var body = utility.body;
    // col span
    var spans = toType(theme('gridColumn'), 'object');
    if (Object.keys(spans).includes(body))
        return new Property$3(['-ms-grid-column-span', 'grid-column'], spans[body]).updateMeta('utilities', 'gridColumn', pluginOrder$1.gridColumn, 1, true);
    if (utility.raw.startsWith('col-span')) {
        return (_b = utility.handler
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty(['-ms-grid-column-span', 'grid-column'], function (value) { return "span " + value + " / span " + value; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'gridColumn', pluginOrder$1.gridColumn, 1, true);
    }
    // col end
    if (utility.raw.startsWith('col-end')) {
        return (_c = utility.handler
            .handleStatic(theme('gridColumnEnd'))
            .handleSquareBrackets()
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty('grid-column-end')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'gridColumnEnd', pluginOrder$1.gridColumnEnd, 1, true);
    }
    // col start
    if (utility.raw.startsWith('col-start')) {
        return (_d = utility.handler
            .handleStatic(theme('gridColumnStart'))
            .handleSquareBrackets()
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty('grid-column-start')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'gridColumnStart', pluginOrder$1.gridColumnStart, 1, true);
    }
    return (_e = utility.handler
        .handleSquareBrackets()
        .createProperty(['-ms-grid-column-span', 'grid-column'], function (value) { return "span " + value + " / span " + value; })) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'gridColumn', pluginOrder$1.gridColumn, 1, true);
}
// https://windicss.org/utilities/grid.html#grid-row-span
// https://windicss.org/utilities/grid.html#grid-row-start
// https://windicss.org/utilities/grid.html#grid-row-end
function gridRow(utility, _a) {
    var _b, _c, _d, _e;
    var theme = _a.theme;
    var body = utility.body;
    // row span
    var spans = toType(theme('gridRow'), 'object');
    if (Object.keys(spans).includes(body))
        return new Property$3(['-ms-grid-row-span', 'grid-row'], spans[body]).updateMeta('utilities', 'gridRow', pluginOrder$1.gridRow, 1, true);
    if (utility.raw.startsWith('row-span')) {
        return (_b = utility.handler
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty(['-ms-grid-row-span', 'grid-row'], function (value) { return "span " + value + " / span " + value; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'gridRow', pluginOrder$1.gridRow, 2, true);
    }
    // row end
    if (utility.raw.startsWith('row-end')) {
        return (_c = utility.handler
            .handleStatic(theme('gridRowEnd'))
            .handleSquareBrackets()
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty('grid-row-end')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'gridRowEnd', pluginOrder$1.gridRowEnd, 1, true);
    }
    // row start
    if (utility.raw.startsWith('row-start')) {
        return (_d = utility.handler
            .handleStatic(theme('gridRowStart'))
            .handleSquareBrackets()
            .handleNumber(1, undefined, 'int')
            .handleVariable()
            .createProperty('grid-row-start')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'gridRowStart', pluginOrder$1.gridRowStart, 1, true);
    }
    return (_e = utility.handler
        .handleSquareBrackets()
        .createProperty(['-ms-grid-row-span', 'grid-row'], function (value) { return "span " + value + " / span " + value; })) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'gridRow', pluginOrder$1.gridRow, 2, true);
}
// https://windicss.org/utilities/grid.html#grid-auto-columns
// https://windicss.org/utilities/grid.html#grid-auto-rows
function gridAuto(utility, _a) {
    var theme = _a.theme;
    var type = utility.raw.startsWith('auto-cols') ? 'columns' : utility.raw.startsWith('auto-rows') ? 'rows' : undefined;
    if (!type)
        return;
    var group = type === 'columns' ? 'gridAutoColumns' : 'gridAutoRows';
    var value = utility.handler.handleStatic(theme(group)).value;
    if (value) {
        var prefixer = minMaxContent(value);
        if (typeof prefixer === 'string')
            return new Property$3("grid-auto-" + type, prefixer).updateMeta('utilities', group, pluginOrder$1[group], 1, true);
        return new Style$3(utility.class, prefixer.map(function (i) { return new Property$3("grid-auto-" + type, i); })).updateMeta('utilities', group, pluginOrder$1[group], 2, true);
    }
}
// https://windicss.org/utilities/grid.html#gap
function gap$1(utility, _a) {
    var theme = _a.theme, config = _a.config;
    return utility.handler
        .handleStatic(theme('gap'))
        .handleSquareBrackets()
        .handleSpacing()
        .handleSize()
        .handleVariable()
        .callback(function (value) {
        if (utility.raw.match(/^gap-x-/))
            return new Property$3(config('prefixer') ? ['-webkit-column-gap', '-moz-column-gap', 'grid-column-gap', 'column-gap'] : 'column-gap', value).updateMeta('utilities', 'gap', pluginOrder$1.gap, 2, true);
        if (utility.raw.match(/^gap-y-/))
            return new Property$3(config('prefixer') ? ['-webkit-row-gap', '-moz-row-gap', 'grid-row-gap', 'row-gap'] : 'row-gap', value).updateMeta('utilities', 'gap', pluginOrder$1.gap, 3, true);
        return new Property$3(config('prefixer') ? ['grid-gap', 'gap'] : 'gap', value).updateMeta('utilities', 'gap', pluginOrder$1.gap, 1, true);
    });
}
// https://windicss.org/utilities/spacing.html#padding
function padding(utility, _a) {
    var theme = _a.theme;
    return utility.handler
        .handleStatic(theme('padding'))
        .handleSquareBrackets()
        .handleSpacing()
        .handleFraction()
        .handleSize()
        .handleVariable()
        .callback(function (value) {
        var directions = expandDirection(utility.identifier.substring(1), false);
        if (directions) {
            if (directions[0] === '*')
                return new Property$3('padding', value).updateMeta('utilities', 'padding', pluginOrder$1.padding, -4, true);
            return new Property$3(directions.map(function (i) { return "padding-" + i; }), value).updateMeta('utilities', 'padding', pluginOrder$1.padding, -directions.length, true);
        }
    });
}
// https://windicss.org/utilities/spacing.html#margin
function margin(utility, _a) {
    var theme = _a.theme;
    return utility.handler
        .handleStatic(theme('margin'))
        .handleSquareBrackets()
        .handleSpacing()
        .handleFraction()
        .handleSize()
        .handleNegative()
        .handleVariable()
        .callback(function (value) {
        var directions = expandDirection(utility.identifier.substring(1), false);
        if (directions) {
            if (directions[0] === '*')
                return new Property$3('margin', value).updateMeta('utilities', 'margin', pluginOrder$1.margin, -4, true);
            return new Property$3(directions.map(function (i) { return "margin-" + i; }), value).updateMeta('utilities', 'margin', pluginOrder$1.margin, -directions.length, true);
        }
    });
}
// https://windicss.org/utilities/spacing.html#space-between-y
function space(utility, _a) {
    var theme = _a.theme;
    if (utility.raw === 'space-x-reverse') {
        return new Style$3(utility.class, [
            new Property$3('--tw-space-x-reverse', '1'),
        ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'space', pluginOrder$1.space, 6, true);
    }
    if (utility.raw === 'space-y-reverse') {
        return new Style$3(utility.class, [
            new Property$3('--tw-space-y-reverse', '1'),
        ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'space', pluginOrder$1.space, 5, true);
    }
    return utility.handler
        .handleStatic(theme('space'))
        .handleSquareBrackets()
        .handleSpacing()
        .handleSize()
        .handleNegative()
        .handleVariable()
        .callback(function (value) {
        if (utility.raw.match(/^-?space-x-/)) {
            return new Style$3(utility.class, [
                new Property$3('--tw-space-x-reverse', '0'),
                new Property$3('margin-right', "calc(" + value + " * var(--tw-space-x-reverse))"),
                new Property$3('margin-left', "calc(" + value + " * calc(1 - var(--tw-space-x-reverse)))"),
            ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'space', pluginOrder$1.space, (utility.raw.charAt(0) === '-' ? 4 : 2), true);
        }
        if (utility.raw.match(/^-?space-y-/)) {
            return new Style$3(utility.class, [
                new Property$3('--tw-space-y-reverse', '0'),
                new Property$3('margin-top', "calc(" + value + " * calc(1 - var(--tw-space-y-reverse)))"),
                new Property$3('margin-bottom', "calc(" + value + " * var(--tw-space-y-reverse))"),
            ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'space', pluginOrder$1.space, (utility.raw.charAt(0) === '-' ? 3 : 1), true);
        }
    });
}
// https://windicss.org/utilities/sizing.html#width
// https://windicss.org/utilities/sizing.html#height
function size(utility, _a) {
    var _b;
    var theme = _a.theme;
    var name = utility.identifier === 'w' ? 'width' : 'height';
    var body = utility.body;
    var sizes = toType(theme(name), 'object');
    // handle static
    if (Object.keys(sizes).includes(body)) {
        var value = sizes[body];
        if (value === 'min-content') {
            return new Style$3(utility.class, [
                new Property$3(name, '-webkit-min-content'),
                new Property$3(name, '-moz-min-content'),
                new Property$3(name, 'min-content'),
            ]).updateMeta('utilities', name, pluginOrder$1[name], 2, true);
        }
        if (value === 'max-content') {
            return new Style$3(utility.class, [
                new Property$3(name, '-webkit-max-content'),
                new Property$3(name, '-moz-max-content'),
                new Property$3(name, 'max-content'),
            ]).updateMeta('utilities', name, pluginOrder$1[name], 3, true);
        }
        return new Style$3(utility.class, new Property$3(name, value)).updateMeta('utilities', name, pluginOrder$1[name], 1, true);
    }
    return (_b = utility.handler
        .handleSquareBrackets()
        .handleSpacing()
        .handleFraction()
        .handleSize()
        .handleNxl(function (number) { return (number - 3) * 8 + 48 + "rem"; })
        .handleVariable()
        .createProperty(name)) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', name, pluginOrder$1[name], 4, true);
}
// https://windicss.org/utilities/sizing.html#min-width
// https://windicss.org/utilities/sizing.html#min-height
// https://windicss.org/utilities/sizing.html#max-width
// https://windicss.org/utilities/sizing.html#max-height
function minMaxSize(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (!utility.raw.match(/^(min|max)-[w|h]-/))
        return;
    var body = utility.raw.replace(/^(min|max)-[w|h]-/, '');
    var prop = utility.raw.substring(0, 5).replace('h', 'height').replace('w', 'width');
    var group = dashToCamel(prop);
    var sizes = toType(theme(group), 'object');
    // handle static
    if (Object.keys(sizes).includes(body)) {
        var value = sizes[body];
        if (value === 'min-content') {
            return new Style$3(utility.class, [
                new Property$3(prop, '-webkit-min-content'),
                new Property$3(prop, '-moz-min-content'),
                new Property$3(prop, 'min-content'),
            ]).updateMeta('utilities', group, pluginOrder$1[group], 2, true);
        }
        if (value === 'max-content') {
            return new Style$3(utility.class, [
                new Property$3(prop, '-webkit-max-content'),
                new Property$3(prop, '-moz-max-content'),
                new Property$3(prop, 'max-content'),
            ]).updateMeta('utilities', group, pluginOrder$1[group], 3, true);
        }
        return new Style$3(utility.class, new Property$3(prop, value)).updateMeta('utilities', group, pluginOrder$1[group], 1, true);
    }
    return (_b = utility.handler
        .handleSquareBrackets()
        .handleSpacing()
        .handleFraction()
        .handleSize()
        .handleNxl(function (number) { return (number - 3) * 8 + 48 + "rem"; })
        .handleVariable()
        .createProperty(prop)) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', group, pluginOrder$1[group], 4, true);
}
// https://windicss.org/utilities/typography.html#text-opacity
// https://windicss.org/utilities/typography.html#text-shadow
// https://windicss.org/utilities/typography.html#text-stroke
// https://windicss.org/utilities/typography.html#text-color
// https://windicss.org/utilities/typography.html#font-size
function text(utility, _a) {
    var _b, _c, _d, _e, _f, _g;
    var theme = _a.theme;
    // handle font opacity
    if (utility.raw.startsWith('text-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('textOpacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-text-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'textOpacity', pluginOrder$1.textOpacity, 1, true);
    }
    if (utility.raw.startsWith('text-shadow')) {
        return (_c = (utility.raw === 'text-shadow'
            ? new Property$3('text-shadow', theme('textShadow.DEFAULT', '0px 0px 1px rgb(0 0 0 / 20%), 0px 0px 1px rgb(1 0 5 / 10%)'))
            : utility.handler
                .handleStatic(theme('textShadow'))
                .createProperty('text-shadow'))) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'textShadow', pluginOrder$1.textShadow, 1, true);
    }
    if (utility.raw.startsWith('text-stroke')) {
        if (utility.raw === 'text-stroke')
            return new Style$3('text-stroke', [
                new Property$3('-webkit-text-stroke-color', theme('textStrokeColor.DEFAULT', '#e4e4e7')),
                new Property$3('-webkit-text-stroke-width', theme('textStrokeWidth.DEFAULT', 'medium')),
            ]).updateMeta('utilities', 'textStrokeColor', pluginOrder$1.textStrokeColor, 1, true);
        if (utility.raw.startsWith('text-stroke-opacity')) {
            return (_d = utility.handler
                .handleStatic(theme('opacity'))
                .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
                .handleVariable()
                .createProperty('--tw-ring-offset-opacity')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'textStrokeColor', pluginOrder$1.textStrokeColor, 3, true);
        }
        return ((_e = utility.clone('textStroke' + utility.raw.slice(11)).handler
            .handleColor(theme('textStrokeColor'))
            .handleOpacity(theme('opacity'))
            .handleVariable()
            .createColorStyle(utility.class, '-webkit-text-stroke-color', '--tw-text-stroke-opacity')) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'textStrokeColor', pluginOrder$1.textStrokeColor, 2, true))
            || ((_f = utility.handler
                .handleStatic(theme('textStrokeWidth'))
                .handleNumber(0, undefined, 'int', function (number) { return number + "px"; })
                .handleSize()
                .createProperty('-webkit-text-stroke-width')) === null || _f === void 0 ? void 0 : _f.updateMeta('utilities', 'textStrokeWidth', pluginOrder$1.textStrokeWidth, 1, true));
    }
    // handle text colors
    var textColor = (_g = utility.handler
        .handleColor(theme('textColor'))
        .handleOpacity(theme('textOpacity'))
        .handleSquareBrackets(notNumberLead)
        .handleVariable()
        .createColorStyle(utility.class, 'color', '--tw-text-opacity')) === null || _g === void 0 ? void 0 : _g.updateMeta('utilities', 'textColor', pluginOrder$1.textColor, 0, true);
    if (textColor)
        return textColor;
    // handle font sizes
    var amount = utility.amount;
    var fontSizes = toType(theme('fontSize'), 'object');
    if (Object.keys(fontSizes).includes(amount))
        return new Style$3(utility.class, generateFontSize(fontSizes[amount])).updateMeta('utilities', 'fontSize', pluginOrder$1.fontSize, 1, true);
    var value = utility.handler
        .handleSquareBrackets(isNumberLead)
        .handleNxl(function (number) { return number + "rem"; })
        .handleSize()
        .value;
    if (utility.raw.startsWith('text-size-$'))
        value = utility.handler.handleVariable().value;
    if (value)
        return new Style$3(utility.class, [new Property$3('font-size', value), new Property$3('line-height', '1')]).updateMeta('utilities', 'fontSize', pluginOrder$1.fontSize, 2, true);
}
// https://windicss.org/utilities/typography.html#font-family
// https://windicss.org/utilities/typography.html#font-weight
function font(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var fonts = theme('fontFamily');
    var map = {};
    for (var _i = 0, _d = Object.entries(fonts); _i < _d.length; _i++) {
        var _e = _d[_i], key = _e[0], value = _e[1];
        map[key] = Array.isArray(value) ? value.join(',') : value;
    }
    return (((_b = utility.handler
        .handleStatic(map)
        .createProperty('font-family')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'fontFamily', pluginOrder$1.fontFamily, 1, true))
        || ((_c = utility.handler
            .handleStatic(theme('fontWeight'))
            .handleNumber(0, 900, 'int')
            .handleVariable()
            .createProperty('font-weight')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'fontWeight', pluginOrder$1.fontWeight, 1, true)));
}
// https://windicss.org/utilities/typography.html#letter-spacing
function letterSpacing(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('letterSpacing'))
        .handleSquareBrackets()
        .handleSize()
        .handleNegative()
        .handleVariable()
        .createProperty('letter-spacing')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'letterSpacing', pluginOrder$1.letterSpacing, 1, true);
}
// https://windicss.org/utilities/typography.html#text-decoration
function textDecoration(utility, _a) {
    var _b, _c, _d, _e;
    var theme = _a.theme;
    // handle text decoration opacity
    if (utility.raw.startsWith('underline-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('textDecorationOpacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-line-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'textDecorationOpacity', pluginOrder$1.textDecorationOpacity, 1, true);
    }
    if (utility.raw.startsWith('underline-offset')) {
        return (_c = utility.handler
            .handleStatic(theme('textDecorationOffset'))
            .handleNumber(0, undefined, 'int', function (number) { return number + "px"; })
            .handleSize()
            .createProperty('text-underline-offset')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'textDecorationOffset', pluginOrder$1.textDecorationOffset, 1, true);
    }
    // handle text decoration color or length
    return ((_d = utility.handler
        .handleColor(theme('textDecorationColor'))
        .handleOpacity(theme('opacity'))
        .handleVariable()
        .createColorStyle(utility.class, ['-webkit-text-decoration-color', 'text-decoration-color'], '--tw-line-opacity')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'textDecorationColor', pluginOrder$1.textDecorationColor, 0, true))
        || ((_e = utility.handler
            .handleStatic(theme('textDecorationLength'))
            .handleNumber(0, undefined, 'int', function (number) { return number + "px"; })
            .handleSize()
            .createProperty('text-decoration-thickness')) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'textDecorationLength', pluginOrder$1.textDecorationLength, 1, true));
}
// https://windicss.org/utilities/typography.html#line-height
function lineHeight(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('lineHeight'))
        .handleNumber(0, undefined, 'int', function (number) { return number * 0.25 + "rem"; })
        .handleSquareBrackets()
        .handleSize()
        .handleVariable()
        .createProperty('line-height')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'lineHeight', pluginOrder$1.lineHeight, 1, true);
}
// https://windicss.org/utilities/behaviors.html#list-style-type
function listStyleType(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('listStyleType'))
        .createProperty('list-style-type')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'listStyleType', pluginOrder$1.listStyleType, 1, true);
}
// https://windicss.org/utilities/behaviors.html#placeholder-color
// https://windicss.org/utilities/behaviors.html#placeholder-opacity
function placeholder(utility, _a) {
    var theme = _a.theme, config = _a.config;
    // handle placeholder opacity
    if (utility.raw.startsWith('placeholder-opacity')) {
        return utility.handler
            .handleStatic(theme('placeholderOpacity'))
            .handleSquareBrackets()
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .callback(function (value) { return generatePlaceholder(utility.class, new Property$3('--tw-placeholder-opacity', value), config('prefixer'))
            .map(function (style) { return style.updateMeta('utilities', 'placeholderOpacity', pluginOrder$1.placeholderOpacity, 1, true); }); });
    }
    var color = utility.handler
        .handleColor(theme('placeholderColor'))
        .handleOpacity(theme('placeholderOpacity'))
        .handleSquareBrackets()
        .handleVariable()
        .createColorStyle(utility.class, 'color', '--tw-placeholder-opacity');
    if (color)
        return generatePlaceholder(color.selector || '', color.property, config('prefixer')).map(function (i) { return i.updateMeta('utilities', 'placeholderColor', pluginOrder$1.placeholderColor, 2, true); });
}
// https://windicss.org/utilities/behaviors.html#caret-color
// https://windicss.org/utilities/behaviors.html#caret-opacity
function caret$1(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    // handle caret opacity
    if (utility.raw.startsWith('caret-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('caretOpacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-caret-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'caretOpacity', pluginOrder$1.caretOpacity, 1, true);
    }
    return (_c = utility.handler
        .handleColor(theme('caretColor'))
        .handleOpacity(theme('caretOpacity'))
        .handleVariable()
        .createColorStyle(utility.class, 'caret-color', '--tw-caret-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'caretColor', pluginOrder$1.caretColor, 0, true);
}
// https://windicss.org/utilities/typography.html#tab-size
function tabSize(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('tabSize'))
        .handleNumber(0, undefined, 'int')
        .handleSize()
        .createProperty(['-moz-tab-size', '-o-tab-size', 'tab-size'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'tabSize', pluginOrder$1.tabSize, 1, true);
}
// https://windicss.org/utilities/typography.html#text-indent
function textIndent(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('textIndent'))
        .handleSize()
        .handleFraction()
        .handleNegative()
        .createProperty('text-indent')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'textIndent', pluginOrder$1.textIndent, 1, true);
}
// https://windicss.org/utilities/backgrounds.html#background-color
// https://windicss.org/utilities/backgrounds.html#background-opacity
// https://windicss.org/utilities/backgrounds.html#background-position
// https://windicss.org/utilities/backgrounds.html#background-size
// https://windicss.org/utilities/backgrounds.html#background-image
function background(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var body = utility.body;
    // handle background positions
    var positions = toType(theme('backgroundPosition'), 'object');
    if (Object.keys(positions).includes(body))
        return new Property$3('background-position', positions[body]).updateMeta('utilities', 'backgroundPosition', pluginOrder$1.backgroundPosition, 1, true);
    // handle background sizes
    var sizes = toType(theme('backgroundSize'), 'object');
    if (Object.keys(sizes).includes(body))
        return new Property$3('background-size', sizes[body]).updateMeta('utilities', 'backgroundSize', pluginOrder$1.backgroundSize, 1, true);
    // handle background image
    var images = toType(theme('backgroundImage'), 'object');
    if (Object.keys(images).includes(body)) {
        var prefixer = linearGradient(images[body]);
        if (Array.isArray(prefixer))
            return new Style$3(utility.class, prefixer.map(function (i) { return new Property$3('background-image', i); })).updateMeta('utilities', 'backgroundImage', pluginOrder$1.backgroundImage, 2, true);
        return new Property$3('background-image', prefixer).updateMeta('utilities', 'backgroundImage', pluginOrder$1.backgroundImage, 1, true);
    }
    // handle background opacity
    if (utility.raw.startsWith('bg-opacity'))
        return (_b = utility.handler
            .handleStatic(theme('backgroundOpacity'))
            .handleSquareBrackets()
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-bg-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'backgroundOpacity', pluginOrder$1.backgroundOpacity, 1, true);
    // handle background color
    return (_c = utility.handler
        .handleColor(theme('backgroundColor'))
        .handleOpacity(theme('backgroundOpacity'))
        .handleSquareBrackets(notNumberLead)
        .handleVariable()
        .createColorStyle(utility.class, 'background-color', '--tw-bg-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'backgroundColor', pluginOrder$1.backgroundColor, 0, true);
}
// https://windicss.org/utilities/backgrounds.html#gradient-from
function gradientColorFrom(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (utility.raw.startsWith('from-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-from-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 2, true);
    }
    var handler = utility.handler.handleColor(theme('gradientColorStops')).handleOpacity(theme('opacity')).handleVariable().handleSquareBrackets();
    if (handler.color || handler.value) {
        return new Style$3(utility.class, [
            new Property$3('--tw-gradient-from', handler.createColorValue('var(--tw-from-opacity, 1)')),
            new Property$3('--tw-gradient-stops', 'var(--tw-gradient-from), var(--tw-gradient-to, rgba(255, 255, 255, 0))'),
        ]).updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 1, true);
    }
}
// https://windicss.org/utilities/backgrounds.html#gradient-via
function gradientColorVia(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    if (utility.raw.startsWith('via-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-via-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 4, true);
    }
    var handler = utility.handler.handleColor(theme('gradientColorStops')).handleOpacity(theme('opacity')).handleVariable().handleSquareBrackets();
    if (handler.color || handler.value) {
        return (_c = new Style$3(utility.class, new Property$3('--tw-gradient-stops', "var(--tw-gradient-from), " + handler.createColorValue('var(--tw-via-opacity, 1)') + ", var(--tw-gradient-to, rgba(255, 255, 255, 0))"))) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 3, true);
    }
}
// https://windicss.org/utilities/backgrounds.html#gradient-to
function gradientColorTo(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    if (utility.raw.startsWith('to-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-to-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 6, true);
    }
    var handler = utility.handler.handleColor(theme('gradientColorStops')).handleOpacity(theme('opacity')).handleVariable().handleSquareBrackets();
    if (handler.color || handler.value) {
        return (_c = new Style$3(utility.class, new Property$3('--tw-gradient-to', handler.createColorValue('var(--tw-to-opacity, 1)')))) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'gradientColorStops', pluginOrder$1.gradientColorStops, 5, true);
    }
}
// https://windicss.org/utilities/borders.html#border-radius
function borderRadius(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var raw = ['rounded', 'rounded-t', 'rounded-l', 'rounded-r', 'rounded-b', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'].includes(utility.raw) ? utility.raw + '-DEFAULT' : utility.raw;
    utility = utility.clone(raw);
    var directions = expandDirection(((_b = raw.match(/rounded-[trbl][trbl]?-/)) === null || _b === void 0 ? void 0 : _b[0].slice(8, -1)) || '', true);
    if (!directions)
        return;
    return (_c = utility.handler
        .handleStatic(theme('borderRadius'))
        .handleSquareBrackets()
        .handleFraction()
        .handleNxl(function (number) { return number * 0.5 + "rem"; })
        .handleSize()
        .handleVariable()
        .createProperty(directions[0] === '*' ? 'border-radius' : directions.map(function (i) { return "border-" + i + "-radius"; }))) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'borderRadius', pluginOrder$1.borderRadius, -(directions[0] === '*' ? 3 : directions.length), true);
}
// https://windicss.org/utilities/borders.html#border-width
// https://windicss.org/utilities/borders.html#border-color
// https://windicss.org/utilities/borders.html#border-opacity
function border(utility, _a) {
    var _b, _c, _d, _e, _f, _g;
    var theme = _a.theme;
    // handle border opacity
    if (utility.raw.startsWith('border-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('borderOpacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-border-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'borderOpacity', pluginOrder$1.borderOpacity, 1, true);
    }
    // handle border color
    var borderColor = (_c = utility.handler
        .handleColor(theme('borderColor'))
        .handleOpacity(theme('borderOpacity'))
        .handleSquareBrackets(notNumberLead)
        .handleVariable(function (variable) { return utility.raw.startsWith('border-$') ? "var(--" + variable + ")" : undefined; })
        .createColorStyle(utility.class, 'border-color', '--tw-border-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'borderColor', pluginOrder$1.borderColor, 2, true);
    if (borderColor)
        return borderColor;
    // handle border width
    var directions = (_d = expandDirection(utility.raw.substring(7, 8), false)) !== null && _d !== void 0 ? _d : ['*'];
    var borders = toType(theme('borderWidth'), 'object');
    var raw = ['border', 'border-t', 'border-r', 'border-b', 'border-l'].includes(utility.raw) ? utility.raw + "-" + ((_e = borders.DEFAULT) !== null && _e !== void 0 ? _e : '1px') : utility.raw;
    // handle border side color
    var borderSide = utility.clone(raw.slice(7)).handler
        .handleColor(theme('borderColor'))
        .handleOpacity(theme('borderOpacity'));
    if (borderSide.value || borderSide.color) {
        if (borderSide.opacity) {
            return new Property$3("border-" + directions[0] + "-color", borderSide.createColorValue(borderSide.opacity)).updateMeta('utilities', 'borderColor', pluginOrder$1.borderColor, 4, true);
        }
        return (_f = borderSide.createColorStyle(utility.class, "border-" + directions[0] + "-color", '--tw-border-opacity')) === null || _f === void 0 ? void 0 : _f.updateMeta('utilities', 'borderColor', pluginOrder$1.borderColor, 3, true);
    }
    utility = utility.clone(raw);
    return (_g = utility.handler
        .handleStatic(borders)
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'int', function (number) { return /^border(-[tlbr])?$/.test(utility.key) ? number + "px" : undefined; })
        .handleSize()
        .handleVariable()
        .createProperty(directions[0] === '*' ? 'border-width' : directions.map(function (i) { return "border-" + i + "-width"; }))) === null || _g === void 0 ? void 0 : _g.updateMeta('utilities', 'borderWidth', pluginOrder$1.borderWidth, (directions[0] === '*' ? 1 : (directions.length + 1)), true);
}
// https://windicss.org/utilities/borders.html#divide-width
// https://windicss.org/utilities/borders.html#divide-color
// https://windicss.org/utilities/borders.html#divide-opacity
// https://windicss.org/utilities/borders.html#divide-style
function divide$2(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    // handle divide style
    if (['solid', 'dashed', 'dotted', 'double', 'none'].includes(utility.amount))
        return new Property$3('border-style', utility.amount).toStyle(utility.class).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideStyle', pluginOrder$1.divideStyle, 1, true);
    // handle divide opacity
    if (utility.raw.startsWith('divide-opacity'))
        return (_b = utility.handler
            .handleStatic(theme('divideOpacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-divide-opacity')) === null || _b === void 0 ? void 0 : _b.toStyle(utility.class).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideOpacity', pluginOrder$1.divideOpacity, 1, true);
    // handle divide color
    var divideColor = (_c = utility.handler
        .handleColor(theme('divideColor'))
        .handleOpacity(theme('divideOpacity'))
        .handleVariable(function (variable) { return utility.raw.startsWith('divide-$') ? "var(--" + variable + ")" : undefined; })
        .createColorStyle(utility.class, 'border-color', '--tw-divide-opacity')) === null || _c === void 0 ? void 0 : _c.child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideColor', pluginOrder$1.divideColor, 0, true);
    if (divideColor)
        return divideColor;
    // handle divide width
    switch (utility.raw) {
        case 'divide-x-reverse':
            return new Style$3(utility.class, new Property$3('--tw-divide-x-reverse', '1')).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 6, true);
        case 'divide-y-reverse':
            return new Style$3(utility.class, new Property$3('--tw-divide-y-reverse', '1')).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 5, true);
        case 'divide-y':
            return new Style$3(utility.class, [
                new Property$3('--tw-divide-y-reverse', '0'),
                new Property$3('border-top-width', 'calc(1px * calc(1 - var(--tw-divide-y-reverse)))'),
                new Property$3('border-bottom-width', 'calc(1px * var(--tw-divide-y-reverse))'),
            ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 3, true);
        case 'divide-x':
            return new Style$3(utility.class, [
                new Property$3('--tw-divide-x-reverse', '0'),
                new Property$3('border-right-width', 'calc(1px * var(--tw-divide-x-reverse))'),
                new Property$3('border-left-width', 'calc(1px * calc(1 - var(--tw-divide-x-reverse)))'),
            ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 4, true);
    }
    return utility.handler
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'float', function (number) { return number + "px"; })
        .handleSize()
        .handleVariable()
        .callback(function (value) {
        var centerMatch = utility.raw.match(/^-?divide-[x|y]/);
        if (centerMatch) {
            var center = centerMatch[0].replace(/^-?divide-/, '');
            switch (center) {
                case 'x':
                    return new Style$3(utility.class, [
                        new Property$3('--tw-divide-x-reverse', '0'),
                        new Property$3('border-right-width', "calc(" + value + " * var(--tw-divide-x-reverse))"),
                        new Property$3('border-left-width', "calc(" + value + " * calc(1 - var(--tw-divide-x-reverse)))"),
                    ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 2, true);
                case 'y':
                    return new Style$3(utility.class, [
                        new Property$3('--tw-divide-y-reverse', '0'),
                        new Property$3('border-top-width', "calc(" + value + " * calc(1 - var(--tw-divide-y-reverse)))"),
                        new Property$3('border-bottom-width', "calc(" + value + " * var(--tw-divide-y-reverse))"),
                    ]).child('> :not([hidden]) ~ :not([hidden])').updateMeta('utilities', 'divideWidth', pluginOrder$1.divideWidth, 1, true);
            }
        }
    });
}
// https://windicss.org/utilities/borders.html#ring-offset-width
// https://windicss.org/utilities/borders.html#ring-offset-color
function ringOffset(utility, _a) {
    var _b, _c, _d;
    var theme = _a.theme;
    var value;
    // handle ring offset width variable
    if (utility.raw.startsWith('ringOffset-width-$')) {
        value = utility.handler.handleVariable().value;
        if (value)
            return new Property$3('--tw-ring-offset-width', value).toStyle(utility.class.replace('ringOffset', 'ring-offset')).updateMeta('utilities', 'ringOffsetWidth', pluginOrder$1.ringOffsetWidth, 2, true);
    }
    if (utility.raw.startsWith('ringOffset-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-ring-offset-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'ringOffsetColor', pluginOrder$1.ringOffsetColor, 2, true);
    }
    // handle ring offset color || ring offset width
    return ((_c = utility.handler
        .handleColor(theme('ringOffsetColor'))
        .handleOpacity('ringOpacity')
        .handleVariable()
        .handleSquareBrackets()
        .createColorStyle(utility.class.replace('ringOffset', 'ring-offset'), '--tw-ring-offset-color', '--tw-ring-offset-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'ringOffsetColor', pluginOrder$1.ringOffsetColor, 1, true))
        || ((_d = utility.handler
            .handleStatic(theme('ringOffsetWidth'))
            .handleSquareBrackets(isNumberLead)
            .handleNumber(0, undefined, 'float', function (number) { return number + "px"; })
            .handleSize()
            .createStyle(utility.class.replace('ringOffset', 'ring-offset'), function (value) { return new Property$3('--tw-ring-offset-width', value); })) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'ringOffsetWidth', pluginOrder$1.ringOffsetWidth, 1, true));
}
// https://windicss.org/utilities/borders.html#ring-width
// https://windicss.org/utilities/borders.html#ring-color
// https://windicss.org/utilities/borders.html#ring-opacity
function ring$1(utility, utils) {
    var _a, _b, _c;
    // handle ring offset
    if (utility.raw.startsWith('ring-offset'))
        return ringOffset(utility.clone(utility.raw.replace('ring-offset', 'ringOffset')), utils);
    // handle ring opacity
    if (utility.raw.startsWith('ring-opacity'))
        return (_a = utility.handler
            .handleStatic(utils.theme('ringOpacity'))
            .handleSquareBrackets()
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-ring-opacity')) === null || _a === void 0 ? void 0 : _a.updateMeta('utilities', 'ringOpacity', pluginOrder$1.ringOpacity, 1, true);
    // handle ring color
    var ringColor = (_b = utility.handler
        .handleColor(utils.theme('ringColor'))
        .handleOpacity(utils.theme('ringOpacity'))
        .handleSquareBrackets(notNumberLead)
        .handleVariable(function (variable) { return utility.raw.startsWith('ring-$') ? "var(--" + variable + ")" : undefined; })
        .createColorStyle(utility.class, '--tw-ring-color', '--tw-ring-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'ringColor', pluginOrder$1.ringColor, 0, true);
    if (ringColor)
        return ringColor;
    // handle ring width
    if (utility.raw === 'ring-inset')
        return new Property$3('--tw-ring-inset', 'inset').updateMeta('utilities', 'ringWidth', pluginOrder$1.ringWidth, 3, true);
    var value = utility.raw === 'ring'
        ? ((_c = toType(utils.theme('ringWidth.DEFAULT'), 'string')) !== null && _c !== void 0 ? _c : '3px')
        : utility.handler
            .handleStatic(utils.theme('ringWidth'))
            .handleSquareBrackets()
            .handleNumber(0, undefined, 'float', function (number) { return number + "px"; })
            .handleSize()
            .handleVariable()
            .value;
    if (!value)
        return;
    return new Style$3(utility.class, [
        new Property$3('--tw-ring-offset-shadow', 'var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)'),
        new Property$3('--tw-ring-shadow', "var(--tw-ring-inset) 0 0 0 calc(" + value + " + var(--tw-ring-offset-width)) var(--tw-ring-color)"),
        new Property$3(['-webkit-box-shadow', 'box-shadow'], 'var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)'),
    ]).updateMeta('utilities', 'ringWidth', pluginOrder$1.ringWidth, (utility.raw === 'ring' ? 1 : 2), true);
}
// https://windicss.org/utilities/filters.html#filter-blur
function blur(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (utility.raw === 'blur')
        utility.raw = 'blur-DEFAULT';
    return (_b = utility.handler
        .handleBody(theme('blur'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'int', function (number) { return number + "px"; })
        .handleSize()
        .createProperty('--tw-blur', function (value) { return "blur(" + value + ")"; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'blur', pluginOrder$1.blur, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-brightness
function brightness(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('brightness'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'int', function (number) { return "" + number / 100; })
        .createProperty('--tw-brightness', function (value) { return "brightness(" + value + ")"; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'brightness', pluginOrder$1.brightness, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-contrast
function contrast(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('contrast'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'int', function (number) { return "" + number / 100; })
        .createProperty('--tw-contrast', function (value) { return "contrast(" + value + ")"; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'contrast', pluginOrder$1.contrast, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-drop-shadow
function dropShadow(utility, _a) {
    var theme = _a.theme;
    var value;
    if (utility.raw === 'drop-shadow') {
        value = theme('dropShadow.DEFAULT', ['0 1px 2px rgba(0, 0, 0, 0.1)', '0 1px 1px rgba(0, 0, 0, 0.06)']);
    }
    else {
        var dropShadows = theme('dropShadow');
        var amount = utility.amount;
        if (utility.raw.startsWith('drop-shadow') && amount in dropShadows)
            value = dropShadows[amount];
    }
    if (value)
        return new Property$3('--tw-drop-shadow', Array.isArray(value) ? value.map(function (i) { return "drop-shadow(" + i + ")"; }).join(' ') : "drop-shadow(" + value + ")").updateMeta('utilities', 'dropShadow', pluginOrder$1.dropShadow, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-grayscale
function grayscale(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (utility.raw === 'grayscale')
        utility.raw = 'grayscale-DEFAULT';
    return (_b = utility.handler
        .handleBody(theme('grayscale'))
        .handleSquareBrackets()
        .handleNumber(0, 100, 'int', function (number) { return "" + number / 100; })
        .createProperty('--tw-grayscale', function (value) { return "grayscale(" + value + ")"; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'grayscale', pluginOrder$1.grayscale, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-hue-rotate
function hueRotate(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('hueRotate'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'float', function (number) { return number + "deg"; })
        .handleNegative()
        .createProperty('--tw-hue-rotate', function (value) { return "hue-rotate(" + value + ")"; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'hueRotate', pluginOrder$1.hueRotate, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-invert
function invert(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (utility.raw === 'invert')
        utility.raw = 'invert-DEFAULT';
    return (_b = utility.handler
        .handleBody(theme('invert'))
        .handleSquareBrackets()
        .handleNumber(0, 100, 'int', function (number) { return "" + number / 100; })
        .createProperty('--tw-invert', function (value) { return "invert(" + value + ")"; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'invert', pluginOrder$1.invert, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-saturate
function saturate(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('saturate'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'int', function (number) { return "" + number / 100; })
        .createProperty('--tw-saturate', function (value) { return "saturate(" + value + ")"; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'saturate', pluginOrder$1.saturate, 1, true);
}
// https://windicss.org/utilities/filters.html#filter-sepia
function sepia(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (utility.raw === 'sepia')
        utility.raw = 'sepia-DEFAULT';
    return (_b = utility.handler
        .handleBody(theme('sepia'))
        .handleSquareBrackets()
        .handleNumber(0, 100, 'int', function (number) { return "" + number / 100; })
        .createProperty('--tw-sepia', function (value) { return "sepia(" + value + ")"; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'sepia', pluginOrder$1.sepia, 1, true);
}
// https://windicss.org/utilities/filters.html#backdrop-filter
// https://windicss.org/utilities/filters.html#backdrop-blur
// https://windicss.org/utilities/filters.html#backdrop-brightness
// https://windicss.org/utilities/filters.html#backdrop-contrast
// https://windicss.org/utilities/filters.html#backdrop-grayscale
// https://windicss.org/utilities/filters.html#backdrop-hue-rotate
// https://windicss.org/utilities/filters.html#backdrop-invert
// https://windicss.org/utilities/filters.html#backdrop-opacity
// https://windicss.org/utilities/filters.html#backdrop-saturate
// https://windicss.org/utilities/filters.html#backdrop-sepia
function backdrop(utility, _a) {
    var _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var theme = _a.theme;
    utility = utility.clone(utility.raw.slice(9));
    switch (utility.match(/[^-]+/)) {
        case 'blur':
            if (utility.raw === 'blur')
                utility.raw = 'blur-DEFAULT';
            return (_b = utility.handler
                .handleBody(theme('backdropBlur'))
                .handleSquareBrackets()
                .handleNumber(0, undefined, 'int', function (number) { return number + "px"; })
                .handleSize()
                .createProperty('--tw-backdrop-blur', function (value) { return "blur(" + value + ")"; })) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'backdropBlur', pluginOrder$1.backdropBlur, 1, true);
        case 'brightness':
            return (_c = utility.handler
                .handleBody(theme('backdropBrightness'))
                .handleSquareBrackets()
                .handleNumber(0, undefined, 'int', function (number) { return "" + number / 100; })
                .createProperty('--tw-backdrop-brightness', function (value) { return "brightness(" + value + ")"; })) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'backdropBrightness', pluginOrder$1.backdropBrightness, 1, true);
        case 'contrast':
            return (_d = utility.handler
                .handleBody(theme('backdropContrast'))
                .handleSquareBrackets()
                .handleNumber(0, undefined, 'int', function (number) { return "" + number / 100; })
                .createProperty('--tw-backdrop-contrast', function (value) { return "contrast(" + value + ")"; })) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'backdropContrast', pluginOrder$1.backdropContrast, 1, true);
        case 'grayscale':
            if (utility.raw === 'grayscale')
                utility.raw = 'grayscale-DEFAULT';
            return (_e = utility.handler
                .handleBody(theme('backdropGrayscale'))
                .handleSquareBrackets()
                .handleNumber(0, 100, 'int', function (number) { return "" + number / 100; })
                .createProperty('--tw-backdrop-grayscale', function (value) { return "grayscale(" + value + ")"; })) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'backdropGrayscale', pluginOrder$1.backdropGrayscale, 1, true);
        case 'hue':
            return (_f = utility.handler
                .handleBody(theme('backdropHueRotate'))
                .handleSquareBrackets()
                .handleNumber(0, undefined, 'float', function (number) { return number + "deg"; })
                .handleNegative()
                .createProperty('--tw-backdrop-hue-rotate', function (value) { return "hue-rotate(" + value + ")"; })) === null || _f === void 0 ? void 0 : _f.updateMeta('utilities', 'backdropHueRotate', pluginOrder$1.backdropHueRotate, 1, true);
        case 'invert':
            if (utility.raw === 'invert')
                utility.raw = 'invert-DEFAULT';
            return (_g = utility.handler
                .handleBody(theme('backdropInvert'))
                .handleSquareBrackets()
                .handleNumber(0, 100, 'int', function (number) { return "" + number / 100; })
                .createProperty('--tw-backdrop-invert', function (value) { return "invert(" + value + ")"; })) === null || _g === void 0 ? void 0 : _g.updateMeta('utilities', 'backdropInvert', pluginOrder$1.backdropInvert, 1, true);
        case 'opacity':
            return (_h = utility.handler
                .handleBody(theme('backdropOpacity'))
                .handleSquareBrackets()
                .handleNumber(0, 100, 'int', function (number) { return "" + number / 100; })
                .createProperty('--tw-backdrop-opacity', function (value) { return "opacity(" + value + ")"; })) === null || _h === void 0 ? void 0 : _h.updateMeta('utilities', 'backdropOpacity', pluginOrder$1.backdropOpacity, 1, true);
        case 'saturate':
            return (_j = utility.handler
                .handleBody(theme('backdropSaturate'))
                .handleSquareBrackets()
                .handleNumber(0, undefined, 'int', function (number) { return "" + number / 100; })
                .createProperty('--tw-backdrop-saturate', function (value) { return "saturate(" + value + ")"; })) === null || _j === void 0 ? void 0 : _j.updateMeta('utilities', 'backdropSaturate', pluginOrder$1.backdropSaturate, 1, true);
        case 'sepia':
            if (utility.raw === 'sepia')
                utility.raw = 'sepia-DEFAULT';
            return (_k = utility.handler
                .handleBody(theme('backdropSepia'))
                .handleSquareBrackets()
                .handleNumber(0, 100, 'int', function (number) { return "" + number / 100; })
                .createProperty('--tw-backdrop-sepia', function (value) { return "sepia(" + value + ")"; })) === null || _k === void 0 ? void 0 : _k.updateMeta('utilities', 'backdropSepia', pluginOrder$1.backdropSepia, 1, true);
    }
}
// https://windicss.org/utilities/effects.html#box-shadow
function boxShadow(utility, _a) {
    var _b;
    var theme = _a.theme;
    var body = utility.body || 'DEFAULT';
    var shadows = toType(theme('boxShadow'), 'object');
    if (Object.keys(shadows).includes(body)) {
        var shadow = shadows[body].replace(/rgba\s*\(\s*0\s*,\s*0\s*,\s*0/g, 'rgba(var(--tw-shadow-color)');
        return new Style$3(utility.class, [
            new Property$3('--tw-shadow-color', '0, 0, 0'),
            new Property$3('--tw-shadow', shadow),
            new Property$3(['-webkit-box-shadow', 'box-shadow'], 'var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)'),
        ]).updateMeta('utilities', 'boxShadow', pluginOrder$1.boxShadow, 0, true);
    }
    // handle shadowColor
    return (_b = utility.handler
        .handleColor(theme('boxShadowColor'))
        .handleOpacity(theme('opacity'))
        .handleSquareBrackets()
        .handleVariable()
        .createColorStyle(utility.class, '--tw-shadow-color', undefined, false)) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'boxShadowColor', pluginOrder$1.boxShadowColor, 0, true);
}
// https://windicss.org/utilities/effects.html#opacity
function opacity(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('opacity'))
        .handleSquareBrackets()
        .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
        .handleVariable()
        .createProperty('opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'opacity', pluginOrder$1.opacity, 0, true);
}
// https://windicss.org/utilities/transitions.html#transition-property
function transition(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var body = utility.body;
    var props = toType(theme('transitionProperty'), 'object');
    for (var _i = 0, _d = Object.entries(props); _i < _d.length; _i++) {
        var _e = _d[_i], key = _e[0], value = _e[1];
        if (body === key || (body === '' && key === 'DEFAULT')) {
            if (value === 'none')
                return new Property$3(['-webkit-transition-property', '-o-transition-property', 'transition-property'], 'none').updateMeta('utilities', 'transitionProperty', pluginOrder$1.transitionProperty, 1, true);
            return new Style$3(utility.class, [
                new Property$3('-webkit-transition-property', value.replace(/(?=(transform|box-shadow))/g, '-webkit-')),
                new Property$3('-o-transition-property', value),
                new Property$3('transition-property', value.replace(/transform/g, 'transform, -webkit-transform').replace(/box-shadow/g, 'box-shadow, -webkit-box-shadow')),
                new Property$3(['-webkit-transition-timing-function', '-o-transition-timing-function', 'transition-timing-function'], (_b = toType(theme('transitionTimingFunction.DEFAULT'), 'string')) !== null && _b !== void 0 ? _b : 'cubic-bezier(0.4, 0, 0.2, 1)'),
                new Property$3(['-webkit-transition-duration', '-o-transition-duration', 'transition-duration'], (_c = toType(theme('transitionDuration.DEFAULT'), 'string')) !== null && _c !== void 0 ? _c : '150ms'),
            ]).updateMeta('utilities', 'transitionProperty', pluginOrder$1.transitionProperty, 2, true);
        }
    }
}
// https://windicss.org/utilities/transitions.html#transition-duration
function duration(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('transitionDuration'))
        .handleSquareBrackets()
        .handleTime(0, undefined, 'float')
        .handleNumber(0, undefined, 'int', function (number) { return number + "ms"; })
        .handleVariable()
        .createProperty(['-webkit-transition-duration', '-o-transition-duration', 'transition-duration'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'transitionDuration', pluginOrder$1.transitionDuration, 1, true);
}
// https://windicss.org/utilities/transitions.html#transition-timing-function
function transitionTimingFunction(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleBody(theme('transitionTimingFunction'))
        .createProperty(['-webkit-transition-timing-function', '-o-transition-timing-function', 'transition-timing-function'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'transitionTimingFunction', pluginOrder$1.transitionTimingFunction, 1, true);
}
// https://windicss.org/utilities/transitions.html#transition-delay
function delay(utility, _a) {
    var _b;
    var theme = _a.theme;
    return (_b = utility.handler
        .handleStatic(theme('transitionDelay'))
        .handleSquareBrackets()
        .handleTime(0, undefined, 'float')
        .handleNumber(0, undefined, 'int', function (number) { return number + "ms"; })
        .handleVariable()
        .createProperty(['-webkit-transition-delay', '-o-transition-delay', 'transition-delay'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'transitionDelay', pluginOrder$1.transitionDelay, 0, true);
}
// https://windicss.org/utilities/behaviors.html#animation
function animation(utility, _a) {
    var _b, _c, _d, _e, _f;
    var theme = _a.theme, config = _a.config;
    var body = utility.body;
    if (utility.raw.startsWith('animate-ease')) {
        return (_b = utility.clone(utility.raw.slice(8)).handler
            .handleBody(theme('animationTimingFunction'))
            .handleSquareBrackets()
            .createProperty(['-webkit-animation-timing-function', 'animation-timing-function'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'animation', pluginOrder$1.animation, 20, true);
    }
    if (utility.raw.startsWith('animate-duration')) {
        return (_c = utility.clone(utility.raw.slice(8)).handler
            .handleStatic(theme('animationDuration'))
            .handleSquareBrackets()
            .handleTime(0, undefined, 'float')
            .handleNumber(0, undefined, 'int', function (number) { return number + "ms"; })
            .handleVariable()
            .createProperty(['-webkit-animation-duration', 'animation-duration'])) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'animation', pluginOrder$1.animation, 21, true);
    }
    if (utility.raw.startsWith('animate-delay')) {
        return (_d = utility.clone(utility.raw.slice(8)).handler
            .handleStatic(theme('animationDelay'))
            .handleSquareBrackets()
            .handleTime(0, undefined, 'float')
            .handleNumber(0, undefined, 'int', function (number) { return number + "ms"; })
            .handleVariable()
            .createProperty(['-webkit-animation-delay', 'animation-delay'])) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'animation', pluginOrder$1.animation, 22, true);
    }
    var animateIterationCount = utility.handler.handleBody(theme('animationIterationCount')).handleNumber(0, undefined, 'int').handleSquareBrackets().value;
    if (animateIterationCount)
        return new Property$3(['-webkit-animation-iteration-count', 'animation-iteration-count'], animateIterationCount).updateMeta('utilities', 'animation', pluginOrder$1.animation, 23, true);
    var animations = toType(theme('animation'), 'object');
    if (Object.keys(animations).includes(body)) {
        var value = animations[body];
        var prop = config('prefixer') ? ['-webkit-animation', 'animation'] : 'animation';
        if (value === 'none')
            return new Property$3(prop, 'none').updateMeta('utilities', 'animation', pluginOrder$1.animation, 1, true);
        var styles = void 0, keyframe = void 0;
        if (typeof value === 'string') {
            keyframe = (_e = value.match(/^\w+/)) === null || _e === void 0 ? void 0 : _e[0];
            styles = [new Style$3(utility.class, new Property$3(prop, value))];
        }
        else {
            keyframe = value['animation'] || value['animationName'] || value['animation-name'];
            if (config('prefixer')) {
                var props = {};
                for (var _i = 0, _g = Object.entries(value); _i < _g.length; _i++) {
                    var _h = _g[_i], k = _h[0], v = _h[1];
                    if (k.startsWith('animation') || k.startsWith('backface')) {
                        props['-webkit-' + k] = v;
                    }
                    else if (k.startsWith('transform')) {
                        props['-webkit-' + k] = v;
                        props['-ms-' + k] = v;
                    }
                    props[k] = v;
                }
                value = props;
            }
            styles = Style$3.generate(utility.class, value).map(function (i) { return i.updateMeta('utilities', 'animation', pluginOrder$1.animation, 2, true); });
        }
        if (styles) {
            return __spreadArray$5(__spreadArray$5([], styles.map(function (i) { return i.updateMeta('utilities', 'animation', pluginOrder$1.animation, 2, true); })), keyframe ? Keyframes$1.generate(keyframe, ((_f = theme("keyframes." + keyframe)) !== null && _f !== void 0 ? _f : {}), undefined, config('prefixer', false)).map(function (i) { return i.updateMeta('utilities', 'keyframes', pluginOrder$1.keyframes, 1, true); }) : []);
        }
    }
}
// https://windicss.org/utilities/transforms.html#transform-origin
function transformOrigin(utility, _a) {
    var theme = _a.theme;
    var body = utility.body;
    var origins = toType(theme('transformOrigin'), 'object');
    if (Object.keys(origins).includes(body))
        return new Property$3(['-webkit-transform-origin', '-ms-transform-origin', 'transform-origin'], origins[body]).updateMeta('utilities', 'transformOrigin', pluginOrder$1.transformOrigin, 0, true);
}
// https://windicss.org/utilities/transforms.html#transform-scale
function scale(utility, _a) {
    var theme = _a.theme;
    return utility.handler
        .handleStatic(theme('scale'))
        .handleNumber(0, undefined, 'int', function (number) { return (number / 100).toString(); })
        .handleVariable()
        .callback(function (value) {
        if (utility.raw.startsWith('scale-x'))
            return new Property$3('--tw-scale-x', value).updateMeta('utilities', 'scale', pluginOrder$1.scale, 2, true);
        if (utility.raw.startsWith('scale-y'))
            return new Property$3('--tw-scale-y', value).updateMeta('utilities', 'scale', pluginOrder$1.scale, 3, true);
        if (utility.raw.startsWith('scale-z'))
            return new Property$3('--tw-scale-z', value).updateMeta('utilities', 'scale', pluginOrder$1.scale, 4, true);
        return new Property$3(['--tw-scale-x', '--tw-scale-y', '--tw-scale-z'], value).updateMeta('utilities', 'scale', pluginOrder$1.scale, 1, true);
    });
}
// https://windicss.org/utilities/transforms.html#transform-rotate
function rotate(utility, _a) {
    var theme = _a.theme;
    return utility.handler
        .handleStatic(theme('rotate'))
        .handleSquareBrackets()
        .handleNumber(0, undefined, 'float', function (number) { return number + "deg"; })
        .handleNegative()
        .handleVariable()
        .callback(function (value) {
        var abs = utility.absolute;
        if (abs.startsWith('rotate-x'))
            return new Property$3('--tw-rotate-x', value).updateMeta('utilities', 'rotate', pluginOrder$1.rotate, 2, true);
        if (abs.startsWith('rotate-y'))
            return new Property$3('--tw-rotate-y', value).updateMeta('utilities', 'rotate', pluginOrder$1.rotate, 3, true);
        if (abs.startsWith('rotate-z'))
            return new Property$3('--tw-rotate-z', value).updateMeta('utilities', 'rotate', pluginOrder$1.rotate, 4, true);
        return new Property$3('--tw-rotate', value).updateMeta('utilities', 'rotate', pluginOrder$1.rotate, 1, true);
    });
}
// https://windicss.org/utilities/transforms.html#transform-translate
function translate(utility, _a) {
    var _b;
    var theme = _a.theme;
    var centerMatch = utility.raw.match(/^-?translate-[x|y|z]/);
    if (centerMatch) {
        var center = centerMatch[0].replace(/^-?translate-/, '');
        return (_b = utility.handler
            .handleStatic(theme('translate'))
            .handleSquareBrackets()
            .handleSpacing()
            .handleFraction()
            .handleSize()
            .handleNegative()
            .handleVariable()
            .createProperty("--tw-translate-" + center)) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'translate', pluginOrder$1.translate, utility.raw.charAt(0) === '-' ? 2 : 1, true);
    }
}
// https://windicss.org/utilities/transforms.html#transform-skew
function skew(utility, _a) {
    var _b;
    var theme = _a.theme;
    var centerMatch = utility.raw.match(/^-?skew-[x|y]/);
    if (centerMatch) {
        var center = centerMatch[0].replace(/^-?skew-/, '');
        return (_b = utility.handler
            .handleStatic(theme('skew'))
            .handleSquareBrackets()
            .handleNumber(0, undefined, 'float', function (number) { return number + "deg"; })
            .handleNegative()
            .handleVariable()
            .createProperty("--tw-skew-" + center)) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'skew', pluginOrder$1.skew, utility.raw.charAt(0) === '-' ? 2 : 1, true);
    }
}
// https://windicss.org/utilities/transforms.html#perspective
function perspective(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    if (utility.raw.startsWith('perspect-origin')) {
        var origin_1 = (_b = utility.clone('perspectOrigin' + utility.raw.slice(15)).handler
            .handleBody(theme('perspectiveOrigin'))
            .handleSquareBrackets()
            .createProperty(['-webkit-perspective-origin', 'perspective-origin'])) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'perspectiveOrigin', pluginOrder$1.perspectiveOrigin, 0, true);
        if (origin_1)
            return origin_1;
    }
    return (_c = utility.handler
        .handleStatic(theme('perspective'))
        .handleNumber(0, undefined, 'int', function (number) { return number + "px"; })
        .handleSize()
        .handleSquareBrackets()
        .createProperty(['-webkit-perspective', 'perspective'])) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'perspective', pluginOrder$1.perspective, 0, true);
}
// https://windicss.org/utilities/behaviors.html#cursor
function cursor(utility, _a) {
    var theme = _a.theme;
    var body = utility.body;
    var cursors = toType(theme('cursor'), 'object');
    if (Object.keys(cursors).includes(body))
        return new Property$3('cursor', cursors[body]).updateMeta('utilities', 'cursor', pluginOrder$1.cursor, 1, true);
}
// https://windicss.org/utilities/behaviors.html#outline
function outline(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    var amount = utility.amount;
    var staticMap = toType(theme('outline'), 'object');
    if (Object.keys(staticMap).includes(amount))
        return new Style$3(utility.class, [new Property$3('outline', staticMap[amount][0]), new Property$3('outline-offset', staticMap[amount][1])]).updateMeta('utilities', 'outline', pluginOrder$1.outline, 1, true);
    if (utility.raw.startsWith('outline-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-outline-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'outline', pluginOrder$1.outline, 4, true);
    }
    if (utility.raw.match(/^outline-(solid|dotted)/)) {
        var newUtility = utility.clone(utility.raw.replace('outline-', ''));
        var outlineColor = newUtility.handler
            .handleStatic({ none: 'transparent', white: 'white', black: 'black' })
            .handleColor()
            .handleOpacity(theme('opacity'))
            .handleVariable()
            .createColorValue('var(--tw-outline-opacity, 1)');
        if (outlineColor)
            return new Style$3(utility.class, [
                new Property$3('outline', "2px " + newUtility.identifier + " " + outlineColor),
                new Property$3('outline-offset', '2px')
            ]).updateMeta('utilities', 'outline', pluginOrder$1.outline, 3, true);
    }
    var handler = utility.handler.handleColor().handleOpacity(theme('opacity')).handleSquareBrackets().handleVariable(function (variable) { return utility.raw.startsWith('outline-$') ? "var(--" + variable + ")" : undefined; });
    var color = handler.createColorValue();
    if (color)
        return (_c = new Style$3(utility.class, [
            new Property$3('outline', "2px " + (handler.value === 'transparent' ? 'solid' : 'dotted') + " " + color),
            new Property$3('outline-offset', '2px'),
        ])) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'outline', pluginOrder$1.outline, 2, true);
}
// https://windicss.org/utilities/svg.html#fill-color
function fill$3(utility, _a) {
    var _b, _c;
    var theme = _a.theme;
    if (utility.raw.startsWith('fill-opacity')) {
        return (_b = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-fill-opacity')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'fill', pluginOrder$1.ringOffsetColor, 2, true);
    }
    return (_c = utility.handler
        .handleColor(theme('fill'))
        .handleOpacity(theme('opacity'))
        .handleSquareBrackets()
        .handleVariable()
        .createColorStyle(utility.class, 'fill', '--tw-fill-opacity')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'fill', pluginOrder$1.fill, 1, true);
}
// https://windicss.org/utilities/svg.html#stroke-color
// https://windicss.org/utilities/svg.html#stroke-width
function stroke(utility, _a) {
    var _b, _c, _d, _e, _f, _g;
    var theme = _a.theme;
    if (utility.raw.startsWith('stroke-dash')) {
        return (_b = utility.handler.handleNumber().createProperty('stroke-dasharray')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'strokeDashArray', pluginOrder$1.strokeDashArray, 0, true);
    }
    if (utility.raw.startsWith('stroke-offset')) {
        return (_c = utility.handler.handleNumber().createProperty('stroke-dashoffset')) === null || _c === void 0 ? void 0 : _c.updateMeta('utilities', 'strokeDashOffset', pluginOrder$1.strokeDashOffset, 0, true);
    }
    if (utility.raw.startsWith('stroke-opacity')) {
        return (_d = utility.handler
            .handleStatic(theme('opacity'))
            .handleNumber(0, 100, 'int', function (number) { return (number / 100).toString(); })
            .handleVariable()
            .createProperty('--tw-stroke-opacity')) === null || _d === void 0 ? void 0 : _d.updateMeta('utilities', 'stroke', pluginOrder$1.stroke, 2, true);
    }
    return ((_e = utility.handler
        .handleColor(theme('stroke'))
        .handleOpacity(theme('opacity'))
        .handleVariable()
        .handleSquareBrackets()
        .createColorStyle(utility.class, 'stroke', '--tw-stroke-opacity')) === null || _e === void 0 ? void 0 : _e.updateMeta('utilities', 'stroke', pluginOrder$1.stroke, 1, true))
        || (utility.raw.startsWith('stroke-$')
            ? (_f = utility.handler
                .handleVariable()
                .createProperty('stroke-width')) === null || _f === void 0 ? void 0 : _f.updateMeta('utilities', 'strokeWidth', pluginOrder$1.strokeWidth, 2, true)
            : (_g = utility.handler
                .handleStatic(theme('strokeWidth'))
                .handleNumber(0, undefined, 'int')
                .createProperty('stroke-width')) === null || _g === void 0 ? void 0 : _g.updateMeta('utilities', 'strokeWidth', pluginOrder$1.strokeWidth, 1, true));
}
function content(utility, _a) {
    var _b;
    var theme = _a.theme;
    if (!utility.raw.startsWith('content-'))
        return;
    return (_b = utility.handler
        .handleBody(theme('content'))
        .handleSquareBrackets()
        .handleVariable()
        .handleString(function (string) { return "\"" + string + "\""; })
        .createProperty('content')) === null || _b === void 0 ? void 0 : _b.updateMeta('utilities', 'content', pluginOrder$1.content, 1, true);
}
var dynamicUtilities$1 = {
    container: container,
    space: space,
    divide: divide$2,
    bg: background,
    from: gradientColorFrom,
    via: gradientColorVia,
    to: gradientColorTo,
    border: border,
    rounded: borderRadius,
    cursor: cursor,
    flex: flex,
    order: order$1,
    font: font,
    h: size,
    leading: lineHeight,
    list: listStyleType,
    m: margin,
    my: margin,
    mx: margin,
    mt: margin,
    mr: margin,
    mb: margin,
    ml: margin,
    min: minMaxSize,
    max: minMaxSize,
    object: objectPosition,
    opacity: opacity,
    outline: outline,
    p: padding,
    py: padding,
    px: padding,
    pt: padding,
    pr: padding,
    pb: padding,
    pl: padding,
    placeholder: placeholder,
    caret: caret$1,
    tab: tabSize,
    indent: textIndent,
    inset: inset,
    top: inset,
    right: inset,
    bottom: inset,
    left: inset,
    shadow: boxShadow,
    ring: ring$1,
    blur: blur,
    brightness: brightness,
    contrast: contrast,
    drop: dropShadow,
    grayscale: grayscale,
    hue: hueRotate,
    invert: invert,
    saturate: saturate,
    sepia: sepia,
    backdrop: backdrop,
    fill: fill$3,
    stroke: stroke,
    text: text,
    tracking: letterSpacing,
    underline: textDecoration,
    w: size,
    z: zIndex,
    gap: gap$1,
    auto: gridAuto,
    grid: gridTemplate,
    col: gridColumn,
    row: gridRow,
    origin: transformOrigin,
    scale: scale,
    rotate: rotate,
    translate: translate,
    skew: skew,
    perspect: perspective,
    transition: transition,
    ease: transitionTimingFunction,
    duration: duration,
    delay: delay,
    content: content,
    animate: animation,
};

var colors = {
    black: '#000',
    white: '#fff',
    rose: {
        50: '#fff1f2',
        100: '#ffe4e6',
        200: '#fecdd3',
        300: '#fda4af',
        400: '#fb7185',
        500: '#f43f5e',
        600: '#e11d48',
        700: '#be123c',
        800: '#9f1239',
        900: '#881337',
    },
    pink: {
        50: '#fdf2f8',
        100: '#fce7f3',
        200: '#fbcfe8',
        300: '#f9a8d4',
        400: '#f472b6',
        500: '#ec4899',
        600: '#db2777',
        700: '#be185d',
        800: '#9d174d',
        900: '#831843',
    },
    fuchsia: {
        50: '#fdf4ff',
        100: '#fae8ff',
        200: '#f5d0fe',
        300: '#f0abfc',
        400: '#e879f9',
        500: '#d946ef',
        600: '#c026d3',
        700: '#a21caf',
        800: '#86198f',
        900: '#701a75',
    },
    purple: {
        50: '#faf5ff',
        100: '#f3e8ff',
        200: '#e9d5ff',
        300: '#d8b4fe',
        400: '#c084fc',
        500: '#a855f7',
        600: '#9333ea',
        700: '#7e22ce',
        800: '#6b21a8',
        900: '#581c87',
    },
    violet: {
        50: '#f5f3ff',
        100: '#ede9fe',
        200: '#ddd6fe',
        300: '#c4b5fd',
        400: '#a78bfa',
        500: '#8b5cf6',
        600: '#7c3aed',
        700: '#6d28d9',
        800: '#5b21b6',
        900: '#4c1d95',
    },
    indigo: {
        50: '#eef2ff',
        100: '#e0e7ff',
        200: '#c7d2fe',
        300: '#a5b4fc',
        400: '#818cf8',
        500: '#6366f1',
        600: '#4f46e5',
        700: '#4338ca',
        800: '#3730a3',
        900: '#312e81',
    },
    blue: {
        50: '#eff6ff',
        100: '#dbeafe',
        200: '#bfdbfe',
        300: '#93c5fd',
        400: '#60a5fa',
        500: '#3b82f6',
        600: '#2563eb',
        700: '#1d4ed8',
        800: '#1e40af',
        900: '#1e3a8a',
    },
    lightBlue: {
        50: '#f0f9ff',
        100: '#e0f2fe',
        200: '#bae6fd',
        300: '#7dd3fc',
        400: '#38bdf8',
        500: '#0ea5e9',
        600: '#0284c7',
        700: '#0369a1',
        800: '#075985',
        900: '#0c4a6e',
    },
    sky: {
        50: '#f0f9ff',
        100: '#e0f2fe',
        200: '#bae6fd',
        300: '#7dd3fc',
        400: '#38bdf8',
        500: '#0ea5e9',
        600: '#0284c7',
        700: '#0369a1',
        800: '#075985',
        900: '#0c4a6e',
    },
    cyan: {
        50: '#ecfeff',
        100: '#cffafe',
        200: '#a5f3fc',
        300: '#67e8f9',
        400: '#22d3ee',
        500: '#06b6d4',
        600: '#0891b2',
        700: '#0e7490',
        800: '#155e75',
        900: '#164e63',
    },
    teal: {
        50: '#f0fdfa',
        100: '#ccfbf1',
        200: '#99f6e4',
        300: '#5eead4',
        400: '#2dd4bf',
        500: '#14b8a6',
        600: '#0d9488',
        700: '#0f766e',
        800: '#115e59',
        900: '#134e4a',
    },
    emerald: {
        50: '#ecfdf5',
        100: '#d1fae5',
        200: '#a7f3d0',
        300: '#6ee7b7',
        400: '#34d399',
        500: '#10b981',
        600: '#059669',
        700: '#047857',
        800: '#065f46',
        900: '#064e3b',
    },
    green: {
        50: '#f0fdf4',
        100: '#dcfce7',
        200: '#bbf7d0',
        300: '#86efac',
        400: '#4ade80',
        500: '#22c55e',
        600: '#16a34a',
        700: '#15803d',
        800: '#166534',
        900: '#14532d',
    },
    lime: {
        50: '#f7fee7',
        100: '#ecfccb',
        200: '#d9f99d',
        300: '#bef264',
        400: '#a3e635',
        500: '#84cc16',
        600: '#65a30d',
        700: '#4d7c0f',
        800: '#3f6212',
        900: '#365314',
    },
    yellow: {
        50: '#fefce8',
        100: '#fef9c3',
        200: '#fef08a',
        300: '#fde047',
        400: '#facc15',
        500: '#eab308',
        600: '#ca8a04',
        700: '#a16207',
        800: '#854d0e',
        900: '#713f12',
    },
    amber: {
        50: '#fffbeb',
        100: '#fef3c7',
        200: '#fde68a',
        300: '#fcd34d',
        400: '#fbbf24',
        500: '#f59e0b',
        600: '#d97706',
        700: '#b45309',
        800: '#92400e',
        900: '#78350f',
    },
    orange: {
        50: '#fff7ed',
        100: '#ffedd5',
        200: '#fed7aa',
        300: '#fdba74',
        400: '#fb923c',
        500: '#f97316',
        600: '#ea580c',
        700: '#c2410c',
        800: '#9a3412',
        900: '#7c2d12',
    },
    red: {
        50: '#fef2f2',
        100: '#fee2e2',
        200: '#fecaca',
        300: '#fca5a5',
        400: '#f87171',
        500: '#ef4444',
        600: '#dc2626',
        700: '#b91c1c',
        800: '#991b1b',
        900: '#7f1d1d',
    },
    warmGray: {
        50: '#fafaf9',
        100: '#f5f5f4',
        200: '#e7e5e4',
        300: '#d6d3d1',
        400: '#a8a29e',
        500: '#78716c',
        600: '#57534e',
        700: '#44403c',
        800: '#292524',
        900: '#1c1917',
    },
    trueGray: {
        50: '#fafafa',
        100: '#f5f5f5',
        200: '#e5e5e5',
        300: '#d4d4d4',
        400: '#a3a3a3',
        500: '#737373',
        600: '#525252',
        700: '#404040',
        800: '#262626',
        900: '#171717',
    },
    gray: {
        50: '#fafafa',
        100: '#f4f4f5',
        200: '#e4e4e7',
        300: '#d4d4d8',
        400: '#a1a1aa',
        500: '#71717a',
        600: '#52525b',
        700: '#3f3f46',
        800: '#27272a',
        900: '#18181b',
    },
    coolGray: {
        50: '#f9fafb',
        100: '#f3f4f6',
        200: '#e5e7eb',
        300: '#d1d5db',
        400: '#9ca3af',
        500: '#6b7280',
        600: '#4b5563',
        700: '#374151',
        800: '#1f2937',
        900: '#111827',
    },
    blueGray: {
        50: '#f8fafc',
        100: '#f1f5f9',
        200: '#e2e8f0',
        300: '#cbd5e1',
        400: '#94a3b8',
        500: '#64748b',
        600: '#475569',
        700: '#334155',
        800: '#1e293b',
        900: '#0f172a',
    },
    light: {
        50: '#fdfdfd',
        100: '#fcfcfc',
        200: '#fafafa',
        300: '#f8f9fa',
        400: '#f6f6f6',
        500: '#f2f2f2',
        600: '#f1f3f5',
        700: '#e9ecef',
        800: '#dee2e6',
        900: '#dde1e3',
    },
    dark: {
        50: '#4a4a4a',
        100: '#3c3c3c',
        200: '#323232',
        300: '#2d2d2d',
        400: '#222222',
        500: '#1f1f1f',
        600: '#1c1c1e',
        700: '#1b1b1b',
        800: '#181818',
        900: '#0f0f0f',
    },
};

var keyframes = {
    spin: {
        from: {
            transform: 'rotate(0deg)',
        },
        to: {
            transform: 'rotate(360deg)',
        },
    },
    ping: {
        '0%': {
            transform: 'scale(1)',
            opacity: '1',
        },
        '75%, 100%': {
            transform: 'scale(2)',
            opacity: '0',
        },
    },
    pulse: {
        '0%, 100%': {
            opacity: '1',
        },
        '50%': {
            opacity: '.5',
        },
    },
    bounce: {
        '0%, 100%': {
            transform: 'translateY(-25%)',
            animationTimingFunction: 'cubic-bezier(0.8,0,1,1)',
        },
        '50%': {
            transform: 'translateY(0)',
            animationTimingFunction: 'cubic-bezier(0,0,0.2,1)',
        },
    },
    shock: {
        'from, 20%, 53%, 80%, to': {
            animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
            transform: 'translate3d(0, 0, 0)',
        },
        '40%, 43%': {
            animationTimingFunction: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
            transform: 'translate3d(0, -30px, 0)',
        },
        '70%': {
            animationTimingFunction: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
            transform: 'translate3d(0, -15px, 0)',
        },
        '90%': {
            transform: 'translate3d(0, -4px, 0)',
        },
    },
    flash: {
        'from, 50%, to': {
            opacity: '1',
        },
        '25%, 75%': {
            opacity: '0',
        },
    },
    bubble: {
        'from': {
            transform: 'scale3d(1, 1, 1)',
        },
        '50%': {
            transform: 'scale3d(1.05, 1.05, 1.05)',
        },
        'to': {
            transform: 'scale3d(1, 1, 1)',
        },
    },
    rubberBand: {
        'from': {
            transform: 'scale3d(1, 1, 1)',
        },
        '30%': {
            transform: 'scale3d(1.25, 0.75, 1)',
        },
        '40%': {
            transform: 'scale3d(0.75, 1.25, 1)',
        },
        '50%': {
            transform: 'scale3d(1.15, 0.85, 1)',
        },
        '65%': {
            transform: 'scale3d(0.95, 1.05, 1)',
        },
        '75%': {
            transform: 'scale3d(1.05, 0.95, 1)',
        },
        'to': {
            transform: 'scale3d(1, 1, 1)',
        },
    },
    shakeX: {
        'from, to': {
            transform: 'translate3d(0, 0, 0)',
        },
        '10%, 30%, 50%, 70%, 90%': {
            transform: 'translate3d(-10px, 0, 0)',
        },
        '20%, 40%, 60%, 80%': {
            transform: 'translate3d(10px, 0, 0)',
        },
    },
    shakeY: {
        'from, to': {
            transform: 'translate3d(0, 0, 0)',
        },
        '10%, 30%, 50%, 70%, 90%': {
            transform: 'translate3d(0, -10px, 0)',
        },
        '20%, 40%, 60%, 80%': {
            transform: 'translate3d(0, 10px, 0)',
        },
    },
    headShake: {
        '0%': {
            transform: 'translateX(0)',
        },
        '6.5%': {
            transform: 'translateX(-6px) rotateY(-9deg)',
        },
        '18.5%': {
            transform: 'translateX(5px) rotateY(7deg)',
        },
        '31.5%': {
            transform: 'translateX(-3px) rotateY(-5deg)',
        },
        '43.5%': {
            transform: 'translateX(2px) rotateY(3deg)',
        },
        '50%': {
            transform: 'translateX(0)',
        },
    },
    swing: {
        '20%': {
            transform: 'rotate3d(0, 0, 1, 15deg)',
        },
        '40%': {
            transform: 'rotate3d(0, 0, 1, -10deg)',
        },
        '60%': {
            transform: 'rotate3d(0, 0, 1, 5deg)',
        },
        '80%': {
            transform: 'rotate3d(0, 0, 1, -5deg)',
        },
        'to': {
            transform: 'rotate3d(0, 0, 1, 0deg)',
        },
    },
    tada: {
        'from': {
            transform: 'scale3d(1, 1, 1)',
        },
        '10%, 20%': {
            transform: 'scale3d(0.9, 0.9, 0.9) rotate3d(0, 0, 1, -3deg)',
        },
        '30%, 50%, 70%, 90%': {
            transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, 3deg)',
        },
        '40%, 60%, 80%': {
            transform: 'scale3d(1.1, 1.1, 1.1) rotate3d(0, 0, 1, -3deg)',
        },
        'to': {
            transform: 'scale3d(1, 1, 1)',
        },
    },
    wobble: {
        'from': {
            transform: 'translate3d(0, 0, 0)',
        },
        '15%': {
            transform: 'translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg)',
        },
        '30%': {
            transform: 'translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg)',
        },
        '45%': {
            transform: 'translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg)',
        },
        '60%': {
            transform: 'translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg)',
        },
        '75%': {
            transform: 'translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    jello: {
        'from, 11.1% to': {
            transform: 'translate3d(0, 0, 0)',
        },
        '22.2%': {
            transform: 'skewX(-12.5deg) skewY(-12.5deg)',
        },
        '33.3%': {
            transform: 'skewX(6.25deg) skewY(6.25deg)',
        },
        '44.4%': {
            transform: 'skewX(-3.125deg) skewY(-3.125deg)',
        },
        '55.5%': {
            transform: 'skewX(1.5625deg) skewY(1.5625deg)',
        },
        '66.6%': {
            transform: 'skewX(-0.78125deg) skewY(-0.78125deg)',
        },
        '77.7%': {
            transform: 'skewX(0.390625deg) skewY(0.390625deg)',
        },
        '88.8%': {
            transform: 'skewX(-0.1953125deg) skewY(-0.1953125deg)',
        },
    },
    heartBeat: {
        '0%': {
            transform: 'scale(1)',
        },
        '14%': {
            transform: 'scale(1.3)',
        },
        '28%': {
            transform: 'scale(1)',
        },
        '42%': {
            transform: 'scale(1.3)',
        },
        '70%': {
            transform: 'scale(1)',
        },
    },
    hinge: {
        '0%': {
            transformOrigin: 'top left',
            animationTimingFunction: 'ease-in-out',
        },
        '20%, 60%': {
            transform: 'rotate3d(0, 0, 1, 80deg)',
            transformOrigin: 'top left',
            animationTimingFunction: 'ease-in-out',
        },
        '40%, 80%': {
            transform: 'rotate3d(0, 0, 1, 60deg)',
            transformOrigin: 'top left',
            animationTimingFunction: 'ease-in-out',
        },
        'to': {
            transform: 'translate3d(0, 700px, 0)',
            opacity: '0',
        },
    },
    jackInTheBox: {
        'from': {
            opacity: '0',
            transformOrigin: 'center bottom',
            transform: 'scale(0.1) rotate(30deg)',
        },
        '50%': {
            transform: 'rotate(-10deg)',
        },
        '70%': {
            transform: 'rotate(3deg)',
        },
        'to': {
            transform: 'scale(1)',
        },
    },
    // light speed
    lightSpeedInRight: {
        'from': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0) skewX(-30deg)',
        },
        '60%': {
            opacity: '1',
            transform: 'skewX(20deg)',
        },
        '80%': {
            transform: 'skewX(-5deg)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    lightSpeedInLeft: {
        'from': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0) skewX(-30deg)',
        },
        '60%': {
            opacity: '1',
            transform: 'skewX(20deg)',
        },
        '80%': {
            transform: 'skewX(-5deg)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    lightSpeedOutLeft: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0) skewX(30deg)',
        },
    },
    lightSpeedOutRight: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0) skewX(30deg)',
        },
    },
    // flip
    flip: {
        'from': {
            transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, -360deg)',
            animationTimingFunction: 'ease-out',
        },
        '40%': {
            transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -190deg)',
            animationTimingFunction: 'ease-out',
        },
        '50%': {
            transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 150px) rotate3d(0, 1, 0, -170deg)',
            animationTimingFunction: 'ease-in',
        },
        '80%': {
            transform: 'perspective(400px) scale3d(0.95, 0.95, 0.95) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)',
            animationTimingFunction: 'ease-in',
        },
        'to': {
            transform: 'perspective(400px) scale3d(1, 1, 1) translate3d(0, 0, 0) rotate3d(0, 1, 0, 0deg)',
            animationTimingFunction: 'ease-in',
        },
    },
    flipInX: {
        'from': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, 90deg)',
            animationTimingFunction: 'ease-in',
            opacity: '0',
        },
        '40%': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, -20deg)',
            animationTimingFunction: 'ease-in',
        },
        '60%': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, 10deg)',
            opacity: '1',
        },
        '80%': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, -5deg)',
        },
        'to': {
            transform: 'perspective(400px)',
        },
    },
    flipInY: {
        'from': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, 90deg)',
            animationTimingFunction: 'ease-in',
            opacity: '0',
        },
        '40%': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, -20deg)',
            animationTimingFunction: 'ease-in',
        },
        '60%': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, 10deg)',
            opacity: '1',
        },
        '80%': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, -5deg)',
        },
        'to': {
            transform: 'perspective(400px)',
        },
    },
    flipOutX: {
        'from': {
            transform: 'perspective(400px)',
        },
        '30%': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, -20deg)',
            opacity: '1',
        },
        'to': {
            transform: 'perspective(400px) rotate3d(1, 0, 0, 90deg)',
            opacity: '0',
        },
    },
    flipOutY: {
        'from': {
            transform: 'perspective(400px)',
        },
        '30%': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, -15deg)',
            opacity: '1',
        },
        'to': {
            transform: 'perspective(400px) rotate3d(0, 1, 0, 90deg)',
            opacity: '0',
        },
    },
    // rotate in
    rotateIn: {
        'from': {
            transformOrigin: 'center',
            transform: 'rotate3d(0, 0, 1, -200deg)',
            opacity: '0',
        },
        'to': {
            transformOrigin: 'center',
            transform: 'translate3d(0, 0, 0)',
            opacity: '1',
        },
    },
    rotateInDownLeft: {
        'from': {
            transformOrigin: 'left bottom',
            transform: 'rotate3d(0, 0, 1, -45deg)',
            opacity: '0',
        },
        'to': {
            transformOrigin: 'left bottom',
            transform: 'translate3d(0, 0, 0)',
            opacity: '1',
        },
    },
    rotateInDownRight: {
        'from': {
            transformOrigin: 'right bottom',
            transform: 'rotate3d(0, 0, 1, 45deg)',
            opacity: '0',
        },
        'to': {
            transformOrigin: 'right bottom',
            transform: 'translate3d(0, 0, 0)',
            opacity: '1',
        },
    },
    rotateInUpLeft: {
        'from': {
            transformOrigin: 'left top',
            transform: 'rotate3d(0, 0, 1, 45deg)',
            opacity: '0',
        },
        'to': {
            transformOrigin: 'left top',
            transform: 'translate3d(0, 0, 0)',
            opacity: '1',
        },
    },
    rotateInUpRight: {
        'from': {
            transformOrigin: 'right bottom',
            transform: 'rotate3d(0, 0, 1, -90deg)',
            opacity: '0',
        },
        'to': {
            transformOrigin: 'right bottom',
            transform: 'translate3d(0, 0, 0)',
            opacity: '1',
        },
    },
    rotateOut: {
        'from': {
            transformOrigin: 'center',
            opacity: '1',
        },
        'to': {
            transformOrigin: 'center',
            transform: 'rotate3d(0, 0, 1, 200deg)',
            opacity: '0',
        },
    },
    rotateOutDownLeft: {
        'from': {
            transformOrigin: 'left bottom',
            opacity: '1',
        },
        'to': {
            transformOrigin: 'left bottom',
            transform: 'rotate3d(0, 0, 1, 45deg)',
            opacity: '0',
        },
    },
    rotateOutDownRight: {
        'from': {
            transformOrigin: 'right bottom',
            opacity: '1',
        },
        'to': {
            transformOrigin: 'right bottom',
            transform: 'rotate3d(0, 0, 1, -45deg)',
            opacity: '0',
        },
    },
    rotateOutUpLeft: {
        'from': {
            transformOrigin: 'left bottom',
            opacity: '1',
        },
        'to': {
            transformOrigin: 'left bottom',
            transform: 'rotate3d(0, 0, 1, -45deg)',
            opacity: '0',
        },
    },
    rotateOutUpRight: {
        'from': {
            transformOrigin: 'right bottom',
            opacity: '1',
        },
        'to': {
            transformOrigin: 'left bottom',
            transform: 'rotate3d(0, 0, 1, 90deg)',
            opacity: '0',
        },
    },
    // roll
    rollIn: {
        'from': {
            opacity: '0',
            transform: 'translate3d(-100%, 0, 0) rotate3d(0, 0, 1, -120deg)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    rollOut: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0) rotate3d(0, 0, 1, 120deg)',
        },
    },
    // zoom in
    zoomIn: {
        'from': {
            opacity: '0',
            transform: 'scale3d(0.3, 0.3, 0.3)',
        },
        '50%': {
            opacity: '1',
        },
    },
    zoomInDown: {
        'from': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, -1000px, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        '60%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    zoomInLeft: {
        'from': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(-1000px, 0, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        '60%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(10px, 0, 0)',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    zoomInRight: {
        'from': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(1000px, 0, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        '60%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(-10px, 0, 0)',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    zoomInUp: {
        'from': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, 1000px, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        '60%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    // bounce in
    bounceIn: {
        'from, 20%, 40%, 60%, 80%, to': {
            animationTimingFunction: 'ease-in-out',
        },
        '0%': {
            opacity: '0',
            transform: 'scale3d(0.3, 0.3, 0.3)',
        },
        '20%': {
            transform: 'scale3d(1.1, 1.1, 1.1)',
        },
        '40%': {
            transform: 'scale3d(0.9, 0.9, 0.9)',
        },
        '60%': {
            transform: 'scale3d(1.03, 1.03, 1.03)',
            opacity: '1',
        },
        '80%': {
            transform: 'scale3d(0.97, 0.97, 0.97)',
        },
        'to': {
            opacity: '1',
            transform: 'scale3d(1, 1, 1)',
        },
    },
    bounceInDown: {
        'from, 60%, 75%, 90%, to': {
            animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
        },
        '0%': {
            opacity: '0',
            transform: 'translate3d(0, -3000px, 0)',
        },
        '60%': {
            opacity: '1',
            transform: 'translate3d(0, 25px, 0)',
        },
        '75%': {
            transform: 'translate3d(0, -10px, 0)',
        },
        '90%': {
            transform: 'translate3d(0, 5px, 0)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    bounceInLeft: {
        'from, 60%, 75%, 90%, to': {
            animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
        },
        '0%': {
            opacity: '0',
            transform: 'translate3d(-3000px, 0, 0)',
        },
        '60%': {
            opacity: '1',
            transform: 'translate3d(25px, 0, 0)',
        },
        '75%': {
            transform: 'translate3d(-10px, 0, 0)',
        },
        '90%': {
            transform: 'translate3d(5px, 0, 0)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    bounceInRight: {
        'from, 60%, 75%, 90%, to': {
            animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
        },
        '0%': {
            opacity: '0',
            transform: 'translate3d(3000px, 0, 0)',
        },
        '60%': {
            opacity: '1',
            transform: 'translate3d(-25px, 0, 0)',
        },
        '75%': {
            transform: 'translate3d(10px, 0, 0)',
        },
        '90%': {
            transform: 'translate3d(-5px, 0, 0)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    bounceInUp: {
        'from, 60%, 75%, 90%, to': {
            animationTimingFunction: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
        },
        '0%': {
            opacity: '0',
            transform: 'translate3d(0, 3000px, 0)',
        },
        '60%': {
            opacity: '1',
            transform: 'translate3d(0, -20px, 0)',
        },
        '75%': {
            transform: 'translate3d(0, 10px, 0)',
        },
        '90%': {
            transform: 'translate3d(0, -5px, 0)',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    // bounce out
    bounceOut: {
        '20%': {
            transform: 'scale3d(0.9, 0.9, 0.9)',
        },
        '50%, 55%': {
            opacity: '1',
            transform: 'scale3d(1.1, 1.1, 1.1)',
        },
        'to': {
            opacity: '0',
            transform: 'scale3d(0.3, 0.3, 0.3)',
        },
    },
    bounceOutDown: {
        '20%': {
            transform: 'translate3d(0, 10px, 0)',
        },
        '40%, 45%': {
            opacity: '1',
            transform: 'translate3d(0, -20px, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, 2000px, 0)',
        },
    },
    bounceOutLeft: {
        '20%': {
            opacity: '1',
            transform: 'translate3d(20px, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(-2000px, 0, 0)',
        },
    },
    bounceOutRight: {
        '20%': {
            opacity: '1',
            transform: 'translate3d(-20px, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(2000px, 0, 0)',
        },
    },
    bounceOutUp: {
        '20%': {
            transform: 'translate3d(0, -10px, 0)',
        },
        '40%, 45%': {
            opacity: '1',
            transform: 'translate3d(0, 20px, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, -2000px, 0)',
        },
    },
    // zoom out
    zoomOut: {
        'from': {
            opacity: '1',
        },
        '50%': {
            opacity: '0',
            transform: 'scale3d(0.3, 0.3, 0.3)',
        },
        'to': {
            opacity: '0',
        },
    },
    zoomOutDown: {
        '40%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, -60px, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        'to': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, 2000px, 0)',
            transformOrigin: 'center bottom',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    zoomOutLeft: {
        '40%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(42px, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'scale(0.1) translate3d(-2000px, 0, 0)',
            transformOrigin: 'left center',
        },
    },
    zoomOutRight: {
        '40%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(-42px, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'scale(0.1) translate3d(2000px, 0, 0)',
            transformOrigin: 'right center',
        },
    },
    zoomOutUp: {
        '40%': {
            opacity: '1',
            transform: 'scale3d(0.475, 0.475, 0.475) translate3d(0, 60px, 0)',
            animationTimingFunction: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
        },
        'to': {
            opacity: '0',
            transform: 'scale3d(0.1, 0.1, 0.1) translate3d(0, -2000px, 0)',
            transformOrigin: 'center bottom',
            animationTimingFunction: 'cubic-bezier(0.175, 0.885, 0.32, 1)',
        },
    },
    // slide in
    slideInDown: {
        'from': {
            transform: 'translate3d(0, -100%, 0)',
            visibility: 'visible',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    slideInLeft: {
        'from': {
            transform: 'translate3d(-100%, 0, 0)',
            visibility: 'visible',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    slideInRight: {
        'from': {
            transform: 'translate3d(100%, 0, 0)',
            visibility: 'visible',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    slideInUp: {
        'from': {
            transform: 'translate3d(0, 100%, 0)',
            visibility: 'visible',
        },
        'to': {
            transform: 'translate3d(0, 0, 0)',
        },
    },
    // slide out
    slideOutDown: {
        'from': {
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            visibility: 'hidden',
            transform: 'translate3d(0, 100%, 0)',
        },
    },
    slideOutLeft: {
        'from': {
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            visibility: 'hidden',
            transform: 'translate3d(-100%, 0, 0)',
        },
    },
    slideOutRight: {
        'from': {
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            visibility: 'hidden',
            transform: 'translate3d(100%, 0, 0)',
        },
    },
    slideOutUp: {
        'from': {
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            visibility: 'hidden',
            transform: 'translate3d(0, -100%, 0)',
        },
    },
    // fade in
    fadeIn: {
        'from': {
            opacity: '0',
        },
        'to': {
            opacity: '1',
        },
    },
    fadeInDown: {
        'from': {
            opacity: '0',
            transform: 'translate3d(0, -100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInDownBig: {
        'from': {
            opacity: '0',
            transform: 'translate3d(0, -2000px, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInLeft: {
        'from': {
            opacity: '0',
            transform: 'translate3d(-100%, 0, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInLeftBig: {
        'from': {
            opacity: '0',
            transform: 'translate3d(-2000px, 0, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInRight: {
        'from': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInRightBig: {
        'from': {
            opacity: '0',
            transform: 'translate3d(2000px, 0, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInUp: {
        'from': {
            opacity: '0',
            transform: 'translate3d(0, 100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInUpBig: {
        'from': {
            opacity: '0',
            transform: 'translate3d(0, 2000px, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInTopLeft: {
        'from': {
            opacity: '0',
            transform: 'translate3d(-100%, -100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInTopRight: {
        'from': {
            opacity: '0',
            transform: 'translate3d(100%, -100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInBottomLeft: {
        'from': {
            opacity: '0',
            transform: 'translate3d(-100%, 100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    fadeInBottomRight: {
        'from': {
            opacity: '0',
            transform: 'translate3d(100%, 100%, 0)',
        },
        'to': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
    },
    // fade out
    fadeOut: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
        },
    },
    fadeOutDown: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, 100%, 0)',
        },
    },
    fadeOutDownBig: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, 2000px, 0)',
        },
    },
    fadeOutLeft: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(-100%, 0, 0)',
        },
    },
    fadeOutLeftBig: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(-2000px, 0, 0)',
        },
    },
    fadeOutRight: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, 0, 0)',
        },
    },
    fadeOutRightBig: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(2000px, 0, 0)',
        },
    },
    fadeOutUp: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, -100%, 0)',
        },
    },
    fadeOutUpBig: {
        'from': {
            opacity: '1',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(0, -2000px, 0)',
        },
    },
    fadeOutTopLeft: {
        'from': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(-100%, -100%, 0)',
        },
    },
    fadeOutTopRight: {
        'from': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, -100%, 0)',
        },
    },
    fadeOutBottomLeft: {
        'from': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(-100%, 100%, 0)',
        },
    },
    fadeOutBottomRight: {
        'from': {
            opacity: '1',
            transform: 'translate3d(0, 0, 0)',
        },
        'to': {
            opacity: '0',
            transform: 'translate3d(100%, 100%, 0)',
        },
    },
    // back in
    backInUp: {
        '0%': {
            opacity: '0.7',
            transform: 'translateY(1200px) scale(0.7)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '1',
            transform: 'scale(1)',
        },
    },
    backInDown: {
        '0%': {
            opacity: '0.7',
            transform: 'translateY(-1200px) scale(0.7)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '1',
            transform: 'scale(1)',
        },
    },
    backInLeft: {
        '0%': {
            opacity: '0.7',
            transform: 'translateX(-2000px) scale(0.7)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateX(0px) scale(0.7)',
        },
        '100%': {
            opacity: '1',
            transform: 'scale(1)',
        },
    },
    backInRight: {
        '0%': {
            opacity: '0.7',
            transform: 'translateX(2000px) scale(0.7)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '1',
            transform: 'scale(1)',
        },
    },
    // back out
    backOutUp: {
        '0%': {
            opacity: '1',
            transform: 'scale(1)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '0.7',
            transform: 'translateY(-700px) scale(0.7)',
        },
    },
    backOutDown: {
        '0%': {
            opacity: '1',
            transform: 'scale(1)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '0.7',
            transform: 'translateY(700px) scale(0.7)',
        },
    },
    backOutLeft: {
        '0%': {
            opacity: '1',
            transform: 'scale(1)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateX(-2000px) scale(0.7)',
        },
        '100%': {
            opacity: '0.7',
            transform: 'translateY(-700px) scale(0.7)',
        },
    },
    backOutRight: {
        '0%': {
            opacity: '1',
            transform: 'scale(1)',
        },
        '80%': {
            opacity: '0.7',
            transform: 'translateY(0px) scale(0.7)',
        },
        '100%': {
            opacity: '0.7',
            transform: 'translateX(2000px) scale(0.7)',
        },
    },
};

var defaultColors = {
    transparent: 'transparent',
    current: 'currentColor',
    light: colors.light,
    dark: colors.dark,
    black: colors.black,
    white: colors.white,
    gray: colors.coolGray,
    red: colors.red,
    yellow: colors.amber,
    green: colors.emerald,
    blue: colors.blue,
    indigo: colors.indigo,
    purple: colors.violet,
    pink: colors.pink,
    rose: colors.rose,
    fuchsia: colors.fuchsia,
    violet: colors.violet,
    cyan: colors.cyan,
    teal: colors.teal,
    emerald: colors.emerald,
    lime: colors.lime,
    amber: colors.amber,
    orange: colors.orange,
    'light-blue': colors.lightBlue,
    'warm-gray': colors.warmGray,
    'true-gray': colors.trueGray,
    'cool-gray': colors.coolGray,
    'blue-gray': colors.blueGray,
};
var baseConfig = {
    // purge: [],
    presets: [],
    prefixer: true,
    attributify: false,
    darkMode: 'class',
    theme: {
        screens: {
            sm: '640px',
            md: '768px',
            lg: '1024px',
            xl: '1280px',
            '2xl': '1536px',
        },
        colors: defaultColors,
        spacing: {
            px: '1px',
            0: '0px',
            0.5: '0.125rem',
            1: '0.25rem',
            1.5: '0.375rem',
            2: '0.5rem',
            2.5: '0.625rem',
            3: '0.75rem',
            3.5: '0.875rem',
            4: '1rem',
            5: '1.25rem',
            6: '1.5rem',
            7: '1.75rem',
            8: '2rem',
            9: '2.25rem',
            10: '2.5rem',
            11: '2.75rem',
            12: '3rem',
            14: '3.5rem',
            16: '4rem',
            20: '5rem',
            24: '6rem',
            28: '7rem',
            32: '8rem',
            36: '9rem',
            40: '10rem',
            44: '11rem',
            48: '12rem',
            52: '13rem',
            56: '14rem',
            60: '15rem',
            64: '16rem',
            72: '18rem',
            80: '20rem',
            96: '24rem',
            // float -> float/4 rem
        },
        animation: {
            none: 'none',
            spin: 'spin 1s linear infinite',
            ping: 'ping 1s cubic-bezier(0, 0, 0.2, 1) infinite',
            pulse: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
            bounce: 'bounce 1s infinite',
            'shock': {
                animation: 'shock',
                transformOrigin: 'center bottom',
            },
            'flash': 'flash',
            'bubble': 'bubble',
            'rubber-band': 'rubberBand',
            'shake-x': 'shakeX',
            'shake-y': 'shakeY',
            'head-shake': 'headShake 1s ease-in-out',
            'swing': {
                animation: 'swing',
                transformOrigin: 'top center',
            },
            'tada': 'tada',
            'wobble': 'wobble',
            'jello': 'jello',
            'heart-beat': 'heartBeat 1s ease-in-out',
            'hinge': 'hinge 2s',
            'jack-in': 'jackInTheBox',
            'light-speed-in-left': 'lightSpeedInLeft',
            'light-speed-in-right': 'lightSpeedInRight',
            'light-speed-out-left': 'lightSpeedOutLeft',
            'light-speed-out-right': 'lightSpeedOutRight',
            'flip': {
                animation: 'flip',
                backfaceVisibility: 'visible',
            },
            'flip-in-x': {
                animation: 'flipInX',
                backfaceVisibility: 'visible',
            },
            'flip-in-y': {
                animation: 'flipInY',
                backfaceVisibility: 'visible',
            },
            'flip-out-x': {
                animation: 'flipOutX',
                backfaceVisibility: 'visible',
            },
            'flip-out-y': {
                animation: 'flipOutY',
                backfaceVisibility: 'visible',
            },
            'rotate-in': 'rotateIn',
            'rotate-in-down-left': 'rotateInDownLeft',
            'rotate-in-down-right': 'rotateInDownRight',
            'rotate-in-up-left': 'rotateInUpLeft',
            'rotate-in-up-right': 'rotateInUpRight',
            'rotate-out': 'rotateOut',
            'rotate-out-down-left': 'rotateOutDownLeft',
            'rotate-out-down-right': 'rotateOutDownRight',
            'rotate-out-up-left': 'rotateOutUpLeft',
            'rotate-out-up-right': 'rotateOutUpRight',
            'roll-in': 'rollIn',
            'roll-out': 'rollOut',
            'zoom-in': 'zoomIn',
            'zoom-in-down': 'zoomInDown',
            'zoom-in-left': 'zoomInLeft',
            'zoom-in-right': 'zoomInRight',
            'zoom-in-up': 'zoomInUp',
            'bounce-in': 'bounceIn 750ms',
            'bounce-in-down': 'bounceInDown',
            'bounce-in-left': 'bounceInLeft',
            'bounce-in-right': 'bounceInRight',
            'bounce-in-up': 'bounceInUp',
            'bounce-out': 'bounceOut 750ms',
            'bounce-out-down': 'bounceOutDown',
            'bounce-out-left': 'bounceOutLeft',
            'bounce-out-right': 'bounceOutRight',
            'bounce-out-up': 'bounceOutUp',
            'zoom-out': 'zoomOut',
            'zoom-out-down': 'zoomOutDown',
            'zoom-out-left': 'zoomOutLeft',
            'zoom-out-right': 'zoomOutRight',
            'zoom-out-up': 'zoomOutUp',
            'slide-in-down': 'slideInDown',
            'slide-in-left': 'slideInLeft',
            'slide-in-right': 'slideInRight',
            'slide-in-up': 'slideInUp',
            'slide-out-down': 'slideOutDown',
            'slide-out-left': 'slideOutLeft',
            'slide-out-right': 'slideOutRight',
            'slide-out-up': 'slideOutUp',
            'fade-in': 'fadeIn',
            'fade-in-down': 'fadeInDown',
            'fade-in-down-big': 'fadeInDownBig',
            'fade-in-left': 'fadeInLeft',
            'fade-in-left-big': 'fadeInLeftBig',
            'fade-in-right': 'fadeInRight',
            'fade-in-right-big': 'fadeInRightBig',
            'fade-in-up': 'fadeInUp',
            'fade-in-up-big': 'fadeInUpBig',
            'fade-in-top-left': 'fadeInTopLeft',
            'fade-in-top-right': 'fadeInTopRight',
            'fade-in-bottom-left': 'fadeInBottomLeft',
            'fade-in-bottom-right': 'fadeInBottomRight',
            'fade-out': 'fadeOut',
            'fade-out-down': 'fadeOutDown',
            'fade-out-down-big': 'fadeOutDownBig',
            'fade-out-left': 'fadeOutLeft',
            'fade-out-left-big': 'fadeOutLeftBig',
            'fade-out-right': 'fadeOutRight',
            'fade-out-right-big': 'fadeOutRightBig',
            'fade-out-up': 'fadeOutUp',
            'fade-out-up-big': 'fadeOutUpBig',
            'back-in-up': 'backInUp',
            'back-in-down': 'backInDown',
            'back-in-left': 'backInLeft',
            'back-in-right': 'backInRight',
            'back-out-up': 'backOutUp',
            'back-out-down': 'backOutDown',
            'back-out-left': 'backOutLeft',
            'back-out-right': 'backOutRight',
        },
        animationDuration: {
            DEFAULT: '1000ms',
            75: '75ms',
            100: '100ms',
            150: '150ms',
            200: '200ms',
            300: '300ms',
            500: '500ms',
            700: '700ms',
            1000: '1000ms',
            1500: '1500ms',
            2000: '2000ms',
            2500: '2500ms',
            3000: '3000ms',
            // int >=0 -> int ms
        },
        animationDelay: {
            DEFAULT: '500ms',
            75: '75ms',
            100: '100ms',
            150: '150ms',
            200: '200ms',
            300: '300ms',
            500: '500ms',
            700: '700ms',
            1000: '1000ms',
            1500: '1500ms',
            2000: '2000ms',
            2500: '2500ms',
            3000: '3000ms',
            // int >=0 -> int ms
        },
        animationIterationCount: {
            DEFAULT: '1',
            loop: 'infinite',
            'repeat-1': '1',
            'repeat-2': '2',
            'repeat-3': '3',
            'repeat-4': '4',
            'repeat-5': '5',
            'repeat-6': '6',
            'repeat-7': '7',
            'repeat-8': '8',
            'repeat-9': '9',
            'repeat-10': '10',
            'repeat-11': '11',
            'repeat-12': '12',
        },
        animationTimingFunction: {
            DEFAULT: 'ease',
            linear: 'linear',
            in: 'ease-in',
            out: 'ease-out',
            'in-out': 'ease-in-out',
        },
        backdropBlur: function (theme) { return theme('blur'); },
        backdropBrightness: function (theme) { return theme('brightness'); },
        backdropContrast: function (theme) { return theme('contrast'); },
        backdropGrayscale: function (theme) { return theme('grayscale'); },
        backdropHueRotate: function (theme) { return theme('hueRotate'); },
        backdropInvert: function (theme) { return theme('invert'); },
        backdropOpacity: function (theme) { return theme('opacity'); },
        backdropSaturate: function (theme) { return theme('saturate'); },
        backdropSepia: function (theme) { return theme('sepia'); },
        backgroundColor: function (theme) { return theme('colors'); },
        backgroundImage: {
            none: 'none',
            'gradient-1': 'linear-gradient(135deg, #FDEB71 10%, #F8D800 100%)',
            'gradient-2': 'linear-gradient(135deg, #ABDCFF 10%, #0396FF 100%)',
            'gradient-3': 'linear-gradient(135deg, #FEB692 10%, #EA5455 100%)',
            'gradient-4': 'linear-gradient(135deg, #CE9FFC 10%, #7367F0 100%)',
            'gradient-5': 'linear-gradient(135deg, #90F7EC 10%, #32CCBC 100%)',
            'gradient-6': 'linear-gradient(135deg, #FFF6B7 10%, #F6416C 100%)',
            'gradient-7': 'linear-gradient(135deg, #81FBB8 10%, #28C76F 100%)',
            'gradient-8': 'linear-gradient(135deg, #E2B0FF 10%, #9F44D3 100%)',
            'gradient-9': 'linear-gradient(135deg, #F97794 10%, #623AA2 100%)',
            'gradient-10': 'linear-gradient(135deg, #FCCF31 10%, #F55555 100%)',
            'gradient-11': 'linear-gradient(135deg, #F761A1 10%, #8C1BAB 100%)',
            'gradient-12': 'linear-gradient(135deg, #43CBFF 10%, #9708CC 100%)',
            'gradient-13': 'linear-gradient(135deg, #5EFCE8 10%, #736EFE 100%)',
            'gradient-14': 'linear-gradient(135deg, #FAD7A1 10%, #E96D71 100%)',
            'gradient-15': 'linear-gradient(135deg, #FFD26F 10%, #3677FF 100%)',
            'gradient-16': 'linear-gradient(135deg, #A0FE65 10%, #FA016D 100%)',
            'gradient-17': 'linear-gradient(135deg, #FFDB01 10%, #0E197D 100%)',
            'gradient-18': 'linear-gradient(135deg, #FEC163 10%, #DE4313 100%)',
            'gradient-19': 'linear-gradient(135deg, #92FFC0 10%, #002661 100%)',
            'gradient-20': 'linear-gradient(135deg, #EEAD92 10%, #6018DC 100%)',
            'gradient-21': 'linear-gradient(135deg, #F6CEEC 10%, #D939CD 100%)',
            'gradient-22': 'linear-gradient(135deg, #52E5E7 10%, #130CB7 100%)',
            'gradient-23': 'linear-gradient(135deg, #F1CA74 10%, #A64DB6 100%)',
            'gradient-24': 'linear-gradient(135deg, #E8D07A 10%, #5312D6 100%)',
            'gradient-25': 'linear-gradient(135deg, #EECE13 10%, #B210FF 100%)',
            'gradient-26': 'linear-gradient(135deg, #79F1A4 10%, #0E5CAD 100%)',
            'gradient-27': 'linear-gradient(135deg, #FDD819 10%, #E80505 100%)',
            'gradient-28': 'linear-gradient(135deg, #FFF3B0 10%, #CA26FF 100%)',
            'gradient-29': 'linear-gradient(135deg, #FFF5C3 10%, #9452A5 100%)',
            'gradient-30': 'linear-gradient(135deg, #F05F57 10%, #360940 100%)',
            'gradient-31': 'linear-gradient(135deg, #2AFADF 10%, #4C83FF 100%)',
            'gradient-32': 'linear-gradient(135deg, #FFF886 10%, #F072B6 100%)',
            'gradient-33': 'linear-gradient(135deg, #97ABFF 10%, #123597 100%)',
            'gradient-34': 'linear-gradient(135deg, #F5CBFF 10%, #C346C2 100%)',
            'gradient-35': 'linear-gradient(135deg, #FFF720 10%, #3CD500 100%)',
            'gradient-36': 'linear-gradient(135deg, #FF6FD8 10%, #3813C2 100%)',
            'gradient-37': 'linear-gradient(135deg, #EE9AE5 10%, #5961F9 100%)',
            'gradient-38': 'linear-gradient(135deg, #FFD3A5 10%, #FD6585 100%)',
            'gradient-39': 'linear-gradient(135deg, #C2FFD8 10%, #465EFB 100%)',
            'gradient-40': 'linear-gradient(135deg, #FD6585 10%, #0D25B9 100%)',
            'gradient-41': 'linear-gradient(135deg, #FD6E6A 10%, #FFC600 100%)',
            'gradient-42': 'linear-gradient(135deg, #65FDF0 10%, #1D6FA3 100%)',
            'gradient-43': 'linear-gradient(135deg, #6B73FF 10%, #000DFF 100%)',
            'gradient-44': 'linear-gradient(135deg, #FF7AF5 10%, #513162 100%)',
            'gradient-45': 'linear-gradient(135deg, #F0FF00 10%, #58CFFB 100%)',
            'gradient-46': 'linear-gradient(135deg, #FFE985 10%, #FA742B 100%)',
            'gradient-47': 'linear-gradient(135deg, #FFA6B7 10%, #1E2AD2 100%)',
            'gradient-48': 'linear-gradient(135deg, #FFAA85 10%, #B3315F 100%)',
            'gradient-49': 'linear-gradient(135deg, #72EDF2 10%, #5151E5 100%)',
            'gradient-50': 'linear-gradient(135deg, #FF9D6C 10%, #BB4E75 100%)',
            'gradient-51': 'linear-gradient(135deg, #F6D242 10%, #FF52E5 100%)',
            'gradient-52': 'linear-gradient(135deg, #69FF97 10%, #00E4FF 100%)',
            'gradient-53': 'linear-gradient(135deg, #3B2667 10%, #BC78EC 100%)',
            'gradient-54': 'linear-gradient(135deg, #70F570 10%, #49C628 100%)',
            'gradient-55': 'linear-gradient(135deg, #3C8CE7 10%, #00EAFF 100%)',
            'gradient-56': 'linear-gradient(135deg, #FAB2FF 10%, #1904E5 100%)',
            'gradient-57': 'linear-gradient(135deg, #81FFEF 10%, #F067B4 100%)',
            'gradient-58': 'linear-gradient(135deg, #FFA8A8 10%, #FCFF00 100%)',
            'gradient-59': 'linear-gradient(135deg, #FFCF71 10%, #2376DD 100%)',
            'gradient-60': 'linear-gradient(135deg, #FF96F9 10%, #C32BAC 100%)',
            'gradient-to-t': 'linear-gradient(to top, var(--tw-gradient-stops))',
            'gradient-to-tr': 'linear-gradient(to top right, var(--tw-gradient-stops))',
            'gradient-to-r': 'linear-gradient(to right, var(--tw-gradient-stops))',
            'gradient-to-br': 'linear-gradient(to bottom right, var(--tw-gradient-stops))',
            'gradient-to-b': 'linear-gradient(to bottom, var(--tw-gradient-stops))',
            'gradient-to-bl': 'linear-gradient(to bottom left, var(--tw-gradient-stops))',
            'gradient-to-l': 'linear-gradient(to left, var(--tw-gradient-stops))',
            'gradient-to-tl': 'linear-gradient(to top left, var(--tw-gradient-stops))',
        },
        backgroundOpacity: function (theme) { return theme('opacity'); },
        backgroundPosition: {
            bottom: 'bottom',
            center: 'center',
            left: 'left',
            'left-bottom': 'left bottom',
            'left-top': 'left top',
            right: 'right',
            'right-bottom': 'right bottom',
            'right-top': 'right top',
            top: 'top',
        },
        backgroundSize: {
            auto: 'auto',
            cover: 'cover',
            contain: 'contain',
        },
        blur: {
            DEFAULT: '8px',
            0: '0',
            sm: '4px',
            md: '12px',
            lg: '16px',
            xl: '24px',
            '2xl': '40px',
            '3xl': '64px',
        },
        borderColor: function (theme) {
            var _a;
            return (__assign$3({ DEFAULT: theme('colors.gray.200', 'currentColor') }, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})));
        },
        borderOpacity: function (theme) { return theme('opacity'); },
        borderRadius: {
            DEFAULT: '0.25rem',
            none: '0px',
            sm: '0.125rem',
            md: '0.375rem',
            lg: '0.5rem',
            xl: '0.75rem',
            '2xl': '1rem',
            '3xl': '1.5rem',
            // nxl
            '1': '100%',
            full: '9999px',
        },
        borderWidth: {
            DEFAULT: '1px',
            0: '0px',
            2: '2px',
            4: '4px',
            8: '8px',
            // int >=0 -> int px
        },
        boxShadow: {
            DEFAULT: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
            sm: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
            md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
            lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
            xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
            '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
            inner: 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)',
            none: 'none',
        },
        boxShadowColor: function (theme) { return theme('colors'); },
        brightness: {
            0: '0',
            50: '.5',
            75: '.75',
            90: '.9',
            95: '.95',
            100: '1',
            105: '1.05',
            110: '1.1',
            125: '1.25',
            150: '1.5',
            200: '2',
        },
        caretColor: function (theme) {
            var _a;
            return (__assign$3({ auto: 'auto' }, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})));
        },
        caretOpacity: function (theme) { return theme('opacity'); },
        container: {},
        content: {
            DEFAULT: '""',
            'open-quote': 'open-quote',
            'close-quote': 'close-quote',
            'open-square': '"["',
            'close-square': '"]"',
            'open-curly': '"{"',
            'close-curly': '"}"',
            'open-bracket': '"("',
            'close-bracket': '")"',
        },
        contrast: {
            0: '0',
            50: '.5',
            75: '.75',
            100: '1',
            125: '1.25',
            150: '1.5',
            200: '2',
        },
        cursor: {
            auto: 'auto',
            default: 'default',
            pointer: 'pointer',
            wait: 'wait',
            text: 'text',
            move: 'move',
            help: 'help',
            'not-allowed': 'not-allowed',
        },
        divideColor: function (theme) { return theme('borderColor'); },
        divideOpacity: function (theme) { return theme('borderOpacity'); },
        divideWidth: function (theme) { return theme('borderWidth'); },
        dropShadow: {
            DEFAULT: ['0 1px 2px rgba(0, 0, 0, 0.1)', '0 1px 1px rgba(0, 0, 0, 0.06)'],
            sm: '0 1px 1px rgba(0,0,0,0.05)',
            md: ['0 4px 3px rgba(0, 0, 0, 0.07)', '0 2px 2px rgba(0, 0, 0, 0.06)'],
            lg: ['0 10px 8px rgba(0, 0, 0, 0.04)', '0 4px 3px rgba(0, 0, 0, 0.1)'],
            xl: ['0 20px 13px rgba(0, 0, 0, 0.03)', '0 8px 5px rgba(0, 0, 0, 0.08)'],
            '2xl': '0 25px 25px rgba(0, 0, 0, 0.15)',
            none: '0 0 #0000',
        },
        fill: function (theme) {
            var _a;
            return (__assign$3(__assign$3({}, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})), { none: 'none' }));
        },
        flex: {
            1: '1 1 0%',
            auto: '1 1 auto',
            initial: '0 1 auto',
            none: 'none',
        },
        flexGrow: {
            DEFAULT: '1',
            0: '0',
        },
        flexShrink: {
            DEFAULT: '1',
            0: '0',
        },
        fontFamily: {
            sans: [
                'ui-sans-serif',
                'system-ui',
                '-apple-system',
                'BlinkMacSystemFont',
                '"Segoe UI"',
                'Roboto',
                '"Helvetica Neue"',
                'Arial',
                '"Noto Sans"',
                'sans-serif',
                '"Apple Color Emoji"',
                '"Segoe UI Emoji"',
                '"Segoe UI Symbol"',
                '"Noto Color Emoji"',
            ],
            serif: [
                'ui-serif',
                'Georgia',
                'Cambria',
                '"Times New Roman"',
                'Times',
                'serif',
            ],
            mono: [
                'ui-monospace',
                'SFMono-Regular',
                'Menlo',
                'Monaco',
                'Consolas',
                '"Liberation Mono"',
                '"Courier New"',
                'monospace',
            ],
        },
        fontSize: {
            xs: ['0.75rem', { lineHeight: '1rem' }],
            sm: ['0.875rem', { lineHeight: '1.25rem' }],
            base: ['1rem', { lineHeight: '1.5rem' }],
            lg: ['1.125rem', { lineHeight: '1.75rem' }],
            xl: ['1.25rem', { lineHeight: '1.75rem' }],
            '2xl': ['1.5rem', { lineHeight: '2rem' }],
            '3xl': ['1.875rem', { lineHeight: '2.25rem' }],
            '4xl': ['2.25rem', { lineHeight: '2.5rem' }],
            '5xl': ['3rem', { lineHeight: '1' }],
            '6xl': ['3.75rem', { lineHeight: '1' }],
            '7xl': ['4.5rem', { lineHeight: '1' }],
            '8xl': ['6rem', { lineHeight: '1' }],
            '9xl': ['8rem', { lineHeight: '1' }],
            // nxl -> [n rem, lineHeight: 1]
        },
        fontWeight: {
            thin: '100',
            extralight: '200',
            light: '300',
            normal: '400',
            medium: '500',
            semibold: '600',
            bold: '700',
            extrabold: '800',
            black: '900',
            // int[0, 900] -> int
        },
        gap: function (theme) { return theme('spacing'); },
        gradientColorStops: function (theme) { return theme('colors'); },
        grayscale: {
            DEFAULT: '100%',
            0: '0',
        },
        gridAutoColumns: {
            auto: 'auto',
            min: 'min-content',
            max: 'max-content',
            fr: 'minmax(0, 1fr)',
        },
        gridAutoRows: {
            auto: 'auto',
            min: 'min-content',
            max: 'max-content',
            fr: 'minmax(0, 1fr)',
        },
        gridColumn: {
            auto: 'auto',
            'span-1': 'span 1 / span 1',
            'span-2': 'span 2 / span 2',
            'span-3': 'span 3 / span 3',
            'span-4': 'span 4 / span 4',
            'span-5': 'span 5 / span 5',
            'span-6': 'span 6 / span 6',
            'span-7': 'span 7 / span 7',
            'span-8': 'span 8 / span 8',
            'span-9': 'span 9 / span 9',
            'span-10': 'span 10 / span 10',
            'span-11': 'span 11 / span 11',
            'span-12': 'span 12 / span 12',
            // span-int(>=1) -> span int / span int
            'span-full': '1 / -1',
        },
        gridColumnEnd: {
            auto: 'auto',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            8: '8',
            9: '9',
            10: '10',
            11: '11',
            12: '12',
            13: '13',
            // int >=1 -> int
        },
        gridColumnStart: {
            auto: 'auto',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            8: '8',
            9: '9',
            10: '10',
            11: '11',
            12: '12',
            13: '13',
            // int >=1 -> int
        },
        gridRow: {
            auto: 'auto',
            'span-1': 'span 1 / span 1',
            'span-2': 'span 2 / span 2',
            'span-3': 'span 3 / span 3',
            'span-4': 'span 4 / span 4',
            'span-5': 'span 5 / span 5',
            'span-6': 'span 6 / span 6',
            // span-int(>=1) -> span int / span int
            'span-full': '1 / -1',
        },
        gridRowStart: {
            auto: 'auto',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            // int >=1 -> int
        },
        gridRowEnd: {
            auto: 'auto',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            // int >=1 -> int
        },
        gridTemplateColumns: {
            none: 'none',
            1: 'repeat(1, minmax(0, 1fr))',
            2: 'repeat(2, minmax(0, 1fr))',
            3: 'repeat(3, minmax(0, 1fr))',
            4: 'repeat(4, minmax(0, 1fr))',
            5: 'repeat(5, minmax(0, 1fr))',
            6: 'repeat(6, minmax(0, 1fr))',
            7: 'repeat(7, minmax(0, 1fr))',
            8: 'repeat(8, minmax(0, 1fr))',
            9: 'repeat(9, minmax(0, 1fr))',
            10: 'repeat(10, minmax(0, 1fr))',
            11: 'repeat(11, minmax(0, 1fr))',
            12: 'repeat(12, minmax(0, 1fr))',
            // int >=1 -> repeat(int, minmax(0, 1fr))
        },
        gridTemplateRows: {
            none: 'none',
            1: 'repeat(1, minmax(0, 1fr))',
            2: 'repeat(2, minmax(0, 1fr))',
            3: 'repeat(3, minmax(0, 1fr))',
            4: 'repeat(4, minmax(0, 1fr))',
            5: 'repeat(5, minmax(0, 1fr))',
            6: 'repeat(6, minmax(0, 1fr))',
            // int >=1 -> repeat(int, minmax(0, 1fr))
        },
        height: function (theme, _a) {
            var _b, _c;
            var breakpoints = _a.breakpoints;
            return (__assign$3(__assign$3(__assign$3({ auto: 'auto' }, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), { '1/2': '50%', '1/3': '33.333333%', '2/3': '66.666667%', '1/4': '25%', '2/4': '50%', '3/4': '75%', '1/5': '20%', '2/5': '40%', '3/5': '60%', '4/5': '80%', '1/6': '16.666667%', '2/6': '33.333333%', '3/6': '50%', '4/6': '66.666667%', '5/6': '83.333333%', 
                // fraction -> percent
                xs: '20rem', sm: '24rem', md: '28rem', lg: '32rem', xl: '36rem', '2xl': '42rem', '3xl': '48rem', '4xl': '56rem', '5xl': '64rem', '6xl': '72rem', '7xl': '80rem', 
                // nxl
                full: '100%', min: 'min-content', max: 'max-content', prose: '65ch', screen: '100vh' }), breakpoints((_c = theme('screens')) !== null && _c !== void 0 ? _c : {})));
        },
        hueRotate: {
            '-180': '-180deg',
            '-90': '-90deg',
            '-60': '-60deg',
            '-30': '-30deg',
            '-15': '-15deg',
            0: '0deg',
            15: '15deg',
            30: '30deg',
            60: '60deg',
            90: '90deg',
            180: '180deg',
        },
        inset: function (theme, _a) {
            var _b;
            var negative = _a.negative;
            return (__assign$3(__assign$3(__assign$3({ auto: 'auto' }, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), negative(theme('spacing'))), { '1/2': '50%', '1/3': '33.333333%', '2/3': '66.666667%', '1/4': '25%', '2/4': '50%', '3/4': '75%', full: '100%', '-1/2': '-50%', '-1/3': '-33.333333%', '-2/3': '-66.666667%', '-1/4': '-25%', '-2/4': '-50%', '-3/4': '-75%', '-full': '-100%' }));
        },
        invert: {
            DEFAULT: '100%',
            0: '0',
        },
        keyframes: keyframes,
        letterSpacing: {
            tighter: '-0.05em',
            tight: '-0.025em',
            normal: '0em',
            wide: '0.025em',
            wider: '0.05em',
            widest: '0.1em',
        },
        lineHeight: {
            none: '1',
            tight: '1.25',
            snug: '1.375',
            normal: '1.5',
            relaxed: '1.625',
            loose: '2',
            3: '.75rem',
            4: '1rem',
            5: '1.25rem',
            6: '1.5rem',
            7: '1.75rem',
            8: '2rem',
            9: '2.25rem',
            10: '2.5rem',
            // int>=0 -> int/4 rem
        },
        listStyleType: {
            none: 'none',
            circle: 'circle',
            square: 'square',
            disc: 'disc',
            decimal: 'decimal',
            'zero-decimal': 'decimal-leading-zero',
            greek: 'lower-greek',
            roman: 'lower-roman',
            alpha: 'lower-alpha',
            'upper-roman': 'upper-roman',
            'upper-alpha': 'upper-alpha',
        },
        margin: function (theme, _a) {
            var _b;
            var negative = _a.negative;
            return (__assign$3(__assign$3({ auto: 'auto' }, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), negative(theme('spacing'))));
        },
        maxHeight: function (theme, _a) {
            var _b, _c;
            var breakpoints = _a.breakpoints;
            return (__assign$3(__assign$3(__assign$3({ none: 'none' }, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), { xs: '20rem', sm: '24rem', md: '28rem', lg: '32rem', xl: '36rem', '2xl': '42rem', '3xl': '48rem', '4xl': '56rem', '5xl': '64rem', '6xl': '72rem', '7xl': '80rem', 
                // nxl
                full: '100%', min: 'min-content', max: 'max-content', prose: '65ch', screen: '100vh' }), breakpoints((_c = theme('screens')) !== null && _c !== void 0 ? _c : {})));
        },
        maxWidth: function (theme, _a) {
            var _b, _c;
            var breakpoints = _a.breakpoints;
            return (__assign$3(__assign$3(__assign$3({ none: 'none' }, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), { xs: '20rem', sm: '24rem', md: '28rem', lg: '32rem', xl: '36rem', '2xl': '42rem', '3xl': '48rem', '4xl': '56rem', '5xl': '64rem', '6xl': '72rem', '7xl': '80rem', 
                // nxl
                full: '100%', min: 'min-content', max: 'max-content', prose: '65ch', screen: '100vw' }), breakpoints((_c = theme('screens')) !== null && _c !== void 0 ? _c : {})));
        },
        minHeight: function (theme) { return theme('maxHeight'); },
        minWidth: function (theme) { return theme('maxWidth'); },
        objectPosition: {
            bottom: 'bottom',
            center: 'center',
            left: 'left',
            'left-bottom': 'left bottom',
            'left-top': 'left top',
            right: 'right',
            'right-bottom': 'right bottom',
            'right-top': 'right top',
            top: 'top',
        },
        opacity: {
            0: '0',
            5: '0.05',
            10: '0.1',
            20: '0.2',
            25: '0.25',
            30: '0.3',
            40: '0.4',
            50: '0.5',
            60: '0.6',
            70: '0.7',
            75: '0.75',
            80: '0.8',
            90: '0.9',
            95: '0.95',
            100: '1',
            // float -> float/100
        },
        order: {
            first: '-9999',
            last: '9999',
            none: '0',
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            8: '8',
            9: '9',
            10: '10',
            11: '11',
            12: '12',
            // int[1, 9999]
        },
        outline: {
            none: ['2px solid transparent', '2px'],
            // white: ['2px dotted white', '2px'],
            // black: ['2px dotted black', '2px'],
        },
        outlineColor: function (theme) { return theme('colors'); },
        padding: function (theme) { return theme('spacing'); },
        perspective: function (theme) {
            var _a;
            return (__assign$3(__assign$3({ none: 'none' }, ((_a = theme('spacing')) !== null && _a !== void 0 ? _a : {})), { xs: '20rem', sm: '24rem', md: '28rem', lg: '32rem', xl: '36rem', '2xl': '42rem', '3xl': '48rem', '4xl': '56rem', '5xl': '64rem', '6xl': '72rem', '7xl': '80rem' }));
        },
        perspectiveOrigin: {
            center: 'center',
            top: 'top',
            'top-right': 'top right',
            right: 'right',
            'bottom-right': 'bottom right',
            bottom: 'bottom',
            'bottom-left': 'bottom left',
            left: 'left',
            'top-left': 'top left',
        },
        placeholderColor: function (theme) { return theme('colors'); },
        placeholderOpacity: function (theme) { return theme('opacity'); },
        ringColor: function (theme) {
            var _a;
            return (__assign$3({ DEFAULT: theme('colors.blue.500', '#3b82f6') }, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})));
        },
        ringOffsetColor: function (theme) { return theme('colors'); },
        ringOffsetWidth: {
            0: '0px',
            1: '1px',
            2: '2px',
            4: '4px',
            8: '8px',
            // float -> float px
        },
        ringOpacity: function (theme) {
            var _a;
            return (__assign$3({ DEFAULT: '0.5' }, ((_a = theme('opacity')) !== null && _a !== void 0 ? _a : {})));
        },
        ringWidth: {
            DEFAULT: '3px',
            0: '0px',
            1: '1px',
            2: '2px',
            4: '4px',
            8: '8px',
            // float -> float px
        },
        rotate: {
            '-180': '-180deg',
            '-90': '-90deg',
            '-45': '-45deg',
            '-12': '-12deg',
            '-6': '-6deg',
            '-3': '-3deg',
            '-2': '-2deg',
            '-1': '-1deg',
            0: '0deg',
            1: '1deg',
            2: '2deg',
            3: '3deg',
            6: '6deg',
            12: '12deg',
            45: '45deg',
            90: '90deg',
            180: '180deg',
            // float[0, 360] -> float[0deg, 360deg]
            // ...negative
        },
        saturate: {
            DEFAULT: '0',
            0: '0',
            50: '.5',
            100: '1',
            150: '1.5',
            200: '2',
        },
        scale: {
            0: '0',
            50: '.5',
            75: '.75',
            90: '.9',
            95: '.95',
            100: '1',
            105: '1.05',
            110: '1.1',
            125: '1.25',
            150: '1.5',
            // int >=0 -> int/100
        },
        sepia: {
            DEFAULT: '100%',
            0: '0',
        },
        skew: {
            '-12': '-12deg',
            '-6': '-6deg',
            '-3': '-3deg',
            '-2': '-2deg',
            '-1': '-1deg',
            0: '0deg',
            1: '1deg',
            2: '2deg',
            3: '3deg',
            6: '6deg',
            12: '12deg',
            // float[0, 360] -> float[0deg, 360deg]
            // ...negative
        },
        space: function (theme, _a) {
            var negative = _a.negative;
            return (__assign$3(__assign$3({}, theme('spacing')), negative(theme('spacing'))));
        },
        stroke: function (theme) {
            var _a;
            return (__assign$3(__assign$3({}, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})), { none: 'none' }));
        },
        strokeWidth: {
            0: '0',
            1: '1',
            2: '2',
        },
        strokeDashArray: {
            0: '0',
            1: '1',
            2: '2',
        },
        strokeDashOffset: {
            0: '0',
            1: '1',
            2: '2',
        },
        tabSize: {
            DEFAULT: '4',
            0: '0',
            2: '2',
            4: '4',
            8: '8',
            // int >=0 -> int px
        },
        textColor: function (theme) { return theme('colors'); },
        textOpacity: function (theme) { return theme('opacity'); },
        textShadow: {
            DEFAULT: '0px 0px 1px rgb(0 0 0 / 20%), 0px 0px 1px rgb(1 0 5 / 10%)',
            sm: '1px 1px 3px rgb(36 37 47 / 25%)',
            md: '0px 1px 2px rgb(30 29 39 / 19%), 1px 2px 4px rgb(54 64 147 / 18%)',
            lg: '3px 3px 6px rgb(0 0 0 / 26%), 0 0 5px rgb(15 3 86 / 22%)',
            xl: '1px 1px 3px rgb(0 0 0 / 29%), 2px 4px 7px rgb(73 64 125 / 35%)',
            none: 'none',
        },
        textDecorationColor: function (theme) { return theme('colors'); },
        textDecorationOpacity: function (theme) { return theme('opacity'); },
        textDecorationLength: {
            'auto': 'auto',
            0: '0px',
            2: '2px',
            4: '4px',
            8: '8px',
        },
        textDecorationOffset: {
            'auto': 'auto',
            0: '0px',
            1: '1px',
            2: '2px',
            4: '4px',
            8: '8px',
        },
        textIndent: {
            DEFAULT: '1.5rem',
            xs: '0.5rem',
            sm: '1rem',
            md: '1.5rem',
            lg: '2rem',
            xl: '2.5rem',
            '2xl': '3rem',
            '3xl': '4rem',
        },
        textStrokeColor: function (theme) {
            var _a;
            return (__assign$3({ DEFAULT: theme('colors.gray.200', 'currentColor') }, ((_a = theme('colors')) !== null && _a !== void 0 ? _a : {})));
        },
        textStrokeWidth: {
            DEFAULT: 'medium',
            'none': '0',
            'sm': 'thin',
            'md': 'medium',
            'lg': 'thick',
        },
        transformOrigin: {
            center: 'center',
            top: 'top',
            'top-right': 'top right',
            right: 'right',
            'bottom-right': 'bottom right',
            bottom: 'bottom',
            'bottom-left': 'bottom left',
            left: 'left',
            'top-left': 'top left',
        },
        transitionDuration: {
            DEFAULT: '150ms',
            75: '75ms',
            100: '100ms',
            150: '150ms',
            200: '200ms',
            300: '300ms',
            500: '500ms',
            700: '700ms',
            1000: '1000ms',
            // int >=0 -> int ms
        },
        transitionDelay: {
            75: '75ms',
            100: '100ms',
            150: '150ms',
            200: '200ms',
            300: '300ms',
            500: '500ms',
            700: '700ms',
            1000: '1000ms',
            // int >=0 -> int ms
        },
        transitionProperty: {
            DEFAULT: 'background-color, border-color, color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter',
            none: 'none',
            all: 'all',
            colors: 'background-color, border-color, color, fill, stroke',
            opacity: 'opacity',
            shadow: 'box-shadow',
            transform: 'transform',
        },
        transitionTimingFunction: {
            DEFAULT: 'cubic-bezier(0.4, 0, 0.2, 1)',
            linear: 'linear',
            in: 'cubic-bezier(0.4, 0, 1, 1)',
            out: 'cubic-bezier(0, 0, 0.2, 1)',
            'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',
        },
        translate: function (theme, _a) {
            var _b;
            var negative = _a.negative;
            return (__assign$3(__assign$3(__assign$3({}, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), negative(theme('spacing'))), { '1/2': '50%', '1/3': '33.333333%', '2/3': '66.666667%', '1/4': '25%', '2/4': '50%', '3/4': '75%', full: '100%', '-1/2': '-50%', '-1/3': '-33.333333%', '-2/3': '-66.666667%', '-1/4': '-25%', '-2/4': '-50%', '-3/4': '-75%', '-full': '-100%' }));
        },
        width: function (theme, _a) {
            var _b, _c;
            var breakpoints = _a.breakpoints;
            return (__assign$3(__assign$3(__assign$3({ auto: 'auto' }, ((_b = theme('spacing')) !== null && _b !== void 0 ? _b : {})), { 
                // fraction -> percent
                '1/2': '50%', '1/3': '33.333333%', '2/3': '66.666667%', '1/4': '25%', '2/4': '50%', '3/4': '75%', '1/5': '20%', '2/5': '40%', '3/5': '60%', '4/5': '80%', '1/6': '16.666667%', '2/6': '33.333333%', '3/6': '50%', '4/6': '66.666667%', '5/6': '83.333333%', '1/12': '8.333333%', '2/12': '16.666667%', '3/12': '25%', '4/12': '33.333333%', '5/12': '41.666667%', '6/12': '50%', '7/12': '58.333333%', '8/12': '66.666667%', '9/12': '75%', '10/12': '83.333333%', '11/12': '91.666667%', xs: '20rem', sm: '24rem', md: '28rem', lg: '32rem', xl: '36rem', '2xl': '42rem', '3xl': '48rem', '4xl': '56rem', '5xl': '64rem', '6xl': '72rem', '7xl': '80rem', 
                // nxl
                full: '100%', min: 'min-content', max: 'max-content', prose: '65ch', screen: '100vw' }), breakpoints((_c = theme('screens')) !== null && _c !== void 0 ? _c : {})));
        },
        zIndex: {
            auto: 'auto',
            0: '0',
            10: '10',
            20: '20',
            30: '30',
            40: '40',
            50: '50',
            // int[0, 99999] ->  int[0, 99999]
            // ...negative
        },
    },
    variantOrder: variantOrder,
    plugins: [],
    handlers: {
        static: true,
        time: true,
        color: true,
        opacity: true,
        number: true,
        string: true,
        bracket: true,
        hex: true,
        nxl: true,
        fraction: true,
        size: true,
        variable: true,
        negative: true,
    },
};

// https://drafts.csswg.org/cssom/#serialize-an-identifier
function cssEscape(str) {
    var length = str.length;
    var index = -1;
    var codeUnit;
    var result = '';
    var firstCodeUnit = str.charCodeAt(0);
    while (++index < length) {
        codeUnit = str.charCodeAt(index);
        // Note: there’s no need to special-case astral symbols, surrogate
        // pairs, or lone surrogates.
        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
        // (U+FFFD).
        if (codeUnit === 0x0000) {
            result += '\uFFFD';
            continue;
        }
        // Comma
        if (codeUnit === 44) {
            result += '\\2c ';
            continue;
        }
        if (
        // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
        // U+007F, […]
        (codeUnit >= 0x0001 && codeUnit <= 0x001f) ||
            codeUnit === 0x007f ||
            // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), […]
            (index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
            // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
            (index === 1 &&
                codeUnit >= 0x0030 &&
                codeUnit <= 0x0039 &&
                firstCodeUnit === 0x002d)) {
            // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
            result += '\\' + codeUnit.toString(16) + ' ';
            continue;
        }
        if (
        // If the character is the first character and is a `-` (U+002D), and
        // there is no second character, […]
        index === 0 &&
            length === 1 &&
            codeUnit === 0x002d) {
            result += '\\' + str.charAt(index);
            continue;
        }
        // If the character is not handled by one of the above rules and is
        // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
        // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
        // U+005A), or [a-z] (U+0061 to U+007A), […]
        if (codeUnit >= 0x0080 ||
            codeUnit === 0x002d ||
            codeUnit === 0x005f ||
            (codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
            (codeUnit >= 0x0041 && codeUnit <= 0x005a) ||
            (codeUnit >= 0x0061 && codeUnit <= 0x007a)) {
            // the character itself
            result += str.charAt(index);
            continue;
        }
        // Otherwise, the escaped character.
        // https://drafts.csswg.org/cssom/#escape-a-character
        result += '\\' + str.charAt(index);
    }
    return result;
}

function combineConfig(a, b, arrayMergeDepth) {
    if (arrayMergeDepth === void 0) { arrayMergeDepth = Infinity; }
    var output = __assign$3({}, a);
    for (var _i = 0, _a = Object.entries(b); _i < _a.length; _i++) {
        var _b = _a[_i], key_of_b = _b[0], value_of_b = _b[1];
        if (key_of_b in a) {
            var value_of_a = a[key_of_b];
            if (value_of_a !== value_of_b) {
                if (value_of_b !== null && value_of_b.constructor !== Object) {
                    if (arrayMergeDepth > 0 && Array.isArray(value_of_a) && Array.isArray(value_of_b)) {
                        output[key_of_b] = __spreadArray$5(__spreadArray$5([], value_of_a), value_of_b);
                    }
                    else {
                        output[key_of_b] = value_of_b;
                    }
                }
                else if (value_of_a !== null && value_of_a.constructor === Object) {
                    output[key_of_b] = combineConfig(value_of_a, value_of_b, arrayMergeDepth - 1);
                }
                else if (Array.isArray(value_of_a)) {
                    output[key_of_b] = __spreadArray$5(__spreadArray$5([], value_of_a), Array.isArray(value_of_b) ? value_of_b : [value_of_b]);
                }
                else {
                    output[key_of_b] = __assign$3({ DEFAULT: value_of_a }, value_of_b);
                }
            }
        }
        else {
            output[key_of_b] = value_of_b;
        }
    }
    return output;
}

function diffConfig(a, b) {
    if (typeof a !== typeof b)
        return b;
    if (Array.isArray(a) && Array.isArray(b)) {
        if (JSON.stringify(a) !== JSON.stringify(b))
            return b;
        return;
    }
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        var output = {};
        for (var _i = 0, _a = Object.entries(b); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (key in a) {
                var diff = diffConfig(a[key], b[key]);
                if (diff)
                    output[key] = diff;
            }
            else {
                output[key] = value;
            }
        }
        if (Object.keys(output).length === 0)
            return;
        return output;
    }
    if (a !== b)
        return b;
}

function createHandler(handlers) {
    if (handlers === void 0) { handlers = { static: true }; }
    return function (utility, value, color) {
        var handler = {
            utility: utility,
            value: value,
            color: color,
            _amount: utility.amount,
            handleStatic: handlers.static ? function (map, callback) {
                if (handler.value)
                    return handler;
                if (map && typeof map === 'object') {
                    var knownMap = map;
                    if (knownMap.DEFAULT)
                        knownMap[handler.utility.raw] = knownMap.DEFAULT;
                    if (handler._amount in knownMap)
                        handler.value = callback
                            ? callback(handler._amount)
                            : "" + knownMap[handler._amount];
                }
                return handler;
            } : function () { return handler; },
            handleBody: handlers.static ? function (map, callback) {
                if (handler.value)
                    return handler;
                if (map && typeof map === 'object') {
                    var knownMap = map;
                    if (knownMap.DEFAULT)
                        knownMap[''] = knownMap.DEFAULT;
                    var body = handler.utility.body;
                    if (body in knownMap)
                        handler.value = callback ? callback(body) : "" + knownMap[body];
                }
                return handler;
            } : function () { return handler; },
            handleNumber: handlers.number ? function (start, end, type, callback) {
                if (start === void 0) { start = -Infinity; }
                if (end === void 0) { end = Infinity; }
                if (type === void 0) { type = 'int'; }
                if (handler.value)
                    return handler;
                if (isNumber$3(handler._amount, start, end, type))
                    handler.value = callback ? callback(+handler._amount) : handler._amount;
                return handler;
            } : function () { return handler; },
            handleTime: handlers.time ? function (start, end, type, callback) {
                if (start === void 0) { start = -Infinity; }
                if (end === void 0) { end = Infinity; }
                if (type === void 0) { type = 'int'; }
                if (handler.value)
                    return handler;
                var unit = 'ms';
                var amount = handler._amount;
                if (amount.endsWith('ms')) {
                    amount = amount.slice(0, -2);
                }
                else if (amount.endsWith('s')) {
                    unit = 's';
                    amount = amount.slice(0, -1);
                }
                else {
                    return handler;
                }
                if (isNumber$3(amount, start, end, type))
                    handler.value = callback ? callback(unit === 's' ? +amount * 1000 : +amount) : handler._amount;
                return handler;
            } : function () { return handler; },
            handleString: handlers.string ? function (callback) {
                if (handler.value)
                    return handler;
                handler.value = callback(handler.utility.body);
                return handler;
            } : function () { return handler; },
            handleSquareBrackets: handlers.bracket ? function (callback) {
                if (handler.value)
                    return handler;
                if (handler._amount[0] === '[' && handler._amount[handler._amount.length - 1] === ']') {
                    var value_1 = handler._amount.slice(1, -1).replace(/_/g, ' '); // replace _ to space
                    if (value_1.indexOf('calc(') > -1) {
                        value_1 = value_1.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, '$1 $2 ');
                    }
                    handler.value = callback
                        ? callback(value_1)
                        : value_1;
                }
                return handler;
            } : function () { return handler; },
            handleSpacing: handlers.number ? function () {
                // just a short-hand for handle spacing.
                return handler.handleNumber(0, undefined, 'float', function (number) {
                    return number === 0 ? '0px' : roundUp(number / 4, 6) + "rem";
                });
            } : function () { return handler; },
            handleNxl: handlers.nxl ? function (callback) {
                if (handler.value)
                    return handler;
                if (/^\d*xl$/.test(handler._amount))
                    handler.value = callback
                        ? callback(handler._amount === 'xl' ? 1 : parseInt(handler._amount))
                        : parseInt(handler._amount).toString();
                return handler;
            } : function () { return handler; },
            handleFraction: handlers.fraction ? function (callback) {
                if (handler.value)
                    return handler;
                if (isFraction(handler._amount))
                    handler.value = callback
                        ? callback(handler._amount)
                        : fracToPercent(handler._amount);
                return handler;
            } : function () { return handler; },
            handleSize: handlers.size ? function (callback) {
                if (handler.value)
                    return handler;
                if (isSize(handler._amount))
                    handler.value = callback ? callback(handler._amount) : handler._amount;
                return handler;
            } : function () { return handler; },
            handleVariable: handlers.variable ? function (callback) {
                if (handler.value)
                    return handler;
                var matchVariable = handler.utility.raw.match(/-\$[\w-]+/);
                if (matchVariable) {
                    var variableName = matchVariable[0].substring(2);
                    handler.value = callback ? callback(variableName) : "var(--" + variableName + ")";
                }
                return handler;
            } : function () { return handler; },
            handleColor: handlers.color ? function (map) {
                if (map === void 0) { map = defaultColors; }
                if (handler.value)
                    return handler;
                var color;
                if (map && typeof map === 'object') {
                    var colors = flatColors$2(map);
                    var body = handler.utility.raw.replace(/^ring-offset|outline-solid|outline-dotted/, 'head').replace(/^\w+-/, '');
                    var _a = splitColorGroup(body), key = _a[0], opacity = _a[1];
                    handler.opacity = opacity;
                    if (key in colors) {
                        color = colors[key];
                    }
                    else if (handlers.hex && key.startsWith('hex-')) {
                        var hex = key.slice(4);
                        if (hex2RGB$1(hex))
                            color = '#' + hex;
                    }
                    if (typeof color === 'string') {
                        handler.value = color;
                    }
                    else if (typeof color === 'function') {
                        handler.color = color;
                    }
                }
                return handler;
            } : function () { return handler; },
            handleOpacity: handlers.opacity ? function (map) {
                if (handler.opacity && typeof map === 'object') {
                    var _map = map;
                    if (handlers.static && handler.opacity in _map) {
                        handler.opacity = _map[handler.opacity];
                    }
                    else if (handlers.number && isNumber$3(handler.opacity, 0, 100, 'int')) {
                        handler.opacity = (+handler.opacity / 100).toString();
                    }
                    else if (handlers.variable && handler.opacity.charAt(0) === '$') {
                        handler.opacity = "var(--" + handler.opacity.slice(1) + ")";
                    }
                    else if (handlers.bracket && handler.opacity.charAt(0) === '[' && handler.opacity.charAt(handler.opacity.length - 1) === ']') {
                        handler.opacity = handler.opacity.slice(1, -1).replace(/_/g, ' ');
                    }
                    else {
                        handler.opacity = undefined;
                    }
                }
                return handler;
            } : function () { return handler; },
            handleNegative: handlers.negative ? function (callback) {
                if (callback === void 0) { callback = negateValue; }
                if (!handler.value)
                    return handler;
                handler.value = handler.utility.isNegative ? callback(handler.value) : handler.value;
                return handler;
            } : function () { return handler; },
            createProperty: function (name, callback) {
                if (!handler.value)
                    return;
                var value = callback ? callback(handler.value) : handler.value;
                return new Property$3(name, value);
            },
            createStyle: function (selector, callback) {
                if (!handler.value)
                    return;
                var value = callback ? callback(handler.value) : undefined;
                return new Style$3(selector, value);
            },
            createColorValue: function (opacityValue) {
                if (handler.color)
                    return handler.color({ opacityValue: opacityValue });
                if (handler.value) {
                    if (['transparent', 'currentColor', 'auto', 'none'].includes(handler.value))
                        return handler.value;
                    if (handler.value.includes('var') && opacityValue)
                        return "rgba(" + handler.value + ", " + (handler.opacity || opacityValue) + ")";
                    return opacityValue ? "rgba(" + toColor(handler.value).color + ", " + (handler.opacity || opacityValue) + ")" : "rgb(" + toColor(handler.value).color + ")";
                }
            },
            createColorStyle: function (selector, property, opacityVariable, wrapRGB) {
                if (wrapRGB === void 0) { wrapRGB = true; }
                if (handler.color) {
                    var value_2 = handler.color({ opacityVariable: opacityVariable, opacityValue: opacityVariable ? "var(" + opacityVariable + ")" : undefined });
                    if (opacityVariable) {
                        return new Style$3(selector, [
                            new Property$3(opacityVariable, handler.opacity || '1'),
                            new Property$3(property, value_2),
                        ]);
                    }
                    return new Style$3(selector, new Property$3(property, value_2));
                }
                var color = handler.value;
                if (!color)
                    return;
                if (['transparent', 'currentColor', 'auto', 'none'].includes(color) || color.includes('var'))
                    return new Style$3(selector, new Property$3(property, color));
                var rgb = toColor(color);
                if (opacityVariable) {
                    return new Style$3(selector, [
                        new Property$3(opacityVariable, handler.opacity || rgb.opacity),
                        new Property$3(property, "rgba(" + rgb.color + ", var(" + opacityVariable + "))"),
                    ]);
                }
                return new Style$3(selector, new Property$3(property, wrapRGB ? "rgb(" + rgb.color + ")" : rgb.color));
            },
            callback: function (func) {
                if (!handler.value)
                    return;
                return func(handler.value);
            },
        };
        return handler;
    };
}
var Utility = /** @class */ (function () {
    function Utility(raw, _h) {
        this.raw = raw; // -placeholder-real-gray-300
        this._h = _h;
    }
    Utility.prototype.match = function (expression) {
        var match = this.absolute.match(expression);
        return match ? match[0] : '';
    };
    Utility.prototype.clone = function (raw) {
        return new Utility(raw || this.raw, this._h);
    };
    Object.defineProperty(Utility.prototype, "class", {
        get: function () {
            return '.' + cssEscape(this.raw); // .-placeholder-real-gray-300
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "isNegative", {
        get: function () {
            return this.raw[0] === '-'; // true
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "absolute", {
        get: function () {
            return this.isNegative ? this.raw.substring(1) : this.raw;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "identifier", {
        get: function () {
            return this.match(/[^-]+/); // placeholder
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "key", {
        get: function () {
            return this.match(/^\w[-\w]+(?=-)/); // placeholder-real-gray
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "center", {
        get: function () {
            return this.match(/-.+(?=-)/).substring(1); // real-gray
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "amount", {
        get: function () {
            return this.match(/(?:[^-]+|\[[\s\S]*?\])$/); // 300
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "body", {
        get: function () {
            return this.match(/-.+/).substring(1); // real-gray-300
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Utility.prototype, "handler", {
        get: function () {
            return this._h(this);
        },
        enumerable: false,
        configurable: true
    });
    return Utility;
}());

function generateStaticStyle(processor, className, addComment) {
    if (addComment === void 0) { addComment = false; }
    // eslint-disable-next-line no-prototype-builtins
    if (!staticUtilities$1.hasOwnProperty(className))
        return;
    var style = new Style$3('.' + className);
    var comment = addComment ? className : undefined;
    var _a = staticUtilities$1[className], utility = _a.utility, meta = _a.meta;
    var _loop_1 = function (key, value) {
        style.add(Array.isArray(value)
            ? value.map(function (i) { return new Property$3(key, i, comment); })
            : new Property$3(key, value, comment));
    };
    for (var _i = 0, _b = Object.entries(utility); _i < _b.length; _i++) {
        var _c = _b[_i], key = _c[0], value = _c[1];
        _loop_1(key, value);
    }
    if (processor._plugin.core && !processor._plugin.core[meta.group])
        return;
    return style.updateMeta('utilities', meta.group, pluginOrder$1[meta.group], meta.order, true);
}
function extract(processor, className, addComment, prefix) {
    if (addComment === void 0) { addComment = false; }
    // handle static base utilities
    if (!prefix && className in staticUtilities$1)
        return generateStaticStyle(processor, className, addComment);
    if (prefix && className.startsWith(prefix)) {
        className = className.replace(new RegExp("^" + prefix), '');
        if (className in staticUtilities$1)
            return generateStaticStyle(processor, className, addComment);
    }
    // handle static plugin utilities & components
    var staticPlugins = __assign$3(__assign$3(__assign$3({}, processor._plugin.utilities), processor._plugin.components), processor._plugin.shortcuts);
    if (className in staticPlugins)
        return deepCopy$3(staticPlugins[className]);
    var utility = new Utility(className, processor._handler);
    // handle dynamic plugin utilities
    for (var _i = 0, _a = Object.entries(processor._plugin.dynamic); _i < _a.length; _i++) {
        var _b = _a[_i], key_1 = _b[0], generator = _b[1];
        if (className.match(new RegExp("^-?" + key_1))) {
            var style = generator(utility);
            if (style instanceof Property$3)
                style = style.toStyle(utility.class);
            if (style && addComment)
                Array.isArray(style)
                    ? style.map(function (i) { return i.property.forEach(function (p) { return (p.comment = className); }); })
                    : style.property.forEach(function (p) { return (p.comment = className); });
            if (style)
                return style;
        }
    }
    // handle dynamic base utilities
    var matches = className.match(/\w+/);
    var key = matches ? matches[0] : undefined;
    // eslint-disable-next-line no-prototype-builtins
    if (key && dynamicUtilities$1.hasOwnProperty(key)) {
        var style = dynamicUtilities$1[key](utility, processor.pluginUtils);
        if (!style)
            return;
        if (processor._plugin.core && !processor._plugin.core[Array.isArray(style) ? style[0].meta.group : style.meta.group])
            return;
        if (style instanceof Property$3)
            style = style.toStyle(utility.class);
        if (addComment)
            Array.isArray(style) ? style.map(function (i) { return i.property.forEach(function (p) { return (p.comment = className); }); }) : style.property.forEach(function (p) { return (p.comment = className); });
        return style;
    }
}

function testStatic(processor, className) {
    // eslint-disable-next-line no-prototype-builtins
    if (!staticUtilities$1.hasOwnProperty(className))
        return false;
    var meta = staticUtilities$1[className].meta;
    if (processor._plugin.core && !processor._plugin.core[meta.group])
        return false;
    return true;
}
function test(processor, className, prefix) {
    // handle static base utilities
    if (!prefix && className in staticUtilities$1)
        return testStatic(processor, className);
    if (prefix && className.startsWith(prefix)) {
        className = className.replace(new RegExp("^" + prefix), '');
        if (className in staticUtilities$1)
            return testStatic(processor, className);
    }
    // handle static plugin utilities & components
    var staticPlugins = __assign$3(__assign$3(__assign$3({}, processor._plugin.utilities), processor._plugin.components), processor._plugin.shortcuts);
    if (className in staticPlugins)
        return true;
    var utility = new Utility(className, processor._handler);
    // handle dynamic plugin utilities
    for (var _i = 0, _a = Object.entries(processor._plugin.dynamic); _i < _a.length; _i++) {
        var _b = _a[_i], key_1 = _b[0], generator = _b[1];
        if (className.match(new RegExp("^-?" + key_1))) {
            if (generator(utility))
                return true;
        }
    }
    // handle dynamic base utilities
    var matches = className.match(/\w+/);
    var key = matches ? matches[0] : undefined;
    // eslint-disable-next-line no-prototype-builtins
    if (key && dynamicUtilities$1.hasOwnProperty(key)) {
        var style = dynamicUtilities$1[key](utility, processor.pluginUtils);
        if (!style)
            return false;
        if (processor._plugin.core && !processor._plugin.core[Array.isArray(style) ? style[0].meta.group : style.meta.group])
            return false;
        return true;
    }
    return false;
}

function preflight(processor, html, includeBase, includeGlobal, includePlugins) {
    if (includeBase === void 0) { includeBase = true; }
    if (includeGlobal === void 0) { includeGlobal = true; }
    if (includePlugins === void 0) { includePlugins = true; }
    // Generate preflight style based on html tags.
    var globalSheet = new StyleSheet$2();
    var styleSheet = new StyleSheet$2();
    var createStyle = function (selector, properties, isGlobal) {
        if (isGlobal === void 0) { isGlobal = false; }
        var style = new Style$3(selector, undefined, false);
        var _loop_1 = function (key, value) {
            style.add(Array.isArray(value)
                ? value.map(function (v) { return new Property$3(key, v); })
                : new Property$3(key, typeof value === 'function' ? value(function (path, defaultValue) { return processor.theme(path, defaultValue); }) : value));
        };
        for (var _i = 0, _a = Object.entries(properties); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
        style.updateMeta('base', 'preflight', 0, isGlobal ? 1 : 2, true);
        return style;
    };
    var tags = html ? Array.from(new Set(html.match(/<\w+/g))).map(function (i) { return i.substring(1); }) : undefined;
    // handle base style
    includeBase && (processor.config('prefixer') ? preflights : preflights.filter(function (i) { return !i.selector || !/::?(webkit-input|-moz|-ms-input)-placeholder$/.test(i.selector); })).forEach(function (p) {
        if (includeGlobal && p.global) {
            // global style, such as * or html, body
            globalSheet.add(createStyle(p.selector, p.properties, true));
        }
        else if (tags !== undefined) {
            // only generate matched styles
            var includeTags = tags.filter(function (i) { return p.keys.includes(i); });
            if (includeTags.length > 0)
                styleSheet.add(createStyle(p.selector ? p.selector : includeTags.join(', '), p.properties));
        }
        else {
            // if no tags input, generate all styles
            styleSheet.add(createStyle(p.selector ? p.selector : p.keys.join(', '), p.properties));
        }
    });
    // handle plugin style
    if (includePlugins) {
        // base Styles
        var preflightList_1 = [];
        Object.values(processor._plugin.preflights).forEach(function (styles) {
            preflightList_1 = preflightList_1.concat(styles);
        });
        styleSheet.add(preflightList_1);
        // always generated styles
        var staticList_1 = [];
        Object.values(processor._plugin.static).forEach(function (styles) {
            staticList_1 = staticList_1.concat(styles);
        });
        styleSheet.add(staticList_1);
    }
    var result = styleSheet.combine().sort();
    return includeGlobal ? result.extend(globalSheet.combine().sort(), false) : result;
}

var createPlugin = function (plugin, config) {
    return {
        handler: plugin,
        config: config,
    };
};
createPlugin.withOptions = function (pluginFunction, configFunction) {
    if (configFunction === void 0) { configFunction = function () { return ({}); }; }
    var optionsFunction = function (options) {
        if (options === void 0) { options = {}; }
        return {
            __options: options,
            handler: pluginFunction(options),
            config: configFunction(options),
        };
    };
    optionsFunction.__isOptionsFunction = true;
    // Expose plugin dependencies so that `object-hash` returns a different
    // value if anything here changes, to ensure a rebuild is triggered.
    optionsFunction.__pluginFunction = pluginFunction;
    optionsFunction.__configFunction = configFunction;
    return optionsFunction;
};

var ClassParser = /** @class */ (function () {
    function ClassParser(classNames, separator, variants) {
        if (separator === void 0) { separator = ':'; }
        this.classNames = classNames;
        this.separator = separator;
        this.variants = variants || [];
        this.index = 0;
    }
    ClassParser.prototype._handle_group = function (removeDuplicated) {
        if (removeDuplicated === void 0) { removeDuplicated = true; }
        if (!this.classNames)
            return [];
        var preChar;
        var char;
        var group;
        var func;
        var variant;
        var variants = [];
        var variantStart = this.index + 1;
        var classStart = this.index + 1;
        var groupStart = this.index + 1;
        var important = false;
        var ignoreSpace = false;
        var ignoreBracket = false;
        var insideSquareBracket = false;
        var sepLength = this.separator.length;
        var parts = [];
        var length = this.classNames.length;
        while (this.index < length) {
            this.index++;
            char = this.classNames.charAt(this.index);
            // ignore parsing and leave content inside square brackets as-is
            if (insideSquareBracket) {
                if (' \n\t\r'.includes(char)) {
                    insideSquareBracket = false;
                }
                else {
                    if (char === ']')
                        insideSquareBracket = false;
                    continue;
                }
            }
            // handle chars
            switch (char) {
                case '!':
                    important = true;
                    break;
                case this.separator[0]:
                    if (this.classNames.slice(this.index, this.index + sepLength) === this.separator) {
                        variant = this.classNames.slice(variantStart, this.index);
                        if (variant.charAt(0) === '!')
                            variant = variant.slice(1);
                        if (this.variants.includes(variant)) {
                            variants.push(variant);
                            this.index += sepLength - 1;
                            variantStart = this.index + 1;
                            ignoreSpace = true;
                        }
                    }
                    break;
                case '[':
                    insideSquareBracket = true;
                    break;
                case '(':
                    preChar = this.classNames.charAt(this.index - 1);
                    if (preChar === '-' || (!ignoreSpace && preChar === ' ')) {
                        ignoreBracket = true;
                    }
                    else if (ignoreSpace) {
                        group = this._handle_group();
                    }
                    else {
                        func = this.classNames.slice(groupStart, this.index);
                        while (!isSpace$1(this.classNames.charAt(this.index))) {
                            this.index++;
                        }
                        this.index--;
                    }
                    ignoreSpace = false;
                    break;
                case '"':
                case '`':
                case '\'':
                case ')':
                case ' ':
                case '\n':
                case '\t':
                case '\r':
                    if (!ignoreSpace) {
                        if (groupStart !== this.index) {
                            var raw = this.classNames.slice(classStart, this.index);
                            var start = classStart - 1;
                            var end = this.index - 1;
                            if (Array.isArray(group)) {
                                parts.push({ raw: raw, start: start, end: end, variants: variants, content: group, type: 'group', important: important });
                                group = undefined;
                            }
                            else if (func) {
                                var utility = this.classNames.slice(variantStart, this.index);
                                parts.push({ raw: raw, start: start, end: end, variants: variants, content: utility, type: 'utility', important: important });
                                func = undefined;
                            }
                            else if (ignoreBracket && char === ')') {
                                // utility with bracket
                                var utility = this.classNames.slice(variantStart, this.index + 1);
                                parts.push({ raw: raw + ')', start: start, end: this.index, variants: variants, content: important ? utility.slice(1) : utility, type: 'utility', important: important });
                            }
                            else {
                                var utility = this.classNames.slice(variantStart, this.index);
                                if (utility.charAt(0) === '*') {
                                    parts.push({ raw: raw, start: start, end: end, variants: variants, content: utility.slice(1), type: 'alias', important: important });
                                }
                                else {
                                    parts.push({ raw: raw, start: start, end: end, variants: variants, content: utility.charAt(0) === '!' ? utility.slice(1) : utility, type: 'utility', important: important });
                                }
                            }
                            variants = [];
                            important = false;
                        }
                        groupStart = this.index + 1;
                        classStart = this.index + 1;
                    }
                    variantStart = this.index + 1;
                    break;
                default:
                    ignoreSpace = false;
            }
            if (char === ')') {
                if (!ignoreBracket)
                    break; // end group
                ignoreBracket = false;
            }
        }
        if (removeDuplicated) {
            var newParts_1 = [];
            var cache_1 = [];
            parts.forEach(function (item) {
                if (!cache_1.includes(item.raw)) {
                    cache_1.push(item.raw);
                    newParts_1.push(item);
                }
            });
            return newParts_1;
        }
        return parts;
    };
    ClassParser.prototype.parse = function (removeDuplicated) {
        if (removeDuplicated === void 0) { removeDuplicated = true; }
        if (!this.classNames)
            return [];
        // Turn classes into group;
        this.classNames = '(' + this.classNames + ')';
        var elements = this._handle_group(removeDuplicated);
        // Initialization, convenient for next call
        this.index = 0;
        this.classNames = this.classNames.slice(1, -1);
        return elements;
    };
    return ClassParser;
}());

/* toSource by Marcello Bastea-Forte - zlib license */
function toSource(object, replacer, indent = '  ', startingIndent = '') {
    const seen = [];
    return walk(object, replacer, indent === false ? '' : indent, startingIndent, seen);
    function walk(object, replacer, indent, currentIndent, seen) {
        const nextIndent = currentIndent + indent;
        object = replacer ? replacer(object) : object;
        switch (typeof object) {
            case 'string':
                return JSON.stringify(object);
            case 'number':
                if (object === -0) {
                    return '-0';
                }
                return String(object);
            case 'boolean':
            case 'undefined':
                return String(object);
            case 'function':
                return object.toString();
        }
        if (object === null) {
            return 'null';
        }
        if (object instanceof RegExp) {
            return object.toString();
        }
        if (object instanceof Date) {
            return `new Date(${object.getTime()})`;
        }
        if (object instanceof Set) {
            return `new Set(${walk(Array.from(object.values()), replacer, indent, nextIndent, seen)})`;
        }
        if (object instanceof Map) {
            return `new Map(${walk(Array.from(object.entries()), replacer, indent, nextIndent, seen)})`;
        }
        if (seen.indexOf(object) >= 0) {
            return '{$circularReference:1}';
        }
        seen.push(object);
        function join(elements) {
            return (indent.slice(1) +
                elements.join(',' + (indent && '\n') + nextIndent) +
                (indent ? ' ' : ''));
        }
        if (Array.isArray(object)) {
            return `[${join(object.map((element) => walk(element, replacer, indent, nextIndent, seen.slice())))}]`;
        }
        const keys = Object.keys(object);
        if (keys.length) {
            return `{${join(keys.map((key) => (legalKey(key) ? key : JSON.stringify(key)) +
                ':' +
                walk(object[key], replacer, indent, nextIndent, seen.slice())))}}`;
        }
        return '{}';
    }
}
const KEYWORD_REGEXP = /^(abstract|boolean|break|byte|case|catch|char|class|const|continue|debugger|default|delete|do|double|else|enum|export|extends|false|final|finally|float|for|function|goto|if|implements|import|in|instanceof|int|interface|long|native|new|null|package|private|protected|public|return|short|static|super|switch|synchronized|this|throw|throws|transient|true|try|typeof|undefined|var|void|volatile|while|with)$/;
function legalKey(key) {
    return (/^([a-z_$][0-9a-z_$]*|[0-9]+)$/gi.test(key) && !KEYWORD_REGEXP.test(key));
}

var dist$1 = toSource;

var Processor = /** @class */ (function () {
    function Processor(config) {
        var _this = this;
        this._variants = {};
        this._cache = {
            count: 0,
            html: [],
            attrs: [],
            classes: [],
            utilities: [],
            variants: [],
        };
        this._plugin = {
            static: {},
            dynamic: {},
            utilities: {},
            components: {},
            preflights: {},
            shortcuts: {},
            alias: {},
            completions: {},
        };
        this.pluginUtils = {
            addDynamic: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.addDynamic.apply(_this, args);
            },
            addUtilities: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.addUtilities.apply(_this, args);
            },
            addComponents: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.addComponents.apply(_this, args);
            },
            addBase: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.addBase.apply(_this, args);
            },
            addVariant: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.addVariant.apply(_this, args);
            },
            e: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.e.apply(_this, args);
            },
            prefix: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.prefix.apply(_this, args);
            },
            config: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.config.apply(_this, args);
            },
            theme: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.theme.apply(_this, args);
            },
            variants: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.variants.apply(_this, args);
            },
        };
        this.variantUtils = {
            modifySelectors: function (modifier) {
                return new Style$3().wrapSelector(function (selector) {
                    return modifier({
                        className: /^[.#]/.test(selector) ? selector.substring(1) : selector,
                    });
                });
            },
            atRule: function (name) { return new Style$3().atRule(name); },
            pseudoClass: function (name) { return new Style$3().pseudoClass(name); },
            pseudoElement: function (name) { return new Style$3().pseudoElement(name); },
            parent: function (name) { return new Style$3().parent(name); },
            child: function (name) { return new Style$3().child(name); },
        };
        this._config = this.resolveConfig(config, baseConfig);
        this._theme = this._config.theme;
        this._handler = createHandler(this._config.handlers);
        this._config.shortcuts && this.loadShortcuts(this._config.shortcuts);
        this._config.alias && this.loadAlias(this._config.alias);
    }
    Processor.prototype._resolveConfig = function (userConfig, presets) {
        var _a;
        if (presets === void 0) { presets = {}; }
        if (userConfig.presets) {
            var resolved = this._resolvePresets(userConfig.presets);
            presets = this._resolveConfig(resolved, presets);
            delete userConfig.presets;
        }
        var userTheme = userConfig.theme;
        if (userTheme)
            delete userConfig.theme;
        var extendTheme = userTheme && 'extend' in userTheme ? (_a = userTheme.extend) !== null && _a !== void 0 ? _a : {} : {};
        var theme = (presets.theme || {});
        if (userTheme) {
            if ('extend' in userTheme)
                delete userTheme.extend;
            for (var _i = 0, _b = Object.entries(userTheme); _i < _b.length; _i++) {
                var _c = _b[_i], key = _c[0], value = _c[1];
                theme[key] = typeof value === 'function' ? value : __assign$3({}, value);
            }
        }
        if (extendTheme && typeof extendTheme === 'object')
            this._reduceFunction(theme, extendTheme);
        return __assign$3(__assign$3(__assign$3({}, presets), userConfig), { theme: theme });
    };
    Processor.prototype._reduceFunction = function (theme, extendTheme) {
        var _loop_1 = function (key, value) {
            var themeValue = theme[key];
            switch (typeof themeValue) {
                case 'function':
                    theme[key] = function (theme, _a) {
                        var negative = _a.negative, breakpoints = _a.breakpoints;
                        return combineConfig(themeValue(theme, { negative: negative, breakpoints: breakpoints }), (typeof value === 'function' ? value(theme, { negative: negative, breakpoints: breakpoints }) : value !== null && value !== void 0 ? value : {}));
                    };
                    break;
                case 'object':
                    theme[key] = function (theme, _a) {
                        var negative = _a.negative, breakpoints = _a.breakpoints;
                        return combineConfig(themeValue, (typeof value === 'function' ? value(theme, { negative: negative, breakpoints: breakpoints }) : value !== null && value !== void 0 ? value : {}), 0 /* prevent fontfamily merge */);
                    };
                    break;
                default:
                    theme[key] = value;
            }
        };
        for (var _i = 0, _a = Object.entries(extendTheme); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
    };
    Processor.prototype._resolvePresets = function (presets) {
        var _this = this;
        var config = {};
        var extend = {};
        presets.forEach(function (p) {
            if (p.theme && 'extend' in p.theme && p.theme.extend) {
                _this._reduceFunction(extend, p.theme.extend);
                delete p.theme.extend;
            }
            config = _this._resolveConfig(p, config);
        });
        if (config.theme) {
            config.theme.extend = extend;
        }
        else {
            config.theme = { extend: extend };
        }
        return config;
    };
    Processor.prototype._resolveFunction = function (config) {
        var _this = this;
        var _a;
        if (!config.theme)
            return config;
        var theme = function (path, defaultValue) { return _this.theme(path, defaultValue); };
        for (var _i = 0, _b = [config.theme, 'extend' in config.theme ? (_a = config.theme.extend) !== null && _a !== void 0 ? _a : {} : {}]; _i < _b.length; _i++) {
            var dict = _b[_i];
            for (var _c = 0, _d = Object.entries(dict); _c < _d.length; _c++) {
                var _e = _d[_c], key = _e[0], value = _e[1];
                if (typeof value === 'function') {
                    dict[key] = value(theme, {
                        negative: negative$1,
                        breakpoints: breakpoints,
                    });
                }
            }
        }
        return config;
    };
    Processor.prototype._replaceStyleVariants = function (styles) {
        var _this = this;
        // @screen sm -> @screen (min-width: 640px)
        styles.forEach(function (style) {
            var _a;
            style.atRules = (_a = style.atRules) === null || _a === void 0 ? void 0 : _a.map(function (i) {
                var _a;
                if (i.match(/@screen/)) {
                    var variant = i.replace(/\s*@screen\s*/, '');
                    var atRule = (_a = _this._variants[variant]().atRules) === null || _a === void 0 ? void 0 : _a[0];
                    return atRule !== null && atRule !== void 0 ? atRule : i;
                }
                return i;
            });
        });
    };
    Processor.prototype._addPluginProcessorCache = function (type, key, styles) {
        styles = toArray$4(styles);
        this._plugin[type][key] = key in this._plugin[type]
            ? __spreadArray$5(__spreadArray$5([], this._plugin[type][key]), styles) : styles;
    };
    Processor.prototype._loadVariables = function () {
        var config = this.theme('vars');
        if (!config)
            return;
        this.addBase({ ':root': Object.assign.apply(Object, __spreadArray$5([{}], Object.keys(config).map(function (i) {
                var _a;
                return (_a = {}, _a["--" + i] = config[i], _a);
            }))) });
    };
    Processor.prototype.loadConfig = function (config) {
        this._config = this.resolveConfig(config, baseConfig);
        this._theme = this._config.theme;
        this._handler = createHandler(this._config.handlers);
        this._config.shortcuts && this.loadShortcuts(this._config.shortcuts);
        this._config.alias && this.loadAlias(this._config.alias);
        return this._config;
    };
    Processor.prototype.resolveConfig = function (config, presets) {
        var _this = this;
        var _a;
        this._config = this._resolveConfig(__assign$3(__assign$3({}, deepCopy$3(config ? config : {})), { exclude: config === null || config === void 0 ? void 0 : config.exclude }), deepCopy$3(presets)); // deep copy
        this._theme = this._config.theme; // update theme to make sure theme() function works.
        (_a = this._config.plugins) === null || _a === void 0 ? void 0 : _a.map(function (i) { return typeof i === 'function' ? ('__isOptionsFunction' in i ? _this.loadPluginWithOptions(i) : _this.loadPlugin(createPlugin(i))) : _this.loadPlugin(i); });
        this._config = this._resolveFunction(this._config);
        this._variants = __assign$3(__assign$3({}, this._variants), this.resolveVariants());
        this._cache.variants = Object.keys(this._variants);
        this._loadVariables();
        if (this._config.corePlugins)
            this._plugin.core = Array.isArray(this._config.corePlugins) ? Object.assign.apply(Object, __spreadArray$5([{}], this._config.corePlugins.map(function (i) {
                var _a;
                return (_a = {}, _a[i] = true, _a);
            }))) : __assign$3(__assign$3({}, Object.assign.apply(Object, __spreadArray$5([{}], Object.keys(pluginOrder$1).slice(Object.keys(pluginOrder$1).length / 2).map(function (i) {
                var _a;
                return (_a = {}, _a[i] = true, _a);
            })))), this._config.corePlugins);
        return this._config;
    };
    Processor.prototype.resolveVariants = function (type) {
        var variants = resolveVariants(this._config);
        if (type) {
            return variants[type];
        }
        return __assign$3(__assign$3(__assign$3({}, variants.screen), variants.theme), variants.state);
    };
    Processor.prototype.resolveStaticUtilities = function (includePlugins) {
        if (includePlugins === void 0) { includePlugins = false; }
        var staticStyles = {};
        for (var key in staticUtilities$1) {
            var style = generateStaticStyle(this, key, true);
            if (style)
                staticStyles[key] = [style];
        }
        if (!includePlugins)
            return staticStyles;
        return __assign$3(__assign$3(__assign$3({}, staticStyles), this._plugin.utilities), this._plugin.components);
    };
    Processor.prototype.resolveDynamicUtilities = function (includePlugins) {
        if (includePlugins === void 0) { includePlugins = false; }
        if (!includePlugins)
            return dynamicUtilities$1;
        return __assign$3(__assign$3({}, dynamicUtilities$1), this._plugin.dynamic);
    };
    Object.defineProperty(Processor.prototype, "allConfig", {
        get: function () {
            return this._config;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Processor.prototype, "allTheme", {
        get: function () {
            var _a;
            return ((_a = this._theme) !== null && _a !== void 0 ? _a : {});
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Processor.prototype, "allVariant", {
        get: function () {
            return this._cache.variants;
        },
        enumerable: false,
        configurable: true
    });
    Processor.prototype.wrapWithVariants = function (variants, styles) {
        var _this = this;
        // apply variant to style
        if (!Array.isArray(styles))
            styles = [styles];
        if (variants.length === 0)
            return styles;
        return styles.map(function (style) {
            if (style instanceof Keyframes$1)
                return style;
            var atrules = [];
            var wrapped = variants
                .filter(function (i) { var _a; return (_a = _this._variants) === null || _a === void 0 ? void 0 : _a[i]; })
                .map(function (i) { return _this._variants[i](); })
                .reduce(function (previousValue, currentValue) {
                var output = previousValue.extend(currentValue);
                if (previousValue.isAtrule)
                    atrules.push(previousValue.atRules[0]);
                return output;
            }, new Style$3())
                .extend(style);
            if (style instanceof Container)
                wrapped = new Container().extend(wrapped);
            if (atrules.length > 0)
                wrapped.meta.variants = atrules;
            return wrapped;
        });
    };
    Processor.prototype.removePrefix = function (className) {
        var prefix = this.config('prefix');
        return prefix ? className.replace(new RegExp("^" + prefix), '') : className;
    };
    Processor.prototype.markAsImportant = function (style, force) {
        if (force === void 0) { force = false; }
        var _important = force ? force : this.config('important', false);
        var important = typeof _important === 'string' ? _important : _important;
        if (important) {
            if (typeof important === 'string') {
                style.parent(important);
            }
            else {
                style.important = true;
                style.property.forEach(function (i) { return i.important = true; });
            }
        }
        return style;
    };
    Processor.prototype.extract = function (className, addComment, prefix) {
        if (addComment === void 0) { addComment = false; }
        return extract(this, className, addComment, prefix);
    };
    Processor.prototype.test = function (className, prefix) {
        return test(this, className, prefix);
    };
    Processor.prototype.preflight = function (html, includeBase, includeGlobal, includePlugins, ignoreProcessed) {
        if (includeBase === void 0) { includeBase = true; }
        if (includeGlobal === void 0) { includeGlobal = true; }
        if (includePlugins === void 0) { includePlugins = true; }
        if (ignoreProcessed === void 0) { ignoreProcessed = false; }
        var id;
        if (html) {
            id = hash$2(html);
            if (ignoreProcessed && this._cache.html.includes(id))
                return new StyleSheet$2();
        }
        id && ignoreProcessed && this._cache.html.push(id);
        return preflight(this, html, includeBase, includeGlobal, includePlugins);
    };
    Processor.prototype.interpret = function (classNames, ignoreProcessed, handleIgnored) {
        var _this = this;
        if (ignoreProcessed === void 0) { ignoreProcessed = false; }
        var ast = new ClassParser(classNames, this.config('separator', ':'), this._cache.variants).parse();
        var success = [];
        var ignored = [];
        var styleSheet = new StyleSheet$2();
        var _hIgnored = function (className) {
            if (handleIgnored) {
                var style = handleIgnored(className);
                if (style) {
                    styleSheet.add(style);
                    success.push(className);
                }
                else {
                    ignored.push(className);
                }
            }
            ignored.push(className);
        };
        var _gStyle = function (baseClass, variants, selector, important, prefix) {
            if (important === void 0) { important = false; }
            if (_this._config.exclude && testRegexr(selector, _this._config.exclude)) {
                // filter exclude className
                ignored.push(selector);
                return;
            }
            if (variants[0] && selector in __assign$3(__assign$3({}, _this._plugin.utilities), _this._plugin.components)) {
                // handle special selector that conflict with class parser, such as 'hover:abc'
                success.push(selector);
                styleSheet.add(deepCopy$3(_this._plugin.utilities[selector]));
                return;
            }
            var result = _this.extract(baseClass, false, prefix);
            if (result) {
                var escapedSelector_1 = '.' + cssEscape(selector);
                if (result instanceof Style$3) {
                    if (!result.meta.respectSelector)
                        result.selector = escapedSelector_1;
                    _this.markAsImportant(result, important);
                }
                else if (Array.isArray(result)) {
                    result = result.map(function (i) {
                        if (i instanceof Keyframes$1)
                            return i;
                        if (!i.meta.respectSelector)
                            i.selector = escapedSelector_1;
                        _this.markAsImportant(i, important);
                        return i;
                    });
                }
                var wrapped = _this.wrapWithVariants(variants, result);
                if (wrapped) {
                    success.push(selector);
                    styleSheet.add(wrapped);
                }
                else {
                    _hIgnored(selector);
                }
            }
            else {
                _hIgnored(selector);
            }
        };
        var _hGroup = function (obj, parentVariants) {
            if (parentVariants === void 0) { parentVariants = []; }
            var _eval = function (u) {
                if (u.type === 'group') {
                    _hGroup(u, obj.variants);
                }
                else if (u.type === 'alias' && u.content in _this._plugin.alias) {
                    _this._plugin.alias[u.content].forEach(function (i) { return _eval(i); });
                }
                else {
                    // utility
                    var variants = __spreadArray$5(__spreadArray$5(__spreadArray$5([], parentVariants), obj.variants), u.variants);
                    var important = obj.important || u.important;
                    var selector = (important ? '!' : '') + __spreadArray$5(__spreadArray$5([], variants), [u.content]).join(':');
                    typeof u.content === 'string' &&
                        _gStyle(u.content, variants, selector, important, _this.config('prefix'));
                }
            };
            Array.isArray(obj.content) && obj.content.forEach(function (u) { return _eval(u); });
        };
        var _gAst = function (ast) {
            ast.forEach(function (obj) {
                if (!(ignoreProcessed && _this._cache.utilities.includes(obj.raw))) {
                    if (ignoreProcessed)
                        _this._cache.utilities.push(obj.raw);
                    if (obj.type === 'utility') {
                        if (Array.isArray(obj.content)) ;
                        else if (obj.content) {
                            _gStyle(obj.content, obj.variants, obj.raw, obj.important, _this.config('prefix'));
                        }
                    }
                    else if (obj.type === 'group') {
                        _hGroup(obj);
                    }
                    else if (obj.type === 'alias' && obj.content in _this._plugin.alias) {
                        _gAst(_this._plugin.alias[obj.content]);
                    }
                    else {
                        _hIgnored(obj.raw);
                    }
                }
            });
        };
        _gAst(ast);
        if (!this.config('prefixer'))
            styleSheet.prefixer = false;
        return {
            success: success,
            ignored: ignored,
            styleSheet: styleSheet.sort(),
        };
    };
    Processor.prototype.validate = function (classNames) {
        var _this = this;
        var ast = new ClassParser(classNames, this.config('separator', ':'), this._cache.variants).parse();
        var success = [];
        var ignored = [];
        var _hSuccess = function (className, self, parent) {
            success.push(__assign$3(__assign$3({ className: className }, self), { parent: parent }));
        };
        var _hIgnored = function (className, self, parent) {
            ignored.push(__assign$3(__assign$3({ className: className }, self), { parent: parent }));
        };
        var _gStyle = function (baseClass, variants, selector, self, parent, prefix) {
            if (_this._config.exclude && testRegexr(selector, _this._config.exclude)) {
                // filter exclude className
                _hIgnored(selector, self, parent);
                return;
            }
            if (variants[0] && selector in __assign$3(__assign$3({}, _this._plugin.utilities), _this._plugin.components)) {
                // handle special selector that conflict with class parser, such as 'hover:abc'
                _hSuccess(selector, self, parent);
                return;
            }
            if (_this.test(baseClass, prefix) && variants.filter(function (i) { return !(i in _this._variants); }).length === 0) {
                _hSuccess(selector, self, parent);
            }
            else {
                _hIgnored(selector, self, parent);
            }
        };
        var _hGroup = function (obj, parentVariants) {
            if (parentVariants === void 0) { parentVariants = []; }
            var _eval = function (u, parent) {
                if (u.type === 'group') {
                    _hGroup(u, obj.variants);
                }
                else if (u.type === 'alias' && u.content in _this._plugin.alias) {
                    _this._plugin.alias[u.content].forEach(function (i) { return _eval(i, u); });
                }
                else {
                    // utility
                    var variants = __spreadArray$5(__spreadArray$5(__spreadArray$5([], parentVariants), obj.variants), u.variants);
                    var important = obj.important || u.important;
                    var selector = (important ? '!' : '') + __spreadArray$5(__spreadArray$5([], variants), [u.content]).join(':');
                    typeof u.content === 'string' &&
                        _gStyle(u.content, variants, selector, u, parent, _this.config('prefix'));
                }
            };
            Array.isArray(obj.content) && obj.content.forEach(function (u) { return _eval(u, obj); });
        };
        var _gAst = function (ast) {
            ast.forEach(function (obj) {
                if (obj.type === 'utility') {
                    if (Array.isArray(obj.content)) ;
                    else if (obj.content) {
                        _gStyle(obj.content, obj.variants, obj.raw, obj, undefined, _this.config('prefix'));
                    }
                }
                else if (obj.type === 'group') {
                    _hGroup(obj);
                }
                else if (obj.type === 'alias' && obj.content in _this._plugin.alias) {
                    _gAst(_this._plugin.alias[obj.content]);
                }
                else {
                    _hIgnored(obj.raw, obj);
                }
            });
        };
        _gAst(ast);
        return {
            success: success,
            ignored: ignored,
        };
    };
    Processor.prototype.compile = function (classNames, prefix, showComment, ignoreGenerated, handleIgnored, outputClassName) {
        var _this = this;
        if (prefix === void 0) { prefix = 'windi-'; }
        if (showComment === void 0) { showComment = false; }
        if (ignoreGenerated === void 0) { ignoreGenerated = false; }
        var ast = new ClassParser(classNames, this.config('separator', ':'), this._cache.variants).parse();
        var success = [];
        var ignored = [];
        var styleSheet = new StyleSheet$2();
        var className = outputClassName !== null && outputClassName !== void 0 ? outputClassName : prefix + hash$2(classNames.trim().split(/\s+/g).join(' '));
        if (ignoreGenerated && this._cache.classes.includes(className))
            return { success: success, ignored: ignored, styleSheet: styleSheet, className: className };
        var buildSelector = '.' + className;
        var _hIgnored = function (className) {
            if (handleIgnored) {
                var style = handleIgnored(className);
                if (style) {
                    styleSheet.add(style);
                    success.push(className);
                }
                else {
                    ignored.push(className);
                }
            }
            ignored.push(className);
        };
        var _gStyle = function (baseClass, variants, selector, important) {
            if (important === void 0) { important = false; }
            if (_this._config.exclude && testRegexr(selector, _this._config.exclude)) {
                // filter exclude className
                ignored.push(selector);
                return;
            }
            if (variants[0] && selector in __assign$3(__assign$3({}, _this._plugin.utilities), _this._plugin.components)) {
                // handle special selector that conflict with class parser, such as 'hover:abc'
                success.push(selector);
                styleSheet.add(deepCopy$3(_this._plugin.utilities[selector]));
                return;
            }
            var result = _this.extract(baseClass, showComment);
            if (result) {
                if (Array.isArray(result)) {
                    result.forEach(function (i) {
                        if (i instanceof Keyframes$1) {
                            i.meta.order = 20;
                            return i;
                        }
                        i.selector = buildSelector;
                        _this.markAsImportant(i, important);
                    });
                }
                else {
                    result.selector = buildSelector;
                    _this.markAsImportant(result, important);
                }
                var wrapped = _this.wrapWithVariants(variants, result);
                if (wrapped) {
                    success.push(selector);
                    styleSheet.add(wrapped);
                }
                else {
                    _hIgnored(selector);
                }
            }
            else {
                _hIgnored(selector);
            }
        };
        var _hGroup = function (obj, parentVariants) {
            if (parentVariants === void 0) { parentVariants = []; }
            Array.isArray(obj.content) &&
                obj.content.forEach(function (u) {
                    if (u.type === 'group') {
                        _hGroup(u, obj.variants);
                    }
                    else {
                        // utility
                        var variants = __spreadArray$5(__spreadArray$5(__spreadArray$5([], parentVariants), obj.variants), u.variants);
                        var selector = __spreadArray$5(__spreadArray$5([], variants), [u.content]).join(':');
                        typeof u.content === 'string' &&
                            _gStyle(_this.removePrefix(u.content), variants, selector, obj.important || u.important);
                    }
                });
        };
        ast.forEach(function (obj) {
            if (obj.type === 'utility') {
                if (Array.isArray(obj.content)) ;
                else if (obj.content) {
                    _gStyle(_this.removePrefix(obj.content), obj.variants, obj.raw, obj.important);
                }
            }
            else if (obj.type === 'group') {
                _hGroup(obj);
            }
            else {
                _hIgnored(obj.raw);
            }
        });
        className = success.length > 0 ? className : undefined;
        if (ignoreGenerated && className)
            this._cache.classes.push(className);
        if (!this.config('prefixer'))
            styleSheet.prefixer = false;
        return {
            success: success,
            ignored: ignored,
            className: className,
            styleSheet: styleSheet.sortby(sortGroup).combine(),
        };
    };
    Processor.prototype.attributify = function (attrs, ignoreProcessed) {
        var _this = this;
        if (ignoreProcessed === void 0) { ignoreProcessed = false; }
        var success = [];
        var ignored = [];
        var styleSheet = new StyleSheet$2();
        var _a = (this._config.attributify && typeof this._config.attributify === 'boolean') ? {} : this._config.attributify || {}, prefix = _a.prefix, separator = _a.separator, disable = _a.disable;
        var _gStyle = function (key, value, equal, notAllow, ignoreProcessed) {
            var _a, _b;
            if (equal === void 0) { equal = false; }
            if (notAllow === void 0) { notAllow = false; }
            if (ignoreProcessed === void 0) { ignoreProcessed = false; }
            var buildSelector = "[" + _this.e((prefix || '') + key) + (equal ? '=' : '~=') + "\"" + value + "\"]";
            if (notAllow || (ignoreProcessed && _this._cache.attrs.includes(buildSelector))) {
                ignored.push(buildSelector);
                return;
            }
            var importantValue = value.startsWith('!');
            if (importantValue)
                value = value.slice(1);
            var importantKey = key.startsWith('!');
            if (importantKey)
                key = key.slice(1);
            var id = (_b = (_a = key.match(/\w+$/)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : '';
            var splits = value.split(separator || ':');
            var variants = splits.slice(0, -1);
            var utility = splits.slice(-1)[0];
            var keys = key.split(separator || ':');
            var lastKey = keys.slice(-1)[0];
            if (lastKey in _this._variants && lastKey !== 'svg') {
                variants = __spreadArray$5(__spreadArray$5([], keys), variants);
            }
            else if (id in _this._variants && id !== 'svg') {
                // sm = ... || sm:hover = ... || sm-hover = ...
                var matches = key.match(/[@<\w]+/g);
                if (!matches) {
                    ignored.push(buildSelector);
                    return;
                }
                variants = __spreadArray$5(__spreadArray$5([], matches), variants);
            }
            else {
                // text = ... || sm:text = ... || sm-text = ... || sm-hover-text = ...
                if (!keys) {
                    ignored.push(buildSelector);
                    return;
                }
                if (keys.length === 1)
                    keys = key.split('-');
                var last = void 0;
                // handle min-h || max-w ...
                if (['min', 'max'].includes(keys.slice(-2, -1)[0])) {
                    variants = __spreadArray$5(__spreadArray$5([], keys.slice(0, -2)), variants);
                    last = keys.slice(-2).join('-');
                }
                else {
                    variants = __spreadArray$5(__spreadArray$5([], keys.slice(0, -1)), variants);
                    last = keys[keys.length - 1];
                }
                // handle negative, such as m = -x-2
                var negative_1 = utility.charAt(0) === '-';
                if (negative_1)
                    utility = utility.slice(1);
                utility = ['m', 'p'].includes(last) && ['t', 'l', 'b', 'r', 'x', 'y'].includes(utility.charAt(0)) ? last + utility : last + '-' + utility;
                if (negative_1)
                    utility = '-' + utility;
                utility !== 'cursor-default' && (utility = utility.replace(/-(~|default)$/, ''));
                // handle special cases
                switch (last) {
                    case 'w':
                        if (['w-min', 'w-max', 'w-min-content', 'w-max-content'].includes(utility)) {
                            utility = utility.slice(0, 5);
                        }
                        else if (utility.startsWith('w-min')) {
                            utility = 'min-w' + utility.slice(5);
                        }
                        else if (utility.startsWith('w-max')) {
                            utility = 'max-w' + utility.slice(5);
                        }
                        break;
                    case 'h':
                        if (['h-min', 'h-max', 'h-min-content', 'h-max-content'].includes(utility)) {
                            utility = utility.slice(0, 5);
                        }
                        else if (utility.startsWith('h-min')) {
                            utility = 'min-h' + utility.slice(5);
                        }
                        else if (utility.startsWith('h-max')) {
                            utility = 'max-h' + utility.slice(5);
                        }
                        break;
                    case 'flex':
                        switch (utility) {
                            case 'flex-default':
                                utility = 'flex';
                                break;
                            case 'flex-inline':
                                utility = 'inline-flex';
                                break;
                        }
                        break;
                    case 'grid':
                        switch (utility) {
                            case 'grid-default':
                                utility = 'grid';
                                break;
                            case 'grid-inline':
                                utility = 'inline-grid';
                                break;
                            default:
                                if (/^grid-(auto|gap|col|row)-/.test(utility))
                                    utility = utility.slice(5);
                        }
                        break;
                    case 'justify':
                        if (utility.startsWith('justify-content-')) {
                            utility = 'justify-' + utility.slice(16);
                        }
                        break;
                    case 'align':
                        if (/^align-(items|self|content)-/.test(utility)) {
                            utility = utility.slice(6);
                        }
                        else {
                            utility = 'content-' + utility.slice(6);
                        }
                        break;
                    case 'place':
                        if (!/^place-(items|self|content)-/.test(utility)) {
                            utility = 'place-content-' + utility.slice(6);
                        }
                        break;
                    case 'font':
                        if (/^font-(tracking|leading)-/.test(utility) || ['font-italic', 'font-not-italic', 'font-antialiased', 'font-subpixel-antialiased', 'font-normal-nums', 'font-ordinal', 'font-slashed-zero', 'font-lining-nums', 'font-oldstyle-nums', 'font-proportional-nums', 'font-tabular-nums', 'font-diagonal-fractions', 'font-stacked-fractions'].includes(utility))
                            utility = utility.slice(5);
                        break;
                    case 'text':
                        if (['text-baseline', 'text-top', 'text-middle', 'text-bottom', 'text-text-top', 'text-text-bottom'].includes(utility)) {
                            utility = 'align-' + utility.slice(5);
                        }
                        else if (utility.startsWith('text-placeholder') || utility.startsWith('text-underline') || utility.startsWith('text-tab') || utility.startsWith('text-indent') || utility.startsWith('text-hyphens') || utility.startsWith('text-write')) {
                            utility = utility.slice(5);
                        }
                        else if (['text-underline', 'text-line-through', 'text-no-underline', 'text-uppercase', 'text-lowercase', 'text-capitalize', 'text-normal-case', 'text-truncate', 'text-overflow-ellipsis', 'text-overflow-clip', 'text-break-normal', 'text-break-words', 'text-break-all'].includes(utility)) {
                            utility = utility.slice(5);
                        }
                        else if (utility.startsWith('text-space')) {
                            utility = 'white' + utility.slice(5);
                        }
                        break;
                    case 'underline':
                        if (utility === 'underline-none') {
                            utility = 'no-underline';
                        }
                        else if (utility === 'underline-line-through') {
                            utility = 'line-through';
                        }
                        break;
                    case 'svg':
                        if (utility.startsWith('svg-fill') || utility.startsWith('svg-stroke'))
                            utility = utility.slice(4);
                        break;
                    case 'border':
                        if (utility.startsWith('border-rounded')) {
                            utility = utility.slice(7);
                        }
                        break;
                    case 'gradient':
                        if (utility === 'gradient-none') {
                            utility = 'bg-none';
                        }
                        else if (/^gradient-to-[trbl]{1,2}$/.test(utility)) {
                            utility = 'bg-' + utility;
                        }
                        else if (/^gradient-(from|via|to)-/.test(utility)) {
                            utility = utility.slice(9);
                        }
                        break;
                    case 'display':
                        utility = utility.slice(8);
                        break;
                    case 'pos':
                        utility = utility.slice(4);
                        break;
                    case 'position':
                        utility = utility.slice(9);
                        break;
                    case 'box':
                        if (/^box-(decoration|shadow)/.test(utility)) {
                            utility = utility.slice(4);
                        }
                        break;
                    case 'filter':
                        if (utility !== 'filter-none' && utility !== 'filter') {
                            utility = utility.slice(7);
                        }
                        break;
                    case 'backdrop':
                        if (utility === 'backdrop') {
                            utility = 'backdrop-filter';
                        }
                        else if (utility === 'backdrop-none') {
                            utility = 'backdrop-filter-none';
                        }
                        break;
                    case 'transition':
                        if (/transition-(duration|ease|delay)-/.test(utility)) {
                            utility = utility.slice(11);
                        }
                        break;
                    case 'transform':
                        if (!['transform-gpu', 'transform-none', 'transform'].includes(utility)) {
                            utility = utility.slice(10);
                        }
                        break;
                    case 'isolation':
                        if (utility === 'isolation-isolate')
                            utility = 'isolate';
                        break;
                    case 'table':
                        if (utility === 'table-inline') {
                            utility = 'inline-table';
                        }
                        else if (utility.startsWith('table-caption-') || utility.startsWith('table-empty-cells')) {
                            utility = utility.slice(6);
                        }
                        break;
                    case 'pointer':
                        utility = 'pointer-events' + utility.slice(7);
                        break;
                    case 'resize':
                        if (utility === 'resize-both')
                            utility = 'resize';
                        break;
                    case 'ring':
                        break;
                    case 'blend':
                        utility = 'mix-' + utility;
                        break;
                    case 'sr':
                        if (utility === 'sr-not-only')
                            utility = 'not-sr-only';
                        break;
                }
            }
            var style = _this.extract(utility, false);
            if (style) {
                var important_1 = importantKey || importantValue;
                if (Array.isArray(style)) {
                    style.forEach(function (i) {
                        if (i instanceof Keyframes$1)
                            return i;
                        i.selector = buildSelector;
                        _this.markAsImportant(i, important_1);
                    });
                }
                else {
                    style.selector = buildSelector;
                    _this.markAsImportant(style, important_1);
                }
                if (variants.find(function (i) { return !(i in _this._variants); })) {
                    ignored.push(buildSelector);
                }
                else {
                    var wrapped = _this.wrapWithVariants(variants, style);
                    if (wrapped) {
                        ignoreProcessed && _this._cache.attrs.push(buildSelector);
                        success.push(buildSelector);
                        styleSheet.add(wrapped);
                    }
                    else {
                        ignored.push(buildSelector);
                    }
                }
            }
            else {
                ignored.push(buildSelector);
            }
        };
        var _loop_2 = function (key, value) {
            var notAllow = false;
            if (prefix) {
                if (key.startsWith(prefix)) {
                    key = key.slice(prefix.length);
                }
                else {
                    notAllow = true;
                }
            }
            if (disable === null || disable === void 0 ? void 0 : disable.includes(key))
                notAllow = true;
            if (Array.isArray(value)) {
                value.forEach(function (i) { return _gStyle(key, i, false, notAllow, ignoreProcessed); });
            }
            else {
                _gStyle(key, value, true, notAllow, ignoreProcessed);
            }
        };
        // eslint-disable-next-line prefer-const
        for (var _i = 0, _b = Object.entries(attrs); _i < _b.length; _i++) {
            var _c = _b[_i], key = _c[0], value = _c[1];
            _loop_2(key, value);
        }
        return {
            success: success,
            ignored: ignored,
            styleSheet: styleSheet.sort().combine(),
        };
    };
    Processor.prototype.loadPlugin = function (_a) {
        var handler = _a.handler, config = _a.config;
        if (config) {
            config = this._resolveFunction(config);
            config = combineConfig(config, this._config);
            var pluginTheme = config.theme;
            var extendTheme = pluginTheme === null || pluginTheme === void 0 ? void 0 : pluginTheme.extend;
            if (pluginTheme && extendTheme && typeof extendTheme === 'object') {
                for (var _i = 0, _b = Object.entries(extendTheme); _i < _b.length; _i++) {
                    var _c = _b[_i], key = _c[0], value = _c[1];
                    var themeValue = pluginTheme[key];
                    if (themeValue && typeof themeValue === 'object') {
                        pluginTheme[key] = __assign$3(__assign$3({}, (themeValue !== null && themeValue !== void 0 ? themeValue : {})), value);
                    }
                    else if (value && typeof value === 'object') {
                        pluginTheme[key] = value;
                    }
                }
            }
            this._config = __assign$3(__assign$3({}, config), { theme: pluginTheme });
            this._theme = pluginTheme;
        }
        this._config = this._resolveFunction(this._config);
        this._theme = this._config.theme;
        this._variants = __assign$3(__assign$3({}, this._variants), this.resolveVariants());
        handler(this.pluginUtils);
    };
    Processor.prototype.loadPluginWithOptions = function (optionsFunction, userOptions) {
        var plugin = optionsFunction(userOptions !== null && userOptions !== void 0 ? userOptions : {});
        this.loadPlugin(plugin);
    };
    Processor.prototype.loadShortcuts = function (shortcuts) {
        var _this = this;
        var _loop_3 = function (key, value) {
            var prefix = this_1.config('prefix', '');
            if (typeof value === 'string') {
                this_1._plugin.shortcuts[key] = this_1.compile(value, undefined, undefined, false, undefined, cssEscape(prefix + key)).styleSheet.children.map(function (i) { return i.updateMeta('components', 'shortcuts', layerOrder$1['shortcuts'], ++_this._cache.count); });
            }
            else {
                var styles_1 = [];
                Style$3.generate('.' + cssEscape(key), value).forEach(function (style) {
                    for (var _i = 0, _a = style.property; _i < _a.length; _i++) {
                        var prop = _a[_i];
                        if (!prop.value)
                            continue;
                        if (prop.name === '@apply') {
                            styles_1 = styles_1.concat(_this.compile(Array.isArray(prop.value) ? prop.value.join(' ') : prop.value).styleSheet.children.map(function (i) {
                                var newStyle = deepCopy$3(style);
                                newStyle.property = [];
                                return newStyle.extend(i);
                            }));
                        }
                        else {
                            var newStyle = deepCopy$3(style);
                            newStyle.property = [prop];
                            styles_1.push(newStyle);
                        }
                    }
                });
                this_1._plugin.shortcuts[key] = styles_1.map(function (i) { return i.updateMeta('components', 'shortcuts', layerOrder$1['shortcuts'], ++_this._cache.count); });
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = Object.entries(shortcuts); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_3(key, value);
        }
    };
    Processor.prototype.loadAlias = function (alias) {
        for (var _i = 0, _a = Object.entries(alias); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            this._plugin.alias[key] = new ClassParser(value, undefined, this._cache.variants).parse();
        }
    };
    Processor.prototype.config = function (path, defaultValue) {
        var _this = this;
        var _a;
        if (path === 'corePlugins')
            return this._plugin.core ? Object.keys(this._plugin.core).filter(function (i) { var _a; return (_a = _this._plugin.core) === null || _a === void 0 ? void 0 : _a[i]; }) : Object.keys(pluginOrder$1).slice(Object.keys(pluginOrder$1).length / 2);
        return (_a = getNestedValue(this._config, path)) !== null && _a !== void 0 ? _a : defaultValue;
    };
    Processor.prototype.theme = function (path, defaultValue) {
        var _a;
        return this._theme ? (_a = getNestedValue(this._theme, path)) !== null && _a !== void 0 ? _a : defaultValue : undefined;
    };
    Processor.prototype.corePlugins = function (path) {
        var _a;
        if (Array.isArray(this._config.corePlugins)) {
            return this._config.corePlugins.includes(path);
        }
        return (_a = this.config("corePlugins." + path, true)) !== null && _a !== void 0 ? _a : false;
    };
    Processor.prototype.variants = function (path, defaultValue) {
        if (defaultValue === void 0) { defaultValue = []; }
        if (Array.isArray(this._config.variants)) {
            return this._config.variants;
        }
        return this.config("variants." + path, defaultValue);
    };
    Processor.prototype.e = function (selector) {
        return cssEscape(selector);
    };
    Processor.prototype.prefix = function (selector) {
        var _a;
        return selector.replace(/(?=[\w])/, (_a = this._config.prefix) !== null && _a !== void 0 ? _a : '');
    };
    Processor.prototype.addUtilities = function (utilities, options) {
        var _this = this;
        var _a;
        if (options === void 0) { options = {
            layer: 'utilities',
            variants: [],
            respectPrefix: true,
            respectImportant: true,
        }; }
        if (Array.isArray(options))
            options = { variants: options };
        if (Array.isArray(utilities))
            utilities = utilities.reduce(function (previous, current) { return combineConfig(previous, current); }, {});
        var output = [];
        var layer = (_a = options.layer) !== null && _a !== void 0 ? _a : 'utilities';
        var order = layerOrder$1[layer] + 1;
        var _loop_4 = function (key, value) {
            var styles = Style$3.generate(key.startsWith('.') && options.respectPrefix ? this_2.prefix(key) : key, value);
            if (options.layer)
                styles.forEach(function (style) { return style.updateMeta(layer, 'plugin', order, ++_this._cache.count); });
            if (options.respectImportant && this_2._config.important)
                styles.forEach(function (style) { return style.important = true; });
            var className = guessClassName(key);
            if (key.charAt(0) === '@') {
                styles.forEach(function (style) {
                    if (style.selector)
                        className = guessClassName(style.selector);
                    if (Array.isArray(className)) {
                        className.filter(function (i) { return i.isClass; }).forEach(function (_a) {
                            var selector = _a.selector, pseudo = _a.pseudo;
                            return _this._addPluginProcessorCache('utilities', selector, pseudo ? style.clone('.' + cssEscape(selector)).wrapSelector(function (selector) { return selector + pseudo; }) : style.clone());
                        });
                        var base = className.filter(function (i) { return !i.isClass; }).map(function (i) { return i.selector; }).join(', ');
                        if (base)
                            _this._addPluginProcessorCache('static', base, style.clone(base));
                    }
                    else {
                        _this._addPluginProcessorCache(className.isClass ? 'utilities' : 'static', className.selector, className.pseudo ? style.clone('.' + cssEscape(className.selector)).wrapSelector(function (selector) { return selector + className.pseudo; }) : style.clone());
                    }
                });
            }
            else if (Array.isArray(className)) {
                className.filter(function (i) { return i.isClass; }).forEach(function (_a) {
                    var selector = _a.selector, pseudo = _a.pseudo;
                    return _this._addPluginProcessorCache('utilities', selector, pseudo ? styles.map(function (i) { return i.clone('.' + cssEscape(selector)).wrapSelector(function (selector) { return selector + pseudo; }); }) : deepCopy$3(styles));
                });
                var base_1 = className.filter(function (i) { return !i.isClass; }).map(function (i) { return i.selector; }).join(', ');
                if (base_1)
                    this_2._addPluginProcessorCache('static', base_1, styles.map(function (i) { return i.clone(base_1); }));
            }
            else {
                this_2._addPluginProcessorCache(className.isClass ? 'utilities' : 'static', className.selector, className.pseudo ? styles.map(function (style) { return style.clone('.' + cssEscape(className.selector)).wrapSelector(function (selector) { return selector + className.pseudo; }); }) : styles);
            }
            output = __spreadArray$5(__spreadArray$5([], output), styles);
        };
        var this_2 = this;
        for (var _i = 0, _b = Object.entries(utilities); _i < _b.length; _i++) {
            var _c = _b[_i], key = _c[0], value = _c[1];
            _loop_4(key, value);
        }
        return output;
    };
    Processor.prototype.addDynamic = function (key, generator, options) {
        var _this = this;
        if (options === void 0) { options = {
            layer: 'utilities',
            group: 'plugin',
            variants: [],
            completions: [],
            respectPrefix: true,
            respectImportant: true,
            respectSelector: false,
        }; }
        var uOptions = Array.isArray(options) ? { variants: options } : options;
        var layer = uOptions.layer || 'utilities';
        var group = uOptions.group || 'plugin';
        var order = uOptions.order || layerOrder$1[layer] + 1;
        if (uOptions.completions)
            this._plugin.completions[group] = group in this._plugin.completions ? __spreadArray$5(__spreadArray$5([], this._plugin.completions[group]), uOptions.completions) : uOptions.completions;
        var style = function (selector, property, important) {
            if (important === void 0) { important = uOptions.respectImportant && _this._config.important ? true : false; }
            return new Style$3(selector, property, important);
        };
        var prop = function (name, value, comment, important) {
            if (important === void 0) { important = uOptions.respectImportant && _this._config.important ? true : false; }
            return new Property$3(name, value, comment, important);
        };
        var keyframes = function (selector, property, important) {
            if (important === void 0) { important = uOptions.respectImportant && _this._config.important ? true : false; }
            return new Keyframes$1(selector, property, important);
        };
        keyframes.generate = Keyframes$1.generate;
        style.generate = Style$3.generate;
        prop.parse = Property$3.parse;
        this._plugin.dynamic[key] = (key in this._plugin.dynamic)
            ? function (Utility) { return deepCopy$3(_this._plugin.dynamic[key])(Utility) || generator({ Utility: Utility, Style: style, Property: prop, Keyframes: keyframes }); }
            : function (Utility) {
                var output = generator({ Utility: Utility, Style: style, Property: prop, Keyframes: keyframes });
                if (!output)
                    return;
                if (Array.isArray(output))
                    return output.map(function (i) { return i.updateMeta(layer, group, order, ++_this._cache.count, false, i.meta.respectSelector || uOptions.respectSelector); });
                return output.updateMeta(layer, group, order, ++_this._cache.count, false, output.meta.respectSelector || uOptions.respectSelector);
            };
        return generator;
    };
    Processor.prototype.addComponents = function (components, options) {
        var _this = this;
        var _a;
        if (options === void 0) { options = { layer: 'components', variants: [], respectPrefix: false }; }
        if (Array.isArray(options))
            options = { variants: options };
        if (Array.isArray(components))
            components = components.reduce(function (previous, current) { return combineConfig(previous, current); }, {});
        var output = [];
        var layer = (_a = options.layer) !== null && _a !== void 0 ? _a : 'components';
        var order = layerOrder$1[layer] + 1;
        var _loop_5 = function (key, value) {
            var styles = Style$3.generate(key.startsWith('.') && options.respectPrefix ? this_3.prefix(key) : key, value);
            styles.forEach(function (style) { return style.updateMeta(layer, 'plugin', order, ++_this._cache.count); });
            if (options.respectImportant && this_3._config.important)
                styles.forEach(function (style) { return style.important = true; });
            var className = guessClassName(key);
            if (key.charAt(0) === '@') {
                styles.forEach(function (style) {
                    if (style.selector)
                        className = guessClassName(style.selector);
                    if (Array.isArray(className)) {
                        className.filter(function (i) { return i.isClass; }).forEach(function (_a) {
                            var selector = _a.selector, pseudo = _a.pseudo;
                            return _this._addPluginProcessorCache('components', selector, pseudo ? style.clone('.' + cssEscape(selector)).wrapSelector(function (selector) { return selector + pseudo; }) : style.clone());
                        });
                        var base = className.filter(function (i) { return !i.isClass; }).map(function (i) { return i.selector; }).join(', ');
                        if (base)
                            _this._addPluginProcessorCache('static', base, style.clone(base));
                    }
                    else {
                        _this._addPluginProcessorCache(className.isClass ? 'components' : 'static', className.selector, className.pseudo ? style.clone('.' + cssEscape(className.selector)).wrapSelector(function (selector) { return selector + className.pseudo; }) : style.clone());
                    }
                });
            }
            else if (Array.isArray(className)) {
                // one of the selector are not class, treat the entire as static to avoid duplication
                if (className.some(function (i) { return !i.isClass; })) {
                    var base_2 = className.map(function (i) { return i.selector; }).join(', ');
                    if (base_2)
                        this_3._addPluginProcessorCache('static', base_2, styles.map(function (i) { return i.clone(base_2); }));
                }
                // class
                else {
                    className.forEach(function (_a) {
                        var selector = _a.selector, pseudo = _a.pseudo;
                        return _this._addPluginProcessorCache('components', selector, pseudo ? styles.map(function (i) { return i.clone('.' + cssEscape(selector)).wrapSelector(function (selector) { return selector + pseudo; }); }) : deepCopy$3(styles));
                    });
                }
            }
            else {
                this_3._addPluginProcessorCache(className.isClass ? 'components' : 'static', className.selector, className.pseudo ? styles.map(function (style) { return style.clone('.' + cssEscape(className.selector)).wrapSelector(function (selector) { return selector + className.pseudo; }); }) : styles);
            }
            output = __spreadArray$5(__spreadArray$5([], output), styles);
        };
        var this_3 = this;
        for (var _i = 0, _b = Object.entries(components); _i < _b.length; _i++) {
            var _c = _b[_i], key = _c[0], value = _c[1];
            _loop_5(key, value);
        }
        return output;
    };
    Processor.prototype.addBase = function (baseStyles) {
        var _this = this;
        var output = [];
        for (var _i = 0, _a = Object.entries(baseStyles); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var styles = Style$3.generate(key, value).map(function (i) { return i.updateMeta('base', 'plugin', 10, ++_this._cache.count); });
            this._replaceStyleVariants(styles);
            this._addPluginProcessorCache('preflights', key, styles);
            output = __spreadArray$5(__spreadArray$5([], output), styles);
        }
        return output;
    };
    Processor.prototype.addVariant = function (name, generator) {
        // name && generator && options;
        var style = generator(__assign$3(__assign$3({}, this.variantUtils), { separator: this.config('separator', ':'), style: new Style$3() }));
        this._variants[name] = function () { return style; };
        this._cache.variants.push(name);
        return style;
    };
    Processor.prototype.dumpConfig = function () {
        var processor = new Processor();
        var diff = diffConfig(processor._config, this._config);
        var output = { theme: { extend: {} }, plugins: [] };
        if (diff.theme) {
            for (var _i = 0, _a = Object.entries(diff.theme); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], value = _b[1];
                if (key !== 'extend') {
                    output.theme.extend[key] = value;
                }
            }
            delete diff.theme;
        }
        if (diff.plugins) {
            for (var _c = 0, _d = diff.plugins; _c < _d.length; _c++) {
                var plugin_1 = _d[_c];
                if ('config' in plugin_1) {
                    delete plugin_1.config;
                }
                output.plugins.push(plugin_1);
            }
            delete diff.plugins;
        }
        output = __assign$3(__assign$3({}, diff), output);
        return "module.exports = " + dist$1(output);
    };
    return Processor;
}());

var dist = {};

var cheerio$1 = {exports: {}};

var cheerio = {exports: {}};

var parse$e = {exports: {}};

var lib$b = {};

var Parser$3 = {};

var Tokenizer$6 = {};

var decode_codepoint = {};

var require$$0$2 = {
	"0": 65533,
	"128": 8364,
	"130": 8218,
	"131": 402,
	"132": 8222,
	"133": 8230,
	"134": 8224,
	"135": 8225,
	"136": 710,
	"137": 8240,
	"138": 352,
	"139": 8249,
	"140": 338,
	"142": 381,
	"145": 8216,
	"146": 8217,
	"147": 8220,
	"148": 8221,
	"149": 8226,
	"150": 8211,
	"151": 8212,
	"152": 732,
	"153": 8482,
	"154": 353,
	"155": 8250,
	"156": 339,
	"158": 382,
	"159": 376
};

var __importDefault$7 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(decode_codepoint, "__esModule", { value: true });
var decode_json_1 = __importDefault$7(require$$0$2);
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
var fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint ||
    function (codePoint) {
        var output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint(codePoint);
}
decode_codepoint.default = decodeCodePoint;

var Aacute$1 = "Á";
var aacute$1 = "á";
var Abreve = "Ă";
var abreve = "ă";
var ac = "∾";
var acd = "∿";
var acE = "∾̳";
var Acirc$1 = "Â";
var acirc$1 = "â";
var acute$1 = "´";
var Acy = "А";
var acy = "а";
var AElig$1 = "Æ";
var aelig$1 = "æ";
var af = "⁡";
var Afr = "𝔄";
var afr = "𝔞";
var Agrave$1 = "À";
var agrave$1 = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var Alpha = "Α";
var alpha = "α";
var Amacr = "Ā";
var amacr = "ā";
var amalg = "⨿";
var amp$2 = "&";
var AMP$1 = "&";
var andand = "⩕";
var And = "⩓";
var and = "∧";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange = "⦤";
var angle = "∠";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angmsd = "∡";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var Aogon = "Ą";
var aogon = "ą";
var Aopf = "𝔸";
var aopf = "𝕒";
var apacir = "⩯";
var ap = "≈";
var apE = "⩰";
var ape = "≊";
var apid = "≋";
var apos$1 = "'";
var ApplyFunction = "⁡";
var approx = "≈";
var approxeq = "≊";
var Aring$1 = "Å";
var aring$1 = "å";
var Ascr = "𝒜";
var ascr = "𝒶";
var Assign = "≔";
var ast = "*";
var asymp = "≈";
var asympeq = "≍";
var Atilde$1 = "Ã";
var atilde$1 = "ã";
var Auml$1 = "Ä";
var auml$1 = "ä";
var awconint = "∳";
var awint = "⨑";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var Backslash = "∖";
var Barv = "⫧";
var barvee = "⊽";
var barwed = "⌅";
var Barwed = "⌆";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var Bcy = "Б";
var bcy = "б";
var bdquo = "„";
var becaus = "∵";
var because = "∵";
var Because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var Bernoullis = "ℬ";
var Beta = "Β";
var beta = "β";
var beth = "ℶ";
var between = "≬";
var Bfr = "𝔅";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bNot = "⫭";
var bnot = "⌐";
var Bopf = "𝔹";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxbox = "⧉";
var boxdl = "┐";
var boxdL = "╕";
var boxDl = "╖";
var boxDL = "╗";
var boxdr = "┌";
var boxdR = "╒";
var boxDr = "╓";
var boxDR = "╔";
var boxh = "─";
var boxH = "═";
var boxhd = "┬";
var boxHd = "╤";
var boxhD = "╥";
var boxHD = "╦";
var boxhu = "┴";
var boxHu = "╧";
var boxhU = "╨";
var boxHU = "╩";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxul = "┘";
var boxuL = "╛";
var boxUl = "╜";
var boxUL = "╝";
var boxur = "└";
var boxuR = "╘";
var boxUr = "╙";
var boxUR = "╚";
var boxv = "│";
var boxV = "║";
var boxvh = "┼";
var boxvH = "╪";
var boxVh = "╫";
var boxVH = "╬";
var boxvl = "┤";
var boxvL = "╡";
var boxVl = "╢";
var boxVL = "╣";
var boxvr = "├";
var boxvR = "╞";
var boxVr = "╟";
var boxVR = "╠";
var bprime = "‵";
var breve = "˘";
var Breve = "˘";
var brvbar$1 = "¦";
var bscr = "𝒷";
var Bscr = "ℬ";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsolb = "⧅";
var bsol = "\\";
var bsolhsub = "⟈";
var bull = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var Bumpeq = "≎";
var bumpeq = "≏";
var Cacute = "Ć";
var cacute = "ć";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var cap = "∩";
var Cap = "⋒";
var capcup = "⩇";
var capdot = "⩀";
var CapitalDifferentialD = "ⅅ";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var Cayleys = "ℭ";
var ccaps = "⩍";
var Ccaron = "Č";
var ccaron = "č";
var Ccedil$1 = "Ç";
var ccedil$1 = "ç";
var Ccirc = "Ĉ";
var ccirc = "ĉ";
var Cconint = "∰";
var ccups = "⩌";
var ccupssm = "⩐";
var Cdot = "Ċ";
var cdot = "ċ";
var cedil$1 = "¸";
var Cedilla = "¸";
var cemptyv = "⦲";
var cent$1 = "¢";
var centerdot = "·";
var CenterDot = "·";
var cfr = "𝔠";
var Cfr = "ℭ";
var CHcy = "Ч";
var chcy = "ч";
var check = "✓";
var checkmark = "✓";
var Chi = "Χ";
var chi = "χ";
var circ = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var CircleDot = "⊙";
var circledR = "®";
var circledS = "Ⓢ";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var cir = "○";
var cirE = "⧃";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var clubs = "♣";
var clubsuit = "♣";
var colon = ":";
var Colon = "∷";
var Colone = "⩴";
var colone = "≔";
var coloneq = "≔";
var comma = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong = "≅";
var congdot = "⩭";
var Congruent = "≡";
var conint = "∮";
var Conint = "∯";
var ContourIntegral = "∮";
var copf = "𝕔";
var Copf = "ℂ";
var coprod = "∐";
var Coproduct = "∐";
var copy$4 = "©";
var COPY$1 = "©";
var copysr = "℗";
var CounterClockwiseContourIntegral = "∳";
var crarr = "↵";
var cross = "✗";
var Cross = "⨯";
var Cscr = "𝒞";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cupbrcap = "⩈";
var cupcap = "⩆";
var CupCap = "≍";
var cup = "∪";
var Cup = "⋓";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curren$1 = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dagger = "†";
var Dagger = "‡";
var daleth = "ℸ";
var darr = "↓";
var Darr = "↡";
var dArr = "⇓";
var dash = "‐";
var Dashv = "⫤";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var Dcaron = "Ď";
var dcaron = "ď";
var Dcy = "Д";
var dcy = "д";
var ddagger = "‡";
var ddarr = "⇊";
var DD = "ⅅ";
var dd = "ⅆ";
var DDotrahd = "⤑";
var ddotseq = "⩷";
var deg$1 = "°";
var Del = "∇";
var Delta = "Δ";
var delta = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var Dfr = "𝔇";
var dfr = "𝔡";
var dHar = "⥥";
var dharl = "⇃";
var dharr = "⇂";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var diam = "⋄";
var diamond = "⋄";
var Diamond = "⋄";
var diamondsuit = "♦";
var diams = "♦";
var die = "¨";
var DifferentialD = "ⅆ";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divide$1 = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var DJcy = "Ђ";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var Dopf = "𝔻";
var dopf = "𝕕";
var Dot = "¨";
var dot = "˙";
var DotDot = "⃜";
var doteq = "≐";
var doteqdot = "≑";
var DotEqual = "≐";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrowBar = "⤓";
var downarrow = "↓";
var DownArrow = "↓";
var Downarrow = "⇓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVectorBar = "⥖";
var DownLeftVector = "↽";
var DownRightTeeVector = "⥟";
var DownRightVectorBar = "⥗";
var DownRightVector = "⇁";
var DownTeeArrow = "↧";
var DownTee = "⊤";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var Dscr = "𝒟";
var dscr = "𝒹";
var DScy = "Ѕ";
var dscy = "ѕ";
var dsol = "⧶";
var Dstrok = "Đ";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var DZcy = "Џ";
var dzcy = "џ";
var dzigrarr = "⟿";
var Eacute$1 = "É";
var eacute$1 = "é";
var easter = "⩮";
var Ecaron = "Ě";
var ecaron = "ě";
var Ecirc$1 = "Ê";
var ecirc$1 = "ê";
var ecir = "≖";
var ecolon = "≕";
var Ecy = "Э";
var ecy = "э";
var eDDot = "⩷";
var Edot = "Ė";
var edot = "ė";
var eDot = "≑";
var ee = "ⅇ";
var efDot = "≒";
var Efr = "𝔈";
var efr = "𝔢";
var eg = "⪚";
var Egrave$1 = "È";
var egrave$1 = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var Element$1 = "∈";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var Emacr = "Ē";
var emacr = "ē";
var empty$1 = "∅";
var emptyset = "∅";
var EmptySmallSquare = "◻";
var emptyv = "∅";
var EmptyVerySmallSquare = "▫";
var emsp13 = " ";
var emsp14 = " ";
var emsp = " ";
var ENG = "Ŋ";
var eng = "ŋ";
var ensp = " ";
var Eogon = "Ę";
var eogon = "ę";
var Eopf = "𝔼";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var Epsilon = "Ε";
var epsilon = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var Equal = "⩵";
var equals = "=";
var EqualTilde = "≂";
var equest = "≟";
var Equilibrium = "⇌";
var equiv = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erarr = "⥱";
var erDot = "≓";
var escr = "ℯ";
var Escr = "ℰ";
var esdot = "≐";
var Esim = "⩳";
var esim = "≂";
var Eta = "Η";
var eta = "η";
var ETH$1 = "Ð";
var eth$1 = "ð";
var Euml$1 = "Ë";
var euml$1 = "ë";
var euro = "€";
var excl = "!";
var exist = "∃";
var Exists = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var ExponentialE = "ⅇ";
var fallingdotseq = "≒";
var Fcy = "Ф";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var Ffr = "𝔉";
var ffr = "𝔣";
var filig = "ﬁ";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var Fopf = "𝔽";
var fopf = "𝕗";
var forall = "∀";
var ForAll = "∀";
var fork = "⋔";
var forkv = "⫙";
var Fouriertrf = "ℱ";
var fpartint = "⨍";
var frac12$1 = "½";
var frac13 = "⅓";
var frac14$1 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac34$1 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var Fscr = "ℱ";
var gacute = "ǵ";
var Gamma = "Γ";
var gamma = "γ";
var Gammad = "Ϝ";
var gammad = "ϝ";
var gap = "⪆";
var Gbreve = "Ğ";
var gbreve = "ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var gcirc = "ĝ";
var Gcy = "Г";
var gcy = "г";
var Gdot = "Ġ";
var gdot = "ġ";
var ge = "≥";
var gE = "≧";
var gEl = "⪌";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var gescc = "⪩";
var ges = "⩾";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var Gfr = "𝔊";
var gfr = "𝔤";
var gg = "≫";
var Gg = "⋙";
var ggg = "⋙";
var gimel = "ℷ";
var GJcy = "Ѓ";
var gjcy = "ѓ";
var gla = "⪥";
var gl = "≷";
var glE = "⪒";
var glj = "⪤";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gnE = "≩";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var Gopf = "𝔾";
var gopf = "𝕘";
var grave = "`";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var gtcc = "⪧";
var gtcir = "⩺";
var gt$2 = ">";
var GT$1 = ">";
var Gt = "≫";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var Hacek = "ˇ";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var HARDcy = "Ъ";
var hardcy = "ъ";
var harrcir = "⥈";
var harr = "↔";
var hArr = "⇔";
var harrw = "↭";
var Hat = "^";
var hbar = "ℏ";
var Hcirc = "Ĥ";
var hcirc = "ĥ";
var hearts = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var hfr = "𝔥";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var Hopf = "ℍ";
var horbar = "―";
var HorizontalLine = "─";
var hscr = "𝒽";
var Hscr = "ℋ";
var hslash = "ℏ";
var Hstrok = "Ħ";
var hstrok = "ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var hybull = "⁃";
var hyphen = "‐";
var Iacute$1 = "Í";
var iacute$1 = "í";
var ic = "⁣";
var Icirc$1 = "Î";
var icirc$1 = "î";
var Icy = "И";
var icy = "и";
var Idot = "İ";
var IEcy = "Е";
var iecy = "е";
var iexcl$1 = "¡";
var iff = "⇔";
var ifr = "𝔦";
var Ifr = "ℑ";
var Igrave$1 = "Ì";
var igrave$1 = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var IJlig = "Ĳ";
var ijlig = "ĳ";
var Imacr = "Ī";
var imacr = "ī";
var image = "ℑ";
var ImaginaryI = "ⅈ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var Im = "ℑ";
var imof = "⊷";
var imped = "Ƶ";
var Implies = "⇒";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var intcal = "⊺";
var int = "∫";
var Int = "∬";
var integers = "ℤ";
var Integral = "∫";
var intercal = "⊺";
var Intersection = "⋂";
var intlarhk = "⨗";
var intprod = "⨼";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var IOcy = "Ё";
var iocy = "ё";
var Iogon = "Į";
var iogon = "į";
var Iopf = "𝕀";
var iopf = "𝕚";
var Iota = "Ι";
var iota = "ι";
var iprod = "⨼";
var iquest$1 = "¿";
var iscr = "𝒾";
var Iscr = "ℐ";
var isin = "∈";
var isindot = "⋵";
var isinE = "⋹";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it = "⁢";
var Itilde = "Ĩ";
var itilde = "ĩ";
var Iukcy = "І";
var iukcy = "і";
var Iuml$1 = "Ï";
var iuml$1 = "ï";
var Jcirc = "Ĵ";
var jcirc = "ĵ";
var Jcy = "Й";
var jcy = "й";
var Jfr = "𝔍";
var jfr = "𝔧";
var jmath = "ȷ";
var Jopf = "𝕁";
var jopf = "𝕛";
var Jscr = "𝒥";
var jscr = "𝒿";
var Jsercy = "Ј";
var jsercy = "ј";
var Jukcy = "Є";
var jukcy = "є";
var Kappa = "Κ";
var kappa = "κ";
var kappav = "ϰ";
var Kcedil = "Ķ";
var kcedil = "ķ";
var Kcy = "К";
var kcy = "к";
var Kfr = "𝔎";
var kfr = "𝔨";
var kgreen = "ĸ";
var KHcy = "Х";
var khcy = "х";
var KJcy = "Ќ";
var kjcy = "ќ";
var Kopf = "𝕂";
var kopf = "𝕜";
var Kscr = "𝒦";
var kscr = "𝓀";
var lAarr = "⇚";
var Lacute = "Ĺ";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var Lambda = "Λ";
var lambda = "λ";
var lang = "⟨";
var Lang = "⟪";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var Laplacetrf = "ℒ";
var laquo$1 = "«";
var larrb = "⇤";
var larrbfs = "⤟";
var larr = "←";
var Larr = "↞";
var lArr = "⇐";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var latail = "⤙";
var lAtail = "⤛";
var lat = "⪫";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lBarr = "⤎";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var Lcaron = "Ľ";
var lcaron = "ľ";
var Lcedil = "Ļ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var Lcy = "Л";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le = "≤";
var lE = "≦";
var LeftAngleBracket = "⟨";
var LeftArrowBar = "⇤";
var leftarrow = "←";
var LeftArrow = "←";
var Leftarrow = "⇐";
var LeftArrowRightArrow = "⇆";
var leftarrowtail = "↢";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVectorBar = "⥙";
var LeftDownVector = "⇃";
var LeftFloor = "⌊";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var LeftRightArrow = "↔";
var Leftrightarrow = "⇔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var LeftRightVector = "⥎";
var LeftTeeArrow = "↤";
var LeftTee = "⊣";
var LeftTeeVector = "⥚";
var leftthreetimes = "⋋";
var LeftTriangleBar = "⧏";
var LeftTriangle = "⊲";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVectorBar = "⥘";
var LeftUpVector = "↿";
var LeftVectorBar = "⥒";
var LeftVector = "↼";
var lEg = "⪋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var lescc = "⪨";
var les = "⩽";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var lessgtr = "≶";
var LessLess = "⪡";
var lesssim = "≲";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var Lfr = "𝔏";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lHar = "⥢";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var LJcy = "Љ";
var ljcy = "љ";
var llarr = "⇇";
var ll = "≪";
var Ll = "⋘";
var llcorner = "⌞";
var Lleftarrow = "⇚";
var llhard = "⥫";
var lltri = "◺";
var Lmidot = "Ŀ";
var lmidot = "ŀ";
var lmoustache = "⎰";
var lmoust = "⎰";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lnE = "≨";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var LongLeftArrow = "⟵";
var Longleftarrow = "⟸";
var longleftrightarrow = "⟷";
var LongLeftRightArrow = "⟷";
var Longleftrightarrow = "⟺";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var LongRightArrow = "⟶";
var Longrightarrow = "⟹";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var Lopf = "𝕃";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var loz = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var lscr = "𝓁";
var Lscr = "ℒ";
var lsh = "↰";
var Lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var Lstrok = "Ł";
var lstrok = "ł";
var ltcc = "⪦";
var ltcir = "⩹";
var lt$2 = "<";
var LT$1 = "<";
var Lt = "≪";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var ltrPar = "⦖";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var macr$1 = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var Mcy = "М";
var mcy = "м";
var mdash = "—";
var mDDot = "∺";
var measuredangle = "∡";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var mfr = "𝔪";
var mho = "℧";
var micro$1 = "µ";
var midast = "*";
var midcir = "⫰";
var mid = "∣";
var middot$1 = "·";
var minusb = "⊟";
var minus = "−";
var minusd = "∸";
var minusdu = "⨪";
var MinusPlus = "∓";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var Mopf = "𝕄";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var Mscr = "ℳ";
var mstpos = "∾";
var Mu = "Μ";
var mu = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nabla = "∇";
var Nacute = "Ń";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natural = "♮";
var naturals = "ℕ";
var natur = "♮";
var nbsp$1 = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var Ncaron = "Ň";
var ncaron = "ň";
var Ncedil = "Ņ";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var Ncy = "Н";
var ncy = "н";
var ndash = "–";
var nearhk = "⤤";
var nearr = "↗";
var neArr = "⇗";
var nearrow = "↗";
var ne = "≠";
var nedot = "≐̸";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var nexist = "∄";
var nexists = "∄";
var Nfr = "𝔑";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var nGg = "⋙̸";
var ngsim = "≵";
var nGt = "≫⃒";
var ngt = "≯";
var ngtr = "≯";
var nGtv = "≫̸";
var nharr = "↮";
var nhArr = "⇎";
var nhpar = "⫲";
var ni = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var NJcy = "Њ";
var njcy = "њ";
var nlarr = "↚";
var nlArr = "⇍";
var nldr = "‥";
var nlE = "≦̸";
var nle = "≰";
var nleftarrow = "↚";
var nLeftarrow = "⇍";
var nleftrightarrow = "↮";
var nLeftrightarrow = "⇎";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nLl = "⋘̸";
var nlsim = "≴";
var nLt = "≪⃒";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nLtv = "≪̸";
var nmid = "∤";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var nopf = "𝕟";
var Nopf = "ℕ";
var Not = "⫬";
var not$1 = "¬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var notin = "∉";
var notindot = "⋵̸";
var notinE = "⋹̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangle = "⋫";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var nparallel = "∦";
var npar = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var nprec = "⊀";
var npreceq = "⪯̸";
var npre = "⪯̸";
var nrarrc = "⤳̸";
var nrarr = "↛";
var nrArr = "⇏";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nRightarrow = "⇏";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var Nscr = "𝒩";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var Ntilde$1 = "Ñ";
var ntilde$1 = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var Nu = "Ν";
var nu = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvDash = "⊭";
var nVdash = "⊮";
var nVDash = "⊯";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvHarr = "⤄";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwarhk = "⤣";
var nwarr = "↖";
var nwArr = "⇖";
var nwarrow = "↖";
var nwnear = "⤧";
var Oacute$1 = "Ó";
var oacute$1 = "ó";
var oast = "⊛";
var Ocirc$1 = "Ô";
var ocirc$1 = "ô";
var ocir = "⊚";
var Ocy = "О";
var ocy = "о";
var odash = "⊝";
var Odblac = "Ő";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var OElig = "Œ";
var oelig = "œ";
var ofcir = "⦿";
var Ofr = "𝔒";
var ofr = "𝔬";
var ogon = "˛";
var Ograve$1 = "Ò";
var ograve$1 = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline = "‾";
var olt = "⧀";
var Omacr = "Ō";
var omacr = "ō";
var Omega = "Ω";
var omega = "ω";
var Omicron = "Ο";
var omicron = "ο";
var omid = "⦶";
var ominus = "⊖";
var Oopf = "𝕆";
var oopf = "𝕠";
var opar = "⦷";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var operp = "⦹";
var oplus = "⊕";
var orarr = "↻";
var Or = "⩔";
var or = "∨";
var ord = "⩝";
var order = "ℴ";
var orderof = "ℴ";
var ordf$1 = "ª";
var ordm$1 = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oS = "Ⓢ";
var Oscr = "𝒪";
var oscr = "ℴ";
var Oslash$1 = "Ø";
var oslash$1 = "ø";
var osol = "⊘";
var Otilde$1 = "Õ";
var otilde$1 = "õ";
var otimesas = "⨶";
var Otimes = "⨷";
var otimes = "⊗";
var Ouml$1 = "Ö";
var ouml$1 = "ö";
var ovbar = "⌽";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var para$1 = "¶";
var parallel = "∥";
var par = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part = "∂";
var PartialD = "∂";
var Pcy = "П";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var Pfr = "𝔓";
var pfr = "𝔭";
var Phi = "Φ";
var phi = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var Pi = "Π";
var pi = "π";
var pitchfork = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plus = "+";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var PlusMinus = "±";
var plusmn$1 = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var Poincareplane = "ℌ";
var pointint = "⨕";
var popf = "𝕡";
var Popf = "ℙ";
var pound$1 = "£";
var prap = "⪷";
var Pr = "⪻";
var pr = "≺";
var prcue = "≼";
var precapprox = "⪷";
var prec = "≺";
var preccurlyeq = "≼";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var pre = "⪯";
var prE = "⪳";
var precsim = "≾";
var prime = "′";
var Prime = "″";
var primes = "ℙ";
var prnap = "⪹";
var prnE = "⪵";
var prnsim = "⋨";
var prod = "∏";
var Product = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop = "∝";
var Proportional = "∝";
var Proportion = "∷";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var Pscr = "𝒫";
var pscr = "𝓅";
var Psi = "Ψ";
var psi = "ψ";
var puncsp = " ";
var Qfr = "𝔔";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var Qopf = "ℚ";
var qprime = "⁗";
var Qscr = "𝒬";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quot$2 = "\"";
var QUOT$1 = "\"";
var rAarr = "⇛";
var race = "∽̱";
var Racute = "Ŕ";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var rang = "⟩";
var Rang = "⟫";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raquo$1 = "»";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarr = "→";
var Rarr = "↠";
var rArr = "⇒";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var Rarrtl = "⤖";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var rAtail = "⤜";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rBarr = "⤏";
var RBarr = "⤐";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var Rcaron = "Ř";
var rcaron = "ř";
var Rcedil = "Ŗ";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var Rcy = "Р";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var real = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var Re = "ℜ";
var rect = "▭";
var reg$1 = "®";
var REG$1 = "®";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var rfisht = "⥽";
var rfloor = "⌋";
var rfr = "𝔯";
var Rfr = "ℜ";
var rHar = "⥤";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var Rho = "Ρ";
var rho = "ρ";
var rhov = "ϱ";
var RightAngleBracket = "⟩";
var RightArrowBar = "⇥";
var rightarrow = "→";
var RightArrow = "→";
var Rightarrow = "⇒";
var RightArrowLeftArrow = "⇄";
var rightarrowtail = "↣";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVectorBar = "⥕";
var RightDownVector = "⇂";
var RightFloor = "⌋";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var RightTeeArrow = "↦";
var RightTee = "⊢";
var RightTeeVector = "⥛";
var rightthreetimes = "⋌";
var RightTriangleBar = "⧐";
var RightTriangle = "⊳";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVectorBar = "⥔";
var RightUpVector = "↾";
var RightVectorBar = "⥓";
var RightVector = "⇀";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoustache = "⎱";
var rmoust = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var Ropf = "ℝ";
var roplus = "⨮";
var rotimes = "⨵";
var RoundImplies = "⥰";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var Rrightarrow = "⇛";
var rsaquo = "›";
var rscr = "𝓇";
var Rscr = "ℛ";
var rsh = "↱";
var Rsh = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var RuleDelayed = "⧴";
var ruluhar = "⥨";
var rx = "℞";
var Sacute = "Ś";
var sacute = "ś";
var sbquo = "‚";
var scap = "⪸";
var Scaron = "Š";
var scaron = "š";
var Sc = "⪼";
var sc = "≻";
var sccue = "≽";
var sce = "⪰";
var scE = "⪴";
var Scedil = "Ş";
var scedil = "ş";
var Scirc = "Ŝ";
var scirc = "ŝ";
var scnap = "⪺";
var scnE = "⪶";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var Scy = "С";
var scy = "с";
var sdotb = "⊡";
var sdot = "⋅";
var sdote = "⩦";
var searhk = "⤥";
var searr = "↘";
var seArr = "⇘";
var searrow = "↘";
var sect$1 = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var Sfr = "𝔖";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var SHCHcy = "Щ";
var shchcy = "щ";
var SHcy = "Ш";
var shcy = "ш";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var shortmid = "∣";
var shortparallel = "∥";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var shy$1 = "­";
var Sigma = "Σ";
var sigma = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var SmallCircle = "∘";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var SOFTcy = "Ь";
var softcy = "ь";
var solbar = "⌿";
var solb = "⧄";
var sol = "/";
var Sopf = "𝕊";
var sopf = "𝕤";
var spades = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var Sqrt = "√";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var square = "□";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var squarf = "▪";
var squ = "□";
var squf = "▪";
var srarr = "→";
var Sscr = "𝒮";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var Star = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub = "⊂";
var Sub = "⋐";
var subdot = "⪽";
var subE = "⫅";
var sube = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var Subset = "⋐";
var subseteq = "⊆";
var subseteqq = "⫅";
var SubsetEqual = "⊆";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succapprox = "⪸";
var succ = "≻";
var succcurlyeq = "≽";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var SuchThat = "∋";
var sum = "∑";
var Sum = "∑";
var sung = "♪";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var sup = "⊃";
var Sup = "⋑";
var supdot = "⪾";
var supdsub = "⫘";
var supE = "⫆";
var supe = "⊇";
var supedot = "⫄";
var Superset = "⊃";
var SupersetEqual = "⊇";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var Supset = "⋑";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swarhk = "⤦";
var swarr = "↙";
var swArr = "⇙";
var swarrow = "↙";
var swnwar = "⤪";
var szlig$1 = "ß";
var Tab = "\t";
var target = "⌖";
var Tau = "Τ";
var tau = "τ";
var tbrk = "⎴";
var Tcaron = "Ť";
var tcaron = "ť";
var Tcedil = "Ţ";
var tcedil = "ţ";
var Tcy = "Т";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var Tfr = "𝔗";
var tfr = "𝔱";
var there4 = "∴";
var therefore = "∴";
var Therefore = "∴";
var Theta = "Θ";
var theta = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var ThickSpace = "  ";
var ThinSpace = " ";
var thinsp = " ";
var thkap = "≈";
var thksim = "∼";
var THORN$1 = "Þ";
var thorn$1 = "þ";
var tilde = "˜";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var timesbar = "⨱";
var timesb = "⊠";
var times$1 = "×";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var topbot = "⌶";
var topcir = "⫱";
var top = "⊤";
var Topf = "𝕋";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade = "™";
var TRADE = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var TripleDot = "⃛";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var Tscr = "𝒯";
var tscr = "𝓉";
var TScy = "Ц";
var tscy = "ц";
var TSHcy = "Ћ";
var tshcy = "ћ";
var Tstrok = "Ŧ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var Uacute$1 = "Ú";
var uacute$1 = "ú";
var uarr = "↑";
var Uarr = "↟";
var uArr = "⇑";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var ubrcy = "ў";
var Ubreve = "Ŭ";
var ubreve = "ŭ";
var Ucirc$1 = "Û";
var ucirc$1 = "û";
var Ucy = "У";
var ucy = "у";
var udarr = "⇅";
var Udblac = "Ű";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var Ufr = "𝔘";
var ufr = "𝔲";
var Ugrave$1 = "Ù";
var ugrave$1 = "ù";
var uHar = "⥣";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var Umacr = "Ū";
var umacr = "ū";
var uml$1 = "¨";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var uogon = "ų";
var Uopf = "𝕌";
var uopf = "𝕦";
var UpArrowBar = "⤒";
var uparrow = "↑";
var UpArrow = "↑";
var Uparrow = "⇑";
var UpArrowDownArrow = "⇅";
var updownarrow = "↕";
var UpDownArrow = "↕";
var Updownarrow = "⇕";
var UpEquilibrium = "⥮";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var upsi = "υ";
var Upsi = "ϒ";
var upsih = "ϒ";
var Upsilon = "Υ";
var upsilon = "υ";
var UpTeeArrow = "↥";
var UpTee = "⊥";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var Uring = "Ů";
var uring = "ů";
var urtri = "◹";
var Uscr = "𝒰";
var uscr = "𝓊";
var utdot = "⋰";
var Utilde = "Ũ";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var Uuml$1 = "Ü";
var uuml$1 = "ü";
var uwangle = "⦧";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var vArr = "⇕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vBar = "⫨";
var Vbar = "⫫";
var vBarv = "⫩";
var Vcy = "В";
var vcy = "в";
var vdash = "⊢";
var vDash = "⊨";
var Vdash = "⊩";
var VDash = "⊫";
var Vdashl = "⫦";
var veebar = "⊻";
var vee = "∨";
var Vee = "⋁";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var Verbar = "‖";
var vert = "|";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var Vopf = "𝕍";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var Vscr = "𝒱";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var Vvdash = "⊪";
var vzigzag = "⦚";
var Wcirc = "Ŵ";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var Wedge = "⋀";
var wedgeq = "≙";
var weierp = "℘";
var Wfr = "𝔚";
var wfr = "𝔴";
var Wopf = "𝕎";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var Wscr = "𝒲";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var Xfr = "𝔛";
var xfr = "𝔵";
var xharr = "⟷";
var xhArr = "⟺";
var Xi = "Ξ";
var xi = "ξ";
var xlarr = "⟵";
var xlArr = "⟸";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var Xopf = "𝕏";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrarr = "⟶";
var xrArr = "⟹";
var Xscr = "𝒳";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var Yacute$1 = "Ý";
var yacute$1 = "ý";
var YAcy = "Я";
var yacy = "я";
var Ycirc = "Ŷ";
var ycirc = "ŷ";
var Ycy = "Ы";
var ycy = "ы";
var yen$1 = "¥";
var Yfr = "𝔜";
var yfr = "𝔶";
var YIcy = "Ї";
var yicy = "ї";
var Yopf = "𝕐";
var yopf = "𝕪";
var Yscr = "𝒴";
var yscr = "𝓎";
var YUcy = "Ю";
var yucy = "ю";
var yuml$1 = "ÿ";
var Yuml = "Ÿ";
var Zacute = "Ź";
var zacute = "ź";
var Zcaron = "Ž";
var zcaron = "ž";
var Zcy = "З";
var zcy = "з";
var Zdot = "Ż";
var zdot = "ż";
var zeetrf = "ℨ";
var ZeroWidthSpace = "​";
var Zeta = "Ζ";
var zeta = "ζ";
var zfr = "𝔷";
var Zfr = "ℨ";
var ZHcy = "Ж";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var Zopf = "ℤ";
var Zscr = "𝒵";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
var require$$1$1 = {
	Aacute: Aacute$1,
	aacute: aacute$1,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc$1,
	acirc: acirc$1,
	acute: acute$1,
	Acy: Acy,
	acy: acy,
	AElig: AElig$1,
	aelig: aelig$1,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave$1,
	agrave: agrave$1,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp$2,
	AMP: AMP$1,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos$1,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring$1,
	aring: aring$1,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde$1,
	atilde: atilde$1,
	Auml: Auml$1,
	auml: auml$1,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar$1,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil$1,
	ccedil: ccedil$1,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil$1,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent$1,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy$4,
	COPY: COPY$1,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren$1,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg$1,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide$1,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute$1,
	eacute: eacute$1,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc$1,
	ecirc: ecirc$1,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave$1,
	egrave: egrave$1,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element$1,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty$1,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH$1,
	eth: eth$1,
	Euml: Euml$1,
	euml: euml$1,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12$1,
	frac13: frac13,
	frac14: frac14$1,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34$1,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt$2,
	GT: GT$1,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute$1,
	iacute: iacute$1,
	ic: ic,
	Icirc: Icirc$1,
	icirc: icirc$1,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl$1,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave$1,
	igrave: igrave$1,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	"in": "∈",
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest$1,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml$1,
	iuml: iuml$1,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo$1,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt$2,
	LT: LT$1,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr$1,
	male: male,
	malt: malt,
	maltese: maltese,
	"Map": "⤅",
	map: map,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro$1,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot$1,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp$1,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not$1,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde$1,
	ntilde: ntilde$1,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute$1,
	oacute: oacute$1,
	oast: oast,
	Ocirc: Ocirc$1,
	ocirc: ocirc$1,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve$1,
	ograve: ograve$1,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf$1,
	ordm: ordm$1,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash$1,
	oslash: oslash$1,
	osol: osol,
	Otilde: Otilde$1,
	otilde: otilde$1,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml$1,
	ouml: ouml$1,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para$1,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn$1,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound$1,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot$2,
	QUOT: QUOT$1,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo$1,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg$1,
	REG: REG$1,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect$1,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy$1,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig$1,
	Tab: Tab,
	target: target,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN$1,
	thorn: thorn$1,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times$1,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute$1,
	uacute: uacute$1,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc$1,
	ucirc: ucirc$1,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave$1,
	ugrave: ugrave$1,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml$1,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml$1,
	uuml: uuml$1,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute$1,
	yacute: yacute$1,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen$1,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml$1,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

var Aacute = "Á";
var aacute = "á";
var Acirc = "Â";
var acirc = "â";
var acute = "´";
var AElig = "Æ";
var aelig = "æ";
var Agrave = "À";
var agrave = "à";
var amp$1 = "&";
var AMP = "&";
var Aring = "Å";
var aring = "å";
var Atilde = "Ã";
var atilde = "ã";
var Auml = "Ä";
var auml = "ä";
var brvbar = "¦";
var Ccedil = "Ç";
var ccedil = "ç";
var cedil = "¸";
var cent = "¢";
var copy$3 = "©";
var COPY = "©";
var curren = "¤";
var deg = "°";
var divide = "÷";
var Eacute = "É";
var eacute = "é";
var Ecirc = "Ê";
var ecirc = "ê";
var Egrave = "È";
var egrave = "è";
var ETH = "Ð";
var eth = "ð";
var Euml = "Ë";
var euml = "ë";
var frac12 = "½";
var frac14 = "¼";
var frac34 = "¾";
var gt$1 = ">";
var GT = ">";
var Iacute = "Í";
var iacute = "í";
var Icirc = "Î";
var icirc = "î";
var iexcl = "¡";
var Igrave = "Ì";
var igrave = "ì";
var iquest = "¿";
var Iuml = "Ï";
var iuml = "ï";
var laquo = "«";
var lt$1 = "<";
var LT = "<";
var macr = "¯";
var micro = "µ";
var middot = "·";
var nbsp = " ";
var not = "¬";
var Ntilde = "Ñ";
var ntilde = "ñ";
var Oacute = "Ó";
var oacute = "ó";
var Ocirc = "Ô";
var ocirc = "ô";
var Ograve = "Ò";
var ograve = "ò";
var ordf = "ª";
var ordm = "º";
var Oslash = "Ø";
var oslash = "ø";
var Otilde = "Õ";
var otilde = "õ";
var Ouml = "Ö";
var ouml = "ö";
var para = "¶";
var plusmn = "±";
var pound = "£";
var quot$1 = "\"";
var QUOT = "\"";
var raquo = "»";
var reg = "®";
var REG = "®";
var sect = "§";
var shy = "­";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var szlig = "ß";
var THORN = "Þ";
var thorn = "þ";
var times = "×";
var Uacute = "Ú";
var uacute = "ú";
var Ucirc = "Û";
var ucirc = "û";
var Ugrave = "Ù";
var ugrave = "ù";
var uml = "¨";
var Uuml = "Ü";
var uuml = "ü";
var Yacute = "Ý";
var yacute = "ý";
var yen = "¥";
var yuml = "ÿ";
var require$$1 = {
	Aacute: Aacute,
	aacute: aacute,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	AElig: AElig,
	aelig: aelig,
	Agrave: Agrave,
	agrave: agrave,
	amp: amp$1,
	AMP: AMP,
	Aring: Aring,
	aring: aring,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	brvbar: brvbar,
	Ccedil: Ccedil,
	ccedil: ccedil,
	cedil: cedil,
	cent: cent,
	copy: copy$3,
	COPY: COPY,
	curren: curren,
	deg: deg,
	divide: divide,
	Eacute: Eacute,
	eacute: eacute,
	Ecirc: Ecirc,
	ecirc: ecirc,
	Egrave: Egrave,
	egrave: egrave,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	frac12: frac12,
	frac14: frac14,
	frac34: frac34,
	gt: gt$1,
	GT: GT,
	Iacute: Iacute,
	iacute: iacute,
	Icirc: Icirc,
	icirc: icirc,
	iexcl: iexcl,
	Igrave: Igrave,
	igrave: igrave,
	iquest: iquest,
	Iuml: Iuml,
	iuml: iuml,
	laquo: laquo,
	lt: lt$1,
	LT: LT,
	macr: macr,
	micro: micro,
	middot: middot,
	nbsp: nbsp,
	not: not,
	Ntilde: Ntilde,
	ntilde: ntilde,
	Oacute: Oacute,
	oacute: oacute,
	Ocirc: Ocirc,
	ocirc: ocirc,
	Ograve: Ograve,
	ograve: ograve,
	ordf: ordf,
	ordm: ordm,
	Oslash: Oslash,
	oslash: oslash,
	Otilde: Otilde,
	otilde: otilde,
	Ouml: Ouml,
	ouml: ouml,
	para: para,
	plusmn: plusmn,
	pound: pound,
	quot: quot$1,
	QUOT: QUOT,
	raquo: raquo,
	reg: reg,
	REG: REG,
	sect: sect,
	shy: shy,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	szlig: szlig,
	THORN: THORN,
	thorn: thorn,
	times: times,
	Uacute: Uacute,
	uacute: uacute,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uml: uml,
	Uuml: Uuml,
	uuml: uuml,
	Yacute: Yacute,
	yacute: yacute,
	yen: yen,
	yuml: yuml
};

var amp = "&";
var apos = "'";
var gt = ">";
var lt = "<";
var quot = "\"";
var require$$0$1 = {
	amp: amp,
	apos: apos,
	gt: gt,
	lt: lt,
	quot: quot
};

var __importDefault$6 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(Tokenizer$6, "__esModule", { value: true });
var decode_codepoint_1$1 = __importDefault$6(decode_codepoint);
var entities_json_1$2 = __importDefault$6(require$$1$1);
var legacy_json_1$1 = __importDefault$6(require$$1);
var xml_json_1$2 = __importDefault$6(require$$0$1);
function whitespace(c) {
    return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
function isASCIIAlpha(c) {
    return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z");
}
function ifElseState(upper, SUCCESS, FAILURE) {
    var lower = upper.toLowerCase();
    if (upper === lower) {
        return function (t, c) {
            if (c === lower) {
                t._state = SUCCESS;
            }
            else {
                t._state = FAILURE;
                t._index--;
            }
        };
    }
    return function (t, c) {
        if (c === lower || c === upper) {
            t._state = SUCCESS;
        }
        else {
            t._state = FAILURE;
            t._index--;
        }
    };
}
function consumeSpecialNameChar(upper, NEXT_STATE) {
    var lower = upper.toLowerCase();
    return function (t, c) {
        if (c === lower || c === upper) {
            t._state = NEXT_STATE;
        }
        else {
            t._state = 3 /* InTagName */;
            t._index--; // Consume the token again
        }
    };
}
var stateBeforeCdata1 = ifElseState("C", 24 /* BeforeCdata2 */, 16 /* InDeclaration */);
var stateBeforeCdata2 = ifElseState("D", 25 /* BeforeCdata3 */, 16 /* InDeclaration */);
var stateBeforeCdata3 = ifElseState("A", 26 /* BeforeCdata4 */, 16 /* InDeclaration */);
var stateBeforeCdata4 = ifElseState("T", 27 /* BeforeCdata5 */, 16 /* InDeclaration */);
var stateBeforeCdata5 = ifElseState("A", 28 /* BeforeCdata6 */, 16 /* InDeclaration */);
var stateBeforeScript1 = consumeSpecialNameChar("R", 35 /* BeforeScript2 */);
var stateBeforeScript2 = consumeSpecialNameChar("I", 36 /* BeforeScript3 */);
var stateBeforeScript3 = consumeSpecialNameChar("P", 37 /* BeforeScript4 */);
var stateBeforeScript4 = consumeSpecialNameChar("T", 38 /* BeforeScript5 */);
var stateAfterScript1 = ifElseState("R", 40 /* AfterScript2 */, 1 /* Text */);
var stateAfterScript2 = ifElseState("I", 41 /* AfterScript3 */, 1 /* Text */);
var stateAfterScript3 = ifElseState("P", 42 /* AfterScript4 */, 1 /* Text */);
var stateAfterScript4 = ifElseState("T", 43 /* AfterScript5 */, 1 /* Text */);
var stateBeforeStyle1 = consumeSpecialNameChar("Y", 45 /* BeforeStyle2 */);
var stateBeforeStyle2 = consumeSpecialNameChar("L", 46 /* BeforeStyle3 */);
var stateBeforeStyle3 = consumeSpecialNameChar("E", 47 /* BeforeStyle4 */);
var stateAfterStyle1 = ifElseState("Y", 49 /* AfterStyle2 */, 1 /* Text */);
var stateAfterStyle2 = ifElseState("L", 50 /* AfterStyle3 */, 1 /* Text */);
var stateAfterStyle3 = ifElseState("E", 51 /* AfterStyle4 */, 1 /* Text */);
var stateBeforeSpecialT = consumeSpecialNameChar("I", 54 /* BeforeTitle1 */);
var stateBeforeTitle1 = consumeSpecialNameChar("T", 55 /* BeforeTitle2 */);
var stateBeforeTitle2 = consumeSpecialNameChar("L", 56 /* BeforeTitle3 */);
var stateBeforeTitle3 = consumeSpecialNameChar("E", 57 /* BeforeTitle4 */);
var stateAfterSpecialTEnd = ifElseState("I", 58 /* AfterTitle1 */, 1 /* Text */);
var stateAfterTitle1 = ifElseState("T", 59 /* AfterTitle2 */, 1 /* Text */);
var stateAfterTitle2 = ifElseState("L", 60 /* AfterTitle3 */, 1 /* Text */);
var stateAfterTitle3 = ifElseState("E", 61 /* AfterTitle4 */, 1 /* Text */);
var stateBeforeEntity = ifElseState("#", 63 /* BeforeNumericEntity */, 64 /* InNamedEntity */);
var stateBeforeNumericEntity = ifElseState("X", 66 /* InHexEntity */, 65 /* InNumericEntity */);
var Tokenizer$5 = /** @class */ (function () {
    function Tokenizer(options, cbs) {
        var _a;
        /** The current state the tokenizer is in. */
        this._state = 1 /* Text */;
        /** The read buffer. */
        this.buffer = "";
        /** The beginning of the section that is currently being read. */
        this.sectionStart = 0;
        /** The index within the buffer that we are currently looking at. */
        this._index = 0;
        /**
         * Data that has already been processed will be removed from the buffer occasionally.
         * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.
         */
        this.bufferOffset = 0;
        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
        this.baseState = 1 /* Text */;
        /** For special parsing behavior inside of script and style tags. */
        this.special = 1 /* None */;
        /** Indicates whether the tokenizer has been paused. */
        this.running = true;
        /** Indicates whether the tokenizer has finished running / `.end` has been called. */
        this.ended = false;
        this.cbs = cbs;
        this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
        this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;
    }
    Tokenizer.prototype.reset = function () {
        this._state = 1 /* Text */;
        this.buffer = "";
        this.sectionStart = 0;
        this._index = 0;
        this.bufferOffset = 0;
        this.baseState = 1 /* Text */;
        this.special = 1 /* None */;
        this.running = true;
        this.ended = false;
    };
    Tokenizer.prototype.write = function (chunk) {
        if (this.ended)
            this.cbs.onerror(Error(".write() after done!"));
        this.buffer += chunk;
        this.parse();
    };
    Tokenizer.prototype.end = function (chunk) {
        if (this.ended)
            this.cbs.onerror(Error(".end() after done!"));
        if (chunk)
            this.write(chunk);
        this.ended = true;
        if (this.running)
            this.finish();
    };
    Tokenizer.prototype.pause = function () {
        this.running = false;
    };
    Tokenizer.prototype.resume = function () {
        this.running = true;
        if (this._index < this.buffer.length) {
            this.parse();
        }
        if (this.ended) {
            this.finish();
        }
    };
    /**
     * The current index within all of the written data.
     */
    Tokenizer.prototype.getAbsoluteIndex = function () {
        return this.bufferOffset + this._index;
    };
    Tokenizer.prototype.stateText = function (c) {
        if (c === "<") {
            if (this._index > this.sectionStart) {
                this.cbs.ontext(this.getSection());
            }
            this._state = 2 /* BeforeTagName */;
            this.sectionStart = this._index;
        }
        else if (this.decodeEntities &&
            c === "&" &&
            (this.special === 1 /* None */ || this.special === 4 /* Title */)) {
            if (this._index > this.sectionStart) {
                this.cbs.ontext(this.getSection());
            }
            this.baseState = 1 /* Text */;
            this._state = 62 /* BeforeEntity */;
            this.sectionStart = this._index;
        }
    };
    /**
     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
     *
     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
     * We allow anything that wouldn't end the tag.
     */
    Tokenizer.prototype.isTagStartChar = function (c) {
        return (isASCIIAlpha(c) ||
            (this.xmlMode && !whitespace(c) && c !== "/" && c !== ">"));
    };
    Tokenizer.prototype.stateBeforeTagName = function (c) {
        if (c === "/") {
            this._state = 5 /* BeforeClosingTagName */;
        }
        else if (c === "<") {
            this.cbs.ontext(this.getSection());
            this.sectionStart = this._index;
        }
        else if (c === ">" ||
            this.special !== 1 /* None */ ||
            whitespace(c)) {
            this._state = 1 /* Text */;
        }
        else if (c === "!") {
            this._state = 15 /* BeforeDeclaration */;
            this.sectionStart = this._index + 1;
        }
        else if (c === "?") {
            this._state = 17 /* InProcessingInstruction */;
            this.sectionStart = this._index + 1;
        }
        else if (!this.isTagStartChar(c)) {
            this._state = 1 /* Text */;
        }
        else {
            this._state =
                !this.xmlMode && (c === "s" || c === "S")
                    ? 32 /* BeforeSpecialS */
                    : !this.xmlMode && (c === "t" || c === "T")
                        ? 52 /* BeforeSpecialT */
                        : 3 /* InTagName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInTagName = function (c) {
        if (c === "/" || c === ">" || whitespace(c)) {
            this.emitToken("onopentagname");
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
        if (whitespace(c)) ;
        else if (c === ">") {
            this._state = 1 /* Text */;
        }
        else if (this.special !== 1 /* None */) {
            if (this.special !== 4 /* Title */ && (c === "s" || c === "S")) {
                this._state = 33 /* BeforeSpecialSEnd */;
            }
            else if (this.special === 4 /* Title */ &&
                (c === "t" || c === "T")) {
                this._state = 53 /* BeforeSpecialTEnd */;
            }
            else {
                this._state = 1 /* Text */;
                this._index--;
            }
        }
        else if (!this.isTagStartChar(c)) {
            this._state = 20 /* InSpecialComment */;
            this.sectionStart = this._index;
        }
        else {
            this._state = 6 /* InClosingTagName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInClosingTagName = function (c) {
        if (c === ">" || whitespace(c)) {
            this.emitToken("onclosetag");
            this._state = 7 /* AfterClosingTagName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateAfterClosingTagName = function (c) {
        // Skip everything until ">"
        if (c === ">") {
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeName = function (c) {
        if (c === ">") {
            this.cbs.onopentagend();
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
        else if (c === "/") {
            this._state = 4 /* InSelfClosingTag */;
        }
        else if (!whitespace(c)) {
            this._state = 9 /* InAttributeName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInSelfClosingTag = function (c) {
        if (c === ">") {
            this.cbs.onselfclosingtag();
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
            this.special = 1 /* None */; // Reset special state, in case of self-closing special tags
        }
        else if (!whitespace(c)) {
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateInAttributeName = function (c) {
        if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
            this.cbs.onattribname(this.getSection());
            this.sectionStart = -1;
            this._state = 10 /* AfterAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateAfterAttributeName = function (c) {
        if (c === "=") {
            this._state = 11 /* BeforeAttributeValue */;
        }
        else if (c === "/" || c === ">") {
            this.cbs.onattribend(undefined);
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
        else if (!whitespace(c)) {
            this.cbs.onattribend(undefined);
            this._state = 9 /* InAttributeName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
        if (c === '"') {
            this._state = 12 /* InAttributeValueDq */;
            this.sectionStart = this._index + 1;
        }
        else if (c === "'") {
            this._state = 13 /* InAttributeValueSq */;
            this.sectionStart = this._index + 1;
        }
        else if (!whitespace(c)) {
            this._state = 14 /* InAttributeValueNq */;
            this.sectionStart = this._index;
            this._index--; // Reconsume token
        }
    };
    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
        if (c === quote) {
            this.emitToken("onattribdata");
            this.cbs.onattribend(quote);
            this._state = 8 /* BeforeAttributeName */;
        }
        else if (this.decodeEntities && c === "&") {
            this.emitToken("onattribdata");
            this.baseState = this._state;
            this._state = 62 /* BeforeEntity */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
        this.handleInAttributeValue(c, '"');
    };
    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
        this.handleInAttributeValue(c, "'");
    };
    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
        if (whitespace(c) || c === ">") {
            this.emitToken("onattribdata");
            this.cbs.onattribend(null);
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
        else if (this.decodeEntities && c === "&") {
            this.emitToken("onattribdata");
            this.baseState = this._state;
            this._state = 62 /* BeforeEntity */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateBeforeDeclaration = function (c) {
        this._state =
            c === "["
                ? 23 /* BeforeCdata1 */
                : c === "-"
                    ? 18 /* BeforeComment */
                    : 16 /* InDeclaration */;
    };
    Tokenizer.prototype.stateInDeclaration = function (c) {
        if (c === ">") {
            this.cbs.ondeclaration(this.getSection());
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateInProcessingInstruction = function (c) {
        if (c === ">") {
            this.cbs.onprocessinginstruction(this.getSection());
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeComment = function (c) {
        if (c === "-") {
            this._state = 19 /* InComment */;
            this.sectionStart = this._index + 1;
        }
        else {
            this._state = 16 /* InDeclaration */;
        }
    };
    Tokenizer.prototype.stateInComment = function (c) {
        if (c === "-")
            this._state = 21 /* AfterComment1 */;
    };
    Tokenizer.prototype.stateInSpecialComment = function (c) {
        if (c === ">") {
            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateAfterComment1 = function (c) {
        if (c === "-") {
            this._state = 22 /* AfterComment2 */;
        }
        else {
            this._state = 19 /* InComment */;
        }
    };
    Tokenizer.prototype.stateAfterComment2 = function (c) {
        if (c === ">") {
            // Remove 2 trailing chars
            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
        else if (c !== "-") {
            this._state = 19 /* InComment */;
        }
        // Else: stay in AFTER_COMMENT_2 (`--->`)
    };
    Tokenizer.prototype.stateBeforeCdata6 = function (c) {
        if (c === "[") {
            this._state = 29 /* InCdata */;
            this.sectionStart = this._index + 1;
        }
        else {
            this._state = 16 /* InDeclaration */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateInCdata = function (c) {
        if (c === "]")
            this._state = 30 /* AfterCdata1 */;
    };
    Tokenizer.prototype.stateAfterCdata1 = function (c) {
        if (c === "]")
            this._state = 31 /* AfterCdata2 */;
        else
            this._state = 29 /* InCdata */;
    };
    Tokenizer.prototype.stateAfterCdata2 = function (c) {
        if (c === ">") {
            // Remove 2 trailing chars
            this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
        else if (c !== "]") {
            this._state = 29 /* InCdata */;
        }
        // Else: stay in AFTER_CDATA_2 (`]]]>`)
    };
    Tokenizer.prototype.stateBeforeSpecialS = function (c) {
        if (c === "c" || c === "C") {
            this._state = 34 /* BeforeScript1 */;
        }
        else if (c === "t" || c === "T") {
            this._state = 44 /* BeforeStyle1 */;
        }
        else {
            this._state = 3 /* InTagName */;
            this._index--; // Consume the token again
        }
    };
    Tokenizer.prototype.stateBeforeSpecialSEnd = function (c) {
        if (this.special === 2 /* Script */ && (c === "c" || c === "C")) {
            this._state = 39 /* AfterScript1 */;
        }
        else if (this.special === 3 /* Style */ && (c === "t" || c === "T")) {
            this._state = 48 /* AfterStyle1 */;
        }
        else
            this._state = 1 /* Text */;
    };
    Tokenizer.prototype.stateBeforeSpecialLast = function (c, special) {
        if (c === "/" || c === ">" || whitespace(c)) {
            this.special = special;
        }
        this._state = 3 /* InTagName */;
        this._index--; // Consume the token again
    };
    Tokenizer.prototype.stateAfterSpecialLast = function (c, sectionStartOffset) {
        if (c === ">" || whitespace(c)) {
            this.special = 1 /* None */;
            this._state = 6 /* InClosingTagName */;
            this.sectionStart = this._index - sectionStartOffset;
            this._index--; // Reconsume the token
        }
        else
            this._state = 1 /* Text */;
    };
    // For entities terminated with a semicolon
    Tokenizer.prototype.parseFixedEntity = function (map) {
        if (map === void 0) { map = this.xmlMode ? xml_json_1$2.default : entities_json_1$2.default; }
        // Offset = 1
        if (this.sectionStart + 1 < this._index) {
            var entity = this.buffer.substring(this.sectionStart + 1, this._index);
            if (Object.prototype.hasOwnProperty.call(map, entity)) {
                this.emitPartial(map[entity]);
                this.sectionStart = this._index + 1;
            }
        }
    };
    // Parses legacy entities (without trailing semicolon)
    Tokenizer.prototype.parseLegacyEntity = function () {
        var start = this.sectionStart + 1;
        // The max length of legacy entities is 6
        var limit = Math.min(this._index - start, 6);
        while (limit >= 2) {
            // The min length of legacy entities is 2
            var entity = this.buffer.substr(start, limit);
            if (Object.prototype.hasOwnProperty.call(legacy_json_1$1.default, entity)) {
                this.emitPartial(legacy_json_1$1.default[entity]);
                this.sectionStart += limit + 1;
                return;
            }
            limit--;
        }
    };
    Tokenizer.prototype.stateInNamedEntity = function (c) {
        if (c === ";") {
            this.parseFixedEntity();
            // Retry as legacy entity if entity wasn't parsed
            if (this.baseState === 1 /* Text */ &&
                this.sectionStart + 1 < this._index &&
                !this.xmlMode) {
                this.parseLegacyEntity();
            }
            this._state = this.baseState;
        }
        else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
            if (this.xmlMode || this.sectionStart + 1 === this._index) ;
            else if (this.baseState !== 1 /* Text */) {
                if (c !== "=") {
                    // Parse as legacy entity, without allowing additional characters.
                    this.parseFixedEntity(legacy_json_1$1.default);
                }
            }
            else {
                this.parseLegacyEntity();
            }
            this._state = this.baseState;
            this._index--;
        }
    };
    Tokenizer.prototype.decodeNumericEntity = function (offset, base, strict) {
        var sectionStart = this.sectionStart + offset;
        if (sectionStart !== this._index) {
            // Parse entity
            var entity = this.buffer.substring(sectionStart, this._index);
            var parsed = parseInt(entity, base);
            this.emitPartial(decode_codepoint_1$1.default(parsed));
            this.sectionStart = strict ? this._index + 1 : this._index;
        }
        this._state = this.baseState;
    };
    Tokenizer.prototype.stateInNumericEntity = function (c) {
        if (c === ";") {
            this.decodeNumericEntity(2, 10, true);
        }
        else if (c < "0" || c > "9") {
            if (!this.xmlMode) {
                this.decodeNumericEntity(2, 10, false);
            }
            else {
                this._state = this.baseState;
            }
            this._index--;
        }
    };
    Tokenizer.prototype.stateInHexEntity = function (c) {
        if (c === ";") {
            this.decodeNumericEntity(3, 16, true);
        }
        else if ((c < "a" || c > "f") &&
            (c < "A" || c > "F") &&
            (c < "0" || c > "9")) {
            if (!this.xmlMode) {
                this.decodeNumericEntity(3, 16, false);
            }
            else {
                this._state = this.baseState;
            }
            this._index--;
        }
    };
    Tokenizer.prototype.cleanup = function () {
        if (this.sectionStart < 0) {
            this.buffer = "";
            this.bufferOffset += this._index;
            this._index = 0;
        }
        else if (this.running) {
            if (this._state === 1 /* Text */) {
                if (this.sectionStart !== this._index) {
                    this.cbs.ontext(this.buffer.substr(this.sectionStart));
                }
                this.buffer = "";
                this.bufferOffset += this._index;
                this._index = 0;
            }
            else if (this.sectionStart === this._index) {
                // The section just started
                this.buffer = "";
                this.bufferOffset += this._index;
                this._index = 0;
            }
            else {
                // Remove everything unnecessary
                this.buffer = this.buffer.substr(this.sectionStart);
                this._index -= this.sectionStart;
                this.bufferOffset += this.sectionStart;
            }
            this.sectionStart = 0;
        }
    };
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    Tokenizer.prototype.parse = function () {
        while (this._index < this.buffer.length && this.running) {
            var c = this.buffer.charAt(this._index);
            if (this._state === 1 /* Text */) {
                this.stateText(c);
            }
            else if (this._state === 12 /* InAttributeValueDq */) {
                this.stateInAttributeValueDoubleQuotes(c);
            }
            else if (this._state === 9 /* InAttributeName */) {
                this.stateInAttributeName(c);
            }
            else if (this._state === 19 /* InComment */) {
                this.stateInComment(c);
            }
            else if (this._state === 20 /* InSpecialComment */) {
                this.stateInSpecialComment(c);
            }
            else if (this._state === 8 /* BeforeAttributeName */) {
                this.stateBeforeAttributeName(c);
            }
            else if (this._state === 3 /* InTagName */) {
                this.stateInTagName(c);
            }
            else if (this._state === 6 /* InClosingTagName */) {
                this.stateInClosingTagName(c);
            }
            else if (this._state === 2 /* BeforeTagName */) {
                this.stateBeforeTagName(c);
            }
            else if (this._state === 10 /* AfterAttributeName */) {
                this.stateAfterAttributeName(c);
            }
            else if (this._state === 13 /* InAttributeValueSq */) {
                this.stateInAttributeValueSingleQuotes(c);
            }
            else if (this._state === 11 /* BeforeAttributeValue */) {
                this.stateBeforeAttributeValue(c);
            }
            else if (this._state === 5 /* BeforeClosingTagName */) {
                this.stateBeforeClosingTagName(c);
            }
            else if (this._state === 7 /* AfterClosingTagName */) {
                this.stateAfterClosingTagName(c);
            }
            else if (this._state === 32 /* BeforeSpecialS */) {
                this.stateBeforeSpecialS(c);
            }
            else if (this._state === 21 /* AfterComment1 */) {
                this.stateAfterComment1(c);
            }
            else if (this._state === 14 /* InAttributeValueNq */) {
                this.stateInAttributeValueNoQuotes(c);
            }
            else if (this._state === 4 /* InSelfClosingTag */) {
                this.stateInSelfClosingTag(c);
            }
            else if (this._state === 16 /* InDeclaration */) {
                this.stateInDeclaration(c);
            }
            else if (this._state === 15 /* BeforeDeclaration */) {
                this.stateBeforeDeclaration(c);
            }
            else if (this._state === 22 /* AfterComment2 */) {
                this.stateAfterComment2(c);
            }
            else if (this._state === 18 /* BeforeComment */) {
                this.stateBeforeComment(c);
            }
            else if (this._state === 33 /* BeforeSpecialSEnd */) {
                this.stateBeforeSpecialSEnd(c);
            }
            else if (this._state === 53 /* BeforeSpecialTEnd */) {
                stateAfterSpecialTEnd(this, c);
            }
            else if (this._state === 39 /* AfterScript1 */) {
                stateAfterScript1(this, c);
            }
            else if (this._state === 40 /* AfterScript2 */) {
                stateAfterScript2(this, c);
            }
            else if (this._state === 41 /* AfterScript3 */) {
                stateAfterScript3(this, c);
            }
            else if (this._state === 34 /* BeforeScript1 */) {
                stateBeforeScript1(this, c);
            }
            else if (this._state === 35 /* BeforeScript2 */) {
                stateBeforeScript2(this, c);
            }
            else if (this._state === 36 /* BeforeScript3 */) {
                stateBeforeScript3(this, c);
            }
            else if (this._state === 37 /* BeforeScript4 */) {
                stateBeforeScript4(this, c);
            }
            else if (this._state === 38 /* BeforeScript5 */) {
                this.stateBeforeSpecialLast(c, 2 /* Script */);
            }
            else if (this._state === 42 /* AfterScript4 */) {
                stateAfterScript4(this, c);
            }
            else if (this._state === 43 /* AfterScript5 */) {
                this.stateAfterSpecialLast(c, 6);
            }
            else if (this._state === 44 /* BeforeStyle1 */) {
                stateBeforeStyle1(this, c);
            }
            else if (this._state === 29 /* InCdata */) {
                this.stateInCdata(c);
            }
            else if (this._state === 45 /* BeforeStyle2 */) {
                stateBeforeStyle2(this, c);
            }
            else if (this._state === 46 /* BeforeStyle3 */) {
                stateBeforeStyle3(this, c);
            }
            else if (this._state === 47 /* BeforeStyle4 */) {
                this.stateBeforeSpecialLast(c, 3 /* Style */);
            }
            else if (this._state === 48 /* AfterStyle1 */) {
                stateAfterStyle1(this, c);
            }
            else if (this._state === 49 /* AfterStyle2 */) {
                stateAfterStyle2(this, c);
            }
            else if (this._state === 50 /* AfterStyle3 */) {
                stateAfterStyle3(this, c);
            }
            else if (this._state === 51 /* AfterStyle4 */) {
                this.stateAfterSpecialLast(c, 5);
            }
            else if (this._state === 52 /* BeforeSpecialT */) {
                stateBeforeSpecialT(this, c);
            }
            else if (this._state === 54 /* BeforeTitle1 */) {
                stateBeforeTitle1(this, c);
            }
            else if (this._state === 55 /* BeforeTitle2 */) {
                stateBeforeTitle2(this, c);
            }
            else if (this._state === 56 /* BeforeTitle3 */) {
                stateBeforeTitle3(this, c);
            }
            else if (this._state === 57 /* BeforeTitle4 */) {
                this.stateBeforeSpecialLast(c, 4 /* Title */);
            }
            else if (this._state === 58 /* AfterTitle1 */) {
                stateAfterTitle1(this, c);
            }
            else if (this._state === 59 /* AfterTitle2 */) {
                stateAfterTitle2(this, c);
            }
            else if (this._state === 60 /* AfterTitle3 */) {
                stateAfterTitle3(this, c);
            }
            else if (this._state === 61 /* AfterTitle4 */) {
                this.stateAfterSpecialLast(c, 5);
            }
            else if (this._state === 17 /* InProcessingInstruction */) {
                this.stateInProcessingInstruction(c);
            }
            else if (this._state === 64 /* InNamedEntity */) {
                this.stateInNamedEntity(c);
            }
            else if (this._state === 23 /* BeforeCdata1 */) {
                stateBeforeCdata1(this, c);
            }
            else if (this._state === 62 /* BeforeEntity */) {
                stateBeforeEntity(this, c);
            }
            else if (this._state === 24 /* BeforeCdata2 */) {
                stateBeforeCdata2(this, c);
            }
            else if (this._state === 25 /* BeforeCdata3 */) {
                stateBeforeCdata3(this, c);
            }
            else if (this._state === 30 /* AfterCdata1 */) {
                this.stateAfterCdata1(c);
            }
            else if (this._state === 31 /* AfterCdata2 */) {
                this.stateAfterCdata2(c);
            }
            else if (this._state === 26 /* BeforeCdata4 */) {
                stateBeforeCdata4(this, c);
            }
            else if (this._state === 27 /* BeforeCdata5 */) {
                stateBeforeCdata5(this, c);
            }
            else if (this._state === 28 /* BeforeCdata6 */) {
                this.stateBeforeCdata6(c);
            }
            else if (this._state === 66 /* InHexEntity */) {
                this.stateInHexEntity(c);
            }
            else if (this._state === 65 /* InNumericEntity */) {
                this.stateInNumericEntity(c);
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            }
            else if (this._state === 63 /* BeforeNumericEntity */) {
                stateBeforeNumericEntity(this, c);
            }
            else {
                this.cbs.onerror(Error("unknown _state"), this._state);
            }
            this._index++;
        }
        this.cleanup();
    };
    Tokenizer.prototype.finish = function () {
        // If there is remaining data, emit it in a reasonable way
        if (this.sectionStart < this._index) {
            this.handleTrailingData();
        }
        this.cbs.onend();
    };
    Tokenizer.prototype.handleTrailingData = function () {
        var data = this.buffer.substr(this.sectionStart);
        if (this._state === 29 /* InCdata */ ||
            this._state === 30 /* AfterCdata1 */ ||
            this._state === 31 /* AfterCdata2 */) {
            this.cbs.oncdata(data);
        }
        else if (this._state === 19 /* InComment */ ||
            this._state === 21 /* AfterComment1 */ ||
            this._state === 22 /* AfterComment2 */) {
            this.cbs.oncomment(data);
        }
        else if (this._state === 64 /* InNamedEntity */ && !this.xmlMode) {
            this.parseLegacyEntity();
            if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
            }
        }
        else if (this._state === 65 /* InNumericEntity */ && !this.xmlMode) {
            this.decodeNumericEntity(2, 10, false);
            if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
            }
        }
        else if (this._state === 66 /* InHexEntity */ && !this.xmlMode) {
            this.decodeNumericEntity(3, 16, false);
            if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
            }
        }
        else if (this._state !== 3 /* InTagName */ &&
            this._state !== 8 /* BeforeAttributeName */ &&
            this._state !== 11 /* BeforeAttributeValue */ &&
            this._state !== 10 /* AfterAttributeName */ &&
            this._state !== 9 /* InAttributeName */ &&
            this._state !== 13 /* InAttributeValueSq */ &&
            this._state !== 12 /* InAttributeValueDq */ &&
            this._state !== 14 /* InAttributeValueNq */ &&
            this._state !== 6 /* InClosingTagName */) {
            this.cbs.ontext(data);
        }
        /*
         * Else, ignore remaining data
         * TODO add a way to remove current tag
         */
    };
    Tokenizer.prototype.getSection = function () {
        return this.buffer.substring(this.sectionStart, this._index);
    };
    Tokenizer.prototype.emitToken = function (name) {
        this.cbs[name](this.getSection());
        this.sectionStart = -1;
    };
    Tokenizer.prototype.emitPartial = function (value) {
        if (this.baseState !== 1 /* Text */) {
            this.cbs.onattribdata(value); // TODO implement the new event
        }
        else {
            this.cbs.ontext(value);
        }
    };
    return Tokenizer;
}());
Tokenizer$6.default = Tokenizer$5;

var __importDefault$5 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(Parser$3, "__esModule", { value: true });
Parser$3.Parser = void 0;
var Tokenizer_1 = __importDefault$5(Tokenizer$6);
var formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea",
]);
var pTag = new Set(["p"]);
var openImpliesClose = {
    tr: new Set(["tr", "th", "td"]),
    th: new Set(["th"]),
    td: new Set(["thead", "th", "td"]),
    body: new Set(["head", "link", "script"]),
    li: new Set(["li"]),
    p: pTag,
    h1: pTag,
    h2: pTag,
    h3: pTag,
    h4: pTag,
    h5: pTag,
    h6: pTag,
    select: formTags,
    input: formTags,
    output: formTags,
    button: formTags,
    datalist: formTags,
    textarea: formTags,
    option: new Set(["option"]),
    optgroup: new Set(["optgroup", "option"]),
    dd: new Set(["dt", "dd"]),
    dt: new Set(["dt", "dd"]),
    address: pTag,
    article: pTag,
    aside: pTag,
    blockquote: pTag,
    details: pTag,
    div: pTag,
    dl: pTag,
    fieldset: pTag,
    figcaption: pTag,
    figure: pTag,
    footer: pTag,
    form: pTag,
    header: pTag,
    hr: pTag,
    main: pTag,
    nav: pTag,
    ol: pTag,
    pre: pTag,
    section: pTag,
    table: pTag,
    ul: pTag,
    rt: new Set(["rt", "rp"]),
    rp: new Set(["rt", "rp"]),
    tbody: new Set(["thead", "tbody"]),
    tfoot: new Set(["thead", "tbody"]),
};
var voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var reNameEnd = /\s|\//;
var Parser$2 = /** @class */ (function () {
    function Parser(cbs, options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d, _e;
        /** The start index of the last event. */
        this.startIndex = 0;
        /** The end index of the last event. */
        this.endIndex = null;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.options = options;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
        this.lowerCaseAttributeNames =
            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    Parser.prototype.updatePosition = function (initialOffset) {
        if (this.endIndex === null) {
            if (this.tokenizer.sectionStart <= initialOffset) {
                this.startIndex = 0;
            }
            else {
                this.startIndex = this.tokenizer.sectionStart - initialOffset;
            }
        }
        else {
            this.startIndex = this.endIndex + 1;
        }
        this.endIndex = this.tokenizer.getAbsoluteIndex();
    };
    // Tokenizer event handlers
    Parser.prototype.ontext = function (data) {
        var _a, _b;
        this.updatePosition(1);
        this.endIndex--;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
    };
    Parser.prototype.onopentagname = function (name) {
        var _a, _b;
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        this.tagname = name;
        if (!this.options.xmlMode &&
            Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
            var el = void 0;
            while (this.stack.length > 0 &&
                openImpliesClose[name].has((el = this.stack[this.stack.length - 1]))) {
                this.onclosetag(el);
            }
        }
        if (this.options.xmlMode || !voidElements.has(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
                this.foreignContext.push(true);
            }
            else if (htmlIntegrationElements.has(name)) {
                this.foreignContext.push(false);
            }
        }
        (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);
        if (this.cbs.onopentag)
            this.attribs = {};
    };
    Parser.prototype.onopentagend = function () {
        var _a, _b;
        this.updatePosition(1);
        if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs);
            this.attribs = null;
        }
        if (!this.options.xmlMode &&
            this.cbs.onclosetag &&
            voidElements.has(this.tagname)) {
            this.cbs.onclosetag(this.tagname);
        }
        this.tagname = "";
    };
    Parser.prototype.onclosetag = function (name) {
        this.updatePosition(1);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) ||
            htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
        }
        if (this.stack.length &&
            (this.options.xmlMode || !voidElements.has(name))) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
                if (this.cbs.onclosetag) {
                    pos = this.stack.length - pos;
                    while (pos--) {
                        // We know the stack has sufficient elements.
                        this.cbs.onclosetag(this.stack.pop());
                    }
                }
                else
                    this.stack.length = pos;
            }
            else if (name === "p" && !this.options.xmlMode) {
                this.onopentagname(name);
                this.closeCurrentTag();
            }
        }
        else if (!this.options.xmlMode && (name === "br" || name === "p")) {
            this.onopentagname(name);
            this.closeCurrentTag();
        }
    };
    Parser.prototype.onselfclosingtag = function () {
        if (this.options.xmlMode ||
            this.options.recognizeSelfClosing ||
            this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag();
        }
        else {
            this.onopentagend();
        }
    };
    Parser.prototype.closeCurrentTag = function () {
        var _a, _b;
        var name = this.tagname;
        this.onopentagend();
        /*
         * Self-closing tags will be on the top of the stack
         * (cheaper check than in onclosetag)
         */
        if (this.stack[this.stack.length - 1] === name) {
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name);
            this.stack.pop();
        }
    };
    Parser.prototype.onattribname = function (name) {
        if (this.lowerCaseAttributeNames) {
            name = name.toLowerCase();
        }
        this.attribname = name;
    };
    Parser.prototype.onattribdata = function (value) {
        this.attribvalue += value;
    };
    Parser.prototype.onattribend = function (quote) {
        var _a, _b;
        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);
        if (this.attribs &&
            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribname = "";
        this.attribvalue = "";
    };
    Parser.prototype.getInstructionName = function (value) {
        var idx = value.search(reNameEnd);
        var name = idx < 0 ? value : value.substr(0, idx);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        return name;
    };
    Parser.prototype.ondeclaration = function (value) {
        if (this.cbs.onprocessinginstruction) {
            var name_1 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
        }
    };
    Parser.prototype.onprocessinginstruction = function (value) {
        if (this.cbs.onprocessinginstruction) {
            var name_2 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
        }
    };
    Parser.prototype.oncomment = function (value) {
        var _a, _b, _c, _d;
        this.updatePosition(4);
        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    };
    Parser.prototype.oncdata = function (value) {
        var _a, _b, _c, _d, _e, _f;
        this.updatePosition(1);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
        }
        else {
            this.oncomment("[CDATA[" + value + "]]");
        }
    };
    Parser.prototype.onerror = function (err) {
        var _a, _b;
        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    Parser.prototype.onend = function () {
        var _a, _b;
        if (this.cbs.onclosetag) {
            for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i]))
                ;
        }
        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    /**
     * Resets the parser to a blank state, ready to parse a new HTML document
     */
    Parser.prototype.reset = function () {
        var _a, _b, _c, _d;
        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack = [];
        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    };
    /**
     * Resets the parser, then parses a complete document and
     * pushes it to the handler.
     *
     * @param data Document to parse.
     */
    Parser.prototype.parseComplete = function (data) {
        this.reset();
        this.end(data);
    };
    /**
     * Parses a chunk of data and calls the corresponding callbacks.
     *
     * @param chunk Chunk to parse.
     */
    Parser.prototype.write = function (chunk) {
        this.tokenizer.write(chunk);
    };
    /**
     * Parses the end of the buffer and clears the stack, calls onend.
     *
     * @param chunk Optional final chunk to parse.
     */
    Parser.prototype.end = function (chunk) {
        this.tokenizer.end(chunk);
    };
    /**
     * Pauses parsing. The parser won't emit events until `resume` is called.
     */
    Parser.prototype.pause = function () {
        this.tokenizer.pause();
    };
    /**
     * Resumes parsing after `pause` was called.
     */
    Parser.prototype.resume = function () {
        this.tokenizer.resume();
    };
    /**
     * Alias of `write`, for backwards compatibility.
     *
     * @param chunk Chunk to parse.
     * @deprecated
     */
    Parser.prototype.parseChunk = function (chunk) {
        this.write(chunk);
    };
    /**
     * Alias of `end`, for backwards compatibility.
     *
     * @param chunk Optional final chunk to parse.
     * @deprecated
     */
    Parser.prototype.done = function (chunk) {
        this.end(chunk);
    };
    return Parser;
}());
Parser$3.Parser = Parser$2;

var lib$a = {};

var lib$9 = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */
    ElementType["Text"] = "text";
    /** Type for <? ... ?> */
    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */
    ElementType["Comment"] = "comment";
    /** Type for <script> tags */
    ElementType["Script"] = "script";
    /** Type for <style> tags */
    ElementType["Style"] = "style";
    /** Type for Any tag */
    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */
    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */
    ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === ElementType.Tag ||
        elem.type === ElementType.Script ||
        elem.type === ElementType.Style);
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */
exports.Root = ElementType.Root;
/** Type for Text */
exports.Text = ElementType.Text;
/** Type for <? ... ?> */
exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */
exports.Comment = ElementType.Comment;
/** Type for <script> tags */
exports.Script = ElementType.Script;
/** Type for <style> tags */
exports.Style = ElementType.Style;
/** Type for Any tag */
exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
exports.Doctype = ElementType.Doctype;
}(lib$9));

var node$3 = {};

var __extends$4 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign$2 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign$2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$2.apply(this, arguments);
};
Object.defineProperty(node$3, "__esModule", { value: true });
node$3.cloneNode = node$3.hasChildren = node$3.isDocument = node$3.isDirective = node$3.isComment = node$3.isText = node$3.isCDATA = node$3.isTag = node$3.Element = node$3.Document = node$3.NodeWithChildren = node$3.ProcessingInstruction = node$3.Comment = node$3.Text = node$3.DataNode = node$3.Node = void 0;
var domelementtype_1 = lib$9;
var nodeTypes$1 = new Map([
    [domelementtype_1.ElementType.Tag, 1],
    [domelementtype_1.ElementType.Script, 1],
    [domelementtype_1.ElementType.Style, 1],
    [domelementtype_1.ElementType.Directive, 1],
    [domelementtype_1.ElementType.Text, 3],
    [domelementtype_1.ElementType.CDATA, 4],
    [domelementtype_1.ElementType.Comment, 8],
    [domelementtype_1.ElementType.Root, 9],
]);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node$1 = /** @class */ (function () {
    /**
     *
     * @param type The type of the node.
     */
    function Node(type) {
        this.type = type;
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "nodeType", {
        // Read-only aliases
        get: function () {
            var _a;
            return (_a = nodeTypes$1.get(this.type)) !== null && _a !== void 0 ? _a : 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        get: function () {
            return this.parent;
        },
        set: function (parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        get: function () {
            return this.prev;
        },
        set: function (prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        get: function () {
            return this.next;
        },
        set: function (next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    Node.prototype.cloneNode = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        return cloneNode(this, recursive);
    };
    return Node;
}());
node$3.Node = Node$1;
var DataNode = /** @class */ (function (_super) {
    __extends$4(DataNode, _super);
    /**
     * @param type The type of the node
     * @param data The content of the data node
     */
    function DataNode(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        get: function () {
            return this.data;
        },
        set: function (data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node$1));
node$3.DataNode = DataNode;
var Text = /** @class */ (function (_super) {
    __extends$4(Text, _super);
    function Text(data) {
        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
    }
    return Text;
}(DataNode));
node$3.Text = Text;
var Comment = /** @class */ (function (_super) {
    __extends$4(Comment, _super);
    function Comment(data) {
        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
    }
    return Comment;
}(DataNode));
node$3.Comment = Comment;
var ProcessingInstruction = /** @class */ (function (_super) {
    __extends$4(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
    }
    return ProcessingInstruction;
}(DataNode));
node$3.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren = /** @class */ (function (_super) {
    __extends$4(NodeWithChildren, _super);
    /**
     * @param type Type of the node.
     * @param children Children of the node. Only certain node types can have children.
     */
    function NodeWithChildren(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        get: function () {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        get: function () {
            return this.children;
        },
        set: function (children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node$1));
node$3.NodeWithChildren = NodeWithChildren;
var Document = /** @class */ (function (_super) {
    __extends$4(Document, _super);
    function Document(children) {
        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
    }
    return Document;
}(NodeWithChildren));
node$3.Document = Document;
var Element = /** @class */ (function (_super) {
    __extends$4(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    function Element(name, attribs, children, type) {
        if (children === void 0) { children = []; }
        if (type === void 0) { type = name === "script"
            ? domelementtype_1.ElementType.Script
            : name === "style"
                ? domelementtype_1.ElementType.Style
                : domelementtype_1.ElementType.Tag; }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
    }
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        get: function () {
            return this.name;
        },
        set: function (name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
                var _a, _b;
                return ({
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren));
node$3.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag(node) {
    return domelementtype_1.isTag(node);
}
node$3.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
}
node$3.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
    return node.type === domelementtype_1.ElementType.Text;
}
node$3.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
    return node.type === domelementtype_1.ElementType.Comment;
}
node$3.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
    return node.type === domelementtype_1.ElementType.Directive;
}
node$3.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
    return node.type === domelementtype_1.ElementType.Root;
}
node$3.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
 */
function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
node$3.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive) {
    if (recursive === void 0) { recursive = false; }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    }
    else if (isComment(node)) {
        result = new Comment(node.data);
    }
    else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign$2({}, node.attribs), children);
        children.forEach(function (child) { return (child.parent = clone_1); });
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign$2({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign$2({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    }
    else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
        children.forEach(function (child) { return (child.parent = clone_2); });
        result = clone_2;
    }
    else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function (child) { return (child.parent = clone_3); });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    }
    else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    }
    else {
        throw new Error("Not implemented yet: " + node.type);
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    return result;
}
node$3.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function (child) { return cloneNode(child, true); });
    for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DomHandler = void 0;
var domelementtype_1 = lib$9;
var node_1 = node$3;
__exportStar(node$3, exports);
var reWhitespace = /\s+/g;
// Default options
var defaultOpts = {
    normalizeWhitespace: false,
    withStartIndices: false,
    withEndIndices: false,
};
var DomHandler = /** @class */ (function () {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */
        this.dom = [];
        /** The root element for the DOM */
        this.root = new node_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */
        this.done = false;
        /** Stack of open tags. */
        this.tagStack = [this.root];
        /** A data node that is still being written to. */
        this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */
        this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function (parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function () {
        var _a;
        this.dom = [];
        this.root = new node_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = (_a = this.parser) !== null && _a !== void 0 ? _a : null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function () {
        if (this.done)
            return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function (error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function () {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
            this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function (name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function (data) {
        var normalizeWhitespace = this.options.normalizeWhitespace;
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
                lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            }
            else {
                lastNode.data += data;
            }
        }
        else {
            if (normalizeWhitespace) {
                data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function (data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function () {
        var text = new node_1.Text("");
        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function (name, data) {
        var node = new node_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function (error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        }
        else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function (node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}());
exports.DomHandler = DomHandler;
exports.default = DomHandler;
}(lib$a));

var FeedHandler$1 = {};

var lib$8 = {};

var stringify$c = {};

var lib$7 = {};

var lib$6 = {};

var decode = {};

var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(decode, "__esModule", { value: true });
decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
var entities_json_1$1 = __importDefault$4(require$$1$1);
var legacy_json_1 = __importDefault$4(require$$1);
var xml_json_1$1 = __importDefault$4(require$$0$1);
var decode_codepoint_1 = __importDefault$4(decode_codepoint);
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
decode.decodeXML = getStrictDecoder(xml_json_1$1.default);
decode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);
function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function (str) { return String(str).replace(strictEntityRe, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
decode.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1$1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1$1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        return map[str.slice(1, -1)] || str;
    };
}

var encode$1 = {};

var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(encode$1, "__esModule", { value: true });
encode$1.escapeUTF8 = encode$1.escape = encode$1.encodeNonAsciiHTML = encode$1.encodeHTML = encode$1.encodeXML = void 0;
var xml_json_1 = __importDefault$3(require$$0$1);
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode$1.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault$3(require$$1$1);
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
/**
 * Encodes all entities and non-ASCII characters in the input.
 *
 * This includes characters that are valid ASCII characters in HTML documents.
 * For example `#` will be encoded as `&num;`. To get a more compact output,
 * consider using the `encodeNonAsciiHTML` function.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode$1.encodeHTML = getInverse(inverseHTML, htmlReplacer);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode$1.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
// /[^\0-\x7F]/gu
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function (str) { return str.codePointAt(0); }
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function (c) {
            return (c.charCodeAt(0) - 0xd800) * 0x400 +
                c.charCodeAt(1) -
                0xdc00 +
                0x10000;
        };
function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
        .toString(16)
        .toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
function escape$1(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
}
encode$1.escape = escape$1;
/**
 * Encodes all characters not valid in XML documents using numeric hexadecimal
 * reference (eg. `&#xfc;`).
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
}
encode$1.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
    return function (data) {
        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
    };
}

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = decode;
var encode_1 = encode$1;
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeXML` or `decodeHTML` directly.
 */
function decode$1(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode$1;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
 */
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
 */
function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = encode$1;
Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
var decode_2 = decode;
Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } });
}(lib$6));

var foreignNames = {};

Object.defineProperty(foreignNames, "__esModule", { value: true });
foreignNames.attributeNames = foreignNames.elementNames = void 0;
foreignNames.elementNames = new Map([
    ["altglyph", "altGlyph"],
    ["altglyphdef", "altGlyphDef"],
    ["altglyphitem", "altGlyphItem"],
    ["animatecolor", "animateColor"],
    ["animatemotion", "animateMotion"],
    ["animatetransform", "animateTransform"],
    ["clippath", "clipPath"],
    ["feblend", "feBlend"],
    ["fecolormatrix", "feColorMatrix"],
    ["fecomponenttransfer", "feComponentTransfer"],
    ["fecomposite", "feComposite"],
    ["feconvolvematrix", "feConvolveMatrix"],
    ["fediffuselighting", "feDiffuseLighting"],
    ["fedisplacementmap", "feDisplacementMap"],
    ["fedistantlight", "feDistantLight"],
    ["fedropshadow", "feDropShadow"],
    ["feflood", "feFlood"],
    ["fefunca", "feFuncA"],
    ["fefuncb", "feFuncB"],
    ["fefuncg", "feFuncG"],
    ["fefuncr", "feFuncR"],
    ["fegaussianblur", "feGaussianBlur"],
    ["feimage", "feImage"],
    ["femerge", "feMerge"],
    ["femergenode", "feMergeNode"],
    ["femorphology", "feMorphology"],
    ["feoffset", "feOffset"],
    ["fepointlight", "fePointLight"],
    ["fespecularlighting", "feSpecularLighting"],
    ["fespotlight", "feSpotLight"],
    ["fetile", "feTile"],
    ["feturbulence", "feTurbulence"],
    ["foreignobject", "foreignObject"],
    ["glyphref", "glyphRef"],
    ["lineargradient", "linearGradient"],
    ["radialgradient", "radialGradient"],
    ["textpath", "textPath"],
]);
foreignNames.attributeNames = new Map([
    ["definitionurl", "definitionURL"],
    ["attributename", "attributeName"],
    ["attributetype", "attributeType"],
    ["basefrequency", "baseFrequency"],
    ["baseprofile", "baseProfile"],
    ["calcmode", "calcMode"],
    ["clippathunits", "clipPathUnits"],
    ["diffuseconstant", "diffuseConstant"],
    ["edgemode", "edgeMode"],
    ["filterunits", "filterUnits"],
    ["glyphref", "glyphRef"],
    ["gradienttransform", "gradientTransform"],
    ["gradientunits", "gradientUnits"],
    ["kernelmatrix", "kernelMatrix"],
    ["kernelunitlength", "kernelUnitLength"],
    ["keypoints", "keyPoints"],
    ["keysplines", "keySplines"],
    ["keytimes", "keyTimes"],
    ["lengthadjust", "lengthAdjust"],
    ["limitingconeangle", "limitingConeAngle"],
    ["markerheight", "markerHeight"],
    ["markerunits", "markerUnits"],
    ["markerwidth", "markerWidth"],
    ["maskcontentunits", "maskContentUnits"],
    ["maskunits", "maskUnits"],
    ["numoctaves", "numOctaves"],
    ["pathlength", "pathLength"],
    ["patterncontentunits", "patternContentUnits"],
    ["patterntransform", "patternTransform"],
    ["patternunits", "patternUnits"],
    ["pointsatx", "pointsAtX"],
    ["pointsaty", "pointsAtY"],
    ["pointsatz", "pointsAtZ"],
    ["preservealpha", "preserveAlpha"],
    ["preserveaspectratio", "preserveAspectRatio"],
    ["primitiveunits", "primitiveUnits"],
    ["refx", "refX"],
    ["refy", "refY"],
    ["repeatcount", "repeatCount"],
    ["repeatdur", "repeatDur"],
    ["requiredextensions", "requiredExtensions"],
    ["requiredfeatures", "requiredFeatures"],
    ["specularconstant", "specularConstant"],
    ["specularexponent", "specularExponent"],
    ["spreadmethod", "spreadMethod"],
    ["startoffset", "startOffset"],
    ["stddeviation", "stdDeviation"],
    ["stitchtiles", "stitchTiles"],
    ["surfacescale", "surfaceScale"],
    ["systemlanguage", "systemLanguage"],
    ["tablevalues", "tableValues"],
    ["targetx", "targetX"],
    ["targety", "targetY"],
    ["textlength", "textLength"],
    ["viewbox", "viewBox"],
    ["viewtarget", "viewTarget"],
    ["xchannelselector", "xChannelSelector"],
    ["ychannelselector", "yChannelSelector"],
    ["zoomandpan", "zoomAndPan"],
]);

var __assign$1 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};
var __createBinding$1 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$1 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
};
Object.defineProperty(lib$7, "__esModule", { value: true });
/*
 * Module dependencies
 */
var ElementType = __importStar$1(lib$9);
var entities_1 = lib$6;
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_1 = foreignNames;
var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript",
]);
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
    if (!attributes)
        return;
    return Object.keys(attributes)
        .map(function (key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */
            key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return key + "=\"" + (opts.decodeEntities !== false
            ? entities_1.encodeXML(value)
            : value.replace(/"/g, "&quot;")) + "\"";
    })
        .join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options) {
    if (options === void 0) { options = {}; }
    // TODO: This is a bit hacky.
    var nodes = Array.isArray(node) || node.cheerio ? node : [node];
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
    }
    return output;
}
lib$7.default = render;
function renderNode(node, options) {
    switch (node.type) {
        case ElementType.Root:
            return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
    }
}
var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */
        if (elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign$1(__assign$1({}, opts), { xmlMode: false });
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign$1(__assign$1({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += " " + attribs;
    }
    if (elem.children.length === 0 &&
        (opts.xmlMode
            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                opts.selfClosingTags !== false
            : // User explicitly asked for self-closing tags, even in HTML mode
                opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
            tag += " ";
        tag += "/>";
    }
    else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</" + elem.name + ">";
        }
    }
    return tag;
}
function renderDirective(elem) {
    return "<" + elem.data + ">";
}
function renderText(elem, opts) {
    var data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (opts.decodeEntities !== false &&
        !(!opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
    }
    return data;
}
function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
}
function renderComment(elem) {
    return "<!--" + elem.data + "-->";
}

var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(stringify$c, "__esModule", { value: true });
stringify$c.getText = stringify$c.getInnerHTML = stringify$c.getOuterHTML = void 0;
var domhandler_1$5 = lib$a;
var dom_serializer_1 = __importDefault$2(lib$7);
/**
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
    return dom_serializer_1.default(node, options);
}
stringify$c.getOuterHTML = getOuterHTML;
/**
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
    return domhandler_1$5.hasChildren(node)
        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
        : "";
}
stringify$c.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text.
 *
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText(node) {
    if (Array.isArray(node))
        return node.map(getText).join("");
    if (domhandler_1$5.isTag(node))
        return node.name === "br" ? "\n" : getText(node.children);
    if (domhandler_1$5.isCDATA(node))
        return getText(node.children);
    if (domhandler_1$5.isText(node))
        return node.data;
    return "";
}
stringify$c.getText = getText;

var traversal = {};

Object.defineProperty(traversal, "__esModule", { value: true });
traversal.prevElementSibling = traversal.nextElementSibling = traversal.getName = traversal.hasAttrib = traversal.getAttributeValue = traversal.getSiblings = traversal.getParent = traversal.getChildren = void 0;
var domhandler_1$4 = lib$a;
var emptyArray = [];
/**
 * Get a node's children.
 *
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren(elem) {
    var _a;
    return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
}
traversal.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */
function getParent(elem) {
    return elem.parent || null;
}
traversal.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first.
 * If we don't have a parent (the element is a root node),
 * we walk the element's `prev` & `next` to get all remaining nodes.
 *
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */
function getSiblings(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
        return getChildren(parent);
    var siblings = [elem];
    var prev = elem.prev, next = elem.next;
    while (prev != null) {
        siblings.unshift(prev);
        (_a = prev, prev = _a.prev);
    }
    while (next != null) {
        siblings.push(next);
        (_b = next, next = _b.next);
    }
    return siblings;
}
traversal.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
traversal.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib(elem, name) {
    return (elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
        elem.attribs[name] != null);
}
traversal.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName(elem) {
    return elem.name;
}
traversal.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */
function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !domhandler_1$4.isTag(next))
        (_a = next, next = _a.next);
    return next;
}
traversal.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag.
 */
function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !domhandler_1$4.isTag(prev))
        (_a = prev, prev = _a.prev);
    return prev;
}
traversal.prevElementSibling = prevElementSibling;

var manipulation$1 = {};

Object.defineProperty(manipulation$1, "__esModule", { value: true });
manipulation$1.prepend = manipulation$1.prependChild = manipulation$1.append = manipulation$1.appendChild = manipulation$1.replaceElement = manipulation$1.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @param elem The element to be removed
 */
function removeElement(elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
    }
}
manipulation$1.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
    var prev = (replacement.prev = elem.prev);
    if (prev) {
        prev.next = replacement;
    }
    var next = (replacement.next = elem.next);
    if (next) {
        next.prev = replacement;
    }
    var parent = (replacement.parent = elem.parent);
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
    }
}
manipulation$1.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild$2(elem, child) {
    removeElement(child);
    child.next = null;
    child.parent = elem;
    if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    }
    else {
        child.prev = null;
    }
}
manipulation$1.appendChild = appendChild$2;
/**
 * Append an element after another.
 *
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append$1(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    }
    else if (parent) {
        parent.children.push(next);
    }
}
manipulation$1.append = append$1;
/**
 * Prepend a child to an element.
 *
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(elem, child) {
    removeElement(child);
    child.parent = elem;
    child.prev = null;
    if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
    }
    else {
        child.next = null;
    }
}
manipulation$1.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
manipulation$1.prepend = prepend;

var querying = {};

Object.defineProperty(querying, "__esModule", { value: true });
querying.findAll = querying.existsOne = querying.findOne = querying.findOneChild = querying.find = querying.filter = void 0;
var domhandler_1$3 = lib$a;
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter(test, node, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    if (!Array.isArray(node))
        node = [node];
    return find(test, node, recurse, limit);
}
querying.filter = filter;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
    var result = [];
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                break;
        }
        if (recurse && domhandler_1$3.hasChildren(elem) && elem.children.length > 0) {
            var children = find(test, elem.children, recurse, limit);
            result.push.apply(result, children);
            limit -= children.length;
            if (limit <= 0)
                break;
        }
    }
    return result;
}
querying.find = find;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 */
function findOneChild(test, nodes) {
    return nodes.find(test);
}
querying.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */
function findOne(test, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    var elem = null;
    for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!domhandler_1$3.isTag(checked)) {
            continue;
        }
        else if (test(checked)) {
            elem = checked;
        }
        else if (recurse && checked.children.length > 0) {
            elem = findOne(test, checked.children);
        }
    }
    return elem;
}
querying.findOne = findOne;
/**
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing a test.
 */
function existsOne(test, nodes) {
    return nodes.some(function (checked) {
        return domhandler_1$3.isTag(checked) &&
            (test(checked) ||
                (checked.children.length > 0 &&
                    existsOne(test, checked.children)));
    });
}
querying.existsOne = existsOne;
/**
 * Search and array of nodes and its children for nodes passing a test function.
 *
 * Same as `find`, only with less options, leading to reduced complexity.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll(test, nodes) {
    var _a;
    var result = [];
    var stack = nodes.filter(domhandler_1$3.isTag);
    var elem;
    while ((elem = stack.shift())) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1$3.isTag);
        if (children && children.length > 0) {
            stack.unshift.apply(stack, children);
        }
        if (test(elem))
            result.push(elem);
    }
    return result;
}
querying.findAll = findAll;

var legacy$2 = {};

Object.defineProperty(legacy$2, "__esModule", { value: true });
legacy$2.getElementsByTagType = legacy$2.getElementsByTagName = legacy$2.getElementById = legacy$2.getElements = legacy$2.testElement = void 0;
var domhandler_1$2 = lib$a;
var querying_1 = querying;
var Checks = {
    tag_name: function (name) {
        if (typeof name === "function") {
            return function (elem) { return domhandler_1$2.isTag(elem) && name(elem.name); };
        }
        else if (name === "*") {
            return domhandler_1$2.isTag;
        }
        return function (elem) { return domhandler_1$2.isTag(elem) && elem.name === name; };
    },
    tag_type: function (type) {
        if (typeof type === "function") {
            return function (elem) { return type(elem.type); };
        }
        return function (elem) { return elem.type === type; };
    },
    tag_contains: function (data) {
        if (typeof data === "function") {
            return function (elem) { return domhandler_1$2.isText(elem) && data(elem.data); };
        }
        return function (elem) { return domhandler_1$2.isText(elem) && elem.data === data; };
    },
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a particular value.
 */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function (elem) { return domhandler_1$2.isTag(elem) && value(elem.attribs[attrib]); };
    }
    return function (elem) { return domhandler_1$2.isTag(elem) && elem.attribs[attrib] === value; };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either
 * of the input functions returns `true` for the node.
 */
function combineFuncs(a, b) {
    return function (elem) { return a(elem) || b(elem); };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true`
 * if any of them match a node.
 */
function compileTest(options) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return key in Checks
            ? Checks[key](value)
            : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
legacy$2.testElement = testElement;
/**
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements$1(options, nodes, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    var test = compileTest(options);
    return test ? querying_1.filter(test, nodes, recurse, limit) : [];
}
legacy$2.getElements = getElements$1;
/**
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    if (!Array.isArray(nodes))
        nodes = [nodes];
    return querying_1.findOne(getAttribCheck("id", id), nodes, recurse);
}
legacy$2.getElementById = getElementById;
/**
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return querying_1.filter(Checks.tag_name(tagName), nodes, recurse, limit);
}
legacy$2.getElementsByTagName = getElementsByTagName;
/**
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return querying_1.filter(Checks.tag_type(type), nodes, recurse, limit);
}
legacy$2.getElementsByTagType = getElementsByTagType;

var helpers$1 = {};

Object.defineProperty(helpers$1, "__esModule", { value: true });
helpers$1.uniqueSort = helpers$1.compareDocumentPosition = helpers$1.removeSubsets = void 0;
var domhandler_1$1 = lib$a;
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */
function removeSubsets(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
helpers$1.removeSubsets = removeSubsets;
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = domhandler_1$1.hasChildren(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = domhandler_1$1.hasChildren(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return 1 /* DISCONNECTED */;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
        }
        return 4 /* FOLLOWING */;
    }
    if (sharedParent === nodeA) {
        return 2 /* PRECEDING */ | 8 /* CONTAINS */;
    }
    return 2 /* PRECEDING */;
}
helpers$1.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
    nodes.sort(function (a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2 /* PRECEDING */) {
            return -1;
        }
        else if (relative & 4 /* FOLLOWING */) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
helpers$1.uniqueSort = uniqueSort;

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(stringify$c, exports);
__exportStar(traversal, exports);
__exportStar(manipulation$1, exports);
__exportStar(querying, exports);
__exportStar(legacy$2, exports);
__exportStar(helpers$1, exports);
var domhandler_1 = lib$a;
Object.defineProperty(exports, "isTag", { enumerable: true, get: function () { return domhandler_1.isTag; } });
Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function () { return domhandler_1.isCDATA; } });
Object.defineProperty(exports, "isText", { enumerable: true, get: function () { return domhandler_1.isText; } });
Object.defineProperty(exports, "isComment", { enumerable: true, get: function () { return domhandler_1.isComment; } });
Object.defineProperty(exports, "isDocument", { enumerable: true, get: function () { return domhandler_1.isDocument; } });
Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function () { return domhandler_1.hasChildren; } });
}(lib$8));

var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(FeedHandler$1, "__esModule", { value: true });
FeedHandler$1.parseFeed = FeedHandler$1.FeedHandler = void 0;
var domhandler_1 = __importDefault$1(lib$a);
var DomUtils = __importStar(lib$8);
var Parser_1 = Parser$3;
var FeedItemMediaMedium;
(function (FeedItemMediaMedium) {
    FeedItemMediaMedium[FeedItemMediaMedium["image"] = 0] = "image";
    FeedItemMediaMedium[FeedItemMediaMedium["audio"] = 1] = "audio";
    FeedItemMediaMedium[FeedItemMediaMedium["video"] = 2] = "video";
    FeedItemMediaMedium[FeedItemMediaMedium["document"] = 3] = "document";
    FeedItemMediaMedium[FeedItemMediaMedium["executable"] = 4] = "executable";
})(FeedItemMediaMedium || (FeedItemMediaMedium = {}));
var FeedItemMediaExpression;
(function (FeedItemMediaExpression) {
    FeedItemMediaExpression[FeedItemMediaExpression["sample"] = 0] = "sample";
    FeedItemMediaExpression[FeedItemMediaExpression["full"] = 1] = "full";
    FeedItemMediaExpression[FeedItemMediaExpression["nonstop"] = 2] = "nonstop";
})(FeedItemMediaExpression || (FeedItemMediaExpression = {}));
// TODO: Consume data as it is coming in
var FeedHandler = /** @class */ (function (_super) {
    __extends$3(FeedHandler, _super);
    /**
     *
     * @param callback
     * @param options
     */
    function FeedHandler(callback, options) {
        var _this = this;
        if (typeof callback === "object") {
            callback = undefined;
            options = callback;
        }
        _this = _super.call(this, callback, options) || this;
        return _this;
    }
    FeedHandler.prototype.onend = function () {
        var _a, _b;
        var feedRoot = getOneElement(isValidFeed, this.dom);
        if (!feedRoot) {
            this.handleCallback(new Error("couldn't find root of feed"));
            return;
        }
        var feed = {};
        if (feedRoot.name === "feed") {
            var childs = feedRoot.children;
            feed.type = "atom";
            addConditionally(feed, "id", "id", childs);
            addConditionally(feed, "title", "title", childs);
            var href = getAttribute("href", getOneElement("link", childs));
            if (href) {
                feed.link = href;
            }
            addConditionally(feed, "description", "subtitle", childs);
            var updated = fetch("updated", childs);
            if (updated) {
                feed.updated = new Date(updated);
            }
            addConditionally(feed, "author", "email", childs, true);
            feed.items = getElements("entry", childs).map(function (item) {
                var entry = {};
                var children = item.children;
                addConditionally(entry, "id", "id", children);
                addConditionally(entry, "title", "title", children);
                var href = getAttribute("href", getOneElement("link", children));
                if (href) {
                    entry.link = href;
                }
                var description = fetch("summary", children) || fetch("content", children);
                if (description) {
                    entry.description = description;
                }
                var pubDate = fetch("updated", children);
                if (pubDate) {
                    entry.pubDate = new Date(pubDate);
                }
                entry.media = getMediaElements(children);
                return entry;
            });
        }
        else {
            var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
            feed.type = feedRoot.name.substr(0, 3);
            feed.id = "";
            addConditionally(feed, "title", "title", childs);
            addConditionally(feed, "link", "link", childs);
            addConditionally(feed, "description", "description", childs);
            var updated = fetch("lastBuildDate", childs);
            if (updated) {
                feed.updated = new Date(updated);
            }
            addConditionally(feed, "author", "managingEditor", childs, true);
            feed.items = getElements("item", feedRoot.children).map(function (item) {
                var entry = {};
                var children = item.children;
                addConditionally(entry, "id", "guid", children);
                addConditionally(entry, "title", "title", children);
                addConditionally(entry, "link", "link", children);
                addConditionally(entry, "description", "description", children);
                var pubDate = fetch("pubDate", children);
                if (pubDate)
                    entry.pubDate = new Date(pubDate);
                entry.media = getMediaElements(children);
                return entry;
            });
        }
        this.feed = feed;
        this.handleCallback(null);
    };
    return FeedHandler;
}(domhandler_1.default));
FeedHandler$1.FeedHandler = FeedHandler;
function getMediaElements(where) {
    return getElements("media:content", where).map(function (elem) {
        var media = {
            medium: elem.attribs.medium,
            isDefault: !!elem.attribs.isDefault,
        };
        if (elem.attribs.url) {
            media.url = elem.attribs.url;
        }
        if (elem.attribs.fileSize) {
            media.fileSize = parseInt(elem.attribs.fileSize, 10);
        }
        if (elem.attribs.type) {
            media.type = elem.attribs.type;
        }
        if (elem.attribs.expression) {
            media.expression = elem.attribs
                .expression;
        }
        if (elem.attribs.bitrate) {
            media.bitrate = parseInt(elem.attribs.bitrate, 10);
        }
        if (elem.attribs.framerate) {
            media.framerate = parseInt(elem.attribs.framerate, 10);
        }
        if (elem.attribs.samplingrate) {
            media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
        }
        if (elem.attribs.channels) {
            media.channels = parseInt(elem.attribs.channels, 10);
        }
        if (elem.attribs.duration) {
            media.duration = parseInt(elem.attribs.duration, 10);
        }
        if (elem.attribs.height) {
            media.height = parseInt(elem.attribs.height, 10);
        }
        if (elem.attribs.width) {
            media.width = parseInt(elem.attribs.width, 10);
        }
        if (elem.attribs.lang) {
            media.lang = elem.attribs.lang;
        }
        return media;
    });
}
function getElements(tagName, where) {
    return DomUtils.getElementsByTagName(tagName, where, true);
}
function getOneElement(tagName, node) {
    return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
}
function fetch(tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function getAttribute(name, elem) {
    if (!elem) {
        return null;
    }
    var attribs = elem.attribs;
    return attribs[name];
}
function addConditionally(obj, prop, what, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    var tmp = fetch(what, where, recurse);
    if (tmp)
        obj[prop] = tmp;
}
function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this option, you should set `xmlMode` to `true`.
 */
function parseFeed(feed, options) {
    if (options === void 0) { options = { xmlMode: true }; }
    var handler = new FeedHandler(options);
    new Parser_1.Parser(handler, options).end(feed);
    return handler.feed;
}
FeedHandler$1.parseFeed = parseFeed;

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RssHandler = exports.DefaultHandler = exports.DomUtils = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;
var Parser_1 = Parser$3;
Object.defineProperty(exports, "Parser", { enumerable: true, get: function () { return Parser_1.Parser; } });
var domhandler_1 = lib$a;
Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function () { return domhandler_1.DomHandler; } });
Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function () { return domhandler_1.DomHandler; } });
// Helper methods
/**
 * Parses the data, returns the resulting document.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */
function parseDocument(data, options) {
    var handler = new domhandler_1.DomHandler(undefined, options);
    new Parser_1.Parser(handler, options).end(data);
    return handler.root;
}
exports.parseDocument = parseDocument;
/**
 * Parses data, returns an array of the root nodes.
 *
 * Note that the root nodes still have a `Document` node as their parent.
 * Use `parseDocument` to get the `Document` node instead.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 * @deprecated Use `parseDocument` instead.
 */
function parseDOM(data, options) {
    return parseDocument(data, options).children;
}
exports.parseDOM = parseDOM;
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param cb A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
 */
function createDomStream(cb, options, elementCb) {
    var handler = new domhandler_1.DomHandler(cb, options, elementCb);
    return new Parser_1.Parser(handler, options);
}
exports.createDomStream = createDomStream;
var Tokenizer_1 = Tokenizer$6;
Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function () { return __importDefault(Tokenizer_1).default; } });
var ElementType = __importStar(lib$9);
exports.ElementType = ElementType;
/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */
__exportStar(FeedHandler$1, exports);
exports.DomUtils = __importStar(lib$8);
var FeedHandler_1 = FeedHandler$1;
Object.defineProperty(exports, "RssHandler", { enumerable: true, get: function () { return FeedHandler_1.FeedHandler; } });
}(lib$b));

var htmlparser2$1 = {};

htmlparser2$1.parse = lib$b.parseDocument;
htmlparser2$1.render = lib$7.default;

var parse5$1 = {};

var lib$5 = {};

var unicode$3 = {};

const UNDEFINED_CODE_POINTS = [
    0xfffe,
    0xffff,
    0x1fffe,
    0x1ffff,
    0x2fffe,
    0x2ffff,
    0x3fffe,
    0x3ffff,
    0x4fffe,
    0x4ffff,
    0x5fffe,
    0x5ffff,
    0x6fffe,
    0x6ffff,
    0x7fffe,
    0x7ffff,
    0x8fffe,
    0x8ffff,
    0x9fffe,
    0x9ffff,
    0xafffe,
    0xaffff,
    0xbfffe,
    0xbffff,
    0xcfffe,
    0xcffff,
    0xdfffe,
    0xdffff,
    0xefffe,
    0xeffff,
    0xffffe,
    0xfffff,
    0x10fffe,
    0x10ffff
];

unicode$3.REPLACEMENT_CHARACTER = '\uFFFD';

unicode$3.CODE_POINTS = {
    EOF: -1,
    NULL: 0x00,
    TABULATION: 0x09,
    CARRIAGE_RETURN: 0x0d,
    LINE_FEED: 0x0a,
    FORM_FEED: 0x0c,
    SPACE: 0x20,
    EXCLAMATION_MARK: 0x21,
    QUOTATION_MARK: 0x22,
    NUMBER_SIGN: 0x23,
    AMPERSAND: 0x26,
    APOSTROPHE: 0x27,
    HYPHEN_MINUS: 0x2d,
    SOLIDUS: 0x2f,
    DIGIT_0: 0x30,
    DIGIT_9: 0x39,
    SEMICOLON: 0x3b,
    LESS_THAN_SIGN: 0x3c,
    EQUALS_SIGN: 0x3d,
    GREATER_THAN_SIGN: 0x3e,
    QUESTION_MARK: 0x3f,
    LATIN_CAPITAL_A: 0x41,
    LATIN_CAPITAL_F: 0x46,
    LATIN_CAPITAL_X: 0x58,
    LATIN_CAPITAL_Z: 0x5a,
    RIGHT_SQUARE_BRACKET: 0x5d,
    GRAVE_ACCENT: 0x60,
    LATIN_SMALL_A: 0x61,
    LATIN_SMALL_F: 0x66,
    LATIN_SMALL_X: 0x78,
    LATIN_SMALL_Z: 0x7a,
    REPLACEMENT_CHARACTER: 0xfffd
};

unicode$3.CODE_POINT_SEQUENCES = {
    DASH_DASH_STRING: [0x2d, 0x2d], //--
    DOCTYPE_STRING: [0x44, 0x4f, 0x43, 0x54, 0x59, 0x50, 0x45], //DOCTYPE
    CDATA_START_STRING: [0x5b, 0x43, 0x44, 0x41, 0x54, 0x41, 0x5b], //[CDATA[
    SCRIPT_STRING: [0x73, 0x63, 0x72, 0x69, 0x70, 0x74], //script
    PUBLIC_STRING: [0x50, 0x55, 0x42, 0x4c, 0x49, 0x43], //PUBLIC
    SYSTEM_STRING: [0x53, 0x59, 0x53, 0x54, 0x45, 0x4d] //SYSTEM
};

//Surrogates
unicode$3.isSurrogate = function(cp) {
    return cp >= 0xd800 && cp <= 0xdfff;
};

unicode$3.isSurrogatePair = function(cp) {
    return cp >= 0xdc00 && cp <= 0xdfff;
};

unicode$3.getSurrogatePairCodePoint = function(cp1, cp2) {
    return (cp1 - 0xd800) * 0x400 + 0x2400 + cp2;
};

//NOTE: excluding NULL and ASCII whitespace
unicode$3.isControlCodePoint = function(cp) {
    return (
        (cp !== 0x20 && cp !== 0x0a && cp !== 0x0d && cp !== 0x09 && cp !== 0x0c && cp >= 0x01 && cp <= 0x1f) ||
        (cp >= 0x7f && cp <= 0x9f)
    );
};

unicode$3.isUndefinedCodePoint = function(cp) {
    return (cp >= 0xfdd0 && cp <= 0xfdef) || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
};

var errorCodes = {
    controlCharacterInInputStream: 'control-character-in-input-stream',
    noncharacterInInputStream: 'noncharacter-in-input-stream',
    surrogateInInputStream: 'surrogate-in-input-stream',
    nonVoidHtmlElementStartTagWithTrailingSolidus: 'non-void-html-element-start-tag-with-trailing-solidus',
    endTagWithAttributes: 'end-tag-with-attributes',
    endTagWithTrailingSolidus: 'end-tag-with-trailing-solidus',
    unexpectedSolidusInTag: 'unexpected-solidus-in-tag',
    unexpectedNullCharacter: 'unexpected-null-character',
    unexpectedQuestionMarkInsteadOfTagName: 'unexpected-question-mark-instead-of-tag-name',
    invalidFirstCharacterOfTagName: 'invalid-first-character-of-tag-name',
    unexpectedEqualsSignBeforeAttributeName: 'unexpected-equals-sign-before-attribute-name',
    missingEndTagName: 'missing-end-tag-name',
    unexpectedCharacterInAttributeName: 'unexpected-character-in-attribute-name',
    unknownNamedCharacterReference: 'unknown-named-character-reference',
    missingSemicolonAfterCharacterReference: 'missing-semicolon-after-character-reference',
    unexpectedCharacterAfterDoctypeSystemIdentifier: 'unexpected-character-after-doctype-system-identifier',
    unexpectedCharacterInUnquotedAttributeValue: 'unexpected-character-in-unquoted-attribute-value',
    eofBeforeTagName: 'eof-before-tag-name',
    eofInTag: 'eof-in-tag',
    missingAttributeValue: 'missing-attribute-value',
    missingWhitespaceBetweenAttributes: 'missing-whitespace-between-attributes',
    missingWhitespaceAfterDoctypePublicKeyword: 'missing-whitespace-after-doctype-public-keyword',
    missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers:
        'missing-whitespace-between-doctype-public-and-system-identifiers',
    missingWhitespaceAfterDoctypeSystemKeyword: 'missing-whitespace-after-doctype-system-keyword',
    missingQuoteBeforeDoctypePublicIdentifier: 'missing-quote-before-doctype-public-identifier',
    missingQuoteBeforeDoctypeSystemIdentifier: 'missing-quote-before-doctype-system-identifier',
    missingDoctypePublicIdentifier: 'missing-doctype-public-identifier',
    missingDoctypeSystemIdentifier: 'missing-doctype-system-identifier',
    abruptDoctypePublicIdentifier: 'abrupt-doctype-public-identifier',
    abruptDoctypeSystemIdentifier: 'abrupt-doctype-system-identifier',
    cdataInHtmlContent: 'cdata-in-html-content',
    incorrectlyOpenedComment: 'incorrectly-opened-comment',
    eofInScriptHtmlCommentLikeText: 'eof-in-script-html-comment-like-text',
    eofInDoctype: 'eof-in-doctype',
    nestedComment: 'nested-comment',
    abruptClosingOfEmptyComment: 'abrupt-closing-of-empty-comment',
    eofInComment: 'eof-in-comment',
    incorrectlyClosedComment: 'incorrectly-closed-comment',
    eofInCdata: 'eof-in-cdata',
    absenceOfDigitsInNumericCharacterReference: 'absence-of-digits-in-numeric-character-reference',
    nullCharacterReference: 'null-character-reference',
    surrogateCharacterReference: 'surrogate-character-reference',
    characterReferenceOutsideUnicodeRange: 'character-reference-outside-unicode-range',
    controlCharacterReference: 'control-character-reference',
    noncharacterCharacterReference: 'noncharacter-character-reference',
    missingWhitespaceBeforeDoctypeName: 'missing-whitespace-before-doctype-name',
    missingDoctypeName: 'missing-doctype-name',
    invalidCharacterSequenceAfterDoctypeName: 'invalid-character-sequence-after-doctype-name',
    duplicateAttribute: 'duplicate-attribute',
    nonConformingDoctype: 'non-conforming-doctype',
    missingDoctype: 'missing-doctype',
    misplacedDoctype: 'misplaced-doctype',
    endTagWithoutMatchingOpenElement: 'end-tag-without-matching-open-element',
    closingOfElementWithOpenChildElements: 'closing-of-element-with-open-child-elements',
    disallowedContentInNoscriptInHead: 'disallowed-content-in-noscript-in-head',
    openElementsLeftAfterEof: 'open-elements-left-after-eof',
    abandonedHeadElementChild: 'abandoned-head-element-child',
    misplacedStartTagForHeadElement: 'misplaced-start-tag-for-head-element',
    nestedNoscriptInHead: 'nested-noscript-in-head',
    eofInElementThatCanContainOnlyText: 'eof-in-element-that-can-contain-only-text'
};

const unicode$2 = unicode$3;
const ERR$2 = errorCodes;

//Aliases
const $$7 = unicode$2.CODE_POINTS;

//Const
const DEFAULT_BUFFER_WATERLINE = 1 << 16;

//Preprocessor
//NOTE: HTML input preprocessing
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
class Preprocessor$1 {
    constructor() {
        this.html = null;

        this.pos = -1;
        this.lastGapPos = -1;
        this.lastCharPos = -1;

        this.gapStack = [];

        this.skipNextNewLine = false;

        this.lastChunkWritten = false;
        this.endOfChunkHit = false;
        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    }

    _err() {
        // NOTE: err reporting is noop by default. Enabled by mixin.
    }

    _addGap() {
        this.gapStack.push(this.lastGapPos);
        this.lastGapPos = this.pos;
    }

    _processSurrogate(cp) {
        //NOTE: try to peek a surrogate pair
        if (this.pos !== this.lastCharPos) {
            const nextCp = this.html.charCodeAt(this.pos + 1);

            if (unicode$2.isSurrogatePair(nextCp)) {
                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
                this.pos++;

                //NOTE: add gap that should be avoided during retreat
                this._addGap();

                return unicode$2.getSurrogatePairCodePoint(cp, nextCp);
            }
        }

        //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.
        else if (!this.lastChunkWritten) {
            this.endOfChunkHit = true;
            return $$7.EOF;
        }

        //NOTE: isolated surrogate
        this._err(ERR$2.surrogateInInputStream);

        return cp;
    }

    dropParsedChunk() {
        if (this.pos > this.bufferWaterline) {
            this.lastCharPos -= this.pos;
            this.html = this.html.substring(this.pos);
            this.pos = 0;
            this.lastGapPos = -1;
            this.gapStack = [];
        }
    }

    write(chunk, isLastChunk) {
        if (this.html) {
            this.html += chunk;
        } else {
            this.html = chunk;
        }

        this.lastCharPos = this.html.length - 1;
        this.endOfChunkHit = false;
        this.lastChunkWritten = isLastChunk;
    }

    insertHtmlAtCurrentPos(chunk) {
        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);

        this.lastCharPos = this.html.length - 1;
        this.endOfChunkHit = false;
    }

    advance() {
        this.pos++;

        if (this.pos > this.lastCharPos) {
            this.endOfChunkHit = !this.lastChunkWritten;
            return $$7.EOF;
        }

        let cp = this.html.charCodeAt(this.pos);

        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
        //must be ignored.
        if (this.skipNextNewLine && cp === $$7.LINE_FEED) {
            this.skipNextNewLine = false;
            this._addGap();
            return this.advance();
        }

        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
        if (cp === $$7.CARRIAGE_RETURN) {
            this.skipNextNewLine = true;
            return $$7.LINE_FEED;
        }

        this.skipNextNewLine = false;

        if (unicode$2.isSurrogate(cp)) {
            cp = this._processSurrogate(cp);
        }

        //OPTIMIZATION: first check if code point is in the common allowed
        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)
        //before going into detailed performance cost validation.
        const isCommonValidRange =
            (cp > 0x1f && cp < 0x7f) || cp === $$7.LINE_FEED || cp === $$7.CARRIAGE_RETURN || (cp > 0x9f && cp < 0xfdd0);

        if (!isCommonValidRange) {
            this._checkForProblematicCharacters(cp);
        }

        return cp;
    }

    _checkForProblematicCharacters(cp) {
        if (unicode$2.isControlCodePoint(cp)) {
            this._err(ERR$2.controlCharacterInInputStream);
        } else if (unicode$2.isUndefinedCodePoint(cp)) {
            this._err(ERR$2.noncharacterInInputStream);
        }
    }

    retreat() {
        if (this.pos === this.lastGapPos) {
            this.lastGapPos = this.gapStack.pop();
            this.pos--;
        }

        this.pos--;
    }
}

var preprocessor = Preprocessor$1;

//NOTE: this file contains auto-generated array mapped radix tree that is used for the named entity references consumption
//(details: https://github.com/inikulin/parse5/tree/master/scripts/generate-named-entity-data/README.md)
var namedEntityData = new Uint16Array([4,52,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,106,303,412,810,1432,1701,1796,1987,2114,2360,2420,2484,3170,3251,4140,4393,4575,4610,5106,5512,5728,6117,6274,6315,6345,6427,6516,7002,7910,8733,9323,9870,10170,10631,10893,11318,11386,11467,12773,13092,14474,14922,15448,15542,16419,17666,18166,18611,19004,19095,19298,19397,4,16,69,77,97,98,99,102,103,108,109,110,111,112,114,115,116,117,140,150,158,169,176,194,199,210,216,222,226,242,256,266,283,294,108,105,103,5,198,1,59,148,1,198,80,5,38,1,59,156,1,38,99,117,116,101,5,193,1,59,167,1,193,114,101,118,101,59,1,258,4,2,105,121,182,191,114,99,5,194,1,59,189,1,194,59,1,1040,114,59,3,55349,56580,114,97,118,101,5,192,1,59,208,1,192,112,104,97,59,1,913,97,99,114,59,1,256,100,59,1,10835,4,2,103,112,232,237,111,110,59,1,260,102,59,3,55349,56632,112,108,121,70,117,110,99,116,105,111,110,59,1,8289,105,110,103,5,197,1,59,264,1,197,4,2,99,115,272,277,114,59,3,55349,56476,105,103,110,59,1,8788,105,108,100,101,5,195,1,59,292,1,195,109,108,5,196,1,59,301,1,196,4,8,97,99,101,102,111,114,115,117,321,350,354,383,388,394,400,405,4,2,99,114,327,336,107,115,108,97,115,104,59,1,8726,4,2,118,119,342,345,59,1,10983,101,100,59,1,8966,121,59,1,1041,4,3,99,114,116,362,369,379,97,117,115,101,59,1,8757,110,111,117,108,108,105,115,59,1,8492,97,59,1,914,114,59,3,55349,56581,112,102,59,3,55349,56633,101,118,101,59,1,728,99,114,59,1,8492,109,112,101,113,59,1,8782,4,14,72,79,97,99,100,101,102,104,105,108,111,114,115,117,442,447,456,504,542,547,569,573,577,616,678,784,790,796,99,121,59,1,1063,80,89,5,169,1,59,454,1,169,4,3,99,112,121,464,470,497,117,116,101,59,1,262,4,2,59,105,476,478,1,8914,116,97,108,68,105,102,102,101,114,101,110,116,105,97,108,68,59,1,8517,108,101,121,115,59,1,8493,4,4,97,101,105,111,514,520,530,535,114,111,110,59,1,268,100,105,108,5,199,1,59,528,1,199,114,99,59,1,264,110,105,110,116,59,1,8752,111,116,59,1,266,4,2,100,110,553,560,105,108,108,97,59,1,184,116,101,114,68,111,116,59,1,183,114,59,1,8493,105,59,1,935,114,99,108,101,4,4,68,77,80,84,591,596,603,609,111,116,59,1,8857,105,110,117,115,59,1,8854,108,117,115,59,1,8853,105,109,101,115,59,1,8855,111,4,2,99,115,623,646,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8754,101,67,117,114,108,121,4,2,68,81,658,671,111,117,98,108,101,81,117,111,116,101,59,1,8221,117,111,116,101,59,1,8217,4,4,108,110,112,117,688,701,736,753,111,110,4,2,59,101,696,698,1,8759,59,1,10868,4,3,103,105,116,709,717,722,114,117,101,110,116,59,1,8801,110,116,59,1,8751,111,117,114,73,110,116,101,103,114,97,108,59,1,8750,4,2,102,114,742,745,59,1,8450,111,100,117,99,116,59,1,8720,110,116,101,114,67,108,111,99,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8755,111,115,115,59,1,10799,99,114,59,3,55349,56478,112,4,2,59,67,803,805,1,8915,97,112,59,1,8781,4,11,68,74,83,90,97,99,101,102,105,111,115,834,850,855,860,865,888,903,916,921,1011,1415,4,2,59,111,840,842,1,8517,116,114,97,104,100,59,1,10513,99,121,59,1,1026,99,121,59,1,1029,99,121,59,1,1039,4,3,103,114,115,873,879,883,103,101,114,59,1,8225,114,59,1,8609,104,118,59,1,10980,4,2,97,121,894,900,114,111,110,59,1,270,59,1,1044,108,4,2,59,116,910,912,1,8711,97,59,1,916,114,59,3,55349,56583,4,2,97,102,927,998,4,2,99,109,933,992,114,105,116,105,99,97,108,4,4,65,68,71,84,950,957,978,985,99,117,116,101,59,1,180,111,4,2,116,117,964,967,59,1,729,98,108,101,65,99,117,116,101,59,1,733,114,97,118,101,59,1,96,105,108,100,101,59,1,732,111,110,100,59,1,8900,102,101,114,101,110,116,105,97,108,68,59,1,8518,4,4,112,116,117,119,1021,1026,1048,1249,102,59,3,55349,56635,4,3,59,68,69,1034,1036,1041,1,168,111,116,59,1,8412,113,117,97,108,59,1,8784,98,108,101,4,6,67,68,76,82,85,86,1065,1082,1101,1189,1211,1236,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8751,111,4,2,116,119,1089,1092,59,1,168,110,65,114,114,111,119,59,1,8659,4,2,101,111,1107,1141,102,116,4,3,65,82,84,1117,1124,1136,114,114,111,119,59,1,8656,105,103,104,116,65,114,114,111,119,59,1,8660,101,101,59,1,10980,110,103,4,2,76,82,1149,1177,101,102,116,4,2,65,82,1158,1165,114,114,111,119,59,1,10232,105,103,104,116,65,114,114,111,119,59,1,10234,105,103,104,116,65,114,114,111,119,59,1,10233,105,103,104,116,4,2,65,84,1199,1206,114,114,111,119,59,1,8658,101,101,59,1,8872,112,4,2,65,68,1218,1225,114,114,111,119,59,1,8657,111,119,110,65,114,114,111,119,59,1,8661,101,114,116,105,99,97,108,66,97,114,59,1,8741,110,4,6,65,66,76,82,84,97,1264,1292,1299,1352,1391,1408,114,114,111,119,4,3,59,66,85,1276,1278,1283,1,8595,97,114,59,1,10515,112,65,114,114,111,119,59,1,8693,114,101,118,101,59,1,785,101,102,116,4,3,82,84,86,1310,1323,1334,105,103,104,116,86,101,99,116,111,114,59,1,10576,101,101,86,101,99,116,111,114,59,1,10590,101,99,116,111,114,4,2,59,66,1345,1347,1,8637,97,114,59,1,10582,105,103,104,116,4,2,84,86,1362,1373,101,101,86,101,99,116,111,114,59,1,10591,101,99,116,111,114,4,2,59,66,1384,1386,1,8641,97,114,59,1,10583,101,101,4,2,59,65,1399,1401,1,8868,114,114,111,119,59,1,8615,114,114,111,119,59,1,8659,4,2,99,116,1421,1426,114,59,3,55349,56479,114,111,107,59,1,272,4,16,78,84,97,99,100,102,103,108,109,111,112,113,115,116,117,120,1466,1470,1478,1489,1515,1520,1525,1536,1544,1593,1609,1617,1650,1664,1668,1677,71,59,1,330,72,5,208,1,59,1476,1,208,99,117,116,101,5,201,1,59,1487,1,201,4,3,97,105,121,1497,1503,1512,114,111,110,59,1,282,114,99,5,202,1,59,1510,1,202,59,1,1069,111,116,59,1,278,114,59,3,55349,56584,114,97,118,101,5,200,1,59,1534,1,200,101,109,101,110,116,59,1,8712,4,2,97,112,1550,1555,99,114,59,1,274,116,121,4,2,83,86,1563,1576,109,97,108,108,83,113,117,97,114,101,59,1,9723,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9643,4,2,103,112,1599,1604,111,110,59,1,280,102,59,3,55349,56636,115,105,108,111,110,59,1,917,117,4,2,97,105,1624,1640,108,4,2,59,84,1631,1633,1,10869,105,108,100,101,59,1,8770,108,105,98,114,105,117,109,59,1,8652,4,2,99,105,1656,1660,114,59,1,8496,109,59,1,10867,97,59,1,919,109,108,5,203,1,59,1675,1,203,4,2,105,112,1683,1689,115,116,115,59,1,8707,111,110,101,110,116,105,97,108,69,59,1,8519,4,5,99,102,105,111,115,1713,1717,1722,1762,1791,121,59,1,1060,114,59,3,55349,56585,108,108,101,100,4,2,83,86,1732,1745,109,97,108,108,83,113,117,97,114,101,59,1,9724,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9642,4,3,112,114,117,1770,1775,1781,102,59,3,55349,56637,65,108,108,59,1,8704,114,105,101,114,116,114,102,59,1,8497,99,114,59,1,8497,4,12,74,84,97,98,99,100,102,103,111,114,115,116,1822,1827,1834,1848,1855,1877,1882,1887,1890,1896,1978,1984,99,121,59,1,1027,5,62,1,59,1832,1,62,109,109,97,4,2,59,100,1843,1845,1,915,59,1,988,114,101,118,101,59,1,286,4,3,101,105,121,1863,1869,1874,100,105,108,59,1,290,114,99,59,1,284,59,1,1043,111,116,59,1,288,114,59,3,55349,56586,59,1,8921,112,102,59,3,55349,56638,101,97,116,101,114,4,6,69,70,71,76,83,84,1915,1933,1944,1953,1959,1971,113,117,97,108,4,2,59,76,1925,1927,1,8805,101,115,115,59,1,8923,117,108,108,69,113,117,97,108,59,1,8807,114,101,97,116,101,114,59,1,10914,101,115,115,59,1,8823,108,97,110,116,69,113,117,97,108,59,1,10878,105,108,100,101,59,1,8819,99,114,59,3,55349,56482,59,1,8811,4,8,65,97,99,102,105,111,115,117,2005,2012,2026,2032,2036,2049,2073,2089,82,68,99,121,59,1,1066,4,2,99,116,2018,2023,101,107,59,1,711,59,1,94,105,114,99,59,1,292,114,59,1,8460,108,98,101,114,116,83,112,97,99,101,59,1,8459,4,2,112,114,2055,2059,102,59,1,8461,105,122,111,110,116,97,108,76,105,110,101,59,1,9472,4,2,99,116,2079,2083,114,59,1,8459,114,111,107,59,1,294,109,112,4,2,68,69,2097,2107,111,119,110,72,117,109,112,59,1,8782,113,117,97,108,59,1,8783,4,14,69,74,79,97,99,100,102,103,109,110,111,115,116,117,2144,2149,2155,2160,2171,2189,2194,2198,2209,2245,2307,2329,2334,2341,99,121,59,1,1045,108,105,103,59,1,306,99,121,59,1,1025,99,117,116,101,5,205,1,59,2169,1,205,4,2,105,121,2177,2186,114,99,5,206,1,59,2184,1,206,59,1,1048,111,116,59,1,304,114,59,1,8465,114,97,118,101,5,204,1,59,2207,1,204,4,3,59,97,112,2217,2219,2238,1,8465,4,2,99,103,2225,2229,114,59,1,298,105,110,97,114,121,73,59,1,8520,108,105,101,115,59,1,8658,4,2,116,118,2251,2281,4,2,59,101,2257,2259,1,8748,4,2,103,114,2265,2271,114,97,108,59,1,8747,115,101,99,116,105,111,110,59,1,8898,105,115,105,98,108,101,4,2,67,84,2293,2300,111,109,109,97,59,1,8291,105,109,101,115,59,1,8290,4,3,103,112,116,2315,2320,2325,111,110,59,1,302,102,59,3,55349,56640,97,59,1,921,99,114,59,1,8464,105,108,100,101,59,1,296,4,2,107,109,2347,2352,99,121,59,1,1030,108,5,207,1,59,2358,1,207,4,5,99,102,111,115,117,2372,2386,2391,2397,2414,4,2,105,121,2378,2383,114,99,59,1,308,59,1,1049,114,59,3,55349,56589,112,102,59,3,55349,56641,4,2,99,101,2403,2408,114,59,3,55349,56485,114,99,121,59,1,1032,107,99,121,59,1,1028,4,7,72,74,97,99,102,111,115,2436,2441,2446,2452,2467,2472,2478,99,121,59,1,1061,99,121,59,1,1036,112,112,97,59,1,922,4,2,101,121,2458,2464,100,105,108,59,1,310,59,1,1050,114,59,3,55349,56590,112,102,59,3,55349,56642,99,114,59,3,55349,56486,4,11,74,84,97,99,101,102,108,109,111,115,116,2508,2513,2520,2562,2585,2981,2986,3004,3011,3146,3167,99,121,59,1,1033,5,60,1,59,2518,1,60,4,5,99,109,110,112,114,2532,2538,2544,2548,2558,117,116,101,59,1,313,98,100,97,59,1,923,103,59,1,10218,108,97,99,101,116,114,102,59,1,8466,114,59,1,8606,4,3,97,101,121,2570,2576,2582,114,111,110,59,1,317,100,105,108,59,1,315,59,1,1051,4,2,102,115,2591,2907,116,4,10,65,67,68,70,82,84,85,86,97,114,2614,2663,2672,2728,2735,2760,2820,2870,2888,2895,4,2,110,114,2620,2633,103,108,101,66,114,97,99,107,101,116,59,1,10216,114,111,119,4,3,59,66,82,2644,2646,2651,1,8592,97,114,59,1,8676,105,103,104,116,65,114,114,111,119,59,1,8646,101,105,108,105,110,103,59,1,8968,111,4,2,117,119,2679,2692,98,108,101,66,114,97,99,107,101,116,59,1,10214,110,4,2,84,86,2699,2710,101,101,86,101,99,116,111,114,59,1,10593,101,99,116,111,114,4,2,59,66,2721,2723,1,8643,97,114,59,1,10585,108,111,111,114,59,1,8970,105,103,104,116,4,2,65,86,2745,2752,114,114,111,119,59,1,8596,101,99,116,111,114,59,1,10574,4,2,101,114,2766,2792,101,4,3,59,65,86,2775,2777,2784,1,8867,114,114,111,119,59,1,8612,101,99,116,111,114,59,1,10586,105,97,110,103,108,101,4,3,59,66,69,2806,2808,2813,1,8882,97,114,59,1,10703,113,117,97,108,59,1,8884,112,4,3,68,84,86,2829,2841,2852,111,119,110,86,101,99,116,111,114,59,1,10577,101,101,86,101,99,116,111,114,59,1,10592,101,99,116,111,114,4,2,59,66,2863,2865,1,8639,97,114,59,1,10584,101,99,116,111,114,4,2,59,66,2881,2883,1,8636,97,114,59,1,10578,114,114,111,119,59,1,8656,105,103,104,116,97,114,114,111,119,59,1,8660,115,4,6,69,70,71,76,83,84,2922,2936,2947,2956,2962,2974,113,117,97,108,71,114,101,97,116,101,114,59,1,8922,117,108,108,69,113,117,97,108,59,1,8806,114,101,97,116,101,114,59,1,8822,101,115,115,59,1,10913,108,97,110,116,69,113,117,97,108,59,1,10877,105,108,100,101,59,1,8818,114,59,3,55349,56591,4,2,59,101,2992,2994,1,8920,102,116,97,114,114,111,119,59,1,8666,105,100,111,116,59,1,319,4,3,110,112,119,3019,3110,3115,103,4,4,76,82,108,114,3030,3058,3070,3098,101,102,116,4,2,65,82,3039,3046,114,114,111,119,59,1,10229,105,103,104,116,65,114,114,111,119,59,1,10231,105,103,104,116,65,114,114,111,119,59,1,10230,101,102,116,4,2,97,114,3079,3086,114,114,111,119,59,1,10232,105,103,104,116,97,114,114,111,119,59,1,10234,105,103,104,116,97,114,114,111,119,59,1,10233,102,59,3,55349,56643,101,114,4,2,76,82,3123,3134,101,102,116,65,114,114,111,119,59,1,8601,105,103,104,116,65,114,114,111,119,59,1,8600,4,3,99,104,116,3154,3158,3161,114,59,1,8466,59,1,8624,114,111,107,59,1,321,59,1,8810,4,8,97,99,101,102,105,111,115,117,3188,3192,3196,3222,3227,3237,3243,3248,112,59,1,10501,121,59,1,1052,4,2,100,108,3202,3213,105,117,109,83,112,97,99,101,59,1,8287,108,105,110,116,114,102,59,1,8499,114,59,3,55349,56592,110,117,115,80,108,117,115,59,1,8723,112,102,59,3,55349,56644,99,114,59,1,8499,59,1,924,4,9,74,97,99,101,102,111,115,116,117,3271,3276,3283,3306,3422,3427,4120,4126,4137,99,121,59,1,1034,99,117,116,101,59,1,323,4,3,97,101,121,3291,3297,3303,114,111,110,59,1,327,100,105,108,59,1,325,59,1,1053,4,3,103,115,119,3314,3380,3415,97,116,105,118,101,4,3,77,84,86,3327,3340,3365,101,100,105,117,109,83,112,97,99,101,59,1,8203,104,105,4,2,99,110,3348,3357,107,83,112,97,99,101,59,1,8203,83,112,97,99,101,59,1,8203,101,114,121,84,104,105,110,83,112,97,99,101,59,1,8203,116,101,100,4,2,71,76,3389,3405,114,101,97,116,101,114,71,114,101,97,116,101,114,59,1,8811,101,115,115,76,101,115,115,59,1,8810,76,105,110,101,59,1,10,114,59,3,55349,56593,4,4,66,110,112,116,3437,3444,3460,3464,114,101,97,107,59,1,8288,66,114,101,97,107,105,110,103,83,112,97,99,101,59,1,160,102,59,1,8469,4,13,59,67,68,69,71,72,76,78,80,82,83,84,86,3492,3494,3517,3536,3578,3657,3685,3784,3823,3860,3915,4066,4107,1,10988,4,2,111,117,3500,3510,110,103,114,117,101,110,116,59,1,8802,112,67,97,112,59,1,8813,111,117,98,108,101,86,101,114,116,105,99,97,108,66,97,114,59,1,8742,4,3,108,113,120,3544,3552,3571,101,109,101,110,116,59,1,8713,117,97,108,4,2,59,84,3561,3563,1,8800,105,108,100,101,59,3,8770,824,105,115,116,115,59,1,8708,114,101,97,116,101,114,4,7,59,69,70,71,76,83,84,3600,3602,3609,3621,3631,3637,3650,1,8815,113,117,97,108,59,1,8817,117,108,108,69,113,117,97,108,59,3,8807,824,114,101,97,116,101,114,59,3,8811,824,101,115,115,59,1,8825,108,97,110,116,69,113,117,97,108,59,3,10878,824,105,108,100,101,59,1,8821,117,109,112,4,2,68,69,3666,3677,111,119,110,72,117,109,112,59,3,8782,824,113,117,97,108,59,3,8783,824,101,4,2,102,115,3692,3724,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3709,3711,3717,1,8938,97,114,59,3,10703,824,113,117,97,108,59,1,8940,115,4,6,59,69,71,76,83,84,3739,3741,3748,3757,3764,3777,1,8814,113,117,97,108,59,1,8816,114,101,97,116,101,114,59,1,8824,101,115,115,59,3,8810,824,108,97,110,116,69,113,117,97,108,59,3,10877,824,105,108,100,101,59,1,8820,101,115,116,101,100,4,2,71,76,3795,3812,114,101,97,116,101,114,71,114,101,97,116,101,114,59,3,10914,824,101,115,115,76,101,115,115,59,3,10913,824,114,101,99,101,100,101,115,4,3,59,69,83,3838,3840,3848,1,8832,113,117,97,108,59,3,10927,824,108,97,110,116,69,113,117,97,108,59,1,8928,4,2,101,105,3866,3881,118,101,114,115,101,69,108,101,109,101,110,116,59,1,8716,103,104,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3900,3902,3908,1,8939,97,114,59,3,10704,824,113,117,97,108,59,1,8941,4,2,113,117,3921,3973,117,97,114,101,83,117,4,2,98,112,3933,3952,115,101,116,4,2,59,69,3942,3945,3,8847,824,113,117,97,108,59,1,8930,101,114,115,101,116,4,2,59,69,3963,3966,3,8848,824,113,117,97,108,59,1,8931,4,3,98,99,112,3981,4000,4045,115,101,116,4,2,59,69,3990,3993,3,8834,8402,113,117,97,108,59,1,8840,99,101,101,100,115,4,4,59,69,83,84,4015,4017,4025,4037,1,8833,113,117,97,108,59,3,10928,824,108,97,110,116,69,113,117,97,108,59,1,8929,105,108,100,101,59,3,8831,824,101,114,115,101,116,4,2,59,69,4056,4059,3,8835,8402,113,117,97,108,59,1,8841,105,108,100,101,4,4,59,69,70,84,4080,4082,4089,4100,1,8769,113,117,97,108,59,1,8772,117,108,108,69,113,117,97,108,59,1,8775,105,108,100,101,59,1,8777,101,114,116,105,99,97,108,66,97,114,59,1,8740,99,114,59,3,55349,56489,105,108,100,101,5,209,1,59,4135,1,209,59,1,925,4,14,69,97,99,100,102,103,109,111,112,114,115,116,117,118,4170,4176,4187,4205,4212,4217,4228,4253,4259,4292,4295,4316,4337,4346,108,105,103,59,1,338,99,117,116,101,5,211,1,59,4185,1,211,4,2,105,121,4193,4202,114,99,5,212,1,59,4200,1,212,59,1,1054,98,108,97,99,59,1,336,114,59,3,55349,56594,114,97,118,101,5,210,1,59,4226,1,210,4,3,97,101,105,4236,4241,4246,99,114,59,1,332,103,97,59,1,937,99,114,111,110,59,1,927,112,102,59,3,55349,56646,101,110,67,117,114,108,121,4,2,68,81,4272,4285,111,117,98,108,101,81,117,111,116,101,59,1,8220,117,111,116,101,59,1,8216,59,1,10836,4,2,99,108,4301,4306,114,59,3,55349,56490,97,115,104,5,216,1,59,4314,1,216,105,4,2,108,109,4323,4332,100,101,5,213,1,59,4330,1,213,101,115,59,1,10807,109,108,5,214,1,59,4344,1,214,101,114,4,2,66,80,4354,4380,4,2,97,114,4360,4364,114,59,1,8254,97,99,4,2,101,107,4372,4375,59,1,9182,101,116,59,1,9140,97,114,101,110,116,104,101,115,105,115,59,1,9180,4,9,97,99,102,104,105,108,111,114,115,4413,4422,4426,4431,4435,4438,4448,4471,4561,114,116,105,97,108,68,59,1,8706,121,59,1,1055,114,59,3,55349,56595,105,59,1,934,59,1,928,117,115,77,105,110,117,115,59,1,177,4,2,105,112,4454,4467,110,99,97,114,101,112,108,97,110,101,59,1,8460,102,59,1,8473,4,4,59,101,105,111,4481,4483,4526,4531,1,10939,99,101,100,101,115,4,4,59,69,83,84,4498,4500,4507,4519,1,8826,113,117,97,108,59,1,10927,108,97,110,116,69,113,117,97,108,59,1,8828,105,108,100,101,59,1,8830,109,101,59,1,8243,4,2,100,112,4537,4543,117,99,116,59,1,8719,111,114,116,105,111,110,4,2,59,97,4555,4557,1,8759,108,59,1,8733,4,2,99,105,4567,4572,114,59,3,55349,56491,59,1,936,4,4,85,102,111,115,4585,4594,4599,4604,79,84,5,34,1,59,4592,1,34,114,59,3,55349,56596,112,102,59,1,8474,99,114,59,3,55349,56492,4,12,66,69,97,99,101,102,104,105,111,114,115,117,4636,4642,4650,4681,4704,4763,4767,4771,5047,5069,5081,5094,97,114,114,59,1,10512,71,5,174,1,59,4648,1,174,4,3,99,110,114,4658,4664,4668,117,116,101,59,1,340,103,59,1,10219,114,4,2,59,116,4675,4677,1,8608,108,59,1,10518,4,3,97,101,121,4689,4695,4701,114,111,110,59,1,344,100,105,108,59,1,342,59,1,1056,4,2,59,118,4710,4712,1,8476,101,114,115,101,4,2,69,85,4722,4748,4,2,108,113,4728,4736,101,109,101,110,116,59,1,8715,117,105,108,105,98,114,105,117,109,59,1,8651,112,69,113,117,105,108,105,98,114,105,117,109,59,1,10607,114,59,1,8476,111,59,1,929,103,104,116,4,8,65,67,68,70,84,85,86,97,4792,4840,4849,4905,4912,4972,5022,5040,4,2,110,114,4798,4811,103,108,101,66,114,97,99,107,101,116,59,1,10217,114,111,119,4,3,59,66,76,4822,4824,4829,1,8594,97,114,59,1,8677,101,102,116,65,114,114,111,119,59,1,8644,101,105,108,105,110,103,59,1,8969,111,4,2,117,119,4856,4869,98,108,101,66,114,97,99,107,101,116,59,1,10215,110,4,2,84,86,4876,4887,101,101,86,101,99,116,111,114,59,1,10589,101,99,116,111,114,4,2,59,66,4898,4900,1,8642,97,114,59,1,10581,108,111,111,114,59,1,8971,4,2,101,114,4918,4944,101,4,3,59,65,86,4927,4929,4936,1,8866,114,114,111,119,59,1,8614,101,99,116,111,114,59,1,10587,105,97,110,103,108,101,4,3,59,66,69,4958,4960,4965,1,8883,97,114,59,1,10704,113,117,97,108,59,1,8885,112,4,3,68,84,86,4981,4993,5004,111,119,110,86,101,99,116,111,114,59,1,10575,101,101,86,101,99,116,111,114,59,1,10588,101,99,116,111,114,4,2,59,66,5015,5017,1,8638,97,114,59,1,10580,101,99,116,111,114,4,2,59,66,5033,5035,1,8640,97,114,59,1,10579,114,114,111,119,59,1,8658,4,2,112,117,5053,5057,102,59,1,8477,110,100,73,109,112,108,105,101,115,59,1,10608,105,103,104,116,97,114,114,111,119,59,1,8667,4,2,99,104,5087,5091,114,59,1,8475,59,1,8625,108,101,68,101,108,97,121,101,100,59,1,10740,4,13,72,79,97,99,102,104,105,109,111,113,115,116,117,5134,5150,5157,5164,5198,5203,5259,5265,5277,5283,5374,5380,5385,4,2,67,99,5140,5146,72,99,121,59,1,1065,121,59,1,1064,70,84,99,121,59,1,1068,99,117,116,101,59,1,346,4,5,59,97,101,105,121,5176,5178,5184,5190,5195,1,10940,114,111,110,59,1,352,100,105,108,59,1,350,114,99,59,1,348,59,1,1057,114,59,3,55349,56598,111,114,116,4,4,68,76,82,85,5216,5227,5238,5250,111,119,110,65,114,114,111,119,59,1,8595,101,102,116,65,114,114,111,119,59,1,8592,105,103,104,116,65,114,114,111,119,59,1,8594,112,65,114,114,111,119,59,1,8593,103,109,97,59,1,931,97,108,108,67,105,114,99,108,101,59,1,8728,112,102,59,3,55349,56650,4,2,114,117,5289,5293,116,59,1,8730,97,114,101,4,4,59,73,83,85,5306,5308,5322,5367,1,9633,110,116,101,114,115,101,99,116,105,111,110,59,1,8851,117,4,2,98,112,5329,5347,115,101,116,4,2,59,69,5338,5340,1,8847,113,117,97,108,59,1,8849,101,114,115,101,116,4,2,59,69,5358,5360,1,8848,113,117,97,108,59,1,8850,110,105,111,110,59,1,8852,99,114,59,3,55349,56494,97,114,59,1,8902,4,4,98,99,109,112,5395,5420,5475,5478,4,2,59,115,5401,5403,1,8912,101,116,4,2,59,69,5411,5413,1,8912,113,117,97,108,59,1,8838,4,2,99,104,5426,5468,101,101,100,115,4,4,59,69,83,84,5440,5442,5449,5461,1,8827,113,117,97,108,59,1,10928,108,97,110,116,69,113,117,97,108,59,1,8829,105,108,100,101,59,1,8831,84,104,97,116,59,1,8715,59,1,8721,4,3,59,101,115,5486,5488,5507,1,8913,114,115,101,116,4,2,59,69,5498,5500,1,8835,113,117,97,108,59,1,8839,101,116,59,1,8913,4,11,72,82,83,97,99,102,104,105,111,114,115,5536,5546,5552,5567,5579,5602,5607,5655,5695,5701,5711,79,82,78,5,222,1,59,5544,1,222,65,68,69,59,1,8482,4,2,72,99,5558,5563,99,121,59,1,1035,121,59,1,1062,4,2,98,117,5573,5576,59,1,9,59,1,932,4,3,97,101,121,5587,5593,5599,114,111,110,59,1,356,100,105,108,59,1,354,59,1,1058,114,59,3,55349,56599,4,2,101,105,5613,5631,4,2,114,116,5619,5627,101,102,111,114,101,59,1,8756,97,59,1,920,4,2,99,110,5637,5647,107,83,112,97,99,101,59,3,8287,8202,83,112,97,99,101,59,1,8201,108,100,101,4,4,59,69,70,84,5668,5670,5677,5688,1,8764,113,117,97,108,59,1,8771,117,108,108,69,113,117,97,108,59,1,8773,105,108,100,101,59,1,8776,112,102,59,3,55349,56651,105,112,108,101,68,111,116,59,1,8411,4,2,99,116,5717,5722,114,59,3,55349,56495,114,111,107,59,1,358,4,14,97,98,99,100,102,103,109,110,111,112,114,115,116,117,5758,5789,5805,5823,5830,5835,5846,5852,5921,5937,6089,6095,6101,6108,4,2,99,114,5764,5774,117,116,101,5,218,1,59,5772,1,218,114,4,2,59,111,5781,5783,1,8607,99,105,114,59,1,10569,114,4,2,99,101,5796,5800,121,59,1,1038,118,101,59,1,364,4,2,105,121,5811,5820,114,99,5,219,1,59,5818,1,219,59,1,1059,98,108,97,99,59,1,368,114,59,3,55349,56600,114,97,118,101,5,217,1,59,5844,1,217,97,99,114,59,1,362,4,2,100,105,5858,5905,101,114,4,2,66,80,5866,5892,4,2,97,114,5872,5876,114,59,1,95,97,99,4,2,101,107,5884,5887,59,1,9183,101,116,59,1,9141,97,114,101,110,116,104,101,115,105,115,59,1,9181,111,110,4,2,59,80,5913,5915,1,8899,108,117,115,59,1,8846,4,2,103,112,5927,5932,111,110,59,1,370,102,59,3,55349,56652,4,8,65,68,69,84,97,100,112,115,5955,5985,5996,6009,6026,6033,6044,6075,114,114,111,119,4,3,59,66,68,5967,5969,5974,1,8593,97,114,59,1,10514,111,119,110,65,114,114,111,119,59,1,8645,111,119,110,65,114,114,111,119,59,1,8597,113,117,105,108,105,98,114,105,117,109,59,1,10606,101,101,4,2,59,65,6017,6019,1,8869,114,114,111,119,59,1,8613,114,114,111,119,59,1,8657,111,119,110,97,114,114,111,119,59,1,8661,101,114,4,2,76,82,6052,6063,101,102,116,65,114,114,111,119,59,1,8598,105,103,104,116,65,114,114,111,119,59,1,8599,105,4,2,59,108,6082,6084,1,978,111,110,59,1,933,105,110,103,59,1,366,99,114,59,3,55349,56496,105,108,100,101,59,1,360,109,108,5,220,1,59,6115,1,220,4,9,68,98,99,100,101,102,111,115,118,6137,6143,6148,6152,6166,6250,6255,6261,6267,97,115,104,59,1,8875,97,114,59,1,10987,121,59,1,1042,97,115,104,4,2,59,108,6161,6163,1,8873,59,1,10982,4,2,101,114,6172,6175,59,1,8897,4,3,98,116,121,6183,6188,6238,97,114,59,1,8214,4,2,59,105,6194,6196,1,8214,99,97,108,4,4,66,76,83,84,6209,6214,6220,6231,97,114,59,1,8739,105,110,101,59,1,124,101,112,97,114,97,116,111,114,59,1,10072,105,108,100,101,59,1,8768,84,104,105,110,83,112,97,99,101,59,1,8202,114,59,3,55349,56601,112,102,59,3,55349,56653,99,114,59,3,55349,56497,100,97,115,104,59,1,8874,4,5,99,101,102,111,115,6286,6292,6298,6303,6309,105,114,99,59,1,372,100,103,101,59,1,8896,114,59,3,55349,56602,112,102,59,3,55349,56654,99,114,59,3,55349,56498,4,4,102,105,111,115,6325,6330,6333,6339,114,59,3,55349,56603,59,1,926,112,102,59,3,55349,56655,99,114,59,3,55349,56499,4,9,65,73,85,97,99,102,111,115,117,6365,6370,6375,6380,6391,6405,6410,6416,6422,99,121,59,1,1071,99,121,59,1,1031,99,121,59,1,1070,99,117,116,101,5,221,1,59,6389,1,221,4,2,105,121,6397,6402,114,99,59,1,374,59,1,1067,114,59,3,55349,56604,112,102,59,3,55349,56656,99,114,59,3,55349,56500,109,108,59,1,376,4,8,72,97,99,100,101,102,111,115,6445,6450,6457,6472,6477,6501,6505,6510,99,121,59,1,1046,99,117,116,101,59,1,377,4,2,97,121,6463,6469,114,111,110,59,1,381,59,1,1047,111,116,59,1,379,4,2,114,116,6483,6497,111,87,105,100,116,104,83,112,97,99,101,59,1,8203,97,59,1,918,114,59,1,8488,112,102,59,1,8484,99,114,59,3,55349,56501,4,16,97,98,99,101,102,103,108,109,110,111,112,114,115,116,117,119,6550,6561,6568,6612,6622,6634,6645,6672,6699,6854,6870,6923,6933,6963,6974,6983,99,117,116,101,5,225,1,59,6559,1,225,114,101,118,101,59,1,259,4,6,59,69,100,105,117,121,6582,6584,6588,6591,6600,6609,1,8766,59,3,8766,819,59,1,8767,114,99,5,226,1,59,6598,1,226,116,101,5,180,1,59,6607,1,180,59,1,1072,108,105,103,5,230,1,59,6620,1,230,4,2,59,114,6628,6630,1,8289,59,3,55349,56606,114,97,118,101,5,224,1,59,6643,1,224,4,2,101,112,6651,6667,4,2,102,112,6657,6663,115,121,109,59,1,8501,104,59,1,8501,104,97,59,1,945,4,2,97,112,6678,6692,4,2,99,108,6684,6688,114,59,1,257,103,59,1,10815,5,38,1,59,6697,1,38,4,2,100,103,6705,6737,4,5,59,97,100,115,118,6717,6719,6724,6727,6734,1,8743,110,100,59,1,10837,59,1,10844,108,111,112,101,59,1,10840,59,1,10842,4,7,59,101,108,109,114,115,122,6753,6755,6758,6762,6814,6835,6848,1,8736,59,1,10660,101,59,1,8736,115,100,4,2,59,97,6770,6772,1,8737,4,8,97,98,99,100,101,102,103,104,6790,6793,6796,6799,6802,6805,6808,6811,59,1,10664,59,1,10665,59,1,10666,59,1,10667,59,1,10668,59,1,10669,59,1,10670,59,1,10671,116,4,2,59,118,6821,6823,1,8735,98,4,2,59,100,6830,6832,1,8894,59,1,10653,4,2,112,116,6841,6845,104,59,1,8738,59,1,197,97,114,114,59,1,9084,4,2,103,112,6860,6865,111,110,59,1,261,102,59,3,55349,56658,4,7,59,69,97,101,105,111,112,6886,6888,6891,6897,6900,6904,6908,1,8776,59,1,10864,99,105,114,59,1,10863,59,1,8778,100,59,1,8779,115,59,1,39,114,111,120,4,2,59,101,6917,6919,1,8776,113,59,1,8778,105,110,103,5,229,1,59,6931,1,229,4,3,99,116,121,6941,6946,6949,114,59,3,55349,56502,59,1,42,109,112,4,2,59,101,6957,6959,1,8776,113,59,1,8781,105,108,100,101,5,227,1,59,6972,1,227,109,108,5,228,1,59,6981,1,228,4,2,99,105,6989,6997,111,110,105,110,116,59,1,8755,110,116,59,1,10769,4,16,78,97,98,99,100,101,102,105,107,108,110,111,112,114,115,117,7036,7041,7119,7135,7149,7155,7219,7224,7347,7354,7463,7489,7786,7793,7814,7866,111,116,59,1,10989,4,2,99,114,7047,7094,107,4,4,99,101,112,115,7058,7064,7073,7080,111,110,103,59,1,8780,112,115,105,108,111,110,59,1,1014,114,105,109,101,59,1,8245,105,109,4,2,59,101,7088,7090,1,8765,113,59,1,8909,4,2,118,119,7100,7105,101,101,59,1,8893,101,100,4,2,59,103,7113,7115,1,8965,101,59,1,8965,114,107,4,2,59,116,7127,7129,1,9141,98,114,107,59,1,9142,4,2,111,121,7141,7146,110,103,59,1,8780,59,1,1073,113,117,111,59,1,8222,4,5,99,109,112,114,116,7167,7181,7188,7193,7199,97,117,115,4,2,59,101,7176,7178,1,8757,59,1,8757,112,116,121,118,59,1,10672,115,105,59,1,1014,110,111,117,59,1,8492,4,3,97,104,119,7207,7210,7213,59,1,946,59,1,8502,101,101,110,59,1,8812,114,59,3,55349,56607,103,4,7,99,111,115,116,117,118,119,7241,7262,7288,7305,7328,7335,7340,4,3,97,105,117,7249,7253,7258,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,4,3,100,112,116,7270,7275,7281,111,116,59,1,10752,108,117,115,59,1,10753,105,109,101,115,59,1,10754,4,2,113,116,7294,7300,99,117,112,59,1,10758,97,114,59,1,9733,114,105,97,110,103,108,101,4,2,100,117,7318,7324,111,119,110,59,1,9661,112,59,1,9651,112,108,117,115,59,1,10756,101,101,59,1,8897,101,100,103,101,59,1,8896,97,114,111,119,59,1,10509,4,3,97,107,111,7362,7436,7458,4,2,99,110,7368,7432,107,4,3,108,115,116,7377,7386,7394,111,122,101,110,103,101,59,1,10731,113,117,97,114,101,59,1,9642,114,105,97,110,103,108,101,4,4,59,100,108,114,7411,7413,7419,7425,1,9652,111,119,110,59,1,9662,101,102,116,59,1,9666,105,103,104,116,59,1,9656,107,59,1,9251,4,2,49,51,7442,7454,4,2,50,52,7448,7451,59,1,9618,59,1,9617,52,59,1,9619,99,107,59,1,9608,4,2,101,111,7469,7485,4,2,59,113,7475,7478,3,61,8421,117,105,118,59,3,8801,8421,116,59,1,8976,4,4,112,116,119,120,7499,7504,7517,7523,102,59,3,55349,56659,4,2,59,116,7510,7512,1,8869,111,109,59,1,8869,116,105,101,59,1,8904,4,12,68,72,85,86,98,100,104,109,112,116,117,118,7549,7571,7597,7619,7655,7660,7682,7708,7715,7721,7728,7750,4,4,76,82,108,114,7559,7562,7565,7568,59,1,9559,59,1,9556,59,1,9558,59,1,9555,4,5,59,68,85,100,117,7583,7585,7588,7591,7594,1,9552,59,1,9574,59,1,9577,59,1,9572,59,1,9575,4,4,76,82,108,114,7607,7610,7613,7616,59,1,9565,59,1,9562,59,1,9564,59,1,9561,4,7,59,72,76,82,104,108,114,7635,7637,7640,7643,7646,7649,7652,1,9553,59,1,9580,59,1,9571,59,1,9568,59,1,9579,59,1,9570,59,1,9567,111,120,59,1,10697,4,4,76,82,108,114,7670,7673,7676,7679,59,1,9557,59,1,9554,59,1,9488,59,1,9484,4,5,59,68,85,100,117,7694,7696,7699,7702,7705,1,9472,59,1,9573,59,1,9576,59,1,9516,59,1,9524,105,110,117,115,59,1,8863,108,117,115,59,1,8862,105,109,101,115,59,1,8864,4,4,76,82,108,114,7738,7741,7744,7747,59,1,9563,59,1,9560,59,1,9496,59,1,9492,4,7,59,72,76,82,104,108,114,7766,7768,7771,7774,7777,7780,7783,1,9474,59,1,9578,59,1,9569,59,1,9566,59,1,9532,59,1,9508,59,1,9500,114,105,109,101,59,1,8245,4,2,101,118,7799,7804,118,101,59,1,728,98,97,114,5,166,1,59,7812,1,166,4,4,99,101,105,111,7824,7829,7834,7846,114,59,3,55349,56503,109,105,59,1,8271,109,4,2,59,101,7841,7843,1,8765,59,1,8909,108,4,3,59,98,104,7855,7857,7860,1,92,59,1,10693,115,117,98,59,1,10184,4,2,108,109,7872,7885,108,4,2,59,101,7879,7881,1,8226,116,59,1,8226,112,4,3,59,69,101,7894,7896,7899,1,8782,59,1,10926,4,2,59,113,7905,7907,1,8783,59,1,8783,4,15,97,99,100,101,102,104,105,108,111,114,115,116,117,119,121,7942,8021,8075,8080,8121,8126,8157,8279,8295,8430,8446,8485,8491,8707,8726,4,3,99,112,114,7950,7956,8007,117,116,101,59,1,263,4,6,59,97,98,99,100,115,7970,7972,7977,7984,7998,8003,1,8745,110,100,59,1,10820,114,99,117,112,59,1,10825,4,2,97,117,7990,7994,112,59,1,10827,112,59,1,10823,111,116,59,1,10816,59,3,8745,65024,4,2,101,111,8013,8017,116,59,1,8257,110,59,1,711,4,4,97,101,105,117,8031,8046,8056,8061,4,2,112,114,8037,8041,115,59,1,10829,111,110,59,1,269,100,105,108,5,231,1,59,8054,1,231,114,99,59,1,265,112,115,4,2,59,115,8069,8071,1,10828,109,59,1,10832,111,116,59,1,267,4,3,100,109,110,8088,8097,8104,105,108,5,184,1,59,8095,1,184,112,116,121,118,59,1,10674,116,5,162,2,59,101,8112,8114,1,162,114,100,111,116,59,1,183,114,59,3,55349,56608,4,3,99,101,105,8134,8138,8154,121,59,1,1095,99,107,4,2,59,109,8146,8148,1,10003,97,114,107,59,1,10003,59,1,967,114,4,7,59,69,99,101,102,109,115,8174,8176,8179,8258,8261,8268,8273,1,9675,59,1,10691,4,3,59,101,108,8187,8189,8193,1,710,113,59,1,8791,101,4,2,97,100,8200,8223,114,114,111,119,4,2,108,114,8210,8216,101,102,116,59,1,8634,105,103,104,116,59,1,8635,4,5,82,83,97,99,100,8235,8238,8241,8246,8252,59,1,174,59,1,9416,115,116,59,1,8859,105,114,99,59,1,8858,97,115,104,59,1,8861,59,1,8791,110,105,110,116,59,1,10768,105,100,59,1,10991,99,105,114,59,1,10690,117,98,115,4,2,59,117,8288,8290,1,9827,105,116,59,1,9827,4,4,108,109,110,112,8305,8326,8376,8400,111,110,4,2,59,101,8313,8315,1,58,4,2,59,113,8321,8323,1,8788,59,1,8788,4,2,109,112,8332,8344,97,4,2,59,116,8339,8341,1,44,59,1,64,4,3,59,102,108,8352,8354,8358,1,8705,110,59,1,8728,101,4,2,109,120,8365,8371,101,110,116,59,1,8705,101,115,59,1,8450,4,2,103,105,8382,8395,4,2,59,100,8388,8390,1,8773,111,116,59,1,10861,110,116,59,1,8750,4,3,102,114,121,8408,8412,8417,59,3,55349,56660,111,100,59,1,8720,5,169,2,59,115,8424,8426,1,169,114,59,1,8471,4,2,97,111,8436,8441,114,114,59,1,8629,115,115,59,1,10007,4,2,99,117,8452,8457,114,59,3,55349,56504,4,2,98,112,8463,8474,4,2,59,101,8469,8471,1,10959,59,1,10961,4,2,59,101,8480,8482,1,10960,59,1,10962,100,111,116,59,1,8943,4,7,100,101,108,112,114,118,119,8507,8522,8536,8550,8600,8697,8702,97,114,114,4,2,108,114,8516,8519,59,1,10552,59,1,10549,4,2,112,115,8528,8532,114,59,1,8926,99,59,1,8927,97,114,114,4,2,59,112,8545,8547,1,8630,59,1,10557,4,6,59,98,99,100,111,115,8564,8566,8573,8587,8592,8596,1,8746,114,99,97,112,59,1,10824,4,2,97,117,8579,8583,112,59,1,10822,112,59,1,10826,111,116,59,1,8845,114,59,1,10821,59,3,8746,65024,4,4,97,108,114,118,8610,8623,8663,8672,114,114,4,2,59,109,8618,8620,1,8631,59,1,10556,121,4,3,101,118,119,8632,8651,8656,113,4,2,112,115,8639,8645,114,101,99,59,1,8926,117,99,99,59,1,8927,101,101,59,1,8910,101,100,103,101,59,1,8911,101,110,5,164,1,59,8670,1,164,101,97,114,114,111,119,4,2,108,114,8684,8690,101,102,116,59,1,8630,105,103,104,116,59,1,8631,101,101,59,1,8910,101,100,59,1,8911,4,2,99,105,8713,8721,111,110,105,110,116,59,1,8754,110,116,59,1,8753,108,99,116,121,59,1,9005,4,19,65,72,97,98,99,100,101,102,104,105,106,108,111,114,115,116,117,119,122,8773,8778,8783,8821,8839,8854,8887,8914,8930,8944,9036,9041,9058,9197,9227,9258,9281,9297,9305,114,114,59,1,8659,97,114,59,1,10597,4,4,103,108,114,115,8793,8799,8805,8809,103,101,114,59,1,8224,101,116,104,59,1,8504,114,59,1,8595,104,4,2,59,118,8816,8818,1,8208,59,1,8867,4,2,107,108,8827,8834,97,114,111,119,59,1,10511,97,99,59,1,733,4,2,97,121,8845,8851,114,111,110,59,1,271,59,1,1076,4,3,59,97,111,8862,8864,8880,1,8518,4,2,103,114,8870,8876,103,101,114,59,1,8225,114,59,1,8650,116,115,101,113,59,1,10871,4,3,103,108,109,8895,8902,8907,5,176,1,59,8900,1,176,116,97,59,1,948,112,116,121,118,59,1,10673,4,2,105,114,8920,8926,115,104,116,59,1,10623,59,3,55349,56609,97,114,4,2,108,114,8938,8941,59,1,8643,59,1,8642,4,5,97,101,103,115,118,8956,8986,8989,8996,9001,109,4,3,59,111,115,8965,8967,8983,1,8900,110,100,4,2,59,115,8975,8977,1,8900,117,105,116,59,1,9830,59,1,9830,59,1,168,97,109,109,97,59,1,989,105,110,59,1,8946,4,3,59,105,111,9009,9011,9031,1,247,100,101,5,247,2,59,111,9020,9022,1,247,110,116,105,109,101,115,59,1,8903,110,120,59,1,8903,99,121,59,1,1106,99,4,2,111,114,9048,9053,114,110,59,1,8990,111,112,59,1,8973,4,5,108,112,116,117,119,9070,9076,9081,9130,9144,108,97,114,59,1,36,102,59,3,55349,56661,4,5,59,101,109,112,115,9093,9095,9109,9116,9122,1,729,113,4,2,59,100,9102,9104,1,8784,111,116,59,1,8785,105,110,117,115,59,1,8760,108,117,115,59,1,8724,113,117,97,114,101,59,1,8865,98,108,101,98,97,114,119,101,100,103,101,59,1,8966,110,4,3,97,100,104,9153,9160,9172,114,114,111,119,59,1,8595,111,119,110,97,114,114,111,119,115,59,1,8650,97,114,112,111,111,110,4,2,108,114,9184,9190,101,102,116,59,1,8643,105,103,104,116,59,1,8642,4,2,98,99,9203,9211,107,97,114,111,119,59,1,10512,4,2,111,114,9217,9222,114,110,59,1,8991,111,112,59,1,8972,4,3,99,111,116,9235,9248,9252,4,2,114,121,9241,9245,59,3,55349,56505,59,1,1109,108,59,1,10742,114,111,107,59,1,273,4,2,100,114,9264,9269,111,116,59,1,8945,105,4,2,59,102,9276,9278,1,9663,59,1,9662,4,2,97,104,9287,9292,114,114,59,1,8693,97,114,59,1,10607,97,110,103,108,101,59,1,10662,4,2,99,105,9311,9315,121,59,1,1119,103,114,97,114,114,59,1,10239,4,18,68,97,99,100,101,102,103,108,109,110,111,112,113,114,115,116,117,120,9361,9376,9398,9439,9444,9447,9462,9495,9531,9585,9598,9614,9659,9755,9771,9792,9808,9826,4,2,68,111,9367,9372,111,116,59,1,10871,116,59,1,8785,4,2,99,115,9382,9392,117,116,101,5,233,1,59,9390,1,233,116,101,114,59,1,10862,4,4,97,105,111,121,9408,9414,9430,9436,114,111,110,59,1,283,114,4,2,59,99,9421,9423,1,8790,5,234,1,59,9428,1,234,108,111,110,59,1,8789,59,1,1101,111,116,59,1,279,59,1,8519,4,2,68,114,9453,9458,111,116,59,1,8786,59,3,55349,56610,4,3,59,114,115,9470,9472,9482,1,10906,97,118,101,5,232,1,59,9480,1,232,4,2,59,100,9488,9490,1,10902,111,116,59,1,10904,4,4,59,105,108,115,9505,9507,9515,9518,1,10905,110,116,101,114,115,59,1,9191,59,1,8467,4,2,59,100,9524,9526,1,10901,111,116,59,1,10903,4,3,97,112,115,9539,9544,9564,99,114,59,1,275,116,121,4,3,59,115,118,9554,9556,9561,1,8709,101,116,59,1,8709,59,1,8709,112,4,2,49,59,9571,9583,4,2,51,52,9577,9580,59,1,8196,59,1,8197,1,8195,4,2,103,115,9591,9594,59,1,331,112,59,1,8194,4,2,103,112,9604,9609,111,110,59,1,281,102,59,3,55349,56662,4,3,97,108,115,9622,9635,9640,114,4,2,59,115,9629,9631,1,8917,108,59,1,10723,117,115,59,1,10865,105,4,3,59,108,118,9649,9651,9656,1,949,111,110,59,1,949,59,1,1013,4,4,99,115,117,118,9669,9686,9716,9747,4,2,105,111,9675,9680,114,99,59,1,8790,108,111,110,59,1,8789,4,2,105,108,9692,9696,109,59,1,8770,97,110,116,4,2,103,108,9705,9710,116,114,59,1,10902,101,115,115,59,1,10901,4,3,97,101,105,9724,9729,9734,108,115,59,1,61,115,116,59,1,8799,118,4,2,59,68,9741,9743,1,8801,68,59,1,10872,112,97,114,115,108,59,1,10725,4,2,68,97,9761,9766,111,116,59,1,8787,114,114,59,1,10609,4,3,99,100,105,9779,9783,9788,114,59,1,8495,111,116,59,1,8784,109,59,1,8770,4,2,97,104,9798,9801,59,1,951,5,240,1,59,9806,1,240,4,2,109,114,9814,9822,108,5,235,1,59,9820,1,235,111,59,1,8364,4,3,99,105,112,9834,9838,9843,108,59,1,33,115,116,59,1,8707,4,2,101,111,9849,9859,99,116,97,116,105,111,110,59,1,8496,110,101,110,116,105,97,108,101,59,1,8519,4,12,97,99,101,102,105,106,108,110,111,112,114,115,9896,9910,9914,9921,9954,9960,9967,9989,9994,10027,10036,10164,108,108,105,110,103,100,111,116,115,101,113,59,1,8786,121,59,1,1092,109,97,108,101,59,1,9792,4,3,105,108,114,9929,9935,9950,108,105,103,59,1,64259,4,2,105,108,9941,9945,103,59,1,64256,105,103,59,1,64260,59,3,55349,56611,108,105,103,59,1,64257,108,105,103,59,3,102,106,4,3,97,108,116,9975,9979,9984,116,59,1,9837,105,103,59,1,64258,110,115,59,1,9649,111,102,59,1,402,4,2,112,114,10000,10005,102,59,3,55349,56663,4,2,97,107,10011,10016,108,108,59,1,8704,4,2,59,118,10022,10024,1,8916,59,1,10969,97,114,116,105,110,116,59,1,10765,4,2,97,111,10042,10159,4,2,99,115,10048,10155,4,6,49,50,51,52,53,55,10062,10102,10114,10135,10139,10151,4,6,50,51,52,53,54,56,10076,10083,10086,10093,10096,10099,5,189,1,59,10081,1,189,59,1,8531,5,188,1,59,10091,1,188,59,1,8533,59,1,8537,59,1,8539,4,2,51,53,10108,10111,59,1,8532,59,1,8534,4,3,52,53,56,10122,10129,10132,5,190,1,59,10127,1,190,59,1,8535,59,1,8540,53,59,1,8536,4,2,54,56,10145,10148,59,1,8538,59,1,8541,56,59,1,8542,108,59,1,8260,119,110,59,1,8994,99,114,59,3,55349,56507,4,17,69,97,98,99,100,101,102,103,105,106,108,110,111,114,115,116,118,10206,10217,10247,10254,10268,10273,10358,10363,10374,10380,10385,10406,10458,10464,10470,10497,10610,4,2,59,108,10212,10214,1,8807,59,1,10892,4,3,99,109,112,10225,10231,10244,117,116,101,59,1,501,109,97,4,2,59,100,10239,10241,1,947,59,1,989,59,1,10886,114,101,118,101,59,1,287,4,2,105,121,10260,10265,114,99,59,1,285,59,1,1075,111,116,59,1,289,4,4,59,108,113,115,10283,10285,10288,10308,1,8805,59,1,8923,4,3,59,113,115,10296,10298,10301,1,8805,59,1,8807,108,97,110,116,59,1,10878,4,4,59,99,100,108,10318,10320,10324,10345,1,10878,99,59,1,10921,111,116,4,2,59,111,10332,10334,1,10880,4,2,59,108,10340,10342,1,10882,59,1,10884,4,2,59,101,10351,10354,3,8923,65024,115,59,1,10900,114,59,3,55349,56612,4,2,59,103,10369,10371,1,8811,59,1,8921,109,101,108,59,1,8503,99,121,59,1,1107,4,4,59,69,97,106,10395,10397,10400,10403,1,8823,59,1,10898,59,1,10917,59,1,10916,4,4,69,97,101,115,10416,10419,10434,10453,59,1,8809,112,4,2,59,112,10426,10428,1,10890,114,111,120,59,1,10890,4,2,59,113,10440,10442,1,10888,4,2,59,113,10448,10450,1,10888,59,1,8809,105,109,59,1,8935,112,102,59,3,55349,56664,97,118,101,59,1,96,4,2,99,105,10476,10480,114,59,1,8458,109,4,3,59,101,108,10489,10491,10494,1,8819,59,1,10894,59,1,10896,5,62,6,59,99,100,108,113,114,10512,10514,10527,10532,10538,10545,1,62,4,2,99,105,10520,10523,59,1,10919,114,59,1,10874,111,116,59,1,8919,80,97,114,59,1,10645,117,101,115,116,59,1,10876,4,5,97,100,101,108,115,10557,10574,10579,10599,10605,4,2,112,114,10563,10570,112,114,111,120,59,1,10886,114,59,1,10616,111,116,59,1,8919,113,4,2,108,113,10586,10592,101,115,115,59,1,8923,108,101,115,115,59,1,10892,101,115,115,59,1,8823,105,109,59,1,8819,4,2,101,110,10616,10626,114,116,110,101,113,113,59,3,8809,65024,69,59,3,8809,65024,4,10,65,97,98,99,101,102,107,111,115,121,10653,10658,10713,10718,10724,10760,10765,10786,10850,10875,114,114,59,1,8660,4,4,105,108,109,114,10668,10674,10678,10684,114,115,112,59,1,8202,102,59,1,189,105,108,116,59,1,8459,4,2,100,114,10690,10695,99,121,59,1,1098,4,3,59,99,119,10703,10705,10710,1,8596,105,114,59,1,10568,59,1,8621,97,114,59,1,8463,105,114,99,59,1,293,4,3,97,108,114,10732,10748,10754,114,116,115,4,2,59,117,10741,10743,1,9829,105,116,59,1,9829,108,105,112,59,1,8230,99,111,110,59,1,8889,114,59,3,55349,56613,115,4,2,101,119,10772,10779,97,114,111,119,59,1,10533,97,114,111,119,59,1,10534,4,5,97,109,111,112,114,10798,10803,10809,10839,10844,114,114,59,1,8703,116,104,116,59,1,8763,107,4,2,108,114,10816,10827,101,102,116,97,114,114,111,119,59,1,8617,105,103,104,116,97,114,114,111,119,59,1,8618,102,59,3,55349,56665,98,97,114,59,1,8213,4,3,99,108,116,10858,10863,10869,114,59,3,55349,56509,97,115,104,59,1,8463,114,111,107,59,1,295,4,2,98,112,10881,10887,117,108,108,59,1,8259,104,101,110,59,1,8208,4,15,97,99,101,102,103,105,106,109,110,111,112,113,115,116,117,10925,10936,10958,10977,10990,11001,11039,11045,11101,11192,11220,11226,11237,11285,11299,99,117,116,101,5,237,1,59,10934,1,237,4,3,59,105,121,10944,10946,10955,1,8291,114,99,5,238,1,59,10953,1,238,59,1,1080,4,2,99,120,10964,10968,121,59,1,1077,99,108,5,161,1,59,10975,1,161,4,2,102,114,10983,10986,59,1,8660,59,3,55349,56614,114,97,118,101,5,236,1,59,10999,1,236,4,4,59,105,110,111,11011,11013,11028,11034,1,8520,4,2,105,110,11019,11024,110,116,59,1,10764,116,59,1,8749,102,105,110,59,1,10716,116,97,59,1,8489,108,105,103,59,1,307,4,3,97,111,112,11053,11092,11096,4,3,99,103,116,11061,11065,11088,114,59,1,299,4,3,101,108,112,11073,11076,11082,59,1,8465,105,110,101,59,1,8464,97,114,116,59,1,8465,104,59,1,305,102,59,1,8887,101,100,59,1,437,4,5,59,99,102,111,116,11113,11115,11121,11136,11142,1,8712,97,114,101,59,1,8453,105,110,4,2,59,116,11129,11131,1,8734,105,101,59,1,10717,100,111,116,59,1,305,4,5,59,99,101,108,112,11154,11156,11161,11179,11186,1,8747,97,108,59,1,8890,4,2,103,114,11167,11173,101,114,115,59,1,8484,99,97,108,59,1,8890,97,114,104,107,59,1,10775,114,111,100,59,1,10812,4,4,99,103,112,116,11202,11206,11211,11216,121,59,1,1105,111,110,59,1,303,102,59,3,55349,56666,97,59,1,953,114,111,100,59,1,10812,117,101,115,116,5,191,1,59,11235,1,191,4,2,99,105,11243,11248,114,59,3,55349,56510,110,4,5,59,69,100,115,118,11261,11263,11266,11271,11282,1,8712,59,1,8953,111,116,59,1,8949,4,2,59,118,11277,11279,1,8948,59,1,8947,59,1,8712,4,2,59,105,11291,11293,1,8290,108,100,101,59,1,297,4,2,107,109,11305,11310,99,121,59,1,1110,108,5,239,1,59,11316,1,239,4,6,99,102,109,111,115,117,11332,11346,11351,11357,11363,11380,4,2,105,121,11338,11343,114,99,59,1,309,59,1,1081,114,59,3,55349,56615,97,116,104,59,1,567,112,102,59,3,55349,56667,4,2,99,101,11369,11374,114,59,3,55349,56511,114,99,121,59,1,1112,107,99,121,59,1,1108,4,8,97,99,102,103,104,106,111,115,11404,11418,11433,11438,11445,11450,11455,11461,112,112,97,4,2,59,118,11413,11415,1,954,59,1,1008,4,2,101,121,11424,11430,100,105,108,59,1,311,59,1,1082,114,59,3,55349,56616,114,101,101,110,59,1,312,99,121,59,1,1093,99,121,59,1,1116,112,102,59,3,55349,56668,99,114,59,3,55349,56512,4,23,65,66,69,72,97,98,99,100,101,102,103,104,106,108,109,110,111,112,114,115,116,117,118,11515,11538,11544,11555,11560,11721,11780,11818,11868,12136,12160,12171,12203,12208,12246,12275,12327,12509,12523,12569,12641,12732,12752,4,3,97,114,116,11523,11528,11532,114,114,59,1,8666,114,59,1,8656,97,105,108,59,1,10523,97,114,114,59,1,10510,4,2,59,103,11550,11552,1,8806,59,1,10891,97,114,59,1,10594,4,9,99,101,103,109,110,112,113,114,116,11580,11586,11594,11600,11606,11624,11627,11636,11694,117,116,101,59,1,314,109,112,116,121,118,59,1,10676,114,97,110,59,1,8466,98,100,97,59,1,955,103,4,3,59,100,108,11615,11617,11620,1,10216,59,1,10641,101,59,1,10216,59,1,10885,117,111,5,171,1,59,11634,1,171,114,4,8,59,98,102,104,108,112,115,116,11655,11657,11669,11673,11677,11681,11685,11690,1,8592,4,2,59,102,11663,11665,1,8676,115,59,1,10527,115,59,1,10525,107,59,1,8617,112,59,1,8619,108,59,1,10553,105,109,59,1,10611,108,59,1,8610,4,3,59,97,101,11702,11704,11709,1,10923,105,108,59,1,10521,4,2,59,115,11715,11717,1,10925,59,3,10925,65024,4,3,97,98,114,11729,11734,11739,114,114,59,1,10508,114,107,59,1,10098,4,2,97,107,11745,11758,99,4,2,101,107,11752,11755,59,1,123,59,1,91,4,2,101,115,11764,11767,59,1,10635,108,4,2,100,117,11774,11777,59,1,10639,59,1,10637,4,4,97,101,117,121,11790,11796,11811,11815,114,111,110,59,1,318,4,2,100,105,11802,11807,105,108,59,1,316,108,59,1,8968,98,59,1,123,59,1,1083,4,4,99,113,114,115,11828,11832,11845,11864,97,59,1,10550,117,111,4,2,59,114,11840,11842,1,8220,59,1,8222,4,2,100,117,11851,11857,104,97,114,59,1,10599,115,104,97,114,59,1,10571,104,59,1,8626,4,5,59,102,103,113,115,11880,11882,12008,12011,12031,1,8804,116,4,5,97,104,108,114,116,11895,11913,11935,11947,11996,114,114,111,119,4,2,59,116,11905,11907,1,8592,97,105,108,59,1,8610,97,114,112,111,111,110,4,2,100,117,11925,11931,111,119,110,59,1,8637,112,59,1,8636,101,102,116,97,114,114,111,119,115,59,1,8647,105,103,104,116,4,3,97,104,115,11959,11974,11984,114,114,111,119,4,2,59,115,11969,11971,1,8596,59,1,8646,97,114,112,111,111,110,115,59,1,8651,113,117,105,103,97,114,114,111,119,59,1,8621,104,114,101,101,116,105,109,101,115,59,1,8907,59,1,8922,4,3,59,113,115,12019,12021,12024,1,8804,59,1,8806,108,97,110,116,59,1,10877,4,5,59,99,100,103,115,12043,12045,12049,12070,12083,1,10877,99,59,1,10920,111,116,4,2,59,111,12057,12059,1,10879,4,2,59,114,12065,12067,1,10881,59,1,10883,4,2,59,101,12076,12079,3,8922,65024,115,59,1,10899,4,5,97,100,101,103,115,12095,12103,12108,12126,12131,112,112,114,111,120,59,1,10885,111,116,59,1,8918,113,4,2,103,113,12115,12120,116,114,59,1,8922,103,116,114,59,1,10891,116,114,59,1,8822,105,109,59,1,8818,4,3,105,108,114,12144,12150,12156,115,104,116,59,1,10620,111,111,114,59,1,8970,59,3,55349,56617,4,2,59,69,12166,12168,1,8822,59,1,10897,4,2,97,98,12177,12198,114,4,2,100,117,12184,12187,59,1,8637,4,2,59,108,12193,12195,1,8636,59,1,10602,108,107,59,1,9604,99,121,59,1,1113,4,5,59,97,99,104,116,12220,12222,12227,12235,12241,1,8810,114,114,59,1,8647,111,114,110,101,114,59,1,8990,97,114,100,59,1,10603,114,105,59,1,9722,4,2,105,111,12252,12258,100,111,116,59,1,320,117,115,116,4,2,59,97,12267,12269,1,9136,99,104,101,59,1,9136,4,4,69,97,101,115,12285,12288,12303,12322,59,1,8808,112,4,2,59,112,12295,12297,1,10889,114,111,120,59,1,10889,4,2,59,113,12309,12311,1,10887,4,2,59,113,12317,12319,1,10887,59,1,8808,105,109,59,1,8934,4,8,97,98,110,111,112,116,119,122,12345,12359,12364,12421,12446,12467,12474,12490,4,2,110,114,12351,12355,103,59,1,10220,114,59,1,8701,114,107,59,1,10214,103,4,3,108,109,114,12373,12401,12409,101,102,116,4,2,97,114,12382,12389,114,114,111,119,59,1,10229,105,103,104,116,97,114,114,111,119,59,1,10231,97,112,115,116,111,59,1,10236,105,103,104,116,97,114,114,111,119,59,1,10230,112,97,114,114,111,119,4,2,108,114,12433,12439,101,102,116,59,1,8619,105,103,104,116,59,1,8620,4,3,97,102,108,12454,12458,12462,114,59,1,10629,59,3,55349,56669,117,115,59,1,10797,105,109,101,115,59,1,10804,4,2,97,98,12480,12485,115,116,59,1,8727,97,114,59,1,95,4,3,59,101,102,12498,12500,12506,1,9674,110,103,101,59,1,9674,59,1,10731,97,114,4,2,59,108,12517,12519,1,40,116,59,1,10643,4,5,97,99,104,109,116,12535,12540,12548,12561,12564,114,114,59,1,8646,111,114,110,101,114,59,1,8991,97,114,4,2,59,100,12556,12558,1,8651,59,1,10605,59,1,8206,114,105,59,1,8895,4,6,97,99,104,105,113,116,12583,12589,12594,12597,12614,12635,113,117,111,59,1,8249,114,59,3,55349,56513,59,1,8624,109,4,3,59,101,103,12606,12608,12611,1,8818,59,1,10893,59,1,10895,4,2,98,117,12620,12623,59,1,91,111,4,2,59,114,12630,12632,1,8216,59,1,8218,114,111,107,59,1,322,5,60,8,59,99,100,104,105,108,113,114,12660,12662,12675,12680,12686,12692,12698,12705,1,60,4,2,99,105,12668,12671,59,1,10918,114,59,1,10873,111,116,59,1,8918,114,101,101,59,1,8907,109,101,115,59,1,8905,97,114,114,59,1,10614,117,101,115,116,59,1,10875,4,2,80,105,12711,12716,97,114,59,1,10646,4,3,59,101,102,12724,12726,12729,1,9667,59,1,8884,59,1,9666,114,4,2,100,117,12739,12746,115,104,97,114,59,1,10570,104,97,114,59,1,10598,4,2,101,110,12758,12768,114,116,110,101,113,113,59,3,8808,65024,69,59,3,8808,65024,4,14,68,97,99,100,101,102,104,105,108,110,111,112,115,117,12803,12809,12893,12908,12914,12928,12933,12937,13011,13025,13032,13049,13052,13069,68,111,116,59,1,8762,4,4,99,108,112,114,12819,12827,12849,12887,114,5,175,1,59,12825,1,175,4,2,101,116,12833,12836,59,1,9794,4,2,59,101,12842,12844,1,10016,115,101,59,1,10016,4,2,59,115,12855,12857,1,8614,116,111,4,4,59,100,108,117,12869,12871,12877,12883,1,8614,111,119,110,59,1,8615,101,102,116,59,1,8612,112,59,1,8613,107,101,114,59,1,9646,4,2,111,121,12899,12905,109,109,97,59,1,10793,59,1,1084,97,115,104,59,1,8212,97,115,117,114,101,100,97,110,103,108,101,59,1,8737,114,59,3,55349,56618,111,59,1,8487,4,3,99,100,110,12945,12954,12985,114,111,5,181,1,59,12952,1,181,4,4,59,97,99,100,12964,12966,12971,12976,1,8739,115,116,59,1,42,105,114,59,1,10992,111,116,5,183,1,59,12983,1,183,117,115,4,3,59,98,100,12995,12997,13000,1,8722,59,1,8863,4,2,59,117,13006,13008,1,8760,59,1,10794,4,2,99,100,13017,13021,112,59,1,10971,114,59,1,8230,112,108,117,115,59,1,8723,4,2,100,112,13038,13044,101,108,115,59,1,8871,102,59,3,55349,56670,59,1,8723,4,2,99,116,13058,13063,114,59,3,55349,56514,112,111,115,59,1,8766,4,3,59,108,109,13077,13079,13087,1,956,116,105,109,97,112,59,1,8888,97,112,59,1,8888,4,24,71,76,82,86,97,98,99,100,101,102,103,104,105,106,108,109,111,112,114,115,116,117,118,119,13142,13165,13217,13229,13247,13330,13359,13414,13420,13508,13513,13579,13602,13626,13631,13762,13767,13855,13936,13995,14214,14285,14312,14432,4,2,103,116,13148,13152,59,3,8921,824,4,2,59,118,13158,13161,3,8811,8402,59,3,8811,824,4,3,101,108,116,13173,13200,13204,102,116,4,2,97,114,13181,13188,114,114,111,119,59,1,8653,105,103,104,116,97,114,114,111,119,59,1,8654,59,3,8920,824,4,2,59,118,13210,13213,3,8810,8402,59,3,8810,824,105,103,104,116,97,114,114,111,119,59,1,8655,4,2,68,100,13235,13241,97,115,104,59,1,8879,97,115,104,59,1,8878,4,5,98,99,110,112,116,13259,13264,13270,13275,13308,108,97,59,1,8711,117,116,101,59,1,324,103,59,3,8736,8402,4,5,59,69,105,111,112,13287,13289,13293,13298,13302,1,8777,59,3,10864,824,100,59,3,8779,824,115,59,1,329,114,111,120,59,1,8777,117,114,4,2,59,97,13316,13318,1,9838,108,4,2,59,115,13325,13327,1,9838,59,1,8469,4,2,115,117,13336,13344,112,5,160,1,59,13342,1,160,109,112,4,2,59,101,13352,13355,3,8782,824,59,3,8783,824,4,5,97,101,111,117,121,13371,13385,13391,13407,13411,4,2,112,114,13377,13380,59,1,10819,111,110,59,1,328,100,105,108,59,1,326,110,103,4,2,59,100,13399,13401,1,8775,111,116,59,3,10861,824,112,59,1,10818,59,1,1085,97,115,104,59,1,8211,4,7,59,65,97,100,113,115,120,13436,13438,13443,13466,13472,13478,13494,1,8800,114,114,59,1,8663,114,4,2,104,114,13450,13454,107,59,1,10532,4,2,59,111,13460,13462,1,8599,119,59,1,8599,111,116,59,3,8784,824,117,105,118,59,1,8802,4,2,101,105,13484,13489,97,114,59,1,10536,109,59,3,8770,824,105,115,116,4,2,59,115,13503,13505,1,8708,59,1,8708,114,59,3,55349,56619,4,4,69,101,115,116,13523,13527,13563,13568,59,3,8807,824,4,3,59,113,115,13535,13537,13559,1,8817,4,3,59,113,115,13545,13547,13551,1,8817,59,3,8807,824,108,97,110,116,59,3,10878,824,59,3,10878,824,105,109,59,1,8821,4,2,59,114,13574,13576,1,8815,59,1,8815,4,3,65,97,112,13587,13592,13597,114,114,59,1,8654,114,114,59,1,8622,97,114,59,1,10994,4,3,59,115,118,13610,13612,13623,1,8715,4,2,59,100,13618,13620,1,8956,59,1,8954,59,1,8715,99,121,59,1,1114,4,7,65,69,97,100,101,115,116,13647,13652,13656,13661,13665,13737,13742,114,114,59,1,8653,59,3,8806,824,114,114,59,1,8602,114,59,1,8229,4,4,59,102,113,115,13675,13677,13703,13725,1,8816,116,4,2,97,114,13684,13691,114,114,111,119,59,1,8602,105,103,104,116,97,114,114,111,119,59,1,8622,4,3,59,113,115,13711,13713,13717,1,8816,59,3,8806,824,108,97,110,116,59,3,10877,824,4,2,59,115,13731,13734,3,10877,824,59,1,8814,105,109,59,1,8820,4,2,59,114,13748,13750,1,8814,105,4,2,59,101,13757,13759,1,8938,59,1,8940,105,100,59,1,8740,4,2,112,116,13773,13778,102,59,3,55349,56671,5,172,3,59,105,110,13787,13789,13829,1,172,110,4,4,59,69,100,118,13800,13802,13806,13812,1,8713,59,3,8953,824,111,116,59,3,8949,824,4,3,97,98,99,13820,13823,13826,59,1,8713,59,1,8951,59,1,8950,105,4,2,59,118,13836,13838,1,8716,4,3,97,98,99,13846,13849,13852,59,1,8716,59,1,8958,59,1,8957,4,3,97,111,114,13863,13892,13899,114,4,4,59,97,115,116,13874,13876,13883,13888,1,8742,108,108,101,108,59,1,8742,108,59,3,11005,8421,59,3,8706,824,108,105,110,116,59,1,10772,4,3,59,99,101,13907,13909,13914,1,8832,117,101,59,1,8928,4,2,59,99,13920,13923,3,10927,824,4,2,59,101,13929,13931,1,8832,113,59,3,10927,824,4,4,65,97,105,116,13946,13951,13971,13982,114,114,59,1,8655,114,114,4,3,59,99,119,13961,13963,13967,1,8603,59,3,10547,824,59,3,8605,824,103,104,116,97,114,114,111,119,59,1,8603,114,105,4,2,59,101,13990,13992,1,8939,59,1,8941,4,7,99,104,105,109,112,113,117,14011,14036,14060,14080,14085,14090,14106,4,4,59,99,101,114,14021,14023,14028,14032,1,8833,117,101,59,1,8929,59,3,10928,824,59,3,55349,56515,111,114,116,4,2,109,112,14045,14050,105,100,59,1,8740,97,114,97,108,108,101,108,59,1,8742,109,4,2,59,101,14067,14069,1,8769,4,2,59,113,14075,14077,1,8772,59,1,8772,105,100,59,1,8740,97,114,59,1,8742,115,117,4,2,98,112,14098,14102,101,59,1,8930,101,59,1,8931,4,3,98,99,112,14114,14157,14171,4,4,59,69,101,115,14124,14126,14130,14133,1,8836,59,3,10949,824,59,1,8840,101,116,4,2,59,101,14141,14144,3,8834,8402,113,4,2,59,113,14151,14153,1,8840,59,3,10949,824,99,4,2,59,101,14164,14166,1,8833,113,59,3,10928,824,4,4,59,69,101,115,14181,14183,14187,14190,1,8837,59,3,10950,824,59,1,8841,101,116,4,2,59,101,14198,14201,3,8835,8402,113,4,2,59,113,14208,14210,1,8841,59,3,10950,824,4,4,103,105,108,114,14224,14228,14238,14242,108,59,1,8825,108,100,101,5,241,1,59,14236,1,241,103,59,1,8824,105,97,110,103,108,101,4,2,108,114,14254,14269,101,102,116,4,2,59,101,14263,14265,1,8938,113,59,1,8940,105,103,104,116,4,2,59,101,14279,14281,1,8939,113,59,1,8941,4,2,59,109,14291,14293,1,957,4,3,59,101,115,14301,14303,14308,1,35,114,111,59,1,8470,112,59,1,8199,4,9,68,72,97,100,103,105,108,114,115,14332,14338,14344,14349,14355,14369,14376,14408,14426,97,115,104,59,1,8877,97,114,114,59,1,10500,112,59,3,8781,8402,97,115,104,59,1,8876,4,2,101,116,14361,14365,59,3,8805,8402,59,3,62,8402,110,102,105,110,59,1,10718,4,3,65,101,116,14384,14389,14393,114,114,59,1,10498,59,3,8804,8402,4,2,59,114,14399,14402,3,60,8402,105,101,59,3,8884,8402,4,2,65,116,14414,14419,114,114,59,1,10499,114,105,101,59,3,8885,8402,105,109,59,3,8764,8402,4,3,65,97,110,14440,14445,14468,114,114,59,1,8662,114,4,2,104,114,14452,14456,107,59,1,10531,4,2,59,111,14462,14464,1,8598,119,59,1,8598,101,97,114,59,1,10535,4,18,83,97,99,100,101,102,103,104,105,108,109,111,112,114,115,116,117,118,14512,14515,14535,14560,14597,14603,14618,14643,14657,14662,14701,14741,14747,14769,14851,14877,14907,14916,59,1,9416,4,2,99,115,14521,14531,117,116,101,5,243,1,59,14529,1,243,116,59,1,8859,4,2,105,121,14541,14557,114,4,2,59,99,14548,14550,1,8858,5,244,1,59,14555,1,244,59,1,1086,4,5,97,98,105,111,115,14572,14577,14583,14587,14591,115,104,59,1,8861,108,97,99,59,1,337,118,59,1,10808,116,59,1,8857,111,108,100,59,1,10684,108,105,103,59,1,339,4,2,99,114,14609,14614,105,114,59,1,10687,59,3,55349,56620,4,3,111,114,116,14626,14630,14640,110,59,1,731,97,118,101,5,242,1,59,14638,1,242,59,1,10689,4,2,98,109,14649,14654,97,114,59,1,10677,59,1,937,110,116,59,1,8750,4,4,97,99,105,116,14672,14677,14693,14698,114,114,59,1,8634,4,2,105,114,14683,14687,114,59,1,10686,111,115,115,59,1,10683,110,101,59,1,8254,59,1,10688,4,3,97,101,105,14709,14714,14719,99,114,59,1,333,103,97,59,1,969,4,3,99,100,110,14727,14733,14736,114,111,110,59,1,959,59,1,10678,117,115,59,1,8854,112,102,59,3,55349,56672,4,3,97,101,108,14755,14759,14764,114,59,1,10679,114,112,59,1,10681,117,115,59,1,8853,4,7,59,97,100,105,111,115,118,14785,14787,14792,14831,14837,14841,14848,1,8744,114,114,59,1,8635,4,4,59,101,102,109,14802,14804,14817,14824,1,10845,114,4,2,59,111,14811,14813,1,8500,102,59,1,8500,5,170,1,59,14822,1,170,5,186,1,59,14829,1,186,103,111,102,59,1,8886,114,59,1,10838,108,111,112,101,59,1,10839,59,1,10843,4,3,99,108,111,14859,14863,14873,114,59,1,8500,97,115,104,5,248,1,59,14871,1,248,108,59,1,8856,105,4,2,108,109,14884,14893,100,101,5,245,1,59,14891,1,245,101,115,4,2,59,97,14901,14903,1,8855,115,59,1,10806,109,108,5,246,1,59,14914,1,246,98,97,114,59,1,9021,4,12,97,99,101,102,104,105,108,109,111,114,115,117,14948,14992,14996,15033,15038,15068,15090,15189,15192,15222,15427,15441,114,4,4,59,97,115,116,14959,14961,14976,14989,1,8741,5,182,2,59,108,14968,14970,1,182,108,101,108,59,1,8741,4,2,105,108,14982,14986,109,59,1,10995,59,1,11005,59,1,8706,121,59,1,1087,114,4,5,99,105,109,112,116,15009,15014,15019,15024,15027,110,116,59,1,37,111,100,59,1,46,105,108,59,1,8240,59,1,8869,101,110,107,59,1,8241,114,59,3,55349,56621,4,3,105,109,111,15046,15057,15063,4,2,59,118,15052,15054,1,966,59,1,981,109,97,116,59,1,8499,110,101,59,1,9742,4,3,59,116,118,15076,15078,15087,1,960,99,104,102,111,114,107,59,1,8916,59,1,982,4,2,97,117,15096,15119,110,4,2,99,107,15103,15115,107,4,2,59,104,15110,15112,1,8463,59,1,8462,118,59,1,8463,115,4,9,59,97,98,99,100,101,109,115,116,15140,15142,15148,15151,15156,15168,15171,15179,15184,1,43,99,105,114,59,1,10787,59,1,8862,105,114,59,1,10786,4,2,111,117,15162,15165,59,1,8724,59,1,10789,59,1,10866,110,5,177,1,59,15177,1,177,105,109,59,1,10790,119,111,59,1,10791,59,1,177,4,3,105,112,117,15200,15208,15213,110,116,105,110,116,59,1,10773,102,59,3,55349,56673,110,100,5,163,1,59,15220,1,163,4,10,59,69,97,99,101,105,110,111,115,117,15244,15246,15249,15253,15258,15334,15347,15367,15416,15421,1,8826,59,1,10931,112,59,1,10935,117,101,59,1,8828,4,2,59,99,15264,15266,1,10927,4,6,59,97,99,101,110,115,15280,15282,15290,15299,15303,15329,1,8826,112,112,114,111,120,59,1,10935,117,114,108,121,101,113,59,1,8828,113,59,1,10927,4,3,97,101,115,15311,15319,15324,112,112,114,111,120,59,1,10937,113,113,59,1,10933,105,109,59,1,8936,105,109,59,1,8830,109,101,4,2,59,115,15342,15344,1,8242,59,1,8473,4,3,69,97,115,15355,15358,15362,59,1,10933,112,59,1,10937,105,109,59,1,8936,4,3,100,102,112,15375,15378,15404,59,1,8719,4,3,97,108,115,15386,15392,15398,108,97,114,59,1,9006,105,110,101,59,1,8978,117,114,102,59,1,8979,4,2,59,116,15410,15412,1,8733,111,59,1,8733,105,109,59,1,8830,114,101,108,59,1,8880,4,2,99,105,15433,15438,114,59,3,55349,56517,59,1,968,110,99,115,112,59,1,8200,4,6,102,105,111,112,115,117,15462,15467,15472,15478,15485,15491,114,59,3,55349,56622,110,116,59,1,10764,112,102,59,3,55349,56674,114,105,109,101,59,1,8279,99,114,59,3,55349,56518,4,3,97,101,111,15499,15520,15534,116,4,2,101,105,15506,15515,114,110,105,111,110,115,59,1,8461,110,116,59,1,10774,115,116,4,2,59,101,15528,15530,1,63,113,59,1,8799,116,5,34,1,59,15540,1,34,4,21,65,66,72,97,98,99,100,101,102,104,105,108,109,110,111,112,114,115,116,117,120,15586,15609,15615,15620,15796,15855,15893,15931,15977,16001,16039,16183,16204,16222,16228,16285,16312,16318,16363,16408,16416,4,3,97,114,116,15594,15599,15603,114,114,59,1,8667,114,59,1,8658,97,105,108,59,1,10524,97,114,114,59,1,10511,97,114,59,1,10596,4,7,99,100,101,110,113,114,116,15636,15651,15656,15664,15687,15696,15770,4,2,101,117,15642,15646,59,3,8765,817,116,101,59,1,341,105,99,59,1,8730,109,112,116,121,118,59,1,10675,103,4,4,59,100,101,108,15675,15677,15680,15683,1,10217,59,1,10642,59,1,10661,101,59,1,10217,117,111,5,187,1,59,15694,1,187,114,4,11,59,97,98,99,102,104,108,112,115,116,119,15721,15723,15727,15739,15742,15746,15750,15754,15758,15763,15767,1,8594,112,59,1,10613,4,2,59,102,15733,15735,1,8677,115,59,1,10528,59,1,10547,115,59,1,10526,107,59,1,8618,112,59,1,8620,108,59,1,10565,105,109,59,1,10612,108,59,1,8611,59,1,8605,4,2,97,105,15776,15781,105,108,59,1,10522,111,4,2,59,110,15788,15790,1,8758,97,108,115,59,1,8474,4,3,97,98,114,15804,15809,15814,114,114,59,1,10509,114,107,59,1,10099,4,2,97,107,15820,15833,99,4,2,101,107,15827,15830,59,1,125,59,1,93,4,2,101,115,15839,15842,59,1,10636,108,4,2,100,117,15849,15852,59,1,10638,59,1,10640,4,4,97,101,117,121,15865,15871,15886,15890,114,111,110,59,1,345,4,2,100,105,15877,15882,105,108,59,1,343,108,59,1,8969,98,59,1,125,59,1,1088,4,4,99,108,113,115,15903,15907,15914,15927,97,59,1,10551,100,104,97,114,59,1,10601,117,111,4,2,59,114,15922,15924,1,8221,59,1,8221,104,59,1,8627,4,3,97,99,103,15939,15966,15970,108,4,4,59,105,112,115,15950,15952,15957,15963,1,8476,110,101,59,1,8475,97,114,116,59,1,8476,59,1,8477,116,59,1,9645,5,174,1,59,15975,1,174,4,3,105,108,114,15985,15991,15997,115,104,116,59,1,10621,111,111,114,59,1,8971,59,3,55349,56623,4,2,97,111,16007,16028,114,4,2,100,117,16014,16017,59,1,8641,4,2,59,108,16023,16025,1,8640,59,1,10604,4,2,59,118,16034,16036,1,961,59,1,1009,4,3,103,110,115,16047,16167,16171,104,116,4,6,97,104,108,114,115,116,16063,16081,16103,16130,16143,16155,114,114,111,119,4,2,59,116,16073,16075,1,8594,97,105,108,59,1,8611,97,114,112,111,111,110,4,2,100,117,16093,16099,111,119,110,59,1,8641,112,59,1,8640,101,102,116,4,2,97,104,16112,16120,114,114,111,119,115,59,1,8644,97,114,112,111,111,110,115,59,1,8652,105,103,104,116,97,114,114,111,119,115,59,1,8649,113,117,105,103,97,114,114,111,119,59,1,8605,104,114,101,101,116,105,109,101,115,59,1,8908,103,59,1,730,105,110,103,100,111,116,115,101,113,59,1,8787,4,3,97,104,109,16191,16196,16201,114,114,59,1,8644,97,114,59,1,8652,59,1,8207,111,117,115,116,4,2,59,97,16214,16216,1,9137,99,104,101,59,1,9137,109,105,100,59,1,10990,4,4,97,98,112,116,16238,16252,16257,16278,4,2,110,114,16244,16248,103,59,1,10221,114,59,1,8702,114,107,59,1,10215,4,3,97,102,108,16265,16269,16273,114,59,1,10630,59,3,55349,56675,117,115,59,1,10798,105,109,101,115,59,1,10805,4,2,97,112,16291,16304,114,4,2,59,103,16298,16300,1,41,116,59,1,10644,111,108,105,110,116,59,1,10770,97,114,114,59,1,8649,4,4,97,99,104,113,16328,16334,16339,16342,113,117,111,59,1,8250,114,59,3,55349,56519,59,1,8625,4,2,98,117,16348,16351,59,1,93,111,4,2,59,114,16358,16360,1,8217,59,1,8217,4,3,104,105,114,16371,16377,16383,114,101,101,59,1,8908,109,101,115,59,1,8906,105,4,4,59,101,102,108,16394,16396,16399,16402,1,9657,59,1,8885,59,1,9656,116,114,105,59,1,10702,108,117,104,97,114,59,1,10600,59,1,8478,4,19,97,98,99,100,101,102,104,105,108,109,111,112,113,114,115,116,117,119,122,16459,16466,16472,16572,16590,16672,16687,16746,16844,16850,16924,16963,16988,17115,17121,17154,17206,17614,17656,99,117,116,101,59,1,347,113,117,111,59,1,8218,4,10,59,69,97,99,101,105,110,112,115,121,16494,16496,16499,16513,16518,16531,16536,16556,16564,16569,1,8827,59,1,10932,4,2,112,114,16505,16508,59,1,10936,111,110,59,1,353,117,101,59,1,8829,4,2,59,100,16524,16526,1,10928,105,108,59,1,351,114,99,59,1,349,4,3,69,97,115,16544,16547,16551,59,1,10934,112,59,1,10938,105,109,59,1,8937,111,108,105,110,116,59,1,10771,105,109,59,1,8831,59,1,1089,111,116,4,3,59,98,101,16582,16584,16587,1,8901,59,1,8865,59,1,10854,4,7,65,97,99,109,115,116,120,16606,16611,16634,16642,16646,16652,16668,114,114,59,1,8664,114,4,2,104,114,16618,16622,107,59,1,10533,4,2,59,111,16628,16630,1,8600,119,59,1,8600,116,5,167,1,59,16640,1,167,105,59,1,59,119,97,114,59,1,10537,109,4,2,105,110,16659,16665,110,117,115,59,1,8726,59,1,8726,116,59,1,10038,114,4,2,59,111,16679,16682,3,55349,56624,119,110,59,1,8994,4,4,97,99,111,121,16697,16702,16716,16739,114,112,59,1,9839,4,2,104,121,16708,16713,99,121,59,1,1097,59,1,1096,114,116,4,2,109,112,16724,16729,105,100,59,1,8739,97,114,97,108,108,101,108,59,1,8741,5,173,1,59,16744,1,173,4,2,103,109,16752,16770,109,97,4,3,59,102,118,16762,16764,16767,1,963,59,1,962,59,1,962,4,8,59,100,101,103,108,110,112,114,16788,16790,16795,16806,16817,16828,16832,16838,1,8764,111,116,59,1,10858,4,2,59,113,16801,16803,1,8771,59,1,8771,4,2,59,69,16812,16814,1,10910,59,1,10912,4,2,59,69,16823,16825,1,10909,59,1,10911,101,59,1,8774,108,117,115,59,1,10788,97,114,114,59,1,10610,97,114,114,59,1,8592,4,4,97,101,105,116,16860,16883,16891,16904,4,2,108,115,16866,16878,108,115,101,116,109,105,110,117,115,59,1,8726,104,112,59,1,10803,112,97,114,115,108,59,1,10724,4,2,100,108,16897,16900,59,1,8739,101,59,1,8995,4,2,59,101,16910,16912,1,10922,4,2,59,115,16918,16920,1,10924,59,3,10924,65024,4,3,102,108,112,16932,16938,16958,116,99,121,59,1,1100,4,2,59,98,16944,16946,1,47,4,2,59,97,16952,16954,1,10692,114,59,1,9023,102,59,3,55349,56676,97,4,2,100,114,16970,16985,101,115,4,2,59,117,16978,16980,1,9824,105,116,59,1,9824,59,1,8741,4,3,99,115,117,16996,17028,17089,4,2,97,117,17002,17015,112,4,2,59,115,17009,17011,1,8851,59,3,8851,65024,112,4,2,59,115,17022,17024,1,8852,59,3,8852,65024,117,4,2,98,112,17035,17062,4,3,59,101,115,17043,17045,17048,1,8847,59,1,8849,101,116,4,2,59,101,17056,17058,1,8847,113,59,1,8849,4,3,59,101,115,17070,17072,17075,1,8848,59,1,8850,101,116,4,2,59,101,17083,17085,1,8848,113,59,1,8850,4,3,59,97,102,17097,17099,17112,1,9633,114,4,2,101,102,17106,17109,59,1,9633,59,1,9642,59,1,9642,97,114,114,59,1,8594,4,4,99,101,109,116,17131,17136,17142,17148,114,59,3,55349,56520,116,109,110,59,1,8726,105,108,101,59,1,8995,97,114,102,59,1,8902,4,2,97,114,17160,17172,114,4,2,59,102,17167,17169,1,9734,59,1,9733,4,2,97,110,17178,17202,105,103,104,116,4,2,101,112,17188,17197,112,115,105,108,111,110,59,1,1013,104,105,59,1,981,115,59,1,175,4,5,98,99,109,110,112,17218,17351,17420,17423,17427,4,9,59,69,100,101,109,110,112,114,115,17238,17240,17243,17248,17261,17267,17279,17285,17291,1,8834,59,1,10949,111,116,59,1,10941,4,2,59,100,17254,17256,1,8838,111,116,59,1,10947,117,108,116,59,1,10945,4,2,69,101,17273,17276,59,1,10955,59,1,8842,108,117,115,59,1,10943,97,114,114,59,1,10617,4,3,101,105,117,17299,17335,17339,116,4,3,59,101,110,17308,17310,17322,1,8834,113,4,2,59,113,17317,17319,1,8838,59,1,10949,101,113,4,2,59,113,17330,17332,1,8842,59,1,10955,109,59,1,10951,4,2,98,112,17345,17348,59,1,10965,59,1,10963,99,4,6,59,97,99,101,110,115,17366,17368,17376,17385,17389,17415,1,8827,112,112,114,111,120,59,1,10936,117,114,108,121,101,113,59,1,8829,113,59,1,10928,4,3,97,101,115,17397,17405,17410,112,112,114,111,120,59,1,10938,113,113,59,1,10934,105,109,59,1,8937,105,109,59,1,8831,59,1,8721,103,59,1,9834,4,13,49,50,51,59,69,100,101,104,108,109,110,112,115,17455,17462,17469,17476,17478,17481,17496,17509,17524,17530,17536,17548,17554,5,185,1,59,17460,1,185,5,178,1,59,17467,1,178,5,179,1,59,17474,1,179,1,8835,59,1,10950,4,2,111,115,17487,17491,116,59,1,10942,117,98,59,1,10968,4,2,59,100,17502,17504,1,8839,111,116,59,1,10948,115,4,2,111,117,17516,17520,108,59,1,10185,98,59,1,10967,97,114,114,59,1,10619,117,108,116,59,1,10946,4,2,69,101,17542,17545,59,1,10956,59,1,8843,108,117,115,59,1,10944,4,3,101,105,117,17562,17598,17602,116,4,3,59,101,110,17571,17573,17585,1,8835,113,4,2,59,113,17580,17582,1,8839,59,1,10950,101,113,4,2,59,113,17593,17595,1,8843,59,1,10956,109,59,1,10952,4,2,98,112,17608,17611,59,1,10964,59,1,10966,4,3,65,97,110,17622,17627,17650,114,114,59,1,8665,114,4,2,104,114,17634,17638,107,59,1,10534,4,2,59,111,17644,17646,1,8601,119,59,1,8601,119,97,114,59,1,10538,108,105,103,5,223,1,59,17664,1,223,4,13,97,98,99,100,101,102,104,105,111,112,114,115,119,17694,17709,17714,17737,17742,17749,17754,17860,17905,17957,17964,18090,18122,4,2,114,117,17700,17706,103,101,116,59,1,8982,59,1,964,114,107,59,1,9140,4,3,97,101,121,17722,17728,17734,114,111,110,59,1,357,100,105,108,59,1,355,59,1,1090,111,116,59,1,8411,108,114,101,99,59,1,8981,114,59,3,55349,56625,4,4,101,105,107,111,17764,17805,17836,17851,4,2,114,116,17770,17786,101,4,2,52,102,17777,17780,59,1,8756,111,114,101,59,1,8756,97,4,3,59,115,118,17795,17797,17802,1,952,121,109,59,1,977,59,1,977,4,2,99,110,17811,17831,107,4,2,97,115,17818,17826,112,112,114,111,120,59,1,8776,105,109,59,1,8764,115,112,59,1,8201,4,2,97,115,17842,17846,112,59,1,8776,105,109,59,1,8764,114,110,5,254,1,59,17858,1,254,4,3,108,109,110,17868,17873,17901,100,101,59,1,732,101,115,5,215,3,59,98,100,17884,17886,17898,1,215,4,2,59,97,17892,17894,1,8864,114,59,1,10801,59,1,10800,116,59,1,8749,4,3,101,112,115,17913,17917,17953,97,59,1,10536,4,4,59,98,99,102,17927,17929,17934,17939,1,8868,111,116,59,1,9014,105,114,59,1,10993,4,2,59,111,17945,17948,3,55349,56677,114,107,59,1,10970,97,59,1,10537,114,105,109,101,59,1,8244,4,3,97,105,112,17972,17977,18082,100,101,59,1,8482,4,7,97,100,101,109,112,115,116,17993,18051,18056,18059,18066,18072,18076,110,103,108,101,4,5,59,100,108,113,114,18009,18011,18017,18032,18035,1,9653,111,119,110,59,1,9663,101,102,116,4,2,59,101,18026,18028,1,9667,113,59,1,8884,59,1,8796,105,103,104,116,4,2,59,101,18045,18047,1,9657,113,59,1,8885,111,116,59,1,9708,59,1,8796,105,110,117,115,59,1,10810,108,117,115,59,1,10809,98,59,1,10701,105,109,101,59,1,10811,101,122,105,117,109,59,1,9186,4,3,99,104,116,18098,18111,18116,4,2,114,121,18104,18108,59,3,55349,56521,59,1,1094,99,121,59,1,1115,114,111,107,59,1,359,4,2,105,111,18128,18133,120,116,59,1,8812,104,101,97,100,4,2,108,114,18143,18154,101,102,116,97,114,114,111,119,59,1,8606,105,103,104,116,97,114,114,111,119,59,1,8608,4,18,65,72,97,98,99,100,102,103,104,108,109,111,112,114,115,116,117,119,18204,18209,18214,18234,18250,18268,18292,18308,18319,18343,18379,18397,18413,18504,18547,18553,18584,18603,114,114,59,1,8657,97,114,59,1,10595,4,2,99,114,18220,18230,117,116,101,5,250,1,59,18228,1,250,114,59,1,8593,114,4,2,99,101,18241,18245,121,59,1,1118,118,101,59,1,365,4,2,105,121,18256,18265,114,99,5,251,1,59,18263,1,251,59,1,1091,4,3,97,98,104,18276,18281,18287,114,114,59,1,8645,108,97,99,59,1,369,97,114,59,1,10606,4,2,105,114,18298,18304,115,104,116,59,1,10622,59,3,55349,56626,114,97,118,101,5,249,1,59,18317,1,249,4,2,97,98,18325,18338,114,4,2,108,114,18332,18335,59,1,8639,59,1,8638,108,107,59,1,9600,4,2,99,116,18349,18374,4,2,111,114,18355,18369,114,110,4,2,59,101,18363,18365,1,8988,114,59,1,8988,111,112,59,1,8975,114,105,59,1,9720,4,2,97,108,18385,18390,99,114,59,1,363,5,168,1,59,18395,1,168,4,2,103,112,18403,18408,111,110,59,1,371,102,59,3,55349,56678,4,6,97,100,104,108,115,117,18427,18434,18445,18470,18475,18494,114,114,111,119,59,1,8593,111,119,110,97,114,114,111,119,59,1,8597,97,114,112,111,111,110,4,2,108,114,18457,18463,101,102,116,59,1,8639,105,103,104,116,59,1,8638,117,115,59,1,8846,105,4,3,59,104,108,18484,18486,18489,1,965,59,1,978,111,110,59,1,965,112,97,114,114,111,119,115,59,1,8648,4,3,99,105,116,18512,18537,18542,4,2,111,114,18518,18532,114,110,4,2,59,101,18526,18528,1,8989,114,59,1,8989,111,112,59,1,8974,110,103,59,1,367,114,105,59,1,9721,99,114,59,3,55349,56522,4,3,100,105,114,18561,18566,18572,111,116,59,1,8944,108,100,101,59,1,361,105,4,2,59,102,18579,18581,1,9653,59,1,9652,4,2,97,109,18590,18595,114,114,59,1,8648,108,5,252,1,59,18601,1,252,97,110,103,108,101,59,1,10663,4,15,65,66,68,97,99,100,101,102,108,110,111,112,114,115,122,18643,18648,18661,18667,18847,18851,18857,18904,18909,18915,18931,18937,18943,18949,18996,114,114,59,1,8661,97,114,4,2,59,118,18656,18658,1,10984,59,1,10985,97,115,104,59,1,8872,4,2,110,114,18673,18679,103,114,116,59,1,10652,4,7,101,107,110,112,114,115,116,18695,18704,18711,18720,18742,18754,18810,112,115,105,108,111,110,59,1,1013,97,112,112,97,59,1,1008,111,116,104,105,110,103,59,1,8709,4,3,104,105,114,18728,18732,18735,105,59,1,981,59,1,982,111,112,116,111,59,1,8733,4,2,59,104,18748,18750,1,8597,111,59,1,1009,4,2,105,117,18760,18766,103,109,97,59,1,962,4,2,98,112,18772,18791,115,101,116,110,101,113,4,2,59,113,18784,18787,3,8842,65024,59,3,10955,65024,115,101,116,110,101,113,4,2,59,113,18803,18806,3,8843,65024,59,3,10956,65024,4,2,104,114,18816,18822,101,116,97,59,1,977,105,97,110,103,108,101,4,2,108,114,18834,18840,101,102,116,59,1,8882,105,103,104,116,59,1,8883,121,59,1,1074,97,115,104,59,1,8866,4,3,101,108,114,18865,18884,18890,4,3,59,98,101,18873,18875,18880,1,8744,97,114,59,1,8891,113,59,1,8794,108,105,112,59,1,8942,4,2,98,116,18896,18901,97,114,59,1,124,59,1,124,114,59,3,55349,56627,116,114,105,59,1,8882,115,117,4,2,98,112,18923,18927,59,3,8834,8402,59,3,8835,8402,112,102,59,3,55349,56679,114,111,112,59,1,8733,116,114,105,59,1,8883,4,2,99,117,18955,18960,114,59,3,55349,56523,4,2,98,112,18966,18981,110,4,2,69,101,18973,18977,59,3,10955,65024,59,3,8842,65024,110,4,2,69,101,18988,18992,59,3,10956,65024,59,3,8843,65024,105,103,122,97,103,59,1,10650,4,7,99,101,102,111,112,114,115,19020,19026,19061,19066,19072,19075,19089,105,114,99,59,1,373,4,2,100,105,19032,19055,4,2,98,103,19038,19043,97,114,59,1,10847,101,4,2,59,113,19050,19052,1,8743,59,1,8793,101,114,112,59,1,8472,114,59,3,55349,56628,112,102,59,3,55349,56680,59,1,8472,4,2,59,101,19081,19083,1,8768,97,116,104,59,1,8768,99,114,59,3,55349,56524,4,14,99,100,102,104,105,108,109,110,111,114,115,117,118,119,19125,19146,19152,19157,19173,19176,19192,19197,19202,19236,19252,19269,19286,19291,4,3,97,105,117,19133,19137,19142,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,116,114,105,59,1,9661,114,59,3,55349,56629,4,2,65,97,19163,19168,114,114,59,1,10234,114,114,59,1,10231,59,1,958,4,2,65,97,19182,19187,114,114,59,1,10232,114,114,59,1,10229,97,112,59,1,10236,105,115,59,1,8955,4,3,100,112,116,19210,19215,19230,111,116,59,1,10752,4,2,102,108,19221,19225,59,3,55349,56681,117,115,59,1,10753,105,109,101,59,1,10754,4,2,65,97,19242,19247,114,114,59,1,10233,114,114,59,1,10230,4,2,99,113,19258,19263,114,59,3,55349,56525,99,117,112,59,1,10758,4,2,112,116,19275,19281,108,117,115,59,1,10756,114,105,59,1,9651,101,101,59,1,8897,101,100,103,101,59,1,8896,4,8,97,99,101,102,105,111,115,117,19316,19335,19349,19357,19362,19367,19373,19379,99,4,2,117,121,19323,19332,116,101,5,253,1,59,19330,1,253,59,1,1103,4,2,105,121,19341,19346,114,99,59,1,375,59,1,1099,110,5,165,1,59,19355,1,165,114,59,3,55349,56630,99,121,59,1,1111,112,102,59,3,55349,56682,99,114,59,3,55349,56526,4,2,99,109,19385,19389,121,59,1,1102,108,5,255,1,59,19395,1,255,4,10,97,99,100,101,102,104,105,111,115,119,19419,19426,19441,19446,19462,19467,19472,19480,19486,19492,99,117,116,101,59,1,378,4,2,97,121,19432,19438,114,111,110,59,1,382,59,1,1079,111,116,59,1,380,4,2,101,116,19452,19458,116,114,102,59,1,8488,97,59,1,950,114,59,3,55349,56631,99,121,59,1,1078,103,114,97,114,114,59,1,8669,112,102,59,3,55349,56683,99,114,59,3,55349,56527,4,2,106,110,19498,19501,59,1,8205,106,59,1,8204]);

const Preprocessor = preprocessor;
const unicode$1 = unicode$3;
const neTree = namedEntityData;
const ERR$1 = errorCodes;

//Aliases
const $$6 = unicode$1.CODE_POINTS;
const $$ = unicode$1.CODE_POINT_SEQUENCES;

//C1 Unicode control character reference replacements
const C1_CONTROLS_REFERENCE_REPLACEMENTS = {
    0x80: 0x20ac,
    0x82: 0x201a,
    0x83: 0x0192,
    0x84: 0x201e,
    0x85: 0x2026,
    0x86: 0x2020,
    0x87: 0x2021,
    0x88: 0x02c6,
    0x89: 0x2030,
    0x8a: 0x0160,
    0x8b: 0x2039,
    0x8c: 0x0152,
    0x8e: 0x017d,
    0x91: 0x2018,
    0x92: 0x2019,
    0x93: 0x201c,
    0x94: 0x201d,
    0x95: 0x2022,
    0x96: 0x2013,
    0x97: 0x2014,
    0x98: 0x02dc,
    0x99: 0x2122,
    0x9a: 0x0161,
    0x9b: 0x203a,
    0x9c: 0x0153,
    0x9e: 0x017e,
    0x9f: 0x0178
};

// Named entity tree flags
const HAS_DATA_FLAG = 1 << 0;
const DATA_DUPLET_FLAG = 1 << 1;
const HAS_BRANCHES_FLAG = 1 << 2;
const MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;

//States
const DATA_STATE = 'DATA_STATE';
const RCDATA_STATE = 'RCDATA_STATE';
const RAWTEXT_STATE = 'RAWTEXT_STATE';
const SCRIPT_DATA_STATE = 'SCRIPT_DATA_STATE';
const PLAINTEXT_STATE = 'PLAINTEXT_STATE';
const TAG_OPEN_STATE = 'TAG_OPEN_STATE';
const END_TAG_OPEN_STATE = 'END_TAG_OPEN_STATE';
const TAG_NAME_STATE = 'TAG_NAME_STATE';
const RCDATA_LESS_THAN_SIGN_STATE = 'RCDATA_LESS_THAN_SIGN_STATE';
const RCDATA_END_TAG_OPEN_STATE = 'RCDATA_END_TAG_OPEN_STATE';
const RCDATA_END_TAG_NAME_STATE = 'RCDATA_END_TAG_NAME_STATE';
const RAWTEXT_LESS_THAN_SIGN_STATE = 'RAWTEXT_LESS_THAN_SIGN_STATE';
const RAWTEXT_END_TAG_OPEN_STATE = 'RAWTEXT_END_TAG_OPEN_STATE';
const RAWTEXT_END_TAG_NAME_STATE = 'RAWTEXT_END_TAG_NAME_STATE';
const SCRIPT_DATA_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE';
const SCRIPT_DATA_END_TAG_OPEN_STATE = 'SCRIPT_DATA_END_TAG_OPEN_STATE';
const SCRIPT_DATA_END_TAG_NAME_STATE = 'SCRIPT_DATA_END_TAG_NAME_STATE';
const SCRIPT_DATA_ESCAPE_START_STATE = 'SCRIPT_DATA_ESCAPE_START_STATE';
const SCRIPT_DATA_ESCAPE_START_DASH_STATE = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE';
const SCRIPT_DATA_ESCAPED_STATE = 'SCRIPT_DATA_ESCAPED_STATE';
const SCRIPT_DATA_ESCAPED_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_STATE';
const SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE';
const SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE';
const SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE';
const SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE';
const BEFORE_ATTRIBUTE_NAME_STATE = 'BEFORE_ATTRIBUTE_NAME_STATE';
const ATTRIBUTE_NAME_STATE = 'ATTRIBUTE_NAME_STATE';
const AFTER_ATTRIBUTE_NAME_STATE = 'AFTER_ATTRIBUTE_NAME_STATE';
const BEFORE_ATTRIBUTE_VALUE_STATE = 'BEFORE_ATTRIBUTE_VALUE_STATE';
const ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE';
const ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE';
const ATTRIBUTE_VALUE_UNQUOTED_STATE = 'ATTRIBUTE_VALUE_UNQUOTED_STATE';
const AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE';
const SELF_CLOSING_START_TAG_STATE = 'SELF_CLOSING_START_TAG_STATE';
const BOGUS_COMMENT_STATE = 'BOGUS_COMMENT_STATE';
const MARKUP_DECLARATION_OPEN_STATE = 'MARKUP_DECLARATION_OPEN_STATE';
const COMMENT_START_STATE = 'COMMENT_START_STATE';
const COMMENT_START_DASH_STATE = 'COMMENT_START_DASH_STATE';
const COMMENT_STATE = 'COMMENT_STATE';
const COMMENT_LESS_THAN_SIGN_STATE = 'COMMENT_LESS_THAN_SIGN_STATE';
const COMMENT_LESS_THAN_SIGN_BANG_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_STATE';
const COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE';
const COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE';
const COMMENT_END_DASH_STATE = 'COMMENT_END_DASH_STATE';
const COMMENT_END_STATE = 'COMMENT_END_STATE';
const COMMENT_END_BANG_STATE = 'COMMENT_END_BANG_STATE';
const DOCTYPE_STATE = 'DOCTYPE_STATE';
const BEFORE_DOCTYPE_NAME_STATE = 'BEFORE_DOCTYPE_NAME_STATE';
const DOCTYPE_NAME_STATE = 'DOCTYPE_NAME_STATE';
const AFTER_DOCTYPE_NAME_STATE = 'AFTER_DOCTYPE_NAME_STATE';
const AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = 'AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE';
const BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
const DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE';
const DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE';
const AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
const BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = 'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE';
const AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = 'AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE';
const BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
const DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE';
const DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE';
const AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
const BOGUS_DOCTYPE_STATE = 'BOGUS_DOCTYPE_STATE';
const CDATA_SECTION_STATE = 'CDATA_SECTION_STATE';
const CDATA_SECTION_BRACKET_STATE = 'CDATA_SECTION_BRACKET_STATE';
const CDATA_SECTION_END_STATE = 'CDATA_SECTION_END_STATE';
const CHARACTER_REFERENCE_STATE = 'CHARACTER_REFERENCE_STATE';
const NAMED_CHARACTER_REFERENCE_STATE = 'NAMED_CHARACTER_REFERENCE_STATE';
const AMBIGUOUS_AMPERSAND_STATE = 'AMBIGUOS_AMPERSAND_STATE';
const NUMERIC_CHARACTER_REFERENCE_STATE = 'NUMERIC_CHARACTER_REFERENCE_STATE';
const HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_START_STATE';
const DECIMAL_CHARACTER_REFERENCE_START_STATE = 'DECIMAL_CHARACTER_REFERENCE_START_STATE';
const HEXADEMICAL_CHARACTER_REFERENCE_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_STATE';
const DECIMAL_CHARACTER_REFERENCE_STATE = 'DECIMAL_CHARACTER_REFERENCE_STATE';
const NUMERIC_CHARACTER_REFERENCE_END_STATE = 'NUMERIC_CHARACTER_REFERENCE_END_STATE';

//Utils

//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
//this functions if they will be situated in another module due to context switch.
//Always perform inlining check before modifying this functions ('node --trace-inlining').
function isWhitespace$1(cp) {
    return cp === $$6.SPACE || cp === $$6.LINE_FEED || cp === $$6.TABULATION || cp === $$6.FORM_FEED;
}

function isAsciiDigit(cp) {
    return cp >= $$6.DIGIT_0 && cp <= $$6.DIGIT_9;
}

function isAsciiUpper(cp) {
    return cp >= $$6.LATIN_CAPITAL_A && cp <= $$6.LATIN_CAPITAL_Z;
}

function isAsciiLower(cp) {
    return cp >= $$6.LATIN_SMALL_A && cp <= $$6.LATIN_SMALL_Z;
}

function isAsciiLetter(cp) {
    return isAsciiLower(cp) || isAsciiUpper(cp);
}

function isAsciiAlphaNumeric(cp) {
    return isAsciiLetter(cp) || isAsciiDigit(cp);
}

function isAsciiUpperHexDigit(cp) {
    return cp >= $$6.LATIN_CAPITAL_A && cp <= $$6.LATIN_CAPITAL_F;
}

function isAsciiLowerHexDigit(cp) {
    return cp >= $$6.LATIN_SMALL_A && cp <= $$6.LATIN_SMALL_F;
}

function isAsciiHexDigit(cp) {
    return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
}

function toAsciiLowerCodePoint(cp) {
    return cp + 0x0020;
}

//NOTE: String.fromCharCode() function can handle only characters from BMP subset.
//So, we need to workaround this manually.
//(see: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode#Getting_it_to_work_with_higher_values)
function toChar(cp) {
    if (cp <= 0xffff) {
        return String.fromCharCode(cp);
    }

    cp -= 0x10000;
    return String.fromCharCode(((cp >>> 10) & 0x3ff) | 0xd800) + String.fromCharCode(0xdc00 | (cp & 0x3ff));
}

function toAsciiLowerChar(cp) {
    return String.fromCharCode(toAsciiLowerCodePoint(cp));
}

function findNamedEntityTreeBranch(nodeIx, cp) {
    const branchCount = neTree[++nodeIx];
    let lo = ++nodeIx;
    let hi = lo + branchCount - 1;

    while (lo <= hi) {
        const mid = (lo + hi) >>> 1;
        const midCp = neTree[mid];

        if (midCp < cp) {
            lo = mid + 1;
        } else if (midCp > cp) {
            hi = mid - 1;
        } else {
            return neTree[mid + branchCount];
        }
    }

    return -1;
}

//Tokenizer
class Tokenizer$4 {
    constructor() {
        this.preprocessor = new Preprocessor();

        this.tokenQueue = [];

        this.allowCDATA = false;

        this.state = DATA_STATE;
        this.returnState = '';

        this.charRefCode = -1;
        this.tempBuff = [];
        this.lastStartTagName = '';

        this.consumedAfterSnapshot = -1;
        this.active = false;

        this.currentCharacterToken = null;
        this.currentToken = null;
        this.currentAttr = null;
    }

    //Errors
    _err() {
        // NOTE: err reporting is noop by default. Enabled by mixin.
    }

    _errOnNextCodePoint(err) {
        this._consume();
        this._err(err);
        this._unconsume();
    }

    //API
    getNextToken() {
        while (!this.tokenQueue.length && this.active) {
            this.consumedAfterSnapshot = 0;

            const cp = this._consume();

            if (!this._ensureHibernation()) {
                this[this.state](cp);
            }
        }

        return this.tokenQueue.shift();
    }

    write(chunk, isLastChunk) {
        this.active = true;
        this.preprocessor.write(chunk, isLastChunk);
    }

    insertHtmlAtCurrentPos(chunk) {
        this.active = true;
        this.preprocessor.insertHtmlAtCurrentPos(chunk);
    }

    //Hibernation
    _ensureHibernation() {
        if (this.preprocessor.endOfChunkHit) {
            for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
                this.preprocessor.retreat();
            }

            this.active = false;
            this.tokenQueue.push({ type: Tokenizer$4.HIBERNATION_TOKEN });

            return true;
        }

        return false;
    }

    //Consumption
    _consume() {
        this.consumedAfterSnapshot++;
        return this.preprocessor.advance();
    }

    _unconsume() {
        this.consumedAfterSnapshot--;
        this.preprocessor.retreat();
    }

    _reconsumeInState(state) {
        this.state = state;
        this._unconsume();
    }

    _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
        let consumedCount = 0;
        let isMatch = true;
        const patternLength = pattern.length;
        let patternPos = 0;
        let cp = startCp;
        let patternCp = void 0;

        for (; patternPos < patternLength; patternPos++) {
            if (patternPos > 0) {
                cp = this._consume();
                consumedCount++;
            }

            if (cp === $$6.EOF) {
                isMatch = false;
                break;
            }

            patternCp = pattern[patternPos];

            if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
                isMatch = false;
                break;
            }
        }

        if (!isMatch) {
            while (consumedCount--) {
                this._unconsume();
            }
        }

        return isMatch;
    }

    //Temp buffer
    _isTempBufferEqualToScriptString() {
        if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
            return false;
        }

        for (let i = 0; i < this.tempBuff.length; i++) {
            if (this.tempBuff[i] !== $$.SCRIPT_STRING[i]) {
                return false;
            }
        }

        return true;
    }

    //Token creation
    _createStartTagToken() {
        this.currentToken = {
            type: Tokenizer$4.START_TAG_TOKEN,
            tagName: '',
            selfClosing: false,
            ackSelfClosing: false,
            attrs: []
        };
    }

    _createEndTagToken() {
        this.currentToken = {
            type: Tokenizer$4.END_TAG_TOKEN,
            tagName: '',
            selfClosing: false,
            attrs: []
        };
    }

    _createCommentToken() {
        this.currentToken = {
            type: Tokenizer$4.COMMENT_TOKEN,
            data: ''
        };
    }

    _createDoctypeToken(initialName) {
        this.currentToken = {
            type: Tokenizer$4.DOCTYPE_TOKEN,
            name: initialName,
            forceQuirks: false,
            publicId: null,
            systemId: null
        };
    }

    _createCharacterToken(type, ch) {
        this.currentCharacterToken = {
            type: type,
            chars: ch
        };
    }

    _createEOFToken() {
        this.currentToken = { type: Tokenizer$4.EOF_TOKEN };
    }

    //Tag attributes
    _createAttr(attrNameFirstCh) {
        this.currentAttr = {
            name: attrNameFirstCh,
            value: ''
        };
    }

    _leaveAttrName(toState) {
        if (Tokenizer$4.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
            this.currentToken.attrs.push(this.currentAttr);
        } else {
            this._err(ERR$1.duplicateAttribute);
        }

        this.state = toState;
    }

    _leaveAttrValue(toState) {
        this.state = toState;
    }

    //Token emission
    _emitCurrentToken() {
        this._emitCurrentCharacterToken();

        const ct = this.currentToken;

        this.currentToken = null;

        //NOTE: store emited start tag's tagName to determine is the following end tag token is appropriate.
        if (ct.type === Tokenizer$4.START_TAG_TOKEN) {
            this.lastStartTagName = ct.tagName;
        } else if (ct.type === Tokenizer$4.END_TAG_TOKEN) {
            if (ct.attrs.length > 0) {
                this._err(ERR$1.endTagWithAttributes);
            }

            if (ct.selfClosing) {
                this._err(ERR$1.endTagWithTrailingSolidus);
            }
        }

        this.tokenQueue.push(ct);
    }

    _emitCurrentCharacterToken() {
        if (this.currentCharacterToken) {
            this.tokenQueue.push(this.currentCharacterToken);
            this.currentCharacterToken = null;
        }
    }

    _emitEOFToken() {
        this._createEOFToken();
        this._emitCurrentToken();
    }

    //Characters emission

    //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
    //If we have a sequence of characters that belong to the same group, parser can process it
    //as a single solid character token.
    //So, there are 3 types of character tokens in parse5:
    //1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
    //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
    //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
    _appendCharToCurrentCharacterToken(type, ch) {
        if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {
            this._emitCurrentCharacterToken();
        }

        if (this.currentCharacterToken) {
            this.currentCharacterToken.chars += ch;
        } else {
            this._createCharacterToken(type, ch);
        }
    }

    _emitCodePoint(cp) {
        let type = Tokenizer$4.CHARACTER_TOKEN;

        if (isWhitespace$1(cp)) {
            type = Tokenizer$4.WHITESPACE_CHARACTER_TOKEN;
        } else if (cp === $$6.NULL) {
            type = Tokenizer$4.NULL_CHARACTER_TOKEN;
        }

        this._appendCharToCurrentCharacterToken(type, toChar(cp));
    }

    _emitSeveralCodePoints(codePoints) {
        for (let i = 0; i < codePoints.length; i++) {
            this._emitCodePoint(codePoints[i]);
        }
    }

    //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
    //So we can avoid additional checks here.
    _emitChars(ch) {
        this._appendCharToCurrentCharacterToken(Tokenizer$4.CHARACTER_TOKEN, ch);
    }

    // Character reference helpers
    _matchNamedCharacterReference(startCp) {
        let result = null;
        let excess = 1;
        let i = findNamedEntityTreeBranch(0, startCp);

        this.tempBuff.push(startCp);

        while (i > -1) {
            const current = neTree[i];
            const inNode = current < MAX_BRANCH_MARKER_VALUE;
            const nodeWithData = inNode && current & HAS_DATA_FLAG;

            if (nodeWithData) {
                //NOTE: we use greedy search, so we continue lookup at this point
                result = current & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];
                excess = 0;
            }

            const cp = this._consume();

            this.tempBuff.push(cp);
            excess++;

            if (cp === $$6.EOF) {
                break;
            }

            if (inNode) {
                i = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;
            } else {
                i = cp === current ? ++i : -1;
            }
        }

        while (excess--) {
            this.tempBuff.pop();
            this._unconsume();
        }

        return result;
    }

    _isCharacterReferenceInAttribute() {
        return (
            this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE ||
            this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE ||
            this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE
        );
    }

    _isCharacterReferenceAttributeQuirk(withSemicolon) {
        if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
            const nextCp = this._consume();

            this._unconsume();

            return nextCp === $$6.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
        }

        return false;
    }

    _flushCodePointsConsumedAsCharacterReference() {
        if (this._isCharacterReferenceInAttribute()) {
            for (let i = 0; i < this.tempBuff.length; i++) {
                this.currentAttr.value += toChar(this.tempBuff[i]);
            }
        } else {
            this._emitSeveralCodePoints(this.tempBuff);
        }

        this.tempBuff = [];
    }

    // State machine

    // Data state
    //------------------------------------------------------------------
    [DATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();

        if (cp === $$6.LESS_THAN_SIGN) {
            this.state = TAG_OPEN_STATE;
        } else if (cp === $$6.AMPERSAND) {
            this.returnState = DATA_STATE;
            this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitCodePoint(cp);
        } else if (cp === $$6.EOF) {
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    //  RCDATA state
    //------------------------------------------------------------------
    [RCDATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();

        if (cp === $$6.AMPERSAND) {
            this.returnState = RCDATA_STATE;
            this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = RCDATA_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // RAWTEXT state
    //------------------------------------------------------------------
    [RAWTEXT_STATE](cp) {
        this.preprocessor.dropParsedChunk();

        if (cp === $$6.LESS_THAN_SIGN) {
            this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // Script data state
    //------------------------------------------------------------------
    [SCRIPT_DATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();

        if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // PLAINTEXT state
    //------------------------------------------------------------------
    [PLAINTEXT_STATE](cp) {
        this.preprocessor.dropParsedChunk();

        if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // Tag open state
    //------------------------------------------------------------------
    [TAG_OPEN_STATE](cp) {
        if (cp === $$6.EXCLAMATION_MARK) {
            this.state = MARKUP_DECLARATION_OPEN_STATE;
        } else if (cp === $$6.SOLIDUS) {
            this.state = END_TAG_OPEN_STATE;
        } else if (isAsciiLetter(cp)) {
            this._createStartTagToken();
            this._reconsumeInState(TAG_NAME_STATE);
        } else if (cp === $$6.QUESTION_MARK) {
            this._err(ERR$1.unexpectedQuestionMarkInsteadOfTagName);
            this._createCommentToken();
            this._reconsumeInState(BOGUS_COMMENT_STATE);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofBeforeTagName);
            this._emitChars('<');
            this._emitEOFToken();
        } else {
            this._err(ERR$1.invalidFirstCharacterOfTagName);
            this._emitChars('<');
            this._reconsumeInState(DATA_STATE);
        }
    }

    // End tag open state
    //------------------------------------------------------------------
    [END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this._reconsumeInState(TAG_NAME_STATE);
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingEndTagName);
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofBeforeTagName);
            this._emitChars('</');
            this._emitEOFToken();
        } else {
            this._err(ERR$1.invalidFirstCharacterOfTagName);
            this._createCommentToken();
            this._reconsumeInState(BOGUS_COMMENT_STATE);
        }
    }

    // Tag name state
    //------------------------------------------------------------------
    [TAG_NAME_STATE](cp) {
        if (isWhitespace$1(cp)) {
            this.state = BEFORE_ATTRIBUTE_NAME_STATE;
        } else if (cp === $$6.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (isAsciiUpper(cp)) {
            this.currentToken.tagName += toAsciiLowerChar(cp);
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.tagName += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this.currentToken.tagName += toChar(cp);
        }
    }

    // RCDATA less-than sign state
    //------------------------------------------------------------------
    [RCDATA_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.SOLIDUS) {
            this.tempBuff = [];
            this.state = RCDATA_END_TAG_OPEN_STATE;
        } else {
            this._emitChars('<');
            this._reconsumeInState(RCDATA_STATE);
        }
    }

    // RCDATA end tag open state
    //------------------------------------------------------------------
    [RCDATA_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
        } else {
            this._emitChars('</');
            this._reconsumeInState(RCDATA_STATE);
        }
    }

    // RCDATA end tag name state
    //------------------------------------------------------------------
    [RCDATA_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
            this.currentToken.tagName += toAsciiLowerChar(cp);
            this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
            this.currentToken.tagName += toChar(cp);
            this.tempBuff.push(cp);
        } else {
            if (this.lastStartTagName === this.currentToken.tagName) {
                if (isWhitespace$1(cp)) {
                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                    return;
                }

                if (cp === $$6.SOLIDUS) {
                    this.state = SELF_CLOSING_START_TAG_STATE;
                    return;
                }

                if (cp === $$6.GREATER_THAN_SIGN) {
                    this.state = DATA_STATE;
                    this._emitCurrentToken();
                    return;
                }
            }

            this._emitChars('</');
            this._emitSeveralCodePoints(this.tempBuff);
            this._reconsumeInState(RCDATA_STATE);
        }
    }

    // RAWTEXT less-than sign state
    //------------------------------------------------------------------
    [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.SOLIDUS) {
            this.tempBuff = [];
            this.state = RAWTEXT_END_TAG_OPEN_STATE;
        } else {
            this._emitChars('<');
            this._reconsumeInState(RAWTEXT_STATE);
        }
    }

    // RAWTEXT end tag open state
    //------------------------------------------------------------------
    [RAWTEXT_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
        } else {
            this._emitChars('</');
            this._reconsumeInState(RAWTEXT_STATE);
        }
    }

    // RAWTEXT end tag name state
    //------------------------------------------------------------------
    [RAWTEXT_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
            this.currentToken.tagName += toAsciiLowerChar(cp);
            this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
            this.currentToken.tagName += toChar(cp);
            this.tempBuff.push(cp);
        } else {
            if (this.lastStartTagName === this.currentToken.tagName) {
                if (isWhitespace$1(cp)) {
                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                    return;
                }

                if (cp === $$6.SOLIDUS) {
                    this.state = SELF_CLOSING_START_TAG_STATE;
                    return;
                }

                if (cp === $$6.GREATER_THAN_SIGN) {
                    this._emitCurrentToken();
                    this.state = DATA_STATE;
                    return;
                }
            }

            this._emitChars('</');
            this._emitSeveralCodePoints(this.tempBuff);
            this._reconsumeInState(RAWTEXT_STATE);
        }
    }

    // Script data less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.SOLIDUS) {
            this.tempBuff = [];
            this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
        } else if (cp === $$6.EXCLAMATION_MARK) {
            this.state = SCRIPT_DATA_ESCAPE_START_STATE;
            this._emitChars('<!');
        } else {
            this._emitChars('<');
            this._reconsumeInState(SCRIPT_DATA_STATE);
        }
    }

    // Script data end tag open state
    //------------------------------------------------------------------
    [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
        } else {
            this._emitChars('</');
            this._reconsumeInState(SCRIPT_DATA_STATE);
        }
    }

    // Script data end tag name state
    //------------------------------------------------------------------
    [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
            this.currentToken.tagName += toAsciiLowerChar(cp);
            this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
            this.currentToken.tagName += toChar(cp);
            this.tempBuff.push(cp);
        } else {
            if (this.lastStartTagName === this.currentToken.tagName) {
                if (isWhitespace$1(cp)) {
                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                    return;
                } else if (cp === $$6.SOLIDUS) {
                    this.state = SELF_CLOSING_START_TAG_STATE;
                    return;
                } else if (cp === $$6.GREATER_THAN_SIGN) {
                    this._emitCurrentToken();
                    this.state = DATA_STATE;
                    return;
                }
            }

            this._emitChars('</');
            this._emitSeveralCodePoints(this.tempBuff);
            this._reconsumeInState(SCRIPT_DATA_STATE);
        }
    }

    // Script data escape start state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPE_START_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
            this._emitChars('-');
        } else {
            this._reconsumeInState(SCRIPT_DATA_STATE);
        }
    }

    // Script data escape start dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
            this._emitChars('-');
        } else {
            this._reconsumeInState(SCRIPT_DATA_STATE);
        }
    }

    // Script data escaped state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // Script data escaped dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.state = SCRIPT_DATA_ESCAPED_STATE;
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this.state = SCRIPT_DATA_ESCAPED_STATE;
            this._emitCodePoint(cp);
        }
    }

    // Script data escaped dash dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = SCRIPT_DATA_STATE;
            this._emitChars('>');
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.state = SCRIPT_DATA_ESCAPED_STATE;
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this.state = SCRIPT_DATA_ESCAPED_STATE;
            this._emitCodePoint(cp);
        }
    }

    // Script data escaped less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.SOLIDUS) {
            this.tempBuff = [];
            this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
        } else if (isAsciiLetter(cp)) {
            this.tempBuff = [];
            this._emitChars('<');
            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
        } else {
            this._emitChars('<');
            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
    }

    // Script data escaped end tag open state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
        } else {
            this._emitChars('</');
            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
    }

    // Script data escaped end tag name state
    //------------------------------------------------------------------
    [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
            this.currentToken.tagName += toAsciiLowerChar(cp);
            this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
            this.currentToken.tagName += toChar(cp);
            this.tempBuff.push(cp);
        } else {
            if (this.lastStartTagName === this.currentToken.tagName) {
                if (isWhitespace$1(cp)) {
                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
                    return;
                }

                if (cp === $$6.SOLIDUS) {
                    this.state = SELF_CLOSING_START_TAG_STATE;
                    return;
                }

                if (cp === $$6.GREATER_THAN_SIGN) {
                    this._emitCurrentToken();
                    this.state = DATA_STATE;
                    return;
                }
            }

            this._emitChars('</');
            this._emitSeveralCodePoints(this.tempBuff);
            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
    }

    // Script data double escape start state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
        if (isWhitespace$1(cp) || cp === $$6.SOLIDUS || cp === $$6.GREATER_THAN_SIGN) {
            this.state = this._isTempBufferEqualToScriptString()
                ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE
                : SCRIPT_DATA_ESCAPED_STATE;
            this._emitCodePoint(cp);
        } else if (isAsciiUpper(cp)) {
            this.tempBuff.push(toAsciiLowerCodePoint(cp));
            this._emitCodePoint(cp);
        } else if (isAsciiLower(cp)) {
            this.tempBuff.push(cp);
            this._emitCodePoint(cp);
        } else {
            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
    }

    // Script data double escaped state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
            this._emitChars('<');
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // Script data double escaped dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
            this._emitChars('<');
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
            this._emitCodePoint(cp);
        }
    }

    // Script data double escaped dash dash state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this._emitChars('-');
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
            this._emitChars('<');
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = SCRIPT_DATA_STATE;
            this._emitChars('>');
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
            this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInScriptHtmlCommentLikeText);
            this._emitEOFToken();
        } else {
            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
            this._emitCodePoint(cp);
        }
    }

    // Script data double escaped less-than sign state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.SOLIDUS) {
            this.tempBuff = [];
            this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
            this._emitChars('/');
        } else {
            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
        }
    }

    // Script data double escape end state
    //------------------------------------------------------------------
    [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
        if (isWhitespace$1(cp) || cp === $$6.SOLIDUS || cp === $$6.GREATER_THAN_SIGN) {
            this.state = this._isTempBufferEqualToScriptString()
                ? SCRIPT_DATA_ESCAPED_STATE
                : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;

            this._emitCodePoint(cp);
        } else if (isAsciiUpper(cp)) {
            this.tempBuff.push(toAsciiLowerCodePoint(cp));
            this._emitCodePoint(cp);
        } else if (isAsciiLower(cp)) {
            this.tempBuff.push(cp);
            this._emitCodePoint(cp);
        } else {
            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
        }
    }

    // Before attribute name state
    //------------------------------------------------------------------
    [BEFORE_ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace$1(cp)) {
            return;
        }

        if (cp === $$6.SOLIDUS || cp === $$6.GREATER_THAN_SIGN || cp === $$6.EOF) {
            this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
        } else if (cp === $$6.EQUALS_SIGN) {
            this._err(ERR$1.unexpectedEqualsSignBeforeAttributeName);
            this._createAttr('=');
            this.state = ATTRIBUTE_NAME_STATE;
        } else {
            this._createAttr('');
            this._reconsumeInState(ATTRIBUTE_NAME_STATE);
        }
    }

    // Attribute name state
    //------------------------------------------------------------------
    [ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace$1(cp) || cp === $$6.SOLIDUS || cp === $$6.GREATER_THAN_SIGN || cp === $$6.EOF) {
            this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
            this._unconsume();
        } else if (cp === $$6.EQUALS_SIGN) {
            this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
        } else if (isAsciiUpper(cp)) {
            this.currentAttr.name += toAsciiLowerChar(cp);
        } else if (cp === $$6.QUOTATION_MARK || cp === $$6.APOSTROPHE || cp === $$6.LESS_THAN_SIGN) {
            this._err(ERR$1.unexpectedCharacterInAttributeName);
            this.currentAttr.name += toChar(cp);
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentAttr.name += unicode$1.REPLACEMENT_CHARACTER;
        } else {
            this.currentAttr.name += toChar(cp);
        }
    }

    // After attribute name state
    //------------------------------------------------------------------
    [AFTER_ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace$1(cp)) {
            return;
        }

        if (cp === $$6.SOLIDUS) {
            this.state = SELF_CLOSING_START_TAG_STATE;
        } else if (cp === $$6.EQUALS_SIGN) {
            this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this._createAttr('');
            this._reconsumeInState(ATTRIBUTE_NAME_STATE);
        }
    }

    // Before attribute value state
    //------------------------------------------------------------------
    [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
        if (isWhitespace$1(cp)) {
            return;
        }

        if (cp === $$6.QUOTATION_MARK) {
            this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingAttributeValue);
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else {
            this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
        }
    }

    // Attribute value (double-quoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $$6.QUOTATION_MARK) {
            this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
        } else if (cp === $$6.AMPERSAND) {
            this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
            this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this.currentAttr.value += toChar(cp);
        }
    }

    // Attribute value (single-quoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
        if (cp === $$6.APOSTROPHE) {
            this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
        } else if (cp === $$6.AMPERSAND) {
            this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
            this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this.currentAttr.value += toChar(cp);
        }
    }

    // Attribute value (unquoted) state
    //------------------------------------------------------------------
    [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
        if (isWhitespace$1(cp)) {
            this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
        } else if (cp === $$6.AMPERSAND) {
            this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
            this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._leaveAttrValue(DATA_STATE);
            this._emitCurrentToken();
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
        } else if (
            cp === $$6.QUOTATION_MARK ||
            cp === $$6.APOSTROPHE ||
            cp === $$6.LESS_THAN_SIGN ||
            cp === $$6.EQUALS_SIGN ||
            cp === $$6.GRAVE_ACCENT
        ) {
            this._err(ERR$1.unexpectedCharacterInUnquotedAttributeValue);
            this.currentAttr.value += toChar(cp);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this.currentAttr.value += toChar(cp);
        }
    }

    // After attribute value (quoted) state
    //------------------------------------------------------------------
    [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
        if (isWhitespace$1(cp)) {
            this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
        } else if (cp === $$6.SOLIDUS) {
            this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._leaveAttrValue(DATA_STATE);
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingWhitespaceBetweenAttributes);
            this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
        }
    }

    // Self-closing start tag state
    //------------------------------------------------------------------
    [SELF_CLOSING_START_TAG_STATE](cp) {
        if (cp === $$6.GREATER_THAN_SIGN) {
            this.currentToken.selfClosing = true;
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInTag);
            this._emitEOFToken();
        } else {
            this._err(ERR$1.unexpectedSolidusInTag);
            this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
        }
    }

    // Bogus comment state
    //------------------------------------------------------------------
    [BOGUS_COMMENT_STATE](cp) {
        if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._emitCurrentToken();
            this._emitEOFToken();
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
        } else {
            this.currentToken.data += toChar(cp);
        }
    }

    // Markup declaration open state
    //------------------------------------------------------------------
    [MARKUP_DECLARATION_OPEN_STATE](cp) {
        if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
            this._createCommentToken();
            this.state = COMMENT_START_STATE;
        } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
            this.state = DOCTYPE_STATE;
        } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
            if (this.allowCDATA) {
                this.state = CDATA_SECTION_STATE;
            } else {
                this._err(ERR$1.cdataInHtmlContent);
                this._createCommentToken();
                this.currentToken.data = '[CDATA[';
                this.state = BOGUS_COMMENT_STATE;
            }
        }

        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
        //results are no longer valid and we will need to start over.
        else if (!this._ensureHibernation()) {
            this._err(ERR$1.incorrectlyOpenedComment);
            this._createCommentToken();
            this._reconsumeInState(BOGUS_COMMENT_STATE);
        }
    }

    // Comment start state
    //------------------------------------------------------------------
    [COMMENT_START_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_START_DASH_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptClosingOfEmptyComment);
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else {
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment start dash state
    //------------------------------------------------------------------
    [COMMENT_START_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_END_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptClosingOfEmptyComment);
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInComment);
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.data += '-';
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment state
    //------------------------------------------------------------------
    [COMMENT_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_END_DASH_STATE;
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.currentToken.data += '<';
            this.state = COMMENT_LESS_THAN_SIGN_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInComment);
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.data += toChar(cp);
        }
    }

    // Comment less-than sign state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$6.EXCLAMATION_MARK) {
            this.currentToken.data += '!';
            this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
        } else if (cp === $$6.LESS_THAN_SIGN) {
            this.currentToken.data += '!';
        } else {
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment less-than sign bang state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
        } else {
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment less-than sign bang dash state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
        } else {
            this._reconsumeInState(COMMENT_END_DASH_STATE);
        }
    }

    // Comment less-than sign bang dash dash state
    //------------------------------------------------------------------
    [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
        if (cp !== $$6.GREATER_THAN_SIGN && cp !== $$6.EOF) {
            this._err(ERR$1.nestedComment);
        }

        this._reconsumeInState(COMMENT_END_STATE);
    }

    // Comment end dash state
    //------------------------------------------------------------------
    [COMMENT_END_DASH_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.state = COMMENT_END_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInComment);
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.data += '-';
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment end state
    //------------------------------------------------------------------
    [COMMENT_END_STATE](cp) {
        if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EXCLAMATION_MARK) {
            this.state = COMMENT_END_BANG_STATE;
        } else if (cp === $$6.HYPHEN_MINUS) {
            this.currentToken.data += '-';
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInComment);
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.data += '--';
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // Comment end bang state
    //------------------------------------------------------------------
    [COMMENT_END_BANG_STATE](cp) {
        if (cp === $$6.HYPHEN_MINUS) {
            this.currentToken.data += '--!';
            this.state = COMMENT_END_DASH_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.incorrectlyClosedComment);
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInComment);
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.data += '--!';
            this._reconsumeInState(COMMENT_STATE);
        }
    }

    // DOCTYPE state
    //------------------------------------------------------------------
    [DOCTYPE_STATE](cp) {
        if (isWhitespace$1(cp)) {
            this.state = BEFORE_DOCTYPE_NAME_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this._createDoctypeToken(null);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingWhitespaceBeforeDoctypeName);
            this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
        }
    }

    // Before DOCTYPE name state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace$1(cp)) {
            return;
        }

        if (isAsciiUpper(cp)) {
            this._createDoctypeToken(toAsciiLowerChar(cp));
            this.state = DOCTYPE_NAME_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this._createDoctypeToken(unicode$1.REPLACEMENT_CHARACTER);
            this.state = DOCTYPE_NAME_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingDoctypeName);
            this._createDoctypeToken(null);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this._createDoctypeToken(null);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._createDoctypeToken(toChar(cp));
            this.state = DOCTYPE_NAME_STATE;
        }
    }

    // DOCTYPE name state
    //------------------------------------------------------------------
    [DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace$1(cp)) {
            this.state = AFTER_DOCTYPE_NAME_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (isAsciiUpper(cp)) {
            this.currentToken.name += toAsciiLowerChar(cp);
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.name += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.name += toChar(cp);
        }
    }

    // After DOCTYPE name state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace$1(cp)) {
            return;
        }

        if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
            this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
        } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
            this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
        }
        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
        //results are no longer valid and we will need to start over.
        else if (!this._ensureHibernation()) {
            this._err(ERR$1.invalidCharacterSequenceAfterDoctypeName);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // After DOCTYPE public keyword state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
        if (isWhitespace$1(cp)) {
            this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $$6.QUOTATION_MARK) {
            this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
            this.currentToken.publicId = '';
            this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
            this.currentToken.publicId = '';
            this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // Before DOCTYPE public identifier state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
        if (isWhitespace$1(cp)) {
            return;
        }

        if (cp === $$6.QUOTATION_MARK) {
            this.currentToken.publicId = '';
            this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this.currentToken.publicId = '';
            this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // DOCTYPE public identifier (double-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $$6.QUOTATION_MARK) {
            this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.publicId += toChar(cp);
        }
    }

    // DOCTYPE public identifier (single-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
        if (cp === $$6.APOSTROPHE) {
            this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptDoctypePublicIdentifier);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.publicId += toChar(cp);
        }
    }

    // After DOCTYPE public identifier state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
        if (isWhitespace$1(cp)) {
            this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.QUOTATION_MARK) {
            this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // Between DOCTYPE public and system identifiers state
    //------------------------------------------------------------------
    [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
        if (isWhitespace$1(cp)) {
            return;
        }

        if (cp === $$6.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.QUOTATION_MARK) {
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // After DOCTYPE system keyword state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
        if (isWhitespace$1(cp)) {
            this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $$6.QUOTATION_MARK) {
            this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // Before DOCTYPE system identifier state
    //------------------------------------------------------------------
    [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
        if (isWhitespace$1(cp)) {
            return;
        }

        if (cp === $$6.QUOTATION_MARK) {
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$6.APOSTROPHE) {
            this.currentToken.systemId = '';
            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.missingDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this.state = DATA_STATE;
            this._emitCurrentToken();
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // DOCTYPE system identifier (double-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $$6.QUOTATION_MARK) {
            this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.systemId += toChar(cp);
        }
    }

    // DOCTYPE system identifier (single-quoted) state
    //------------------------------------------------------------------
    [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
        if (cp === $$6.APOSTROPHE) {
            this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
            this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$6.GREATER_THAN_SIGN) {
            this._err(ERR$1.abruptDoctypeSystemIdentifier);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this.currentToken.systemId += toChar(cp);
        }
    }

    // After DOCTYPE system identifier state
    //------------------------------------------------------------------
    [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
        if (isWhitespace$1(cp)) {
            return;
        }

        if (cp === $$6.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInDoctype);
            this.currentToken.forceQuirks = true;
            this._emitCurrentToken();
            this._emitEOFToken();
        } else {
            this._err(ERR$1.unexpectedCharacterAfterDoctypeSystemIdentifier);
            this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
    }

    // Bogus DOCTYPE state
    //------------------------------------------------------------------
    [BOGUS_DOCTYPE_STATE](cp) {
        if (cp === $$6.GREATER_THAN_SIGN) {
            this._emitCurrentToken();
            this.state = DATA_STATE;
        } else if (cp === $$6.NULL) {
            this._err(ERR$1.unexpectedNullCharacter);
        } else if (cp === $$6.EOF) {
            this._emitCurrentToken();
            this._emitEOFToken();
        }
    }

    // CDATA section state
    //------------------------------------------------------------------
    [CDATA_SECTION_STATE](cp) {
        if (cp === $$6.RIGHT_SQUARE_BRACKET) {
            this.state = CDATA_SECTION_BRACKET_STATE;
        } else if (cp === $$6.EOF) {
            this._err(ERR$1.eofInCdata);
            this._emitEOFToken();
        } else {
            this._emitCodePoint(cp);
        }
    }

    // CDATA section bracket state
    //------------------------------------------------------------------
    [CDATA_SECTION_BRACKET_STATE](cp) {
        if (cp === $$6.RIGHT_SQUARE_BRACKET) {
            this.state = CDATA_SECTION_END_STATE;
        } else {
            this._emitChars(']');
            this._reconsumeInState(CDATA_SECTION_STATE);
        }
    }

    // CDATA section end state
    //------------------------------------------------------------------
    [CDATA_SECTION_END_STATE](cp) {
        if (cp === $$6.GREATER_THAN_SIGN) {
            this.state = DATA_STATE;
        } else if (cp === $$6.RIGHT_SQUARE_BRACKET) {
            this._emitChars(']');
        } else {
            this._emitChars(']]');
            this._reconsumeInState(CDATA_SECTION_STATE);
        }
    }

    // Character reference state
    //------------------------------------------------------------------
    [CHARACTER_REFERENCE_STATE](cp) {
        this.tempBuff = [$$6.AMPERSAND];

        if (cp === $$6.NUMBER_SIGN) {
            this.tempBuff.push(cp);
            this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
        } else if (isAsciiAlphaNumeric(cp)) {
            this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
        } else {
            this._flushCodePointsConsumedAsCharacterReference();
            this._reconsumeInState(this.returnState);
        }
    }

    // Named character reference state
    //------------------------------------------------------------------
    [NAMED_CHARACTER_REFERENCE_STATE](cp) {
        const matchResult = this._matchNamedCharacterReference(cp);

        //NOTE: matching can be abrupted by hibernation. In that case match
        //results are no longer valid and we will need to start over.
        if (this._ensureHibernation()) {
            this.tempBuff = [$$6.AMPERSAND];
        } else if (matchResult) {
            const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $$6.SEMICOLON;

            if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
                if (!withSemicolon) {
                    this._errOnNextCodePoint(ERR$1.missingSemicolonAfterCharacterReference);
                }

                this.tempBuff = matchResult;
            }

            this._flushCodePointsConsumedAsCharacterReference();
            this.state = this.returnState;
        } else {
            this._flushCodePointsConsumedAsCharacterReference();
            this.state = AMBIGUOUS_AMPERSAND_STATE;
        }
    }

    // Ambiguos ampersand state
    //------------------------------------------------------------------
    [AMBIGUOUS_AMPERSAND_STATE](cp) {
        if (isAsciiAlphaNumeric(cp)) {
            if (this._isCharacterReferenceInAttribute()) {
                this.currentAttr.value += toChar(cp);
            } else {
                this._emitCodePoint(cp);
            }
        } else {
            if (cp === $$6.SEMICOLON) {
                this._err(ERR$1.unknownNamedCharacterReference);
            }

            this._reconsumeInState(this.returnState);
        }
    }

    // Numeric character reference state
    //------------------------------------------------------------------
    [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
        this.charRefCode = 0;

        if (cp === $$6.LATIN_SMALL_X || cp === $$6.LATIN_CAPITAL_X) {
            this.tempBuff.push(cp);
            this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
        } else {
            this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
        }
    }

    // Hexademical character reference start state
    //------------------------------------------------------------------
    [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
        if (isAsciiHexDigit(cp)) {
            this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
        } else {
            this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
            this._flushCodePointsConsumedAsCharacterReference();
            this._reconsumeInState(this.returnState);
        }
    }

    // Decimal character reference start state
    //------------------------------------------------------------------
    [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
        if (isAsciiDigit(cp)) {
            this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
        } else {
            this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
            this._flushCodePointsConsumedAsCharacterReference();
            this._reconsumeInState(this.returnState);
        }
    }

    // Hexademical character reference state
    //------------------------------------------------------------------
    [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
        if (isAsciiUpperHexDigit(cp)) {
            this.charRefCode = this.charRefCode * 16 + cp - 0x37;
        } else if (isAsciiLowerHexDigit(cp)) {
            this.charRefCode = this.charRefCode * 16 + cp - 0x57;
        } else if (isAsciiDigit(cp)) {
            this.charRefCode = this.charRefCode * 16 + cp - 0x30;
        } else if (cp === $$6.SEMICOLON) {
            this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
        } else {
            this._err(ERR$1.missingSemicolonAfterCharacterReference);
            this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
        }
    }

    // Decimal character reference state
    //------------------------------------------------------------------
    [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
        if (isAsciiDigit(cp)) {
            this.charRefCode = this.charRefCode * 10 + cp - 0x30;
        } else if (cp === $$6.SEMICOLON) {
            this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
        } else {
            this._err(ERR$1.missingSemicolonAfterCharacterReference);
            this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
        }
    }

    // Numeric character reference end state
    //------------------------------------------------------------------
    [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
        if (this.charRefCode === $$6.NULL) {
            this._err(ERR$1.nullCharacterReference);
            this.charRefCode = $$6.REPLACEMENT_CHARACTER;
        } else if (this.charRefCode > 0x10ffff) {
            this._err(ERR$1.characterReferenceOutsideUnicodeRange);
            this.charRefCode = $$6.REPLACEMENT_CHARACTER;
        } else if (unicode$1.isSurrogate(this.charRefCode)) {
            this._err(ERR$1.surrogateCharacterReference);
            this.charRefCode = $$6.REPLACEMENT_CHARACTER;
        } else if (unicode$1.isUndefinedCodePoint(this.charRefCode)) {
            this._err(ERR$1.noncharacterCharacterReference);
        } else if (unicode$1.isControlCodePoint(this.charRefCode) || this.charRefCode === $$6.CARRIAGE_RETURN) {
            this._err(ERR$1.controlCharacterReference);

            const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];

            if (replacement) {
                this.charRefCode = replacement;
            }
        }

        this.tempBuff = [this.charRefCode];

        this._flushCodePointsConsumedAsCharacterReference();
        this._reconsumeInState(this.returnState);
    }
}

//Token types
Tokenizer$4.CHARACTER_TOKEN = 'CHARACTER_TOKEN';
Tokenizer$4.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN';
Tokenizer$4.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN';
Tokenizer$4.START_TAG_TOKEN = 'START_TAG_TOKEN';
Tokenizer$4.END_TAG_TOKEN = 'END_TAG_TOKEN';
Tokenizer$4.COMMENT_TOKEN = 'COMMENT_TOKEN';
Tokenizer$4.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN';
Tokenizer$4.EOF_TOKEN = 'EOF_TOKEN';
Tokenizer$4.HIBERNATION_TOKEN = 'HIBERNATION_TOKEN';

//Tokenizer initial states for different modes
Tokenizer$4.MODE = {
    DATA: DATA_STATE,
    RCDATA: RCDATA_STATE,
    RAWTEXT: RAWTEXT_STATE,
    SCRIPT_DATA: SCRIPT_DATA_STATE,
    PLAINTEXT: PLAINTEXT_STATE
};

//Static
Tokenizer$4.getTokenAttr = function(token, attrName) {
    for (let i = token.attrs.length - 1; i >= 0; i--) {
        if (token.attrs[i].name === attrName) {
            return token.attrs[i].value;
        }
    }

    return null;
};

var tokenizer = Tokenizer$4;

var html = {};

const NS$4 = (html.NAMESPACES = {
    HTML: 'http://www.w3.org/1999/xhtml',
    MATHML: 'http://www.w3.org/1998/Math/MathML',
    SVG: 'http://www.w3.org/2000/svg',
    XLINK: 'http://www.w3.org/1999/xlink',
    XML: 'http://www.w3.org/XML/1998/namespace',
    XMLNS: 'http://www.w3.org/2000/xmlns/'
});

html.ATTRS = {
    TYPE: 'type',
    ACTION: 'action',
    ENCODING: 'encoding',
    PROMPT: 'prompt',
    NAME: 'name',
    COLOR: 'color',
    FACE: 'face',
    SIZE: 'size'
};

html.DOCUMENT_MODE = {
    NO_QUIRKS: 'no-quirks',
    QUIRKS: 'quirks',
    LIMITED_QUIRKS: 'limited-quirks'
};

const $$5 = (html.TAG_NAMES = {
    A: 'a',
    ADDRESS: 'address',
    ANNOTATION_XML: 'annotation-xml',
    APPLET: 'applet',
    AREA: 'area',
    ARTICLE: 'article',
    ASIDE: 'aside',

    B: 'b',
    BASE: 'base',
    BASEFONT: 'basefont',
    BGSOUND: 'bgsound',
    BIG: 'big',
    BLOCKQUOTE: 'blockquote',
    BODY: 'body',
    BR: 'br',
    BUTTON: 'button',

    CAPTION: 'caption',
    CENTER: 'center',
    CODE: 'code',
    COL: 'col',
    COLGROUP: 'colgroup',

    DD: 'dd',
    DESC: 'desc',
    DETAILS: 'details',
    DIALOG: 'dialog',
    DIR: 'dir',
    DIV: 'div',
    DL: 'dl',
    DT: 'dt',

    EM: 'em',
    EMBED: 'embed',

    FIELDSET: 'fieldset',
    FIGCAPTION: 'figcaption',
    FIGURE: 'figure',
    FONT: 'font',
    FOOTER: 'footer',
    FOREIGN_OBJECT: 'foreignObject',
    FORM: 'form',
    FRAME: 'frame',
    FRAMESET: 'frameset',

    H1: 'h1',
    H2: 'h2',
    H3: 'h3',
    H4: 'h4',
    H5: 'h5',
    H6: 'h6',
    HEAD: 'head',
    HEADER: 'header',
    HGROUP: 'hgroup',
    HR: 'hr',
    HTML: 'html',

    I: 'i',
    IMG: 'img',
    IMAGE: 'image',
    INPUT: 'input',
    IFRAME: 'iframe',

    KEYGEN: 'keygen',

    LABEL: 'label',
    LI: 'li',
    LINK: 'link',
    LISTING: 'listing',

    MAIN: 'main',
    MALIGNMARK: 'malignmark',
    MARQUEE: 'marquee',
    MATH: 'math',
    MENU: 'menu',
    META: 'meta',
    MGLYPH: 'mglyph',
    MI: 'mi',
    MO: 'mo',
    MN: 'mn',
    MS: 'ms',
    MTEXT: 'mtext',

    NAV: 'nav',
    NOBR: 'nobr',
    NOFRAMES: 'noframes',
    NOEMBED: 'noembed',
    NOSCRIPT: 'noscript',

    OBJECT: 'object',
    OL: 'ol',
    OPTGROUP: 'optgroup',
    OPTION: 'option',

    P: 'p',
    PARAM: 'param',
    PLAINTEXT: 'plaintext',
    PRE: 'pre',

    RB: 'rb',
    RP: 'rp',
    RT: 'rt',
    RTC: 'rtc',
    RUBY: 'ruby',

    S: 's',
    SCRIPT: 'script',
    SECTION: 'section',
    SELECT: 'select',
    SOURCE: 'source',
    SMALL: 'small',
    SPAN: 'span',
    STRIKE: 'strike',
    STRONG: 'strong',
    STYLE: 'style',
    SUB: 'sub',
    SUMMARY: 'summary',
    SUP: 'sup',

    TABLE: 'table',
    TBODY: 'tbody',
    TEMPLATE: 'template',
    TEXTAREA: 'textarea',
    TFOOT: 'tfoot',
    TD: 'td',
    TH: 'th',
    THEAD: 'thead',
    TITLE: 'title',
    TR: 'tr',
    TRACK: 'track',
    TT: 'tt',

    U: 'u',
    UL: 'ul',

    SVG: 'svg',

    VAR: 'var',

    WBR: 'wbr',

    XMP: 'xmp'
});

html.SPECIAL_ELEMENTS = {
    [NS$4.HTML]: {
        [$$5.ADDRESS]: true,
        [$$5.APPLET]: true,
        [$$5.AREA]: true,
        [$$5.ARTICLE]: true,
        [$$5.ASIDE]: true,
        [$$5.BASE]: true,
        [$$5.BASEFONT]: true,
        [$$5.BGSOUND]: true,
        [$$5.BLOCKQUOTE]: true,
        [$$5.BODY]: true,
        [$$5.BR]: true,
        [$$5.BUTTON]: true,
        [$$5.CAPTION]: true,
        [$$5.CENTER]: true,
        [$$5.COL]: true,
        [$$5.COLGROUP]: true,
        [$$5.DD]: true,
        [$$5.DETAILS]: true,
        [$$5.DIR]: true,
        [$$5.DIV]: true,
        [$$5.DL]: true,
        [$$5.DT]: true,
        [$$5.EMBED]: true,
        [$$5.FIELDSET]: true,
        [$$5.FIGCAPTION]: true,
        [$$5.FIGURE]: true,
        [$$5.FOOTER]: true,
        [$$5.FORM]: true,
        [$$5.FRAME]: true,
        [$$5.FRAMESET]: true,
        [$$5.H1]: true,
        [$$5.H2]: true,
        [$$5.H3]: true,
        [$$5.H4]: true,
        [$$5.H5]: true,
        [$$5.H6]: true,
        [$$5.HEAD]: true,
        [$$5.HEADER]: true,
        [$$5.HGROUP]: true,
        [$$5.HR]: true,
        [$$5.HTML]: true,
        [$$5.IFRAME]: true,
        [$$5.IMG]: true,
        [$$5.INPUT]: true,
        [$$5.LI]: true,
        [$$5.LINK]: true,
        [$$5.LISTING]: true,
        [$$5.MAIN]: true,
        [$$5.MARQUEE]: true,
        [$$5.MENU]: true,
        [$$5.META]: true,
        [$$5.NAV]: true,
        [$$5.NOEMBED]: true,
        [$$5.NOFRAMES]: true,
        [$$5.NOSCRIPT]: true,
        [$$5.OBJECT]: true,
        [$$5.OL]: true,
        [$$5.P]: true,
        [$$5.PARAM]: true,
        [$$5.PLAINTEXT]: true,
        [$$5.PRE]: true,
        [$$5.SCRIPT]: true,
        [$$5.SECTION]: true,
        [$$5.SELECT]: true,
        [$$5.SOURCE]: true,
        [$$5.STYLE]: true,
        [$$5.SUMMARY]: true,
        [$$5.TABLE]: true,
        [$$5.TBODY]: true,
        [$$5.TD]: true,
        [$$5.TEMPLATE]: true,
        [$$5.TEXTAREA]: true,
        [$$5.TFOOT]: true,
        [$$5.TH]: true,
        [$$5.THEAD]: true,
        [$$5.TITLE]: true,
        [$$5.TR]: true,
        [$$5.TRACK]: true,
        [$$5.UL]: true,
        [$$5.WBR]: true,
        [$$5.XMP]: true
    },
    [NS$4.MATHML]: {
        [$$5.MI]: true,
        [$$5.MO]: true,
        [$$5.MN]: true,
        [$$5.MS]: true,
        [$$5.MTEXT]: true,
        [$$5.ANNOTATION_XML]: true
    },
    [NS$4.SVG]: {
        [$$5.TITLE]: true,
        [$$5.FOREIGN_OBJECT]: true,
        [$$5.DESC]: true
    }
};

const HTML$4 = html;

//Aliases
const $$4 = HTML$4.TAG_NAMES;
const NS$3 = HTML$4.NAMESPACES;

//Element utils

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function isImpliedEndTagRequired(tn) {
    switch (tn.length) {
        case 1:
            return tn === $$4.P;

        case 2:
            return tn === $$4.RB || tn === $$4.RP || tn === $$4.RT || tn === $$4.DD || tn === $$4.DT || tn === $$4.LI;

        case 3:
            return tn === $$4.RTC;

        case 6:
            return tn === $$4.OPTION;

        case 8:
            return tn === $$4.OPTGROUP;
    }

    return false;
}

function isImpliedEndTagRequiredThoroughly(tn) {
    switch (tn.length) {
        case 1:
            return tn === $$4.P;

        case 2:
            return (
                tn === $$4.RB ||
                tn === $$4.RP ||
                tn === $$4.RT ||
                tn === $$4.DD ||
                tn === $$4.DT ||
                tn === $$4.LI ||
                tn === $$4.TD ||
                tn === $$4.TH ||
                tn === $$4.TR
            );

        case 3:
            return tn === $$4.RTC;

        case 5:
            return tn === $$4.TBODY || tn === $$4.TFOOT || tn === $$4.THEAD;

        case 6:
            return tn === $$4.OPTION;

        case 7:
            return tn === $$4.CAPTION;

        case 8:
            return tn === $$4.OPTGROUP || tn === $$4.COLGROUP;
    }

    return false;
}

function isScopingElement(tn, ns) {
    switch (tn.length) {
        case 2:
            if (tn === $$4.TD || tn === $$4.TH) {
                return ns === NS$3.HTML;
            } else if (tn === $$4.MI || tn === $$4.MO || tn === $$4.MN || tn === $$4.MS) {
                return ns === NS$3.MATHML;
            }

            break;

        case 4:
            if (tn === $$4.HTML) {
                return ns === NS$3.HTML;
            } else if (tn === $$4.DESC) {
                return ns === NS$3.SVG;
            }

            break;

        case 5:
            if (tn === $$4.TABLE) {
                return ns === NS$3.HTML;
            } else if (tn === $$4.MTEXT) {
                return ns === NS$3.MATHML;
            } else if (tn === $$4.TITLE) {
                return ns === NS$3.SVG;
            }

            break;

        case 6:
            return (tn === $$4.APPLET || tn === $$4.OBJECT) && ns === NS$3.HTML;

        case 7:
            return (tn === $$4.CAPTION || tn === $$4.MARQUEE) && ns === NS$3.HTML;

        case 8:
            return tn === $$4.TEMPLATE && ns === NS$3.HTML;

        case 13:
            return tn === $$4.FOREIGN_OBJECT && ns === NS$3.SVG;

        case 14:
            return tn === $$4.ANNOTATION_XML && ns === NS$3.MATHML;
    }

    return false;
}

//Stack of open elements
class OpenElementStack$1 {
    constructor(document, treeAdapter) {
        this.stackTop = -1;
        this.items = [];
        this.current = document;
        this.currentTagName = null;
        this.currentTmplContent = null;
        this.tmplCount = 0;
        this.treeAdapter = treeAdapter;
    }

    //Index of element
    _indexOf(element) {
        let idx = -1;

        for (let i = this.stackTop; i >= 0; i--) {
            if (this.items[i] === element) {
                idx = i;
                break;
            }
        }
        return idx;
    }

    //Update current element
    _isInTemplate() {
        return this.currentTagName === $$4.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS$3.HTML;
    }

    _updateCurrentElement() {
        this.current = this.items[this.stackTop];
        this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);

        this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
    }

    //Mutations
    push(element) {
        this.items[++this.stackTop] = element;
        this._updateCurrentElement();

        if (this._isInTemplate()) {
            this.tmplCount++;
        }
    }

    pop() {
        this.stackTop--;

        if (this.tmplCount > 0 && this._isInTemplate()) {
            this.tmplCount--;
        }

        this._updateCurrentElement();
    }

    replace(oldElement, newElement) {
        const idx = this._indexOf(oldElement);

        this.items[idx] = newElement;

        if (idx === this.stackTop) {
            this._updateCurrentElement();
        }
    }

    insertAfter(referenceElement, newElement) {
        const insertionIdx = this._indexOf(referenceElement) + 1;

        this.items.splice(insertionIdx, 0, newElement);

        if (insertionIdx === ++this.stackTop) {
            this._updateCurrentElement();
        }
    }

    popUntilTagNamePopped(tagName) {
        while (this.stackTop > -1) {
            const tn = this.currentTagName;
            const ns = this.treeAdapter.getNamespaceURI(this.current);

            this.pop();

            if (tn === tagName && ns === NS$3.HTML) {
                break;
            }
        }
    }

    popUntilElementPopped(element) {
        while (this.stackTop > -1) {
            const poppedElement = this.current;

            this.pop();

            if (poppedElement === element) {
                break;
            }
        }
    }

    popUntilNumberedHeaderPopped() {
        while (this.stackTop > -1) {
            const tn = this.currentTagName;
            const ns = this.treeAdapter.getNamespaceURI(this.current);

            this.pop();

            if (
                tn === $$4.H1 ||
                tn === $$4.H2 ||
                tn === $$4.H3 ||
                tn === $$4.H4 ||
                tn === $$4.H5 ||
                (tn === $$4.H6 && ns === NS$3.HTML)
            ) {
                break;
            }
        }
    }

    popUntilTableCellPopped() {
        while (this.stackTop > -1) {
            const tn = this.currentTagName;
            const ns = this.treeAdapter.getNamespaceURI(this.current);

            this.pop();

            if (tn === $$4.TD || (tn === $$4.TH && ns === NS$3.HTML)) {
                break;
            }
        }
    }

    popAllUpToHtmlElement() {
        //NOTE: here we assume that root <html> element is always first in the open element stack, so
        //we perform this fast stack clean up.
        this.stackTop = 0;
        this._updateCurrentElement();
    }

    clearBackToTableContext() {
        while (
            (this.currentTagName !== $$4.TABLE && this.currentTagName !== $$4.TEMPLATE && this.currentTagName !== $$4.HTML) ||
            this.treeAdapter.getNamespaceURI(this.current) !== NS$3.HTML
        ) {
            this.pop();
        }
    }

    clearBackToTableBodyContext() {
        while (
            (this.currentTagName !== $$4.TBODY &&
                this.currentTagName !== $$4.TFOOT &&
                this.currentTagName !== $$4.THEAD &&
                this.currentTagName !== $$4.TEMPLATE &&
                this.currentTagName !== $$4.HTML) ||
            this.treeAdapter.getNamespaceURI(this.current) !== NS$3.HTML
        ) {
            this.pop();
        }
    }

    clearBackToTableRowContext() {
        while (
            (this.currentTagName !== $$4.TR && this.currentTagName !== $$4.TEMPLATE && this.currentTagName !== $$4.HTML) ||
            this.treeAdapter.getNamespaceURI(this.current) !== NS$3.HTML
        ) {
            this.pop();
        }
    }

    remove(element) {
        for (let i = this.stackTop; i >= 0; i--) {
            if (this.items[i] === element) {
                this.items.splice(i, 1);
                this.stackTop--;
                this._updateCurrentElement();
                break;
            }
        }
    }

    //Search
    tryPeekProperlyNestedBodyElement() {
        //Properly nested <body> element (should be second element in stack).
        const element = this.items[1];

        return element && this.treeAdapter.getTagName(element) === $$4.BODY ? element : null;
    }

    contains(element) {
        return this._indexOf(element) > -1;
    }

    getCommonAncestor(element) {
        let elementIdx = this._indexOf(element);

        return --elementIdx >= 0 ? this.items[elementIdx] : null;
    }

    isRootHtmlElementCurrent() {
        return this.stackTop === 0 && this.currentTagName === $$4.HTML;
    }

    //Element in scope
    hasInScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (tn === tagName && ns === NS$3.HTML) {
                return true;
            }

            if (isScopingElement(tn, ns)) {
                return false;
            }
        }

        return true;
    }

    hasNumberedHeaderInScope() {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (
                (tn === $$4.H1 || tn === $$4.H2 || tn === $$4.H3 || tn === $$4.H4 || tn === $$4.H5 || tn === $$4.H6) &&
                ns === NS$3.HTML
            ) {
                return true;
            }

            if (isScopingElement(tn, ns)) {
                return false;
            }
        }

        return true;
    }

    hasInListItemScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (tn === tagName && ns === NS$3.HTML) {
                return true;
            }

            if (((tn === $$4.UL || tn === $$4.OL) && ns === NS$3.HTML) || isScopingElement(tn, ns)) {
                return false;
            }
        }

        return true;
    }

    hasInButtonScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (tn === tagName && ns === NS$3.HTML) {
                return true;
            }

            if ((tn === $$4.BUTTON && ns === NS$3.HTML) || isScopingElement(tn, ns)) {
                return false;
            }
        }

        return true;
    }

    hasInTableScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (ns !== NS$3.HTML) {
                continue;
            }

            if (tn === tagName) {
                return true;
            }

            if (tn === $$4.TABLE || tn === $$4.TEMPLATE || tn === $$4.HTML) {
                return false;
            }
        }

        return true;
    }

    hasTableBodyContextInTableScope() {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (ns !== NS$3.HTML) {
                continue;
            }

            if (tn === $$4.TBODY || tn === $$4.THEAD || tn === $$4.TFOOT) {
                return true;
            }

            if (tn === $$4.TABLE || tn === $$4.HTML) {
                return false;
            }
        }

        return true;
    }

    hasInSelectScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
            const tn = this.treeAdapter.getTagName(this.items[i]);
            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);

            if (ns !== NS$3.HTML) {
                continue;
            }

            if (tn === tagName) {
                return true;
            }

            if (tn !== $$4.OPTION && tn !== $$4.OPTGROUP) {
                return false;
            }
        }

        return true;
    }

    //Implied end tags
    generateImpliedEndTags() {
        while (isImpliedEndTagRequired(this.currentTagName)) {
            this.pop();
        }
    }

    generateImpliedEndTagsThoroughly() {
        while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
            this.pop();
        }
    }

    generateImpliedEndTagsWithExclusion(exclusionTagName) {
        while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {
            this.pop();
        }
    }
}

var openElementStack = OpenElementStack$1;

//Const
const NOAH_ARK_CAPACITY = 3;

//List of formatting elements
class FormattingElementList$1 {
    constructor(treeAdapter) {
        this.length = 0;
        this.entries = [];
        this.treeAdapter = treeAdapter;
        this.bookmark = null;
    }

    //Noah Ark's condition
    //OPTIMIZATION: at first we try to find possible candidates for exclusion using
    //lightweight heuristics without thorough attributes check.
    _getNoahArkConditionCandidates(newElement) {
        const candidates = [];

        if (this.length >= NOAH_ARK_CAPACITY) {
            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
            const neTagName = this.treeAdapter.getTagName(newElement);
            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);

            for (let i = this.length - 1; i >= 0; i--) {
                const entry = this.entries[i];

                if (entry.type === FormattingElementList$1.MARKER_ENTRY) {
                    break;
                }

                const element = entry.element;
                const elementAttrs = this.treeAdapter.getAttrList(element);

                const isCandidate =
                    this.treeAdapter.getTagName(element) === neTagName &&
                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&
                    elementAttrs.length === neAttrsLength;

                if (isCandidate) {
                    candidates.push({ idx: i, attrs: elementAttrs });
                }
            }
        }

        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
    }

    _ensureNoahArkCondition(newElement) {
        const candidates = this._getNoahArkConditionCandidates(newElement);
        let cLength = candidates.length;

        if (cLength) {
            const neAttrs = this.treeAdapter.getAttrList(newElement);
            const neAttrsLength = neAttrs.length;
            const neAttrsMap = Object.create(null);

            //NOTE: build attrs map for the new element so we can perform fast lookups
            for (let i = 0; i < neAttrsLength; i++) {
                const neAttr = neAttrs[i];

                neAttrsMap[neAttr.name] = neAttr.value;
            }

            for (let i = 0; i < neAttrsLength; i++) {
                for (let j = 0; j < cLength; j++) {
                    const cAttr = candidates[j].attrs[i];

                    if (neAttrsMap[cAttr.name] !== cAttr.value) {
                        candidates.splice(j, 1);
                        cLength--;
                    }

                    if (candidates.length < NOAH_ARK_CAPACITY) {
                        return;
                    }
                }
            }

            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met
            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {
                this.entries.splice(candidates[i].idx, 1);
                this.length--;
            }
        }
    }

    //Mutations
    insertMarker() {
        this.entries.push({ type: FormattingElementList$1.MARKER_ENTRY });
        this.length++;
    }

    pushElement(element, token) {
        this._ensureNoahArkCondition(element);

        this.entries.push({
            type: FormattingElementList$1.ELEMENT_ENTRY,
            element: element,
            token: token
        });

        this.length++;
    }

    insertElementAfterBookmark(element, token) {
        let bookmarkIdx = this.length - 1;

        for (; bookmarkIdx >= 0; bookmarkIdx--) {
            if (this.entries[bookmarkIdx] === this.bookmark) {
                break;
            }
        }

        this.entries.splice(bookmarkIdx + 1, 0, {
            type: FormattingElementList$1.ELEMENT_ENTRY,
            element: element,
            token: token
        });

        this.length++;
    }

    removeEntry(entry) {
        for (let i = this.length - 1; i >= 0; i--) {
            if (this.entries[i] === entry) {
                this.entries.splice(i, 1);
                this.length--;
                break;
            }
        }
    }

    clearToLastMarker() {
        while (this.length) {
            const entry = this.entries.pop();

            this.length--;

            if (entry.type === FormattingElementList$1.MARKER_ENTRY) {
                break;
            }
        }
    }

    //Search
    getElementEntryInScopeWithTagName(tagName) {
        for (let i = this.length - 1; i >= 0; i--) {
            const entry = this.entries[i];

            if (entry.type === FormattingElementList$1.MARKER_ENTRY) {
                return null;
            }

            if (this.treeAdapter.getTagName(entry.element) === tagName) {
                return entry;
            }
        }

        return null;
    }

    getElementEntry(element) {
        for (let i = this.length - 1; i >= 0; i--) {
            const entry = this.entries[i];

            if (entry.type === FormattingElementList$1.ELEMENT_ENTRY && entry.element === element) {
                return entry;
            }
        }

        return null;
    }
}

//Entry types
FormattingElementList$1.MARKER_ENTRY = 'MARKER_ENTRY';
FormattingElementList$1.ELEMENT_ENTRY = 'ELEMENT_ENTRY';

var formattingElementList = FormattingElementList$1;

class Mixin$9 {
    constructor(host) {
        const originalMethods = {};
        const overriddenMethods = this._getOverriddenMethods(this, originalMethods);

        for (const key of Object.keys(overriddenMethods)) {
            if (typeof overriddenMethods[key] === 'function') {
                originalMethods[key] = host[key];
                host[key] = overriddenMethods[key];
            }
        }
    }

    _getOverriddenMethods() {
        throw new Error('Not implemented');
    }
}

Mixin$9.install = function(host, Ctor, opts) {
    if (!host.__mixins) {
        host.__mixins = [];
    }

    for (let i = 0; i < host.__mixins.length; i++) {
        if (host.__mixins[i].constructor === Ctor) {
            return host.__mixins[i];
        }
    }

    const mixin = new Ctor(host, opts);

    host.__mixins.push(mixin);

    return mixin;
};

var mixin = Mixin$9;

const Mixin$8 = mixin;

class PositionTrackingPreprocessorMixin$2 extends Mixin$8 {
    constructor(preprocessor) {
        super(preprocessor);

        this.preprocessor = preprocessor;
        this.isEol = false;
        this.lineStartPos = 0;
        this.droppedBufferSize = 0;

        this.offset = 0;
        this.col = 0;
        this.line = 1;
    }

    _getOverriddenMethods(mxn, orig) {
        return {
            advance() {
                const pos = this.pos + 1;
                const ch = this.html[pos];

                //NOTE: LF should be in the last column of the line
                if (mxn.isEol) {
                    mxn.isEol = false;
                    mxn.line++;
                    mxn.lineStartPos = pos;
                }

                if (ch === '\n' || (ch === '\r' && this.html[pos + 1] !== '\n')) {
                    mxn.isEol = true;
                }

                mxn.col = pos - mxn.lineStartPos + 1;
                mxn.offset = mxn.droppedBufferSize + pos;

                return orig.advance.call(this);
            },

            retreat() {
                orig.retreat.call(this);

                mxn.isEol = false;
                mxn.col = this.pos - mxn.lineStartPos + 1;
            },

            dropParsedChunk() {
                const prevPos = this.pos;

                orig.dropParsedChunk.call(this);

                const reduction = prevPos - this.pos;

                mxn.lineStartPos -= reduction;
                mxn.droppedBufferSize += reduction;
                mxn.offset = mxn.droppedBufferSize + this.pos;
            }
        };
    }
}

var preprocessorMixin$1 = PositionTrackingPreprocessorMixin$2;

const Mixin$7 = mixin;
const Tokenizer$3 = tokenizer;
const PositionTrackingPreprocessorMixin$1 = preprocessorMixin$1;

class LocationInfoTokenizerMixin$2 extends Mixin$7 {
    constructor(tokenizer) {
        super(tokenizer);

        this.tokenizer = tokenizer;
        this.posTracker = Mixin$7.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin$1);
        this.currentAttrLocation = null;
        this.ctLoc = null;
    }

    _getCurrentLocation() {
        return {
            startLine: this.posTracker.line,
            startCol: this.posTracker.col,
            startOffset: this.posTracker.offset,
            endLine: -1,
            endCol: -1,
            endOffset: -1
        };
    }

    _attachCurrentAttrLocationInfo() {
        this.currentAttrLocation.endLine = this.posTracker.line;
        this.currentAttrLocation.endCol = this.posTracker.col;
        this.currentAttrLocation.endOffset = this.posTracker.offset;

        const currentToken = this.tokenizer.currentToken;
        const currentAttr = this.tokenizer.currentAttr;

        if (!currentToken.location.attrs) {
            currentToken.location.attrs = Object.create(null);
        }

        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
    }

    _getOverriddenMethods(mxn, orig) {
        const methods = {
            _createStartTagToken() {
                orig._createStartTagToken.call(this);
                this.currentToken.location = mxn.ctLoc;
            },

            _createEndTagToken() {
                orig._createEndTagToken.call(this);
                this.currentToken.location = mxn.ctLoc;
            },

            _createCommentToken() {
                orig._createCommentToken.call(this);
                this.currentToken.location = mxn.ctLoc;
            },

            _createDoctypeToken(initialName) {
                orig._createDoctypeToken.call(this, initialName);
                this.currentToken.location = mxn.ctLoc;
            },

            _createCharacterToken(type, ch) {
                orig._createCharacterToken.call(this, type, ch);
                this.currentCharacterToken.location = mxn.ctLoc;
            },

            _createEOFToken() {
                orig._createEOFToken.call(this);
                this.currentToken.location = mxn._getCurrentLocation();
            },

            _createAttr(attrNameFirstCh) {
                orig._createAttr.call(this, attrNameFirstCh);
                mxn.currentAttrLocation = mxn._getCurrentLocation();
            },

            _leaveAttrName(toState) {
                orig._leaveAttrName.call(this, toState);
                mxn._attachCurrentAttrLocationInfo();
            },

            _leaveAttrValue(toState) {
                orig._leaveAttrValue.call(this, toState);
                mxn._attachCurrentAttrLocationInfo();
            },

            _emitCurrentToken() {
                const ctLoc = this.currentToken.location;

                //NOTE: if we have pending character token make it's end location equal to the
                //current token's start location.
                if (this.currentCharacterToken) {
                    this.currentCharacterToken.location.endLine = ctLoc.startLine;
                    this.currentCharacterToken.location.endCol = ctLoc.startCol;
                    this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
                }

                if (this.currentToken.type === Tokenizer$3.EOF_TOKEN) {
                    ctLoc.endLine = ctLoc.startLine;
                    ctLoc.endCol = ctLoc.startCol;
                    ctLoc.endOffset = ctLoc.startOffset;
                } else {
                    ctLoc.endLine = mxn.posTracker.line;
                    ctLoc.endCol = mxn.posTracker.col + 1;
                    ctLoc.endOffset = mxn.posTracker.offset + 1;
                }

                orig._emitCurrentToken.call(this);
            },

            _emitCurrentCharacterToken() {
                const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;

                //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),
                //then set it's location at the current preprocessor position.
                //We don't need to increment preprocessor position, since character token
                //emission is always forced by the start of the next character token here.
                //So, we already have advanced position.
                if (ctLoc && ctLoc.endOffset === -1) {
                    ctLoc.endLine = mxn.posTracker.line;
                    ctLoc.endCol = mxn.posTracker.col;
                    ctLoc.endOffset = mxn.posTracker.offset;
                }

                orig._emitCurrentCharacterToken.call(this);
            }
        };

        //NOTE: patch initial states for each mode to obtain token start position
        Object.keys(Tokenizer$3.MODE).forEach(modeName => {
            const state = Tokenizer$3.MODE[modeName];

            methods[state] = function(cp) {
                mxn.ctLoc = mxn._getCurrentLocation();
                orig[state].call(this, cp);
            };
        });

        return methods;
    }
}

var tokenizerMixin$1 = LocationInfoTokenizerMixin$2;

const Mixin$6 = mixin;

class LocationInfoOpenElementStackMixin$1 extends Mixin$6 {
    constructor(stack, opts) {
        super(stack);

        this.onItemPop = opts.onItemPop;
    }

    _getOverriddenMethods(mxn, orig) {
        return {
            pop() {
                mxn.onItemPop(this.current);
                orig.pop.call(this);
            },

            popAllUpToHtmlElement() {
                for (let i = this.stackTop; i > 0; i--) {
                    mxn.onItemPop(this.items[i]);
                }

                orig.popAllUpToHtmlElement.call(this);
            },

            remove(element) {
                mxn.onItemPop(this.current);
                orig.remove.call(this, element);
            }
        };
    }
}

var openElementStackMixin = LocationInfoOpenElementStackMixin$1;

const Mixin$5 = mixin;
const Tokenizer$2 = tokenizer;
const LocationInfoTokenizerMixin$1 = tokenizerMixin$1;
const LocationInfoOpenElementStackMixin = openElementStackMixin;
const HTML$3 = html;

//Aliases
const $$3 = HTML$3.TAG_NAMES;

class LocationInfoParserMixin$1 extends Mixin$5 {
    constructor(parser) {
        super(parser);

        this.parser = parser;
        this.treeAdapter = this.parser.treeAdapter;
        this.posTracker = null;
        this.lastStartTagToken = null;
        this.lastFosterParentingLocation = null;
        this.currentToken = null;
    }

    _setStartLocation(element) {
        let loc = null;

        if (this.lastStartTagToken) {
            loc = Object.assign({}, this.lastStartTagToken.location);
            loc.startTag = this.lastStartTagToken.location;
        }

        this.treeAdapter.setNodeSourceCodeLocation(element, loc);
    }

    _setEndLocation(element, closingToken) {
        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);

        if (loc) {
            if (closingToken.location) {
                const ctLoc = closingToken.location;
                const tn = this.treeAdapter.getTagName(element);

                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
                const isClosingEndTag = closingToken.type === Tokenizer$2.END_TAG_TOKEN && tn === closingToken.tagName;
                const endLoc = {};
                if (isClosingEndTag) {
                    endLoc.endTag = Object.assign({}, ctLoc);
                    endLoc.endLine = ctLoc.endLine;
                    endLoc.endCol = ctLoc.endCol;
                    endLoc.endOffset = ctLoc.endOffset;
                } else {
                    endLoc.endLine = ctLoc.startLine;
                    endLoc.endCol = ctLoc.startCol;
                    endLoc.endOffset = ctLoc.startOffset;
                }

                this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
            }
        }
    }

    _getOverriddenMethods(mxn, orig) {
        return {
            _bootstrap(document, fragmentContext) {
                orig._bootstrap.call(this, document, fragmentContext);

                mxn.lastStartTagToken = null;
                mxn.lastFosterParentingLocation = null;
                mxn.currentToken = null;

                const tokenizerMixin = Mixin$5.install(this.tokenizer, LocationInfoTokenizerMixin$1);

                mxn.posTracker = tokenizerMixin.posTracker;

                Mixin$5.install(this.openElements, LocationInfoOpenElementStackMixin, {
                    onItemPop: function(element) {
                        mxn._setEndLocation(element, mxn.currentToken);
                    }
                });
            },

            _runParsingLoop(scriptHandler) {
                orig._runParsingLoop.call(this, scriptHandler);

                // NOTE: generate location info for elements
                // that remains on open element stack
                for (let i = this.openElements.stackTop; i >= 0; i--) {
                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
                }
            },

            //Token processing
            _processTokenInForeignContent(token) {
                mxn.currentToken = token;
                orig._processTokenInForeignContent.call(this, token);
            },

            _processToken(token) {
                mxn.currentToken = token;
                orig._processToken.call(this, token);

                //NOTE: <body> and <html> are never popped from the stack, so we need to updated
                //their end location explicitly.
                const requireExplicitUpdate =
                    token.type === Tokenizer$2.END_TAG_TOKEN &&
                    (token.tagName === $$3.HTML || (token.tagName === $$3.BODY && this.openElements.hasInScope($$3.BODY)));

                if (requireExplicitUpdate) {
                    for (let i = this.openElements.stackTop; i >= 0; i--) {
                        const element = this.openElements.items[i];

                        if (this.treeAdapter.getTagName(element) === token.tagName) {
                            mxn._setEndLocation(element, token);
                            break;
                        }
                    }
                }
            },

            //Doctype
            _setDocumentType(token) {
                orig._setDocumentType.call(this, token);

                const documentChildren = this.treeAdapter.getChildNodes(this.document);
                const cnLength = documentChildren.length;

                for (let i = 0; i < cnLength; i++) {
                    const node = documentChildren[i];

                    if (this.treeAdapter.isDocumentTypeNode(node)) {
                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);
                        break;
                    }
                }
            },

            //Elements
            _attachElementToTree(element) {
                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.
                //So we will use token location stored in this methods for the element.
                mxn._setStartLocation(element);
                mxn.lastStartTagToken = null;
                orig._attachElementToTree.call(this, element);
            },

            _appendElement(token, namespaceURI) {
                mxn.lastStartTagToken = token;
                orig._appendElement.call(this, token, namespaceURI);
            },

            _insertElement(token, namespaceURI) {
                mxn.lastStartTagToken = token;
                orig._insertElement.call(this, token, namespaceURI);
            },

            _insertTemplate(token) {
                mxn.lastStartTagToken = token;
                orig._insertTemplate.call(this, token);

                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);

                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
            },

            _insertFakeRootElement() {
                orig._insertFakeRootElement.call(this);
                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
            },

            //Comments
            _appendCommentNode(token, parent) {
                orig._appendCommentNode.call(this, token, parent);

                const children = this.treeAdapter.getChildNodes(parent);
                const commentNode = children[children.length - 1];

                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
            },

            //Text
            _findFosterParentingLocation() {
                //NOTE: store last foster parenting location, so we will be able to find inserted text
                //in case of foster parenting
                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);

                return mxn.lastFosterParentingLocation;
            },

            _insertCharacters(token) {
                orig._insertCharacters.call(this, token);

                const hasFosterParent = this._shouldFosterParentOnInsertion();

                const parent =
                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||
                    this.openElements.currentTmplContent ||
                    this.openElements.current;

                const siblings = this.treeAdapter.getChildNodes(parent);

                const textNodeIdx =
                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement
                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1
                        : siblings.length - 1;

                const textNode = siblings[textNodeIdx];

                //NOTE: if we have location assigned by another token, then just update end position
                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);

                if (tnLoc) {
                    const { endLine, endCol, endOffset } = token.location;
                    this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
                } else {
                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
                }
            }
        };
    }
}

var parserMixin$1 = LocationInfoParserMixin$1;

const Mixin$4 = mixin;

class ErrorReportingMixinBase$3 extends Mixin$4 {
    constructor(host, opts) {
        super(host);

        this.posTracker = null;
        this.onParseError = opts.onParseError;
    }

    _setErrorLocation(err) {
        err.startLine = err.endLine = this.posTracker.line;
        err.startCol = err.endCol = this.posTracker.col;
        err.startOffset = err.endOffset = this.posTracker.offset;
    }

    _reportError(code) {
        const err = {
            code: code,
            startLine: -1,
            startCol: -1,
            startOffset: -1,
            endLine: -1,
            endCol: -1,
            endOffset: -1
        };

        this._setErrorLocation(err);
        this.onParseError(err);
    }

    _getOverriddenMethods(mxn) {
        return {
            _err(code) {
                mxn._reportError(code);
            }
        };
    }
}

var mixinBase = ErrorReportingMixinBase$3;

const ErrorReportingMixinBase$2 = mixinBase;
const PositionTrackingPreprocessorMixin = preprocessorMixin$1;
const Mixin$3 = mixin;

class ErrorReportingPreprocessorMixin$1 extends ErrorReportingMixinBase$2 {
    constructor(preprocessor, opts) {
        super(preprocessor, opts);

        this.posTracker = Mixin$3.install(preprocessor, PositionTrackingPreprocessorMixin);
        this.lastErrOffset = -1;
    }

    _reportError(code) {
        //NOTE: avoid reporting error twice on advance/retreat
        if (this.lastErrOffset !== this.posTracker.offset) {
            this.lastErrOffset = this.posTracker.offset;
            super._reportError(code);
        }
    }
}

var preprocessorMixin = ErrorReportingPreprocessorMixin$1;

const ErrorReportingMixinBase$1 = mixinBase;
const ErrorReportingPreprocessorMixin = preprocessorMixin;
const Mixin$2 = mixin;

class ErrorReportingTokenizerMixin$1 extends ErrorReportingMixinBase$1 {
    constructor(tokenizer, opts) {
        super(tokenizer, opts);

        const preprocessorMixin = Mixin$2.install(tokenizer.preprocessor, ErrorReportingPreprocessorMixin, opts);

        this.posTracker = preprocessorMixin.posTracker;
    }
}

var tokenizerMixin = ErrorReportingTokenizerMixin$1;

const ErrorReportingMixinBase = mixinBase;
const ErrorReportingTokenizerMixin = tokenizerMixin;
const LocationInfoTokenizerMixin = tokenizerMixin$1;
const Mixin$1 = mixin;

class ErrorReportingParserMixin$1 extends ErrorReportingMixinBase {
    constructor(parser, opts) {
        super(parser, opts);

        this.opts = opts;
        this.ctLoc = null;
        this.locBeforeToken = false;
    }

    _setErrorLocation(err) {
        if (this.ctLoc) {
            err.startLine = this.ctLoc.startLine;
            err.startCol = this.ctLoc.startCol;
            err.startOffset = this.ctLoc.startOffset;

            err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
            err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
            err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
        }
    }

    _getOverriddenMethods(mxn, orig) {
        return {
            _bootstrap(document, fragmentContext) {
                orig._bootstrap.call(this, document, fragmentContext);

                Mixin$1.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
                Mixin$1.install(this.tokenizer, LocationInfoTokenizerMixin);
            },

            _processInputToken(token) {
                mxn.ctLoc = token.location;

                orig._processInputToken.call(this, token);
            },

            _err(code, options) {
                mxn.locBeforeToken = options && options.beforeToken;
                mxn._reportError(code);
            }
        };
    }
}

var parserMixin = ErrorReportingParserMixin$1;

var _default = {};

const { DOCUMENT_MODE: DOCUMENT_MODE$2 } = html;

//Node construction
_default.createDocument = function() {
    return {
        nodeName: '#document',
        mode: DOCUMENT_MODE$2.NO_QUIRKS,
        childNodes: []
    };
};

_default.createDocumentFragment = function() {
    return {
        nodeName: '#document-fragment',
        childNodes: []
    };
};

_default.createElement = function(tagName, namespaceURI, attrs) {
    return {
        nodeName: tagName,
        tagName: tagName,
        attrs: attrs,
        namespaceURI: namespaceURI,
        childNodes: [],
        parentNode: null
    };
};

_default.createCommentNode = function(data) {
    return {
        nodeName: '#comment',
        data: data,
        parentNode: null
    };
};

const createTextNode$1 = function(value) {
    return {
        nodeName: '#text',
        value: value,
        parentNode: null
    };
};

//Tree mutation
const appendChild$1 = (_default.appendChild = function(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
});

const insertBefore$1 = (_default.insertBefore = function(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);

    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
});

_default.setTemplateContent = function(templateElement, contentElement) {
    templateElement.content = contentElement;
};

_default.getTemplateContent = function(templateElement) {
    return templateElement.content;
};

_default.setDocumentType = function(document, name, publicId, systemId) {
    let doctypeNode = null;

    for (let i = 0; i < document.childNodes.length; i++) {
        if (document.childNodes[i].nodeName === '#documentType') {
            doctypeNode = document.childNodes[i];
            break;
        }
    }

    if (doctypeNode) {
        doctypeNode.name = name;
        doctypeNode.publicId = publicId;
        doctypeNode.systemId = systemId;
    } else {
        appendChild$1(document, {
            nodeName: '#documentType',
            name: name,
            publicId: publicId,
            systemId: systemId
        });
    }
};

_default.setDocumentMode = function(document, mode) {
    document.mode = mode;
};

_default.getDocumentMode = function(document) {
    return document.mode;
};

_default.detachNode = function(node) {
    if (node.parentNode) {
        const idx = node.parentNode.childNodes.indexOf(node);

        node.parentNode.childNodes.splice(idx, 1);
        node.parentNode = null;
    }
};

_default.insertText = function(parentNode, text) {
    if (parentNode.childNodes.length) {
        const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];

        if (prevNode.nodeName === '#text') {
            prevNode.value += text;
            return;
        }
    }

    appendChild$1(parentNode, createTextNode$1(text));
};

_default.insertTextBefore = function(parentNode, text, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];

    if (prevNode && prevNode.nodeName === '#text') {
        prevNode.value += text;
    } else {
        insertBefore$1(parentNode, createTextNode$1(text), referenceNode);
    }
};

_default.adoptAttributes = function(recipient, attrs) {
    const recipientAttrsMap = [];

    for (let i = 0; i < recipient.attrs.length; i++) {
        recipientAttrsMap.push(recipient.attrs[i].name);
    }

    for (let j = 0; j < attrs.length; j++) {
        if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
            recipient.attrs.push(attrs[j]);
        }
    }
};

//Tree traversing
_default.getFirstChild = function(node) {
    return node.childNodes[0];
};

_default.getChildNodes = function(node) {
    return node.childNodes;
};

_default.getParentNode = function(node) {
    return node.parentNode;
};

_default.getAttrList = function(element) {
    return element.attrs;
};

//Node data
_default.getTagName = function(element) {
    return element.tagName;
};

_default.getNamespaceURI = function(element) {
    return element.namespaceURI;
};

_default.getTextNodeContent = function(textNode) {
    return textNode.value;
};

_default.getCommentNodeContent = function(commentNode) {
    return commentNode.data;
};

_default.getDocumentTypeNodeName = function(doctypeNode) {
    return doctypeNode.name;
};

_default.getDocumentTypeNodePublicId = function(doctypeNode) {
    return doctypeNode.publicId;
};

_default.getDocumentTypeNodeSystemId = function(doctypeNode) {
    return doctypeNode.systemId;
};

//Node types
_default.isTextNode = function(node) {
    return node.nodeName === '#text';
};

_default.isCommentNode = function(node) {
    return node.nodeName === '#comment';
};

_default.isDocumentTypeNode = function(node) {
    return node.nodeName === '#documentType';
};

_default.isElementNode = function(node) {
    return !!node.tagName;
};

// Source code location
_default.setNodeSourceCodeLocation = function(node, location) {
    node.sourceCodeLocation = location;
};

_default.getNodeSourceCodeLocation = function(node) {
    return node.sourceCodeLocation;
};

_default.updateNodeSourceCodeLocation = function(node, endLocation) {
    node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);
};

var mergeOptions$2 = function mergeOptions(defaults, options) {
    options = options || Object.create(null);

    return [defaults, options].reduce((merged, optObj) => {
        Object.keys(optObj).forEach(key => {
            merged[key] = optObj[key];
        });

        return merged;
    }, Object.create(null));
};

var doctype$3 = {};

const { DOCUMENT_MODE: DOCUMENT_MODE$1 } = html;

//Const
const VALID_DOCTYPE_NAME = 'html';
const VALID_SYSTEM_ID = 'about:legacy-compat';
const QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';

const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
    '+//silmaril//dtd html pro v0r11 19970101//',
    '-//as//dtd html 3.0 aswedit + extensions//',
    '-//advasoft ltd//dtd html 3.0 aswedit + extensions//',
    '-//ietf//dtd html 2.0 level 1//',
    '-//ietf//dtd html 2.0 level 2//',
    '-//ietf//dtd html 2.0 strict level 1//',
    '-//ietf//dtd html 2.0 strict level 2//',
    '-//ietf//dtd html 2.0 strict//',
    '-//ietf//dtd html 2.0//',
    '-//ietf//dtd html 2.1e//',
    '-//ietf//dtd html 3.0//',
    '-//ietf//dtd html 3.2 final//',
    '-//ietf//dtd html 3.2//',
    '-//ietf//dtd html 3//',
    '-//ietf//dtd html level 0//',
    '-//ietf//dtd html level 1//',
    '-//ietf//dtd html level 2//',
    '-//ietf//dtd html level 3//',
    '-//ietf//dtd html strict level 0//',
    '-//ietf//dtd html strict level 1//',
    '-//ietf//dtd html strict level 2//',
    '-//ietf//dtd html strict level 3//',
    '-//ietf//dtd html strict//',
    '-//ietf//dtd html//',
    '-//metrius//dtd metrius presentational//',
    '-//microsoft//dtd internet explorer 2.0 html strict//',
    '-//microsoft//dtd internet explorer 2.0 html//',
    '-//microsoft//dtd internet explorer 2.0 tables//',
    '-//microsoft//dtd internet explorer 3.0 html strict//',
    '-//microsoft//dtd internet explorer 3.0 html//',
    '-//microsoft//dtd internet explorer 3.0 tables//',
    '-//netscape comm. corp.//dtd html//',
    '-//netscape comm. corp.//dtd strict html//',
    "-//o'reilly and associates//dtd html 2.0//",
    "-//o'reilly and associates//dtd html extended 1.0//",
    "-//o'reilly and associates//dtd html extended relaxed 1.0//",
    '-//sq//dtd html 2.0 hotmetal + extensions//',
    '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',
    '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',
    '-//spyglass//dtd html 2.0 extended//',
    '-//sun microsystems corp.//dtd hotjava html//',
    '-//sun microsystems corp.//dtd hotjava strict html//',
    '-//w3c//dtd html 3 1995-03-24//',
    '-//w3c//dtd html 3.2 draft//',
    '-//w3c//dtd html 3.2 final//',
    '-//w3c//dtd html 3.2//',
    '-//w3c//dtd html 3.2s draft//',
    '-//w3c//dtd html 4.0 frameset//',
    '-//w3c//dtd html 4.0 transitional//',
    '-//w3c//dtd html experimental 19960712//',
    '-//w3c//dtd html experimental 970421//',
    '-//w3c//dtd w3 html//',
    '-//w3o//dtd w3 html 3.0//',
    '-//webtechs//dtd mozilla html 2.0//',
    '-//webtechs//dtd mozilla html//'
];

const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
    '-//w3c//dtd html 4.01 frameset//',
    '-//w3c//dtd html 4.01 transitional//'
]);

const QUIRKS_MODE_PUBLIC_IDS = ['-//w3o//dtd w3 html strict 3.0//en//', '-/w3c/dtd html 4.0 transitional/en', 'html'];
const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];

const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
    '-//w3c//dtd html 4.01 frameset//',
    '-//w3c//dtd html 4.01 transitional//'
]);

//Utils
function enquoteDoctypeId(id) {
    const quote = id.indexOf('"') !== -1 ? "'" : '"';

    return quote + id + quote;
}

function hasPrefix(publicId, prefixes) {
    for (let i = 0; i < prefixes.length; i++) {
        if (publicId.indexOf(prefixes[i]) === 0) {
            return true;
        }
    }

    return false;
}

//API
doctype$3.isConforming = function(token) {
    return (
        token.name === VALID_DOCTYPE_NAME &&
        token.publicId === null &&
        (token.systemId === null || token.systemId === VALID_SYSTEM_ID)
    );
};

doctype$3.getDocumentMode = function(token) {
    if (token.name !== VALID_DOCTYPE_NAME) {
        return DOCUMENT_MODE$1.QUIRKS;
    }

    const systemId = token.systemId;

    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
        return DOCUMENT_MODE$1.QUIRKS;
    }

    let publicId = token.publicId;

    if (publicId !== null) {
        publicId = publicId.toLowerCase();

        if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
            return DOCUMENT_MODE$1.QUIRKS;
        }

        let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;

        if (hasPrefix(publicId, prefixes)) {
            return DOCUMENT_MODE$1.QUIRKS;
        }

        prefixes =
            systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;

        if (hasPrefix(publicId, prefixes)) {
            return DOCUMENT_MODE$1.LIMITED_QUIRKS;
        }
    }

    return DOCUMENT_MODE$1.NO_QUIRKS;
};

doctype$3.serializeContent = function(name, publicId, systemId) {
    let str = '!DOCTYPE ';

    if (name) {
        str += name;
    }

    if (publicId) {
        str += ' PUBLIC ' + enquoteDoctypeId(publicId);
    } else if (systemId) {
        str += ' SYSTEM';
    }

    if (systemId !== null) {
        str += ' ' + enquoteDoctypeId(systemId);
    }

    return str;
};

var foreignContent$1 = {};

const Tokenizer$1 = tokenizer;
const HTML$2 = html;

//Aliases
const $$2 = HTML$2.TAG_NAMES;
const NS$2 = HTML$2.NAMESPACES;
const ATTRS$1 = HTML$2.ATTRS;

//MIME types
const MIME_TYPES = {
    TEXT_HTML: 'text/html',
    APPLICATION_XML: 'application/xhtml+xml'
};

//Attributes
const DEFINITION_URL_ATTR = 'definitionurl';
const ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';
const SVG_ATTRS_ADJUSTMENT_MAP = {
    attributename: 'attributeName',
    attributetype: 'attributeType',
    basefrequency: 'baseFrequency',
    baseprofile: 'baseProfile',
    calcmode: 'calcMode',
    clippathunits: 'clipPathUnits',
    diffuseconstant: 'diffuseConstant',
    edgemode: 'edgeMode',
    filterunits: 'filterUnits',
    glyphref: 'glyphRef',
    gradienttransform: 'gradientTransform',
    gradientunits: 'gradientUnits',
    kernelmatrix: 'kernelMatrix',
    kernelunitlength: 'kernelUnitLength',
    keypoints: 'keyPoints',
    keysplines: 'keySplines',
    keytimes: 'keyTimes',
    lengthadjust: 'lengthAdjust',
    limitingconeangle: 'limitingConeAngle',
    markerheight: 'markerHeight',
    markerunits: 'markerUnits',
    markerwidth: 'markerWidth',
    maskcontentunits: 'maskContentUnits',
    maskunits: 'maskUnits',
    numoctaves: 'numOctaves',
    pathlength: 'pathLength',
    patterncontentunits: 'patternContentUnits',
    patterntransform: 'patternTransform',
    patternunits: 'patternUnits',
    pointsatx: 'pointsAtX',
    pointsaty: 'pointsAtY',
    pointsatz: 'pointsAtZ',
    preservealpha: 'preserveAlpha',
    preserveaspectratio: 'preserveAspectRatio',
    primitiveunits: 'primitiveUnits',
    refx: 'refX',
    refy: 'refY',
    repeatcount: 'repeatCount',
    repeatdur: 'repeatDur',
    requiredextensions: 'requiredExtensions',
    requiredfeatures: 'requiredFeatures',
    specularconstant: 'specularConstant',
    specularexponent: 'specularExponent',
    spreadmethod: 'spreadMethod',
    startoffset: 'startOffset',
    stddeviation: 'stdDeviation',
    stitchtiles: 'stitchTiles',
    surfacescale: 'surfaceScale',
    systemlanguage: 'systemLanguage',
    tablevalues: 'tableValues',
    targetx: 'targetX',
    targety: 'targetY',
    textlength: 'textLength',
    viewbox: 'viewBox',
    viewtarget: 'viewTarget',
    xchannelselector: 'xChannelSelector',
    ychannelselector: 'yChannelSelector',
    zoomandpan: 'zoomAndPan'
};

const XML_ATTRS_ADJUSTMENT_MAP = {
    'xlink:actuate': { prefix: 'xlink', name: 'actuate', namespace: NS$2.XLINK },
    'xlink:arcrole': { prefix: 'xlink', name: 'arcrole', namespace: NS$2.XLINK },
    'xlink:href': { prefix: 'xlink', name: 'href', namespace: NS$2.XLINK },
    'xlink:role': { prefix: 'xlink', name: 'role', namespace: NS$2.XLINK },
    'xlink:show': { prefix: 'xlink', name: 'show', namespace: NS$2.XLINK },
    'xlink:title': { prefix: 'xlink', name: 'title', namespace: NS$2.XLINK },
    'xlink:type': { prefix: 'xlink', name: 'type', namespace: NS$2.XLINK },
    'xml:base': { prefix: 'xml', name: 'base', namespace: NS$2.XML },
    'xml:lang': { prefix: 'xml', name: 'lang', namespace: NS$2.XML },
    'xml:space': { prefix: 'xml', name: 'space', namespace: NS$2.XML },
    xmlns: { prefix: '', name: 'xmlns', namespace: NS$2.XMLNS },
    'xmlns:xlink': { prefix: 'xmlns', name: 'xlink', namespace: NS$2.XMLNS }
};

//SVG tag names adjustment map
const SVG_TAG_NAMES_ADJUSTMENT_MAP = (foreignContent$1.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
    altglyph: 'altGlyph',
    altglyphdef: 'altGlyphDef',
    altglyphitem: 'altGlyphItem',
    animatecolor: 'animateColor',
    animatemotion: 'animateMotion',
    animatetransform: 'animateTransform',
    clippath: 'clipPath',
    feblend: 'feBlend',
    fecolormatrix: 'feColorMatrix',
    fecomponenttransfer: 'feComponentTransfer',
    fecomposite: 'feComposite',
    feconvolvematrix: 'feConvolveMatrix',
    fediffuselighting: 'feDiffuseLighting',
    fedisplacementmap: 'feDisplacementMap',
    fedistantlight: 'feDistantLight',
    feflood: 'feFlood',
    fefunca: 'feFuncA',
    fefuncb: 'feFuncB',
    fefuncg: 'feFuncG',
    fefuncr: 'feFuncR',
    fegaussianblur: 'feGaussianBlur',
    feimage: 'feImage',
    femerge: 'feMerge',
    femergenode: 'feMergeNode',
    femorphology: 'feMorphology',
    feoffset: 'feOffset',
    fepointlight: 'fePointLight',
    fespecularlighting: 'feSpecularLighting',
    fespotlight: 'feSpotLight',
    fetile: 'feTile',
    feturbulence: 'feTurbulence',
    foreignobject: 'foreignObject',
    glyphref: 'glyphRef',
    lineargradient: 'linearGradient',
    radialgradient: 'radialGradient',
    textpath: 'textPath'
});

//Tags that causes exit from foreign content
const EXITS_FOREIGN_CONTENT = {
    [$$2.B]: true,
    [$$2.BIG]: true,
    [$$2.BLOCKQUOTE]: true,
    [$$2.BODY]: true,
    [$$2.BR]: true,
    [$$2.CENTER]: true,
    [$$2.CODE]: true,
    [$$2.DD]: true,
    [$$2.DIV]: true,
    [$$2.DL]: true,
    [$$2.DT]: true,
    [$$2.EM]: true,
    [$$2.EMBED]: true,
    [$$2.H1]: true,
    [$$2.H2]: true,
    [$$2.H3]: true,
    [$$2.H4]: true,
    [$$2.H5]: true,
    [$$2.H6]: true,
    [$$2.HEAD]: true,
    [$$2.HR]: true,
    [$$2.I]: true,
    [$$2.IMG]: true,
    [$$2.LI]: true,
    [$$2.LISTING]: true,
    [$$2.MENU]: true,
    [$$2.META]: true,
    [$$2.NOBR]: true,
    [$$2.OL]: true,
    [$$2.P]: true,
    [$$2.PRE]: true,
    [$$2.RUBY]: true,
    [$$2.S]: true,
    [$$2.SMALL]: true,
    [$$2.SPAN]: true,
    [$$2.STRONG]: true,
    [$$2.STRIKE]: true,
    [$$2.SUB]: true,
    [$$2.SUP]: true,
    [$$2.TABLE]: true,
    [$$2.TT]: true,
    [$$2.U]: true,
    [$$2.UL]: true,
    [$$2.VAR]: true
};

//Check exit from foreign content
foreignContent$1.causesExit = function(startTagToken) {
    const tn = startTagToken.tagName;
    const isFontWithAttrs =
        tn === $$2.FONT &&
        (Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.COLOR) !== null ||
            Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.SIZE) !== null ||
            Tokenizer$1.getTokenAttr(startTagToken, ATTRS$1.FACE) !== null);

    return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
};

//Token adjustments
foreignContent$1.adjustTokenMathMLAttrs = function(token) {
    for (let i = 0; i < token.attrs.length; i++) {
        if (token.attrs[i].name === DEFINITION_URL_ATTR) {
            token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
            break;
        }
    }
};

foreignContent$1.adjustTokenSVGAttrs = function(token) {
    for (let i = 0; i < token.attrs.length; i++) {
        const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

        if (adjustedAttrName) {
            token.attrs[i].name = adjustedAttrName;
        }
    }
};

foreignContent$1.adjustTokenXMLAttrs = function(token) {
    for (let i = 0; i < token.attrs.length; i++) {
        const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];

        if (adjustedAttrEntry) {
            token.attrs[i].prefix = adjustedAttrEntry.prefix;
            token.attrs[i].name = adjustedAttrEntry.name;
            token.attrs[i].namespace = adjustedAttrEntry.namespace;
        }
    }
};

foreignContent$1.adjustTokenSVGTagName = function(token) {
    const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];

    if (adjustedTagName) {
        token.tagName = adjustedTagName;
    }
};

//Integration points
function isMathMLTextIntegrationPoint(tn, ns) {
    return ns === NS$2.MATHML && (tn === $$2.MI || tn === $$2.MO || tn === $$2.MN || tn === $$2.MS || tn === $$2.MTEXT);
}

function isHtmlIntegrationPoint(tn, ns, attrs) {
    if (ns === NS$2.MATHML && tn === $$2.ANNOTATION_XML) {
        for (let i = 0; i < attrs.length; i++) {
            if (attrs[i].name === ATTRS$1.ENCODING) {
                const value = attrs[i].value.toLowerCase();

                return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
            }
        }
    }

    return ns === NS$2.SVG && (tn === $$2.FOREIGN_OBJECT || tn === $$2.DESC || tn === $$2.TITLE);
}

foreignContent$1.isIntegrationPoint = function(tn, ns, attrs, foreignNS) {
    if ((!foreignNS || foreignNS === NS$2.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) {
        return true;
    }

    if ((!foreignNS || foreignNS === NS$2.MATHML) && isMathMLTextIntegrationPoint(tn, ns)) {
        return true;
    }

    return false;
};

const Tokenizer = tokenizer;
const OpenElementStack = openElementStack;
const FormattingElementList = formattingElementList;
const LocationInfoParserMixin = parserMixin$1;
const ErrorReportingParserMixin = parserMixin;
const Mixin = mixin;
const defaultTreeAdapter$1 = _default;
const mergeOptions$1 = mergeOptions$2;
const doctype$2 = doctype$3;
const foreignContent = foreignContent$1;
const ERR = errorCodes;
const unicode = unicode$3;
const HTML$1 = html;

//Aliases
const $$1 = HTML$1.TAG_NAMES;
const NS$1 = HTML$1.NAMESPACES;
const ATTRS = HTML$1.ATTRS;

const DEFAULT_OPTIONS$1 = {
    scriptingEnabled: true,
    sourceCodeLocationInfo: false,
    onParseError: null,
    treeAdapter: defaultTreeAdapter$1
};

//Misc constants
const HIDDEN_INPUT_TYPE = 'hidden';

//Adoption agency loops iteration count
const AA_OUTER_LOOP_ITER = 8;
const AA_INNER_LOOP_ITER = 3;

//Insertion modes
const INITIAL_MODE = 'INITIAL_MODE';
const BEFORE_HTML_MODE = 'BEFORE_HTML_MODE';
const BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE';
const IN_HEAD_MODE = 'IN_HEAD_MODE';
const IN_HEAD_NO_SCRIPT_MODE = 'IN_HEAD_NO_SCRIPT_MODE';
const AFTER_HEAD_MODE = 'AFTER_HEAD_MODE';
const IN_BODY_MODE = 'IN_BODY_MODE';
const TEXT_MODE = 'TEXT_MODE';
const IN_TABLE_MODE = 'IN_TABLE_MODE';
const IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE';
const IN_CAPTION_MODE = 'IN_CAPTION_MODE';
const IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE';
const IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE';
const IN_ROW_MODE = 'IN_ROW_MODE';
const IN_CELL_MODE = 'IN_CELL_MODE';
const IN_SELECT_MODE = 'IN_SELECT_MODE';
const IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE';
const IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE';
const AFTER_BODY_MODE = 'AFTER_BODY_MODE';
const IN_FRAMESET_MODE = 'IN_FRAMESET_MODE';
const AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE';
const AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE';
const AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE';

//Insertion mode reset map
const INSERTION_MODE_RESET_MAP = {
    [$$1.TR]: IN_ROW_MODE,
    [$$1.TBODY]: IN_TABLE_BODY_MODE,
    [$$1.THEAD]: IN_TABLE_BODY_MODE,
    [$$1.TFOOT]: IN_TABLE_BODY_MODE,
    [$$1.CAPTION]: IN_CAPTION_MODE,
    [$$1.COLGROUP]: IN_COLUMN_GROUP_MODE,
    [$$1.TABLE]: IN_TABLE_MODE,
    [$$1.BODY]: IN_BODY_MODE,
    [$$1.FRAMESET]: IN_FRAMESET_MODE
};

//Template insertion mode switch map
const TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
    [$$1.CAPTION]: IN_TABLE_MODE,
    [$$1.COLGROUP]: IN_TABLE_MODE,
    [$$1.TBODY]: IN_TABLE_MODE,
    [$$1.TFOOT]: IN_TABLE_MODE,
    [$$1.THEAD]: IN_TABLE_MODE,
    [$$1.COL]: IN_COLUMN_GROUP_MODE,
    [$$1.TR]: IN_TABLE_BODY_MODE,
    [$$1.TD]: IN_ROW_MODE,
    [$$1.TH]: IN_ROW_MODE
};

//Token handlers map for insertion modes
const TOKEN_HANDLERS = {
    [INITIAL_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
        [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
        [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
        [Tokenizer.EOF_TOKEN]: tokenInInitialMode
    },
    [BEFORE_HTML_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
        [Tokenizer.EOF_TOKEN]: tokenBeforeHtml
    },
    [BEFORE_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
        [Tokenizer.EOF_TOKEN]: tokenBeforeHead
    },
    [IN_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagInHead,
        [Tokenizer.END_TAG_TOKEN]: endTagInHead,
        [Tokenizer.EOF_TOKEN]: tokenInHead
    },
    [IN_HEAD_NO_SCRIPT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
        [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
        [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
    },
    [AFTER_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
        [Tokenizer.EOF_TOKEN]: tokenAfterHead
    },
    [IN_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInBody,
        [Tokenizer.END_TAG_TOKEN]: endTagInBody,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [TEXT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: ignoreToken,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: ignoreToken,
        [Tokenizer.END_TAG_TOKEN]: endTagInText,
        [Tokenizer.EOF_TOKEN]: eofInText
    },
    [IN_TABLE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTable,
        [Tokenizer.END_TAG_TOKEN]: endTagInTable,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TABLE_TEXT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTableText,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
        [Tokenizer.COMMENT_TOKEN]: tokenInTableText,
        [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
        [Tokenizer.START_TAG_TOKEN]: tokenInTableText,
        [Tokenizer.END_TAG_TOKEN]: tokenInTableText,
        [Tokenizer.EOF_TOKEN]: tokenInTableText
    },
    [IN_CAPTION_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInCaption,
        [Tokenizer.END_TAG_TOKEN]: endTagInCaption,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_COLUMN_GROUP_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
        [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TABLE_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
        [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_ROW_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInRow,
        [Tokenizer.END_TAG_TOKEN]: endTagInRow,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_CELL_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInCell,
        [Tokenizer.END_TAG_TOKEN]: endTagInCell,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_SELECT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInSelect,
        [Tokenizer.END_TAG_TOKEN]: endTagInSelect,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_SELECT_IN_TABLE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
        [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
        [Tokenizer.EOF_TOKEN]: eofInBody
    },
    [IN_TEMPLATE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
        [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
        [Tokenizer.EOF_TOKEN]: eofInTemplate
    },
    [AFTER_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
        [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [IN_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
        [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
        [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
        [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_AFTER_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
        [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.EOF_TOKEN]: stopParsing
    },
    [AFTER_AFTER_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
        [Tokenizer.END_TAG_TOKEN]: ignoreToken,
        [Tokenizer.EOF_TOKEN]: stopParsing
    }
};

//Parser
class Parser$1 {
    constructor(options) {
        this.options = mergeOptions$1(DEFAULT_OPTIONS$1, options);

        this.treeAdapter = this.options.treeAdapter;
        this.pendingScript = null;

        if (this.options.sourceCodeLocationInfo) {
            Mixin.install(this, LocationInfoParserMixin);
        }

        if (this.options.onParseError) {
            Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });
        }
    }

    // API
    parse(html) {
        const document = this.treeAdapter.createDocument();

        this._bootstrap(document, null);
        this.tokenizer.write(html, true);
        this._runParsingLoop(null);

        return document;
    }

    parseFragment(html, fragmentContext) {
        //NOTE: use <template> element as a fragment context if context element was not provided,
        //so we will parse in "forgiving" manner
        if (!fragmentContext) {
            fragmentContext = this.treeAdapter.createElement($$1.TEMPLATE, NS$1.HTML, []);
        }

        //NOTE: create fake element which will be used as 'document' for fragment parsing.
        //This is important for jsdom there 'document' can't be recreated, therefore
        //fragment parsing causes messing of the main `document`.
        const documentMock = this.treeAdapter.createElement('documentmock', NS$1.HTML, []);

        this._bootstrap(documentMock, fragmentContext);

        if (this.treeAdapter.getTagName(fragmentContext) === $$1.TEMPLATE) {
            this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
        }

        this._initTokenizerForFragmentParsing();
        this._insertFakeRootElement();
        this._resetInsertionMode();
        this._findFormInFragmentContext();
        this.tokenizer.write(html, true);
        this._runParsingLoop(null);

        const rootElement = this.treeAdapter.getFirstChild(documentMock);
        const fragment = this.treeAdapter.createDocumentFragment();

        this._adoptNodes(rootElement, fragment);

        return fragment;
    }

    //Bootstrap parser
    _bootstrap(document, fragmentContext) {
        this.tokenizer = new Tokenizer(this.options);

        this.stopped = false;

        this.insertionMode = INITIAL_MODE;
        this.originalInsertionMode = '';

        this.document = document;
        this.fragmentContext = fragmentContext;

        this.headElement = null;
        this.formElement = null;

        this.openElements = new OpenElementStack(this.document, this.treeAdapter);
        this.activeFormattingElements = new FormattingElementList(this.treeAdapter);

        this.tmplInsertionModeStack = [];
        this.tmplInsertionModeStackTop = -1;
        this.currentTmplInsertionMode = null;

        this.pendingCharacterTokens = [];
        this.hasNonWhitespacePendingCharacterToken = false;

        this.framesetOk = true;
        this.skipNextNewLine = false;
        this.fosterParentingEnabled = false;
    }

    //Errors
    _err() {
        // NOTE: err reporting is noop by default. Enabled by mixin.
    }

    //Parsing loop
    _runParsingLoop(scriptHandler) {
        while (!this.stopped) {
            this._setupTokenizerCDATAMode();

            const token = this.tokenizer.getNextToken();

            if (token.type === Tokenizer.HIBERNATION_TOKEN) {
                break;
            }

            if (this.skipNextNewLine) {
                this.skipNextNewLine = false;

                if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\n') {
                    if (token.chars.length === 1) {
                        continue;
                    }

                    token.chars = token.chars.substr(1);
                }
            }

            this._processInputToken(token);

            if (scriptHandler && this.pendingScript) {
                break;
            }
        }
    }

    runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
        this._runParsingLoop(scriptHandler);

        if (scriptHandler && this.pendingScript) {
            const script = this.pendingScript;

            this.pendingScript = null;

            scriptHandler(script);

            return;
        }

        if (writeCallback) {
            writeCallback();
        }
    }

    //Text parsing
    _setupTokenizerCDATAMode() {
        const current = this._getAdjustedCurrentElement();

        this.tokenizer.allowCDATA =
            current &&
            current !== this.document &&
            this.treeAdapter.getNamespaceURI(current) !== NS$1.HTML &&
            !this._isIntegrationPoint(current);
    }

    _switchToTextParsing(currentToken, nextTokenizerState) {
        this._insertElement(currentToken, NS$1.HTML);
        this.tokenizer.state = nextTokenizerState;
        this.originalInsertionMode = this.insertionMode;
        this.insertionMode = TEXT_MODE;
    }

    switchToPlaintextParsing() {
        this.insertionMode = TEXT_MODE;
        this.originalInsertionMode = IN_BODY_MODE;
        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
    }

    //Fragment parsing
    _getAdjustedCurrentElement() {
        return this.openElements.stackTop === 0 && this.fragmentContext
            ? this.fragmentContext
            : this.openElements.current;
    }

    _findFormInFragmentContext() {
        let node = this.fragmentContext;

        do {
            if (this.treeAdapter.getTagName(node) === $$1.FORM) {
                this.formElement = node;
                break;
            }

            node = this.treeAdapter.getParentNode(node);
        } while (node);
    }

    _initTokenizerForFragmentParsing() {
        if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS$1.HTML) {
            const tn = this.treeAdapter.getTagName(this.fragmentContext);

            if (tn === $$1.TITLE || tn === $$1.TEXTAREA) {
                this.tokenizer.state = Tokenizer.MODE.RCDATA;
            } else if (
                tn === $$1.STYLE ||
                tn === $$1.XMP ||
                tn === $$1.IFRAME ||
                tn === $$1.NOEMBED ||
                tn === $$1.NOFRAMES ||
                tn === $$1.NOSCRIPT
            ) {
                this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
            } else if (tn === $$1.SCRIPT) {
                this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
            } else if (tn === $$1.PLAINTEXT) {
                this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
            }
        }
    }

    //Tree mutation
    _setDocumentType(token) {
        const name = token.name || '';
        const publicId = token.publicId || '';
        const systemId = token.systemId || '';

        this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
    }

    _attachElementToTree(element) {
        if (this._shouldFosterParentOnInsertion()) {
            this._fosterParentElement(element);
        } else {
            const parent = this.openElements.currentTmplContent || this.openElements.current;

            this.treeAdapter.appendChild(parent, element);
        }
    }

    _appendElement(token, namespaceURI) {
        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

        this._attachElementToTree(element);
    }

    _insertElement(token, namespaceURI) {
        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);

        this._attachElementToTree(element);
        this.openElements.push(element);
    }

    _insertFakeElement(tagName) {
        const element = this.treeAdapter.createElement(tagName, NS$1.HTML, []);

        this._attachElementToTree(element);
        this.openElements.push(element);
    }

    _insertTemplate(token) {
        const tmpl = this.treeAdapter.createElement(token.tagName, NS$1.HTML, token.attrs);
        const content = this.treeAdapter.createDocumentFragment();

        this.treeAdapter.setTemplateContent(tmpl, content);
        this._attachElementToTree(tmpl);
        this.openElements.push(tmpl);
    }

    _insertFakeRootElement() {
        const element = this.treeAdapter.createElement($$1.HTML, NS$1.HTML, []);

        this.treeAdapter.appendChild(this.openElements.current, element);
        this.openElements.push(element);
    }

    _appendCommentNode(token, parent) {
        const commentNode = this.treeAdapter.createCommentNode(token.data);

        this.treeAdapter.appendChild(parent, commentNode);
    }

    _insertCharacters(token) {
        if (this._shouldFosterParentOnInsertion()) {
            this._fosterParentText(token.chars);
        } else {
            const parent = this.openElements.currentTmplContent || this.openElements.current;

            this.treeAdapter.insertText(parent, token.chars);
        }
    }

    _adoptNodes(donor, recipient) {
        for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
            this.treeAdapter.detachNode(child);
            this.treeAdapter.appendChild(recipient, child);
        }
    }

    //Token processing
    _shouldProcessTokenInForeignContent(token) {
        const current = this._getAdjustedCurrentElement();

        if (!current || current === this.document) {
            return false;
        }

        const ns = this.treeAdapter.getNamespaceURI(current);

        if (ns === NS$1.HTML) {
            return false;
        }

        if (
            this.treeAdapter.getTagName(current) === $$1.ANNOTATION_XML &&
            ns === NS$1.MATHML &&
            token.type === Tokenizer.START_TAG_TOKEN &&
            token.tagName === $$1.SVG
        ) {
            return false;
        }

        const isCharacterToken =
            token.type === Tokenizer.CHARACTER_TOKEN ||
            token.type === Tokenizer.NULL_CHARACTER_TOKEN ||
            token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;

        const isMathMLTextStartTag =
            token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $$1.MGLYPH && token.tagName !== $$1.MALIGNMARK;

        if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS$1.MATHML)) {
            return false;
        }

        if (
            (token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) &&
            this._isIntegrationPoint(current, NS$1.HTML)
        ) {
            return false;
        }

        return token.type !== Tokenizer.EOF_TOKEN;
    }

    _processToken(token) {
        TOKEN_HANDLERS[this.insertionMode][token.type](this, token);
    }

    _processTokenInBodyMode(token) {
        TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);
    }

    _processTokenInForeignContent(token) {
        if (token.type === Tokenizer.CHARACTER_TOKEN) {
            characterInForeignContent(this, token);
        } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
            nullCharacterInForeignContent(this, token);
        } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
            insertCharacters(this, token);
        } else if (token.type === Tokenizer.COMMENT_TOKEN) {
            appendComment(this, token);
        } else if (token.type === Tokenizer.START_TAG_TOKEN) {
            startTagInForeignContent(this, token);
        } else if (token.type === Tokenizer.END_TAG_TOKEN) {
            endTagInForeignContent(this, token);
        }
    }

    _processInputToken(token) {
        if (this._shouldProcessTokenInForeignContent(token)) {
            this._processTokenInForeignContent(token);
        } else {
            this._processToken(token);
        }

        if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {
            this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
        }
    }

    //Integration points
    _isIntegrationPoint(element, foreignNS) {
        const tn = this.treeAdapter.getTagName(element);
        const ns = this.treeAdapter.getNamespaceURI(element);
        const attrs = this.treeAdapter.getAttrList(element);

        return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);
    }

    //Active formatting elements reconstruction
    _reconstructActiveFormattingElements() {
        const listLength = this.activeFormattingElements.length;

        if (listLength) {
            let unopenIdx = listLength;
            let entry = null;

            do {
                unopenIdx--;
                entry = this.activeFormattingElements.entries[unopenIdx];

                if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
                    unopenIdx++;
                    break;
                }
            } while (unopenIdx > 0);

            for (let i = unopenIdx; i < listLength; i++) {
                entry = this.activeFormattingElements.entries[i];
                this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
                entry.element = this.openElements.current;
            }
        }
    }

    //Close elements
    _closeTableCell() {
        this.openElements.generateImpliedEndTags();
        this.openElements.popUntilTableCellPopped();
        this.activeFormattingElements.clearToLastMarker();
        this.insertionMode = IN_ROW_MODE;
    }

    _closePElement() {
        this.openElements.generateImpliedEndTagsWithExclusion($$1.P);
        this.openElements.popUntilTagNamePopped($$1.P);
    }

    //Insertion modes
    _resetInsertionMode() {
        for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {
            let element = this.openElements.items[i];

            if (i === 0) {
                last = true;

                if (this.fragmentContext) {
                    element = this.fragmentContext;
                }
            }

            const tn = this.treeAdapter.getTagName(element);
            const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];

            if (newInsertionMode) {
                this.insertionMode = newInsertionMode;
                break;
            } else if (!last && (tn === $$1.TD || tn === $$1.TH)) {
                this.insertionMode = IN_CELL_MODE;
                break;
            } else if (!last && tn === $$1.HEAD) {
                this.insertionMode = IN_HEAD_MODE;
                break;
            } else if (tn === $$1.SELECT) {
                this._resetInsertionModeForSelect(i);
                break;
            } else if (tn === $$1.TEMPLATE) {
                this.insertionMode = this.currentTmplInsertionMode;
                break;
            } else if (tn === $$1.HTML) {
                this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
                break;
            } else if (last) {
                this.insertionMode = IN_BODY_MODE;
                break;
            }
        }
    }

    _resetInsertionModeForSelect(selectIdx) {
        if (selectIdx > 0) {
            for (let i = selectIdx - 1; i > 0; i--) {
                const ancestor = this.openElements.items[i];
                const tn = this.treeAdapter.getTagName(ancestor);

                if (tn === $$1.TEMPLATE) {
                    break;
                } else if (tn === $$1.TABLE) {
                    this.insertionMode = IN_SELECT_IN_TABLE_MODE;
                    return;
                }
            }
        }

        this.insertionMode = IN_SELECT_MODE;
    }

    _pushTmplInsertionMode(mode) {
        this.tmplInsertionModeStack.push(mode);
        this.tmplInsertionModeStackTop++;
        this.currentTmplInsertionMode = mode;
    }

    _popTmplInsertionMode() {
        this.tmplInsertionModeStack.pop();
        this.tmplInsertionModeStackTop--;
        this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
    }

    //Foster parenting
    _isElementCausesFosterParenting(element) {
        const tn = this.treeAdapter.getTagName(element);

        return tn === $$1.TABLE || tn === $$1.TBODY || tn === $$1.TFOOT || tn === $$1.THEAD || tn === $$1.TR;
    }

    _shouldFosterParentOnInsertion() {
        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
    }

    _findFosterParentingLocation() {
        const location = {
            parent: null,
            beforeElement: null
        };

        for (let i = this.openElements.stackTop; i >= 0; i--) {
            const openElement = this.openElements.items[i];
            const tn = this.treeAdapter.getTagName(openElement);
            const ns = this.treeAdapter.getNamespaceURI(openElement);

            if (tn === $$1.TEMPLATE && ns === NS$1.HTML) {
                location.parent = this.treeAdapter.getTemplateContent(openElement);
                break;
            } else if (tn === $$1.TABLE) {
                location.parent = this.treeAdapter.getParentNode(openElement);

                if (location.parent) {
                    location.beforeElement = openElement;
                } else {
                    location.parent = this.openElements.items[i - 1];
                }

                break;
            }
        }

        if (!location.parent) {
            location.parent = this.openElements.items[0];
        }

        return location;
    }

    _fosterParentElement(element) {
        const location = this._findFosterParentingLocation();

        if (location.beforeElement) {
            this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
        } else {
            this.treeAdapter.appendChild(location.parent, element);
        }
    }

    _fosterParentText(chars) {
        const location = this._findFosterParentingLocation();

        if (location.beforeElement) {
            this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);
        } else {
            this.treeAdapter.insertText(location.parent, chars);
        }
    }

    //Special elements
    _isSpecialElement(element) {
        const tn = this.treeAdapter.getTagName(element);
        const ns = this.treeAdapter.getNamespaceURI(element);

        return HTML$1.SPECIAL_ELEMENTS[ns][tn];
    }
}

var parser = Parser$1;

//Adoption agency algorithm
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
//------------------------------------------------------------------

//Steps 5-8 of the algorithm
function aaObtainFormattingElementEntry(p, token) {
    let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);

    if (formattingElementEntry) {
        if (!p.openElements.contains(formattingElementEntry.element)) {
            p.activeFormattingElements.removeEntry(formattingElementEntry);
            formattingElementEntry = null;
        } else if (!p.openElements.hasInScope(token.tagName)) {
            formattingElementEntry = null;
        }
    } else {
        genericEndTagInBody(p, token);
    }

    return formattingElementEntry;
}

//Steps 9 and 10 of the algorithm
function aaObtainFurthestBlock(p, formattingElementEntry) {
    let furthestBlock = null;

    for (let i = p.openElements.stackTop; i >= 0; i--) {
        const element = p.openElements.items[i];

        if (element === formattingElementEntry.element) {
            break;
        }

        if (p._isSpecialElement(element)) {
            furthestBlock = element;
        }
    }

    if (!furthestBlock) {
        p.openElements.popUntilElementPopped(formattingElementEntry.element);
        p.activeFormattingElements.removeEntry(formattingElementEntry);
    }

    return furthestBlock;
}

//Step 13 of the algorithm
function aaInnerLoop(p, furthestBlock, formattingElement) {
    let lastElement = furthestBlock;
    let nextElement = p.openElements.getCommonAncestor(furthestBlock);

    for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
        //NOTE: store next element for the next loop iteration (it may be deleted from the stack by step 9.5)
        nextElement = p.openElements.getCommonAncestor(element);

        const elementEntry = p.activeFormattingElements.getElementEntry(element);
        const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
        const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;

        if (shouldRemoveFromOpenElements) {
            if (counterOverflow) {
                p.activeFormattingElements.removeEntry(elementEntry);
            }

            p.openElements.remove(element);
        } else {
            element = aaRecreateElementFromEntry(p, elementEntry);

            if (lastElement === furthestBlock) {
                p.activeFormattingElements.bookmark = elementEntry;
            }

            p.treeAdapter.detachNode(lastElement);
            p.treeAdapter.appendChild(element, lastElement);
            lastElement = element;
        }
    }

    return lastElement;
}

//Step 13.7 of the algorithm
function aaRecreateElementFromEntry(p, elementEntry) {
    const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
    const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);

    p.openElements.replace(elementEntry.element, newElement);
    elementEntry.element = newElement;

    return newElement;
}

//Step 14 of the algorithm
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
    if (p._isElementCausesFosterParenting(commonAncestor)) {
        p._fosterParentElement(lastElement);
    } else {
        const tn = p.treeAdapter.getTagName(commonAncestor);
        const ns = p.treeAdapter.getNamespaceURI(commonAncestor);

        if (tn === $$1.TEMPLATE && ns === NS$1.HTML) {
            commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
        }

        p.treeAdapter.appendChild(commonAncestor, lastElement);
    }
}

//Steps 15-19 of the algorithm
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
    const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
    const token = formattingElementEntry.token;
    const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);

    p._adoptNodes(furthestBlock, newElement);
    p.treeAdapter.appendChild(furthestBlock, newElement);

    p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
    p.activeFormattingElements.removeEntry(formattingElementEntry);

    p.openElements.remove(formattingElementEntry.element);
    p.openElements.insertAfter(furthestBlock, newElement);
}

//Algorithm entry point
function callAdoptionAgency(p, token) {
    let formattingElementEntry;

    for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
        formattingElementEntry = aaObtainFormattingElementEntry(p, token);

        if (!formattingElementEntry) {
            break;
        }

        const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);

        if (!furthestBlock) {
            break;
        }

        p.activeFormattingElements.bookmark = formattingElementEntry;

        const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
        const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);

        p.treeAdapter.detachNode(lastElement);
        aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
        aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
    }
}

//Generic token handlers
//------------------------------------------------------------------
function ignoreToken() {
    //NOTE: do nothing =)
}

function misplacedDoctype(p) {
    p._err(ERR.misplacedDoctype);
}

function appendComment(p, token) {
    p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);
}

function appendCommentToRootHtmlElement(p, token) {
    p._appendCommentNode(token, p.openElements.items[0]);
}

function appendCommentToDocument(p, token) {
    p._appendCommentNode(token, p.document);
}

function insertCharacters(p, token) {
    p._insertCharacters(token);
}

function stopParsing(p) {
    p.stopped = true;
}

// The "initial" insertion mode
//------------------------------------------------------------------
function doctypeInInitialMode(p, token) {
    p._setDocumentType(token);

    const mode = token.forceQuirks ? HTML$1.DOCUMENT_MODE.QUIRKS : doctype$2.getDocumentMode(token);

    if (!doctype$2.isConforming(token)) {
        p._err(ERR.nonConformingDoctype);
    }

    p.treeAdapter.setDocumentMode(p.document, mode);

    p.insertionMode = BEFORE_HTML_MODE;
}

function tokenInInitialMode(p, token) {
    p._err(ERR.missingDoctype, { beforeToken: true });
    p.treeAdapter.setDocumentMode(p.document, HTML$1.DOCUMENT_MODE.QUIRKS);
    p.insertionMode = BEFORE_HTML_MODE;
    p._processToken(token);
}

// The "before html" insertion mode
//------------------------------------------------------------------
function startTagBeforeHtml(p, token) {
    if (token.tagName === $$1.HTML) {
        p._insertElement(token, NS$1.HTML);
        p.insertionMode = BEFORE_HEAD_MODE;
    } else {
        tokenBeforeHtml(p, token);
    }
}

function endTagBeforeHtml(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML || tn === $$1.HEAD || tn === $$1.BODY || tn === $$1.BR) {
        tokenBeforeHtml(p, token);
    }
}

function tokenBeforeHtml(p, token) {
    p._insertFakeRootElement();
    p.insertionMode = BEFORE_HEAD_MODE;
    p._processToken(token);
}

// The "before head" insertion mode
//------------------------------------------------------------------
function startTagBeforeHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.HEAD) {
        p._insertElement(token, NS$1.HTML);
        p.headElement = p.openElements.current;
        p.insertionMode = IN_HEAD_MODE;
    } else {
        tokenBeforeHead(p, token);
    }
}

function endTagBeforeHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HEAD || tn === $$1.BODY || tn === $$1.HTML || tn === $$1.BR) {
        tokenBeforeHead(p, token);
    } else {
        p._err(ERR.endTagWithoutMatchingOpenElement);
    }
}

function tokenBeforeHead(p, token) {
    p._insertFakeElement($$1.HEAD);
    p.headElement = p.openElements.current;
    p.insertionMode = IN_HEAD_MODE;
    p._processToken(token);
}

// The "in head" insertion mode
//------------------------------------------------------------------
function startTagInHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.BASE || tn === $$1.BASEFONT || tn === $$1.BGSOUND || tn === $$1.LINK || tn === $$1.META) {
        p._appendElement(token, NS$1.HTML);
        token.ackSelfClosing = true;
    } else if (tn === $$1.TITLE) {
        p._switchToTextParsing(token, Tokenizer.MODE.RCDATA);
    } else if (tn === $$1.NOSCRIPT) {
        if (p.options.scriptingEnabled) {
            p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
        } else {
            p._insertElement(token, NS$1.HTML);
            p.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
        }
    } else if (tn === $$1.NOFRAMES || tn === $$1.STYLE) {
        p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
    } else if (tn === $$1.SCRIPT) {
        p._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);
    } else if (tn === $$1.TEMPLATE) {
        p._insertTemplate(token, NS$1.HTML);
        p.activeFormattingElements.insertMarker();
        p.framesetOk = false;
        p.insertionMode = IN_TEMPLATE_MODE;
        p._pushTmplInsertionMode(IN_TEMPLATE_MODE);
    } else if (tn === $$1.HEAD) {
        p._err(ERR.misplacedStartTagForHeadElement);
    } else {
        tokenInHead(p, token);
    }
}

function endTagInHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HEAD) {
        p.openElements.pop();
        p.insertionMode = AFTER_HEAD_MODE;
    } else if (tn === $$1.BODY || tn === $$1.BR || tn === $$1.HTML) {
        tokenInHead(p, token);
    } else if (tn === $$1.TEMPLATE) {
        if (p.openElements.tmplCount > 0) {
            p.openElements.generateImpliedEndTagsThoroughly();

            if (p.openElements.currentTagName !== $$1.TEMPLATE) {
                p._err(ERR.closingOfElementWithOpenChildElements);
            }

            p.openElements.popUntilTagNamePopped($$1.TEMPLATE);
            p.activeFormattingElements.clearToLastMarker();
            p._popTmplInsertionMode();
            p._resetInsertionMode();
        } else {
            p._err(ERR.endTagWithoutMatchingOpenElement);
        }
    } else {
        p._err(ERR.endTagWithoutMatchingOpenElement);
    }
}

function tokenInHead(p, token) {
    p.openElements.pop();
    p.insertionMode = AFTER_HEAD_MODE;
    p._processToken(token);
}

// The "in head no script" insertion mode
//------------------------------------------------------------------
function startTagInHeadNoScript(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (
        tn === $$1.BASEFONT ||
        tn === $$1.BGSOUND ||
        tn === $$1.HEAD ||
        tn === $$1.LINK ||
        tn === $$1.META ||
        tn === $$1.NOFRAMES ||
        tn === $$1.STYLE
    ) {
        startTagInHead(p, token);
    } else if (tn === $$1.NOSCRIPT) {
        p._err(ERR.nestedNoscriptInHead);
    } else {
        tokenInHeadNoScript(p, token);
    }
}

function endTagInHeadNoScript(p, token) {
    const tn = token.tagName;

    if (tn === $$1.NOSCRIPT) {
        p.openElements.pop();
        p.insertionMode = IN_HEAD_MODE;
    } else if (tn === $$1.BR) {
        tokenInHeadNoScript(p, token);
    } else {
        p._err(ERR.endTagWithoutMatchingOpenElement);
    }
}

function tokenInHeadNoScript(p, token) {
    const errCode =
        token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;

    p._err(errCode);
    p.openElements.pop();
    p.insertionMode = IN_HEAD_MODE;
    p._processToken(token);
}

// The "after head" insertion mode
//------------------------------------------------------------------
function startTagAfterHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.BODY) {
        p._insertElement(token, NS$1.HTML);
        p.framesetOk = false;
        p.insertionMode = IN_BODY_MODE;
    } else if (tn === $$1.FRAMESET) {
        p._insertElement(token, NS$1.HTML);
        p.insertionMode = IN_FRAMESET_MODE;
    } else if (
        tn === $$1.BASE ||
        tn === $$1.BASEFONT ||
        tn === $$1.BGSOUND ||
        tn === $$1.LINK ||
        tn === $$1.META ||
        tn === $$1.NOFRAMES ||
        tn === $$1.SCRIPT ||
        tn === $$1.STYLE ||
        tn === $$1.TEMPLATE ||
        tn === $$1.TITLE
    ) {
        p._err(ERR.abandonedHeadElementChild);
        p.openElements.push(p.headElement);
        startTagInHead(p, token);
        p.openElements.remove(p.headElement);
    } else if (tn === $$1.HEAD) {
        p._err(ERR.misplacedStartTagForHeadElement);
    } else {
        tokenAfterHead(p, token);
    }
}

function endTagAfterHead(p, token) {
    const tn = token.tagName;

    if (tn === $$1.BODY || tn === $$1.HTML || tn === $$1.BR) {
        tokenAfterHead(p, token);
    } else if (tn === $$1.TEMPLATE) {
        endTagInHead(p, token);
    } else {
        p._err(ERR.endTagWithoutMatchingOpenElement);
    }
}

function tokenAfterHead(p, token) {
    p._insertFakeElement($$1.BODY);
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}

// The "in body" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertCharacters(token);
}

function characterInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertCharacters(token);
    p.framesetOk = false;
}

function htmlStartTagInBody(p, token) {
    if (p.openElements.tmplCount === 0) {
        p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
    }
}

function bodyStartTagInBody(p, token) {
    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

    if (bodyElement && p.openElements.tmplCount === 0) {
        p.framesetOk = false;
        p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
    }
}

function framesetStartTagInBody(p, token) {
    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();

    if (p.framesetOk && bodyElement) {
        p.treeAdapter.detachNode(bodyElement);
        p.openElements.popAllUpToHtmlElement();
        p._insertElement(token, NS$1.HTML);
        p.insertionMode = IN_FRAMESET_MODE;
    }
}

function addressStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
}

function numberedHeaderStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    const tn = p.openElements.currentTagName;

    if (tn === $$1.H1 || tn === $$1.H2 || tn === $$1.H3 || tn === $$1.H4 || tn === $$1.H5 || tn === $$1.H6) {
        p.openElements.pop();
    }

    p._insertElement(token, NS$1.HTML);
}

function preStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
    //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
    p.skipNextNewLine = true;
    p.framesetOk = false;
}

function formStartTagInBody(p, token) {
    const inTemplate = p.openElements.tmplCount > 0;

    if (!p.formElement || inTemplate) {
        if (p.openElements.hasInButtonScope($$1.P)) {
            p._closePElement();
        }

        p._insertElement(token, NS$1.HTML);

        if (!inTemplate) {
            p.formElement = p.openElements.current;
        }
    }
}

function listItemStartTagInBody(p, token) {
    p.framesetOk = false;

    const tn = token.tagName;

    for (let i = p.openElements.stackTop; i >= 0; i--) {
        const element = p.openElements.items[i];
        const elementTn = p.treeAdapter.getTagName(element);
        let closeTn = null;

        if (tn === $$1.LI && elementTn === $$1.LI) {
            closeTn = $$1.LI;
        } else if ((tn === $$1.DD || tn === $$1.DT) && (elementTn === $$1.DD || elementTn === $$1.DT)) {
            closeTn = elementTn;
        }

        if (closeTn) {
            p.openElements.generateImpliedEndTagsWithExclusion(closeTn);
            p.openElements.popUntilTagNamePopped(closeTn);
            break;
        }

        if (elementTn !== $$1.ADDRESS && elementTn !== $$1.DIV && elementTn !== $$1.P && p._isSpecialElement(element)) {
            break;
        }
    }

    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
}

function plaintextStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
    p.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
}

function buttonStartTagInBody(p, token) {
    if (p.openElements.hasInScope($$1.BUTTON)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped($$1.BUTTON);
    }

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
    p.framesetOk = false;
}

function aStartTagInBody(p, token) {
    const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($$1.A);

    if (activeElementEntry) {
        callAdoptionAgency(p, token);
        p.openElements.remove(activeElementEntry.element);
        p.activeFormattingElements.removeEntry(activeElementEntry);
    }

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function bStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function nobrStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    if (p.openElements.hasInScope($$1.NOBR)) {
        callAdoptionAgency(p, token);
        p._reconstructActiveFormattingElements();
    }

    p._insertElement(token, NS$1.HTML);
    p.activeFormattingElements.pushElement(p.openElements.current, token);
}

function appletStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
    p.activeFormattingElements.insertMarker();
    p.framesetOk = false;
}

function tableStartTagInBody(p, token) {
    if (
        p.treeAdapter.getDocumentMode(p.document) !== HTML$1.DOCUMENT_MODE.QUIRKS &&
        p.openElements.hasInButtonScope($$1.P)
    ) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
    p.framesetOk = false;
    p.insertionMode = IN_TABLE_MODE;
}

function areaStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._appendElement(token, NS$1.HTML);
    p.framesetOk = false;
    token.ackSelfClosing = true;
}

function inputStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._appendElement(token, NS$1.HTML);

    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

    if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
        p.framesetOk = false;
    }

    token.ackSelfClosing = true;
}

function paramStartTagInBody(p, token) {
    p._appendElement(token, NS$1.HTML);
    token.ackSelfClosing = true;
}

function hrStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._appendElement(token, NS$1.HTML);
    p.framesetOk = false;
    token.ackSelfClosing = true;
}

function imageStartTagInBody(p, token) {
    token.tagName = $$1.IMG;
    areaStartTagInBody(p, token);
}

function textareaStartTagInBody(p, token) {
    p._insertElement(token, NS$1.HTML);
    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
    //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
    p.skipNextNewLine = true;
    p.tokenizer.state = Tokenizer.MODE.RCDATA;
    p.originalInsertionMode = p.insertionMode;
    p.framesetOk = false;
    p.insertionMode = TEXT_MODE;
}

function xmpStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._reconstructActiveFormattingElements();
    p.framesetOk = false;
    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}

function iframeStartTagInBody(p, token) {
    p.framesetOk = false;
    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}

//NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse
//<noembed> as a rawtext.
function noembedStartTagInBody(p, token) {
    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}

function selectStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
    p.framesetOk = false;

    if (
        p.insertionMode === IN_TABLE_MODE ||
        p.insertionMode === IN_CAPTION_MODE ||
        p.insertionMode === IN_TABLE_BODY_MODE ||
        p.insertionMode === IN_ROW_MODE ||
        p.insertionMode === IN_CELL_MODE
    ) {
        p.insertionMode = IN_SELECT_IN_TABLE_MODE;
    } else {
        p.insertionMode = IN_SELECT_MODE;
    }
}

function optgroupStartTagInBody(p, token) {
    if (p.openElements.currentTagName === $$1.OPTION) {
        p.openElements.pop();
    }

    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
}

function rbStartTagInBody(p, token) {
    if (p.openElements.hasInScope($$1.RUBY)) {
        p.openElements.generateImpliedEndTags();
    }

    p._insertElement(token, NS$1.HTML);
}

function rtStartTagInBody(p, token) {
    if (p.openElements.hasInScope($$1.RUBY)) {
        p.openElements.generateImpliedEndTagsWithExclusion($$1.RTC);
    }

    p._insertElement(token, NS$1.HTML);
}

function menuStartTagInBody(p, token) {
    if (p.openElements.hasInButtonScope($$1.P)) {
        p._closePElement();
    }

    p._insertElement(token, NS$1.HTML);
}

function mathStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    foreignContent.adjustTokenMathMLAttrs(token);
    foreignContent.adjustTokenXMLAttrs(token);

    if (token.selfClosing) {
        p._appendElement(token, NS$1.MATHML);
    } else {
        p._insertElement(token, NS$1.MATHML);
    }

    token.ackSelfClosing = true;
}

function svgStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();

    foreignContent.adjustTokenSVGAttrs(token);
    foreignContent.adjustTokenXMLAttrs(token);

    if (token.selfClosing) {
        p._appendElement(token, NS$1.SVG);
    } else {
        p._insertElement(token, NS$1.SVG);
    }

    token.ackSelfClosing = true;
}

function genericStartTagInBody(p, token) {
    p._reconstructActiveFormattingElements();
    p._insertElement(token, NS$1.HTML);
}

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function startTagInBody(p, token) {
    const tn = token.tagName;

    switch (tn.length) {
        case 1:
            if (tn === $$1.I || tn === $$1.S || tn === $$1.B || tn === $$1.U) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.P) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.A) {
                aStartTagInBody(p, token);
            } else {
                genericStartTagInBody(p, token);
            }

            break;

        case 2:
            if (tn === $$1.DL || tn === $$1.OL || tn === $$1.UL) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.H1 || tn === $$1.H2 || tn === $$1.H3 || tn === $$1.H4 || tn === $$1.H5 || tn === $$1.H6) {
                numberedHeaderStartTagInBody(p, token);
            } else if (tn === $$1.LI || tn === $$1.DD || tn === $$1.DT) {
                listItemStartTagInBody(p, token);
            } else if (tn === $$1.EM || tn === $$1.TT) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.BR) {
                areaStartTagInBody(p, token);
            } else if (tn === $$1.HR) {
                hrStartTagInBody(p, token);
            } else if (tn === $$1.RB) {
                rbStartTagInBody(p, token);
            } else if (tn === $$1.RT || tn === $$1.RP) {
                rtStartTagInBody(p, token);
            } else if (tn !== $$1.TH && tn !== $$1.TD && tn !== $$1.TR) {
                genericStartTagInBody(p, token);
            }

            break;

        case 3:
            if (tn === $$1.DIV || tn === $$1.DIR || tn === $$1.NAV) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.PRE) {
                preStartTagInBody(p, token);
            } else if (tn === $$1.BIG) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.IMG || tn === $$1.WBR) {
                areaStartTagInBody(p, token);
            } else if (tn === $$1.XMP) {
                xmpStartTagInBody(p, token);
            } else if (tn === $$1.SVG) {
                svgStartTagInBody(p, token);
            } else if (tn === $$1.RTC) {
                rbStartTagInBody(p, token);
            } else if (tn !== $$1.COL) {
                genericStartTagInBody(p, token);
            }

            break;

        case 4:
            if (tn === $$1.HTML) {
                htmlStartTagInBody(p, token);
            } else if (tn === $$1.BASE || tn === $$1.LINK || tn === $$1.META) {
                startTagInHead(p, token);
            } else if (tn === $$1.BODY) {
                bodyStartTagInBody(p, token);
            } else if (tn === $$1.MAIN || tn === $$1.MENU) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.FORM) {
                formStartTagInBody(p, token);
            } else if (tn === $$1.CODE || tn === $$1.FONT) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.NOBR) {
                nobrStartTagInBody(p, token);
            } else if (tn === $$1.AREA) {
                areaStartTagInBody(p, token);
            } else if (tn === $$1.MATH) {
                mathStartTagInBody(p, token);
            } else if (tn === $$1.MENU) {
                menuStartTagInBody(p, token);
            } else if (tn !== $$1.HEAD) {
                genericStartTagInBody(p, token);
            }

            break;

        case 5:
            if (tn === $$1.STYLE || tn === $$1.TITLE) {
                startTagInHead(p, token);
            } else if (tn === $$1.ASIDE) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.SMALL) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.TABLE) {
                tableStartTagInBody(p, token);
            } else if (tn === $$1.EMBED) {
                areaStartTagInBody(p, token);
            } else if (tn === $$1.INPUT) {
                inputStartTagInBody(p, token);
            } else if (tn === $$1.PARAM || tn === $$1.TRACK) {
                paramStartTagInBody(p, token);
            } else if (tn === $$1.IMAGE) {
                imageStartTagInBody(p, token);
            } else if (tn !== $$1.FRAME && tn !== $$1.TBODY && tn !== $$1.TFOOT && tn !== $$1.THEAD) {
                genericStartTagInBody(p, token);
            }

            break;

        case 6:
            if (tn === $$1.SCRIPT) {
                startTagInHead(p, token);
            } else if (
                tn === $$1.CENTER ||
                tn === $$1.FIGURE ||
                tn === $$1.FOOTER ||
                tn === $$1.HEADER ||
                tn === $$1.HGROUP ||
                tn === $$1.DIALOG
            ) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.BUTTON) {
                buttonStartTagInBody(p, token);
            } else if (tn === $$1.STRIKE || tn === $$1.STRONG) {
                bStartTagInBody(p, token);
            } else if (tn === $$1.APPLET || tn === $$1.OBJECT) {
                appletStartTagInBody(p, token);
            } else if (tn === $$1.KEYGEN) {
                areaStartTagInBody(p, token);
            } else if (tn === $$1.SOURCE) {
                paramStartTagInBody(p, token);
            } else if (tn === $$1.IFRAME) {
                iframeStartTagInBody(p, token);
            } else if (tn === $$1.SELECT) {
                selectStartTagInBody(p, token);
            } else if (tn === $$1.OPTION) {
                optgroupStartTagInBody(p, token);
            } else {
                genericStartTagInBody(p, token);
            }

            break;

        case 7:
            if (tn === $$1.BGSOUND) {
                startTagInHead(p, token);
            } else if (
                tn === $$1.DETAILS ||
                tn === $$1.ADDRESS ||
                tn === $$1.ARTICLE ||
                tn === $$1.SECTION ||
                tn === $$1.SUMMARY
            ) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.LISTING) {
                preStartTagInBody(p, token);
            } else if (tn === $$1.MARQUEE) {
                appletStartTagInBody(p, token);
            } else if (tn === $$1.NOEMBED) {
                noembedStartTagInBody(p, token);
            } else if (tn !== $$1.CAPTION) {
                genericStartTagInBody(p, token);
            }

            break;

        case 8:
            if (tn === $$1.BASEFONT) {
                startTagInHead(p, token);
            } else if (tn === $$1.FRAMESET) {
                framesetStartTagInBody(p, token);
            } else if (tn === $$1.FIELDSET) {
                addressStartTagInBody(p, token);
            } else if (tn === $$1.TEXTAREA) {
                textareaStartTagInBody(p, token);
            } else if (tn === $$1.TEMPLATE) {
                startTagInHead(p, token);
            } else if (tn === $$1.NOSCRIPT) {
                if (p.options.scriptingEnabled) {
                    noembedStartTagInBody(p, token);
                } else {
                    genericStartTagInBody(p, token);
                }
            } else if (tn === $$1.OPTGROUP) {
                optgroupStartTagInBody(p, token);
            } else if (tn !== $$1.COLGROUP) {
                genericStartTagInBody(p, token);
            }

            break;

        case 9:
            if (tn === $$1.PLAINTEXT) {
                plaintextStartTagInBody(p, token);
            } else {
                genericStartTagInBody(p, token);
            }

            break;

        case 10:
            if (tn === $$1.BLOCKQUOTE || tn === $$1.FIGCAPTION) {
                addressStartTagInBody(p, token);
            } else {
                genericStartTagInBody(p, token);
            }

            break;

        default:
            genericStartTagInBody(p, token);
    }
}

function bodyEndTagInBody(p) {
    if (p.openElements.hasInScope($$1.BODY)) {
        p.insertionMode = AFTER_BODY_MODE;
    }
}

function htmlEndTagInBody(p, token) {
    if (p.openElements.hasInScope($$1.BODY)) {
        p.insertionMode = AFTER_BODY_MODE;
        p._processToken(token);
    }
}

function addressEndTagInBody(p, token) {
    const tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
    }
}

function formEndTagInBody(p) {
    const inTemplate = p.openElements.tmplCount > 0;
    const formElement = p.formElement;

    if (!inTemplate) {
        p.formElement = null;
    }

    if ((formElement || inTemplate) && p.openElements.hasInScope($$1.FORM)) {
        p.openElements.generateImpliedEndTags();

        if (inTemplate) {
            p.openElements.popUntilTagNamePopped($$1.FORM);
        } else {
            p.openElements.remove(formElement);
        }
    }
}

function pEndTagInBody(p) {
    if (!p.openElements.hasInButtonScope($$1.P)) {
        p._insertFakeElement($$1.P);
    }

    p._closePElement();
}

function liEndTagInBody(p) {
    if (p.openElements.hasInListItemScope($$1.LI)) {
        p.openElements.generateImpliedEndTagsWithExclusion($$1.LI);
        p.openElements.popUntilTagNamePopped($$1.LI);
    }
}

function ddEndTagInBody(p, token) {
    const tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTagsWithExclusion(tn);
        p.openElements.popUntilTagNamePopped(tn);
    }
}

function numberedHeaderEndTagInBody(p) {
    if (p.openElements.hasNumberedHeaderInScope()) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilNumberedHeaderPopped();
    }
}

function appletEndTagInBody(p, token) {
    const tn = token.tagName;

    if (p.openElements.hasInScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
    }
}

function brEndTagInBody(p) {
    p._reconstructActiveFormattingElements();
    p._insertFakeElement($$1.BR);
    p.openElements.pop();
    p.framesetOk = false;
}

function genericEndTagInBody(p, token) {
    const tn = token.tagName;

    for (let i = p.openElements.stackTop; i > 0; i--) {
        const element = p.openElements.items[i];

        if (p.treeAdapter.getTagName(element) === tn) {
            p.openElements.generateImpliedEndTagsWithExclusion(tn);
            p.openElements.popUntilElementPopped(element);
            break;
        }

        if (p._isSpecialElement(element)) {
            break;
        }
    }
}

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function endTagInBody(p, token) {
    const tn = token.tagName;

    switch (tn.length) {
        case 1:
            if (tn === $$1.A || tn === $$1.B || tn === $$1.I || tn === $$1.S || tn === $$1.U) {
                callAdoptionAgency(p, token);
            } else if (tn === $$1.P) {
                pEndTagInBody(p);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 2:
            if (tn === $$1.DL || tn === $$1.UL || tn === $$1.OL) {
                addressEndTagInBody(p, token);
            } else if (tn === $$1.LI) {
                liEndTagInBody(p);
            } else if (tn === $$1.DD || tn === $$1.DT) {
                ddEndTagInBody(p, token);
            } else if (tn === $$1.H1 || tn === $$1.H2 || tn === $$1.H3 || tn === $$1.H4 || tn === $$1.H5 || tn === $$1.H6) {
                numberedHeaderEndTagInBody(p);
            } else if (tn === $$1.BR) {
                brEndTagInBody(p);
            } else if (tn === $$1.EM || tn === $$1.TT) {
                callAdoptionAgency(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 3:
            if (tn === $$1.BIG) {
                callAdoptionAgency(p, token);
            } else if (tn === $$1.DIR || tn === $$1.DIV || tn === $$1.NAV || tn === $$1.PRE) {
                addressEndTagInBody(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 4:
            if (tn === $$1.BODY) {
                bodyEndTagInBody(p);
            } else if (tn === $$1.HTML) {
                htmlEndTagInBody(p, token);
            } else if (tn === $$1.FORM) {
                formEndTagInBody(p);
            } else if (tn === $$1.CODE || tn === $$1.FONT || tn === $$1.NOBR) {
                callAdoptionAgency(p, token);
            } else if (tn === $$1.MAIN || tn === $$1.MENU) {
                addressEndTagInBody(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 5:
            if (tn === $$1.ASIDE) {
                addressEndTagInBody(p, token);
            } else if (tn === $$1.SMALL) {
                callAdoptionAgency(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 6:
            if (
                tn === $$1.CENTER ||
                tn === $$1.FIGURE ||
                tn === $$1.FOOTER ||
                tn === $$1.HEADER ||
                tn === $$1.HGROUP ||
                tn === $$1.DIALOG
            ) {
                addressEndTagInBody(p, token);
            } else if (tn === $$1.APPLET || tn === $$1.OBJECT) {
                appletEndTagInBody(p, token);
            } else if (tn === $$1.STRIKE || tn === $$1.STRONG) {
                callAdoptionAgency(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 7:
            if (
                tn === $$1.ADDRESS ||
                tn === $$1.ARTICLE ||
                tn === $$1.DETAILS ||
                tn === $$1.SECTION ||
                tn === $$1.SUMMARY ||
                tn === $$1.LISTING
            ) {
                addressEndTagInBody(p, token);
            } else if (tn === $$1.MARQUEE) {
                appletEndTagInBody(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 8:
            if (tn === $$1.FIELDSET) {
                addressEndTagInBody(p, token);
            } else if (tn === $$1.TEMPLATE) {
                endTagInHead(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        case 10:
            if (tn === $$1.BLOCKQUOTE || tn === $$1.FIGCAPTION) {
                addressEndTagInBody(p, token);
            } else {
                genericEndTagInBody(p, token);
            }

            break;

        default:
            genericEndTagInBody(p, token);
    }
}

function eofInBody(p, token) {
    if (p.tmplInsertionModeStackTop > -1) {
        eofInTemplate(p, token);
    } else {
        p.stopped = true;
    }
}

// The "text" insertion mode
//------------------------------------------------------------------
function endTagInText(p, token) {
    if (token.tagName === $$1.SCRIPT) {
        p.pendingScript = p.openElements.current;
    }

    p.openElements.pop();
    p.insertionMode = p.originalInsertionMode;
}

function eofInText(p, token) {
    p._err(ERR.eofInElementThatCanContainOnlyText);
    p.openElements.pop();
    p.insertionMode = p.originalInsertionMode;
    p._processToken(token);
}

// The "in table" insertion mode
//------------------------------------------------------------------
function characterInTable(p, token) {
    const curTn = p.openElements.currentTagName;

    if (curTn === $$1.TABLE || curTn === $$1.TBODY || curTn === $$1.TFOOT || curTn === $$1.THEAD || curTn === $$1.TR) {
        p.pendingCharacterTokens = [];
        p.hasNonWhitespacePendingCharacterToken = false;
        p.originalInsertionMode = p.insertionMode;
        p.insertionMode = IN_TABLE_TEXT_MODE;
        p._processToken(token);
    } else {
        tokenInTable(p, token);
    }
}

function captionStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p.activeFormattingElements.insertMarker();
    p._insertElement(token, NS$1.HTML);
    p.insertionMode = IN_CAPTION_MODE;
}

function colgroupStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertElement(token, NS$1.HTML);
    p.insertionMode = IN_COLUMN_GROUP_MODE;
}

function colStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertFakeElement($$1.COLGROUP);
    p.insertionMode = IN_COLUMN_GROUP_MODE;
    p._processToken(token);
}

function tbodyStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertElement(token, NS$1.HTML);
    p.insertionMode = IN_TABLE_BODY_MODE;
}

function tdStartTagInTable(p, token) {
    p.openElements.clearBackToTableContext();
    p._insertFakeElement($$1.TBODY);
    p.insertionMode = IN_TABLE_BODY_MODE;
    p._processToken(token);
}

function tableStartTagInTable(p, token) {
    if (p.openElements.hasInTableScope($$1.TABLE)) {
        p.openElements.popUntilTagNamePopped($$1.TABLE);
        p._resetInsertionMode();
        p._processToken(token);
    }
}

function inputStartTagInTable(p, token) {
    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);

    if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
        p._appendElement(token, NS$1.HTML);
    } else {
        tokenInTable(p, token);
    }

    token.ackSelfClosing = true;
}

function formStartTagInTable(p, token) {
    if (!p.formElement && p.openElements.tmplCount === 0) {
        p._insertElement(token, NS$1.HTML);
        p.formElement = p.openElements.current;
        p.openElements.pop();
    }
}

function startTagInTable(p, token) {
    const tn = token.tagName;

    switch (tn.length) {
        case 2:
            if (tn === $$1.TD || tn === $$1.TH || tn === $$1.TR) {
                tdStartTagInTable(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 3:
            if (tn === $$1.COL) {
                colStartTagInTable(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 4:
            if (tn === $$1.FORM) {
                formStartTagInTable(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 5:
            if (tn === $$1.TABLE) {
                tableStartTagInTable(p, token);
            } else if (tn === $$1.STYLE) {
                startTagInHead(p, token);
            } else if (tn === $$1.TBODY || tn === $$1.TFOOT || tn === $$1.THEAD) {
                tbodyStartTagInTable(p, token);
            } else if (tn === $$1.INPUT) {
                inputStartTagInTable(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 6:
            if (tn === $$1.SCRIPT) {
                startTagInHead(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 7:
            if (tn === $$1.CAPTION) {
                captionStartTagInTable(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        case 8:
            if (tn === $$1.COLGROUP) {
                colgroupStartTagInTable(p, token);
            } else if (tn === $$1.TEMPLATE) {
                startTagInHead(p, token);
            } else {
                tokenInTable(p, token);
            }

            break;

        default:
            tokenInTable(p, token);
    }
}

function endTagInTable(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TABLE) {
        if (p.openElements.hasInTableScope($$1.TABLE)) {
            p.openElements.popUntilTagNamePopped($$1.TABLE);
            p._resetInsertionMode();
        }
    } else if (tn === $$1.TEMPLATE) {
        endTagInHead(p, token);
    } else if (
        tn !== $$1.BODY &&
        tn !== $$1.CAPTION &&
        tn !== $$1.COL &&
        tn !== $$1.COLGROUP &&
        tn !== $$1.HTML &&
        tn !== $$1.TBODY &&
        tn !== $$1.TD &&
        tn !== $$1.TFOOT &&
        tn !== $$1.TH &&
        tn !== $$1.THEAD &&
        tn !== $$1.TR
    ) {
        tokenInTable(p, token);
    }
}

function tokenInTable(p, token) {
    const savedFosterParentingState = p.fosterParentingEnabled;

    p.fosterParentingEnabled = true;
    p._processTokenInBodyMode(token);
    p.fosterParentingEnabled = savedFosterParentingState;
}

// The "in table text" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInTableText(p, token) {
    p.pendingCharacterTokens.push(token);
}

function characterInTableText(p, token) {
    p.pendingCharacterTokens.push(token);
    p.hasNonWhitespacePendingCharacterToken = true;
}

function tokenInTableText(p, token) {
    let i = 0;

    if (p.hasNonWhitespacePendingCharacterToken) {
        for (; i < p.pendingCharacterTokens.length; i++) {
            tokenInTable(p, p.pendingCharacterTokens[i]);
        }
    } else {
        for (; i < p.pendingCharacterTokens.length; i++) {
            p._insertCharacters(p.pendingCharacterTokens[i]);
        }
    }

    p.insertionMode = p.originalInsertionMode;
    p._processToken(token);
}

// The "in caption" insertion mode
//------------------------------------------------------------------
function startTagInCaption(p, token) {
    const tn = token.tagName;

    if (
        tn === $$1.CAPTION ||
        tn === $$1.COL ||
        tn === $$1.COLGROUP ||
        tn === $$1.TBODY ||
        tn === $$1.TD ||
        tn === $$1.TFOOT ||
        tn === $$1.TH ||
        tn === $$1.THEAD ||
        tn === $$1.TR
    ) {
        if (p.openElements.hasInTableScope($$1.CAPTION)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped($$1.CAPTION);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_TABLE_MODE;
            p._processToken(token);
        }
    } else {
        startTagInBody(p, token);
    }
}

function endTagInCaption(p, token) {
    const tn = token.tagName;

    if (tn === $$1.CAPTION || tn === $$1.TABLE) {
        if (p.openElements.hasInTableScope($$1.CAPTION)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped($$1.CAPTION);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_TABLE_MODE;

            if (tn === $$1.TABLE) {
                p._processToken(token);
            }
        }
    } else if (
        tn !== $$1.BODY &&
        tn !== $$1.COL &&
        tn !== $$1.COLGROUP &&
        tn !== $$1.HTML &&
        tn !== $$1.TBODY &&
        tn !== $$1.TD &&
        tn !== $$1.TFOOT &&
        tn !== $$1.TH &&
        tn !== $$1.THEAD &&
        tn !== $$1.TR
    ) {
        endTagInBody(p, token);
    }
}

// The "in column group" insertion mode
//------------------------------------------------------------------
function startTagInColumnGroup(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.COL) {
        p._appendElement(token, NS$1.HTML);
        token.ackSelfClosing = true;
    } else if (tn === $$1.TEMPLATE) {
        startTagInHead(p, token);
    } else {
        tokenInColumnGroup(p, token);
    }
}

function endTagInColumnGroup(p, token) {
    const tn = token.tagName;

    if (tn === $$1.COLGROUP) {
        if (p.openElements.currentTagName === $$1.COLGROUP) {
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
        }
    } else if (tn === $$1.TEMPLATE) {
        endTagInHead(p, token);
    } else if (tn !== $$1.COL) {
        tokenInColumnGroup(p, token);
    }
}

function tokenInColumnGroup(p, token) {
    if (p.openElements.currentTagName === $$1.COLGROUP) {
        p.openElements.pop();
        p.insertionMode = IN_TABLE_MODE;
        p._processToken(token);
    }
}

// The "in table body" insertion mode
//------------------------------------------------------------------
function startTagInTableBody(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TR) {
        p.openElements.clearBackToTableBodyContext();
        p._insertElement(token, NS$1.HTML);
        p.insertionMode = IN_ROW_MODE;
    } else if (tn === $$1.TH || tn === $$1.TD) {
        p.openElements.clearBackToTableBodyContext();
        p._insertFakeElement($$1.TR);
        p.insertionMode = IN_ROW_MODE;
        p._processToken(token);
    } else if (
        tn === $$1.CAPTION ||
        tn === $$1.COL ||
        tn === $$1.COLGROUP ||
        tn === $$1.TBODY ||
        tn === $$1.TFOOT ||
        tn === $$1.THEAD
    ) {
        if (p.openElements.hasTableBodyContextInTableScope()) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
            p._processToken(token);
        }
    } else {
        startTagInTable(p, token);
    }
}

function endTagInTableBody(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TBODY || tn === $$1.TFOOT || tn === $$1.THEAD) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
        }
    } else if (tn === $$1.TABLE) {
        if (p.openElements.hasTableBodyContextInTableScope()) {
            p.openElements.clearBackToTableBodyContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_MODE;
            p._processToken(token);
        }
    } else if (
        (tn !== $$1.BODY && tn !== $$1.CAPTION && tn !== $$1.COL && tn !== $$1.COLGROUP) ||
        (tn !== $$1.HTML && tn !== $$1.TD && tn !== $$1.TH && tn !== $$1.TR)
    ) {
        endTagInTable(p, token);
    }
}

// The "in row" insertion mode
//------------------------------------------------------------------
function startTagInRow(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TH || tn === $$1.TD) {
        p.openElements.clearBackToTableRowContext();
        p._insertElement(token, NS$1.HTML);
        p.insertionMode = IN_CELL_MODE;
        p.activeFormattingElements.insertMarker();
    } else if (
        tn === $$1.CAPTION ||
        tn === $$1.COL ||
        tn === $$1.COLGROUP ||
        tn === $$1.TBODY ||
        tn === $$1.TFOOT ||
        tn === $$1.THEAD ||
        tn === $$1.TR
    ) {
        if (p.openElements.hasInTableScope($$1.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
            p._processToken(token);
        }
    } else {
        startTagInTable(p, token);
    }
}

function endTagInRow(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TR) {
        if (p.openElements.hasInTableScope($$1.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
        }
    } else if (tn === $$1.TABLE) {
        if (p.openElements.hasInTableScope($$1.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
            p._processToken(token);
        }
    } else if (tn === $$1.TBODY || tn === $$1.TFOOT || tn === $$1.THEAD) {
        if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($$1.TR)) {
            p.openElements.clearBackToTableRowContext();
            p.openElements.pop();
            p.insertionMode = IN_TABLE_BODY_MODE;
            p._processToken(token);
        }
    } else if (
        (tn !== $$1.BODY && tn !== $$1.CAPTION && tn !== $$1.COL && tn !== $$1.COLGROUP) ||
        (tn !== $$1.HTML && tn !== $$1.TD && tn !== $$1.TH)
    ) {
        endTagInTable(p, token);
    }
}

// The "in cell" insertion mode
//------------------------------------------------------------------
function startTagInCell(p, token) {
    const tn = token.tagName;

    if (
        tn === $$1.CAPTION ||
        tn === $$1.COL ||
        tn === $$1.COLGROUP ||
        tn === $$1.TBODY ||
        tn === $$1.TD ||
        tn === $$1.TFOOT ||
        tn === $$1.TH ||
        tn === $$1.THEAD ||
        tn === $$1.TR
    ) {
        if (p.openElements.hasInTableScope($$1.TD) || p.openElements.hasInTableScope($$1.TH)) {
            p._closeTableCell();
            p._processToken(token);
        }
    } else {
        startTagInBody(p, token);
    }
}

function endTagInCell(p, token) {
    const tn = token.tagName;

    if (tn === $$1.TD || tn === $$1.TH) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped(tn);
            p.activeFormattingElements.clearToLastMarker();
            p.insertionMode = IN_ROW_MODE;
        }
    } else if (tn === $$1.TABLE || tn === $$1.TBODY || tn === $$1.TFOOT || tn === $$1.THEAD || tn === $$1.TR) {
        if (p.openElements.hasInTableScope(tn)) {
            p._closeTableCell();
            p._processToken(token);
        }
    } else if (tn !== $$1.BODY && tn !== $$1.CAPTION && tn !== $$1.COL && tn !== $$1.COLGROUP && tn !== $$1.HTML) {
        endTagInBody(p, token);
    }
}

// The "in select" insertion mode
//------------------------------------------------------------------
function startTagInSelect(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.OPTION) {
        if (p.openElements.currentTagName === $$1.OPTION) {
            p.openElements.pop();
        }

        p._insertElement(token, NS$1.HTML);
    } else if (tn === $$1.OPTGROUP) {
        if (p.openElements.currentTagName === $$1.OPTION) {
            p.openElements.pop();
        }

        if (p.openElements.currentTagName === $$1.OPTGROUP) {
            p.openElements.pop();
        }

        p._insertElement(token, NS$1.HTML);
    } else if (tn === $$1.INPUT || tn === $$1.KEYGEN || tn === $$1.TEXTAREA || tn === $$1.SELECT) {
        if (p.openElements.hasInSelectScope($$1.SELECT)) {
            p.openElements.popUntilTagNamePopped($$1.SELECT);
            p._resetInsertionMode();

            if (tn !== $$1.SELECT) {
                p._processToken(token);
            }
        }
    } else if (tn === $$1.SCRIPT || tn === $$1.TEMPLATE) {
        startTagInHead(p, token);
    }
}

function endTagInSelect(p, token) {
    const tn = token.tagName;

    if (tn === $$1.OPTGROUP) {
        const prevOpenElement = p.openElements.items[p.openElements.stackTop - 1];
        const prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);

        if (p.openElements.currentTagName === $$1.OPTION && prevOpenElementTn === $$1.OPTGROUP) {
            p.openElements.pop();
        }

        if (p.openElements.currentTagName === $$1.OPTGROUP) {
            p.openElements.pop();
        }
    } else if (tn === $$1.OPTION) {
        if (p.openElements.currentTagName === $$1.OPTION) {
            p.openElements.pop();
        }
    } else if (tn === $$1.SELECT && p.openElements.hasInSelectScope($$1.SELECT)) {
        p.openElements.popUntilTagNamePopped($$1.SELECT);
        p._resetInsertionMode();
    } else if (tn === $$1.TEMPLATE) {
        endTagInHead(p, token);
    }
}

//12.2.5.4.17 The "in select in table" insertion mode
//------------------------------------------------------------------
function startTagInSelectInTable(p, token) {
    const tn = token.tagName;

    if (
        tn === $$1.CAPTION ||
        tn === $$1.TABLE ||
        tn === $$1.TBODY ||
        tn === $$1.TFOOT ||
        tn === $$1.THEAD ||
        tn === $$1.TR ||
        tn === $$1.TD ||
        tn === $$1.TH
    ) {
        p.openElements.popUntilTagNamePopped($$1.SELECT);
        p._resetInsertionMode();
        p._processToken(token);
    } else {
        startTagInSelect(p, token);
    }
}

function endTagInSelectInTable(p, token) {
    const tn = token.tagName;

    if (
        tn === $$1.CAPTION ||
        tn === $$1.TABLE ||
        tn === $$1.TBODY ||
        tn === $$1.TFOOT ||
        tn === $$1.THEAD ||
        tn === $$1.TR ||
        tn === $$1.TD ||
        tn === $$1.TH
    ) {
        if (p.openElements.hasInTableScope(tn)) {
            p.openElements.popUntilTagNamePopped($$1.SELECT);
            p._resetInsertionMode();
            p._processToken(token);
        }
    } else {
        endTagInSelect(p, token);
    }
}

// The "in template" insertion mode
//------------------------------------------------------------------
function startTagInTemplate(p, token) {
    const tn = token.tagName;

    if (
        tn === $$1.BASE ||
        tn === $$1.BASEFONT ||
        tn === $$1.BGSOUND ||
        tn === $$1.LINK ||
        tn === $$1.META ||
        tn === $$1.NOFRAMES ||
        tn === $$1.SCRIPT ||
        tn === $$1.STYLE ||
        tn === $$1.TEMPLATE ||
        tn === $$1.TITLE
    ) {
        startTagInHead(p, token);
    } else {
        const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;

        p._popTmplInsertionMode();
        p._pushTmplInsertionMode(newInsertionMode);
        p.insertionMode = newInsertionMode;
        p._processToken(token);
    }
}

function endTagInTemplate(p, token) {
    if (token.tagName === $$1.TEMPLATE) {
        endTagInHead(p, token);
    }
}

function eofInTemplate(p, token) {
    if (p.openElements.tmplCount > 0) {
        p.openElements.popUntilTagNamePopped($$1.TEMPLATE);
        p.activeFormattingElements.clearToLastMarker();
        p._popTmplInsertionMode();
        p._resetInsertionMode();
        p._processToken(token);
    } else {
        p.stopped = true;
    }
}

// The "after body" insertion mode
//------------------------------------------------------------------
function startTagAfterBody(p, token) {
    if (token.tagName === $$1.HTML) {
        startTagInBody(p, token);
    } else {
        tokenAfterBody(p, token);
    }
}

function endTagAfterBody(p, token) {
    if (token.tagName === $$1.HTML) {
        if (!p.fragmentContext) {
            p.insertionMode = AFTER_AFTER_BODY_MODE;
        }
    } else {
        tokenAfterBody(p, token);
    }
}

function tokenAfterBody(p, token) {
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}

// The "in frameset" insertion mode
//------------------------------------------------------------------
function startTagInFrameset(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.FRAMESET) {
        p._insertElement(token, NS$1.HTML);
    } else if (tn === $$1.FRAME) {
        p._appendElement(token, NS$1.HTML);
        token.ackSelfClosing = true;
    } else if (tn === $$1.NOFRAMES) {
        startTagInHead(p, token);
    }
}

function endTagInFrameset(p, token) {
    if (token.tagName === $$1.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
        p.openElements.pop();

        if (!p.fragmentContext && p.openElements.currentTagName !== $$1.FRAMESET) {
            p.insertionMode = AFTER_FRAMESET_MODE;
        }
    }
}

// The "after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterFrameset(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.NOFRAMES) {
        startTagInHead(p, token);
    }
}

function endTagAfterFrameset(p, token) {
    if (token.tagName === $$1.HTML) {
        p.insertionMode = AFTER_AFTER_FRAMESET_MODE;
    }
}

// The "after after body" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterBody(p, token) {
    if (token.tagName === $$1.HTML) {
        startTagInBody(p, token);
    } else {
        tokenAfterAfterBody(p, token);
    }
}

function tokenAfterAfterBody(p, token) {
    p.insertionMode = IN_BODY_MODE;
    p._processToken(token);
}

// The "after after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterFrameset(p, token) {
    const tn = token.tagName;

    if (tn === $$1.HTML) {
        startTagInBody(p, token);
    } else if (tn === $$1.NOFRAMES) {
        startTagInHead(p, token);
    }
}

// The rules for parsing tokens in foreign content
//------------------------------------------------------------------
function nullCharacterInForeignContent(p, token) {
    token.chars = unicode.REPLACEMENT_CHARACTER;
    p._insertCharacters(token);
}

function characterInForeignContent(p, token) {
    p._insertCharacters(token);
    p.framesetOk = false;
}

function startTagInForeignContent(p, token) {
    if (foreignContent.causesExit(token) && !p.fragmentContext) {
        while (
            p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS$1.HTML &&
            !p._isIntegrationPoint(p.openElements.current)
        ) {
            p.openElements.pop();
        }

        p._processToken(token);
    } else {
        const current = p._getAdjustedCurrentElement();
        const currentNs = p.treeAdapter.getNamespaceURI(current);

        if (currentNs === NS$1.MATHML) {
            foreignContent.adjustTokenMathMLAttrs(token);
        } else if (currentNs === NS$1.SVG) {
            foreignContent.adjustTokenSVGTagName(token);
            foreignContent.adjustTokenSVGAttrs(token);
        }

        foreignContent.adjustTokenXMLAttrs(token);

        if (token.selfClosing) {
            p._appendElement(token, currentNs);
        } else {
            p._insertElement(token, currentNs);
        }

        token.ackSelfClosing = true;
    }
}

function endTagInForeignContent(p, token) {
    for (let i = p.openElements.stackTop; i > 0; i--) {
        const element = p.openElements.items[i];

        if (p.treeAdapter.getNamespaceURI(element) === NS$1.HTML) {
            p._processToken(token);
            break;
        }

        if (p.treeAdapter.getTagName(element).toLowerCase() === token.tagName) {
            p.openElements.popUntilElementPopped(element);
            break;
        }
    }
}

const defaultTreeAdapter = _default;
const mergeOptions = mergeOptions$2;
const doctype$1 = doctype$3;
const HTML = html;

//Aliases
const $ = HTML.TAG_NAMES;
const NS = HTML.NAMESPACES;

//Default serializer options
const DEFAULT_OPTIONS = {
    treeAdapter: defaultTreeAdapter
};

//Escaping regexes
const AMP_REGEX = /&/g;
const NBSP_REGEX = /\u00a0/g;
const DOUBLE_QUOTE_REGEX = /"/g;
const LT_REGEX = /</g;
const GT_REGEX = />/g;

//Serializer
class Serializer$1 {
    constructor(node, options) {
        this.options = mergeOptions(DEFAULT_OPTIONS, options);
        this.treeAdapter = this.options.treeAdapter;

        this.html = '';
        this.startNode = node;
    }

    //API
    serialize() {
        this._serializeChildNodes(this.startNode);

        return this.html;
    }

    //Internals
    _serializeChildNodes(parentNode) {
        const childNodes = this.treeAdapter.getChildNodes(parentNode);

        if (childNodes) {
            for (let i = 0, cnLength = childNodes.length; i < cnLength; i++) {
                const currentNode = childNodes[i];

                if (this.treeAdapter.isElementNode(currentNode)) {
                    this._serializeElement(currentNode);
                } else if (this.treeAdapter.isTextNode(currentNode)) {
                    this._serializeTextNode(currentNode);
                } else if (this.treeAdapter.isCommentNode(currentNode)) {
                    this._serializeCommentNode(currentNode);
                } else if (this.treeAdapter.isDocumentTypeNode(currentNode)) {
                    this._serializeDocumentTypeNode(currentNode);
                }
            }
        }
    }

    _serializeElement(node) {
        const tn = this.treeAdapter.getTagName(node);
        const ns = this.treeAdapter.getNamespaceURI(node);

        this.html += '<' + tn;
        this._serializeAttributes(node);
        this.html += '>';

        if (
            tn !== $.AREA &&
            tn !== $.BASE &&
            tn !== $.BASEFONT &&
            tn !== $.BGSOUND &&
            tn !== $.BR &&
            tn !== $.COL &&
            tn !== $.EMBED &&
            tn !== $.FRAME &&
            tn !== $.HR &&
            tn !== $.IMG &&
            tn !== $.INPUT &&
            tn !== $.KEYGEN &&
            tn !== $.LINK &&
            tn !== $.META &&
            tn !== $.PARAM &&
            tn !== $.SOURCE &&
            tn !== $.TRACK &&
            tn !== $.WBR
        ) {
            const childNodesHolder =
                tn === $.TEMPLATE && ns === NS.HTML ? this.treeAdapter.getTemplateContent(node) : node;

            this._serializeChildNodes(childNodesHolder);
            this.html += '</' + tn + '>';
        }
    }

    _serializeAttributes(node) {
        const attrs = this.treeAdapter.getAttrList(node);

        for (let i = 0, attrsLength = attrs.length; i < attrsLength; i++) {
            const attr = attrs[i];
            const value = Serializer$1.escapeString(attr.value, true);

            this.html += ' ';

            if (!attr.namespace) {
                this.html += attr.name;
            } else if (attr.namespace === NS.XML) {
                this.html += 'xml:' + attr.name;
            } else if (attr.namespace === NS.XMLNS) {
                if (attr.name !== 'xmlns') {
                    this.html += 'xmlns:';
                }

                this.html += attr.name;
            } else if (attr.namespace === NS.XLINK) {
                this.html += 'xlink:' + attr.name;
            } else {
                this.html += attr.prefix + ':' + attr.name;
            }

            this.html += '="' + value + '"';
        }
    }

    _serializeTextNode(node) {
        const content = this.treeAdapter.getTextNodeContent(node);
        const parent = this.treeAdapter.getParentNode(node);
        let parentTn = void 0;

        if (parent && this.treeAdapter.isElementNode(parent)) {
            parentTn = this.treeAdapter.getTagName(parent);
        }

        if (
            parentTn === $.STYLE ||
            parentTn === $.SCRIPT ||
            parentTn === $.XMP ||
            parentTn === $.IFRAME ||
            parentTn === $.NOEMBED ||
            parentTn === $.NOFRAMES ||
            parentTn === $.PLAINTEXT ||
            parentTn === $.NOSCRIPT
        ) {
            this.html += content;
        } else {
            this.html += Serializer$1.escapeString(content, false);
        }
    }

    _serializeCommentNode(node) {
        this.html += '<!--' + this.treeAdapter.getCommentNodeContent(node) + '-->';
    }

    _serializeDocumentTypeNode(node) {
        const name = this.treeAdapter.getDocumentTypeNodeName(node);

        this.html += '<' + doctype$1.serializeContent(name, null, null) + '>';
    }
}

// NOTE: used in tests and by rewriting stream
Serializer$1.escapeString = function(str, attrMode) {
    str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');

    if (attrMode) {
        str = str.replace(DOUBLE_QUOTE_REGEX, '&quot;');
    } else {
        str = str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');
    }

    return str;
};

var serializer = Serializer$1;

const Parser = parser;
const Serializer = serializer;

// Shorthands
lib$5.parse = function parse(html, options) {
    const parser = new Parser(options);

    return parser.parse(html);
};

lib$5.parseFragment = function parseFragment(fragmentContext, html, options) {
    if (typeof fragmentContext === 'string') {
        options = html;
        html = fragmentContext;
        fragmentContext = null;
    }

    const parser = new Parser(options);

    return parser.parseFragment(html, fragmentContext);
};

lib$5.serialize = function(node, options) {
    const serializer = new Serializer(node, options);

    return serializer.serialize();
};

var lib$4 = {};

const doctype = doctype$3;
const { DOCUMENT_MODE } = html;

//Conversion tables for DOM Level1 structure emulation
const nodeTypes = {
    element: 1,
    text: 3,
    cdata: 4,
    comment: 8
};

const nodePropertyShorthands = {
    tagName: 'name',
    childNodes: 'children',
    parentNode: 'parent',
    previousSibling: 'prev',
    nextSibling: 'next',
    nodeValue: 'data'
};

//Node
class Node {
    constructor(props) {
        for (const key of Object.keys(props)) {
            this[key] = props[key];
        }
    }

    get firstChild() {
        const children = this.children;

        return (children && children[0]) || null;
    }

    get lastChild() {
        const children = this.children;

        return (children && children[children.length - 1]) || null;
    }

    get nodeType() {
        return nodeTypes[this.type] || nodeTypes.element;
    }
}

Object.keys(nodePropertyShorthands).forEach(key => {
    const shorthand = nodePropertyShorthands[key];

    Object.defineProperty(Node.prototype, key, {
        get: function() {
            return this[shorthand] || null;
        },
        set: function(val) {
            this[shorthand] = val;
            return val;
        }
    });
});

//Node construction
lib$4.createDocument = function() {
    return new Node({
        type: 'root',
        name: 'root',
        parent: null,
        prev: null,
        next: null,
        children: [],
        'x-mode': DOCUMENT_MODE.NO_QUIRKS
    });
};

lib$4.createDocumentFragment = function() {
    return new Node({
        type: 'root',
        name: 'root',
        parent: null,
        prev: null,
        next: null,
        children: []
    });
};

lib$4.createElement = function(tagName, namespaceURI, attrs) {
    const attribs = Object.create(null);
    const attribsNamespace = Object.create(null);
    const attribsPrefix = Object.create(null);

    for (let i = 0; i < attrs.length; i++) {
        const attrName = attrs[i].name;

        attribs[attrName] = attrs[i].value;
        attribsNamespace[attrName] = attrs[i].namespace;
        attribsPrefix[attrName] = attrs[i].prefix;
    }

    return new Node({
        type: tagName === 'script' || tagName === 'style' ? tagName : 'tag',
        name: tagName,
        namespace: namespaceURI,
        attribs: attribs,
        'x-attribsNamespace': attribsNamespace,
        'x-attribsPrefix': attribsPrefix,
        children: [],
        parent: null,
        prev: null,
        next: null
    });
};

lib$4.createCommentNode = function(data) {
    return new Node({
        type: 'comment',
        data: data,
        parent: null,
        prev: null,
        next: null
    });
};

const createTextNode = function(value) {
    return new Node({
        type: 'text',
        data: value,
        parent: null,
        prev: null,
        next: null
    });
};

//Tree mutation
const appendChild = (lib$4.appendChild = function(parentNode, newNode) {
    const prev = parentNode.children[parentNode.children.length - 1];

    if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
    }

    parentNode.children.push(newNode);
    newNode.parent = parentNode;
});

const insertBefore = (lib$4.insertBefore = function(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.children.indexOf(referenceNode);
    const prev = referenceNode.prev;

    if (prev) {
        prev.next = newNode;
        newNode.prev = prev;
    }

    referenceNode.prev = newNode;
    newNode.next = referenceNode;

    parentNode.children.splice(insertionIdx, 0, newNode);
    newNode.parent = parentNode;
});

lib$4.setTemplateContent = function(templateElement, contentElement) {
    appendChild(templateElement, contentElement);
};

lib$4.getTemplateContent = function(templateElement) {
    return templateElement.children[0];
};

lib$4.setDocumentType = function(document, name, publicId, systemId) {
    const data = doctype.serializeContent(name, publicId, systemId);
    let doctypeNode = null;

    for (let i = 0; i < document.children.length; i++) {
        if (document.children[i].type === 'directive' && document.children[i].name === '!doctype') {
            doctypeNode = document.children[i];
            break;
        }
    }

    if (doctypeNode) {
        doctypeNode.data = data;
        doctypeNode['x-name'] = name;
        doctypeNode['x-publicId'] = publicId;
        doctypeNode['x-systemId'] = systemId;
    } else {
        appendChild(
            document,
            new Node({
                type: 'directive',
                name: '!doctype',
                data: data,
                'x-name': name,
                'x-publicId': publicId,
                'x-systemId': systemId
            })
        );
    }
};

lib$4.setDocumentMode = function(document, mode) {
    document['x-mode'] = mode;
};

lib$4.getDocumentMode = function(document) {
    return document['x-mode'];
};

lib$4.detachNode = function(node) {
    if (node.parent) {
        const idx = node.parent.children.indexOf(node);
        const prev = node.prev;
        const next = node.next;

        node.prev = null;
        node.next = null;

        if (prev) {
            prev.next = next;
        }

        if (next) {
            next.prev = prev;
        }

        node.parent.children.splice(idx, 1);
        node.parent = null;
    }
};

lib$4.insertText = function(parentNode, text) {
    const lastChild = parentNode.children[parentNode.children.length - 1];

    if (lastChild && lastChild.type === 'text') {
        lastChild.data += text;
    } else {
        appendChild(parentNode, createTextNode(text));
    }
};

lib$4.insertTextBefore = function(parentNode, text, referenceNode) {
    const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];

    if (prevNode && prevNode.type === 'text') {
        prevNode.data += text;
    } else {
        insertBefore(parentNode, createTextNode(text), referenceNode);
    }
};

lib$4.adoptAttributes = function(recipient, attrs) {
    for (let i = 0; i < attrs.length; i++) {
        const attrName = attrs[i].name;

        if (typeof recipient.attribs[attrName] === 'undefined') {
            recipient.attribs[attrName] = attrs[i].value;
            recipient['x-attribsNamespace'][attrName] = attrs[i].namespace;
            recipient['x-attribsPrefix'][attrName] = attrs[i].prefix;
        }
    }
};

//Tree traversing
lib$4.getFirstChild = function(node) {
    return node.children[0];
};

lib$4.getChildNodes = function(node) {
    return node.children;
};

lib$4.getParentNode = function(node) {
    return node.parent;
};

lib$4.getAttrList = function(element) {
    const attrList = [];

    for (const name in element.attribs) {
        attrList.push({
            name: name,
            value: element.attribs[name],
            namespace: element['x-attribsNamespace'][name],
            prefix: element['x-attribsPrefix'][name]
        });
    }

    return attrList;
};

//Node data
lib$4.getTagName = function(element) {
    return element.name;
};

lib$4.getNamespaceURI = function(element) {
    return element.namespace;
};

lib$4.getTextNodeContent = function(textNode) {
    return textNode.data;
};

lib$4.getCommentNodeContent = function(commentNode) {
    return commentNode.data;
};

lib$4.getDocumentTypeNodeName = function(doctypeNode) {
    return doctypeNode['x-name'];
};

lib$4.getDocumentTypeNodePublicId = function(doctypeNode) {
    return doctypeNode['x-publicId'];
};

lib$4.getDocumentTypeNodeSystemId = function(doctypeNode) {
    return doctypeNode['x-systemId'];
};

//Node types
lib$4.isTextNode = function(node) {
    return node.type === 'text';
};

lib$4.isCommentNode = function(node) {
    return node.type === 'comment';
};

lib$4.isDocumentTypeNode = function(node) {
    return node.type === 'directive' && node.name === '!doctype';
};

lib$4.isElementNode = function(node) {
    return !!node.attribs;
};

// Source code location
lib$4.setNodeSourceCodeLocation = function(node, location) {
    node.sourceCodeLocation = location;
};

lib$4.getNodeSourceCodeLocation = function(node) {
    return node.sourceCodeLocation;
};

lib$4.updateNodeSourceCodeLocation = function(node, endLocation) {
    node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);
};

var parse5 = lib$5;
var htmlparser2Adapter = lib$4;

parse5$1.parse = function (content, options, isDocument) {
  var opts = {
    scriptingEnabled:
      typeof options.scriptingEnabled === 'boolean'
        ? options.scriptingEnabled
        : true,
    treeAdapter: htmlparser2Adapter,
    sourceCodeLocationInfo: options.sourceCodeLocationInfo,
  };

  var context = options.context;

  return isDocument
    ? parse5.parse(content, opts)
    : parse5.parseFragment(context, content, opts);
};

parse5$1.render = function (dom) {
  // `dom-serializer` passes over the special "root" node and renders the
  // node's children in its place. To mimic this behavior with `parse5`, an
  // equivalent operation must be applied to the input array.
  var nodes = 'length' in dom ? dom : [dom];
  for (var index = 0; index < nodes.length; index += 1) {
    if (nodes[index].type === 'root') {
      nodes.splice.apply(nodes, [index, 1].concat(nodes[index].children));
    }
  }

  return parse5.serialize(
    { children: nodes },
    { treeAdapter: htmlparser2Adapter }
  );
};

(function (module, exports) {
/*
  Module Dependencies
*/
var DomUtils = lib$b.DomUtils;
var parseWithHtmlparser2 = htmlparser2$1.parse;
var parseWithParse5 = parse5$1.parse;
var Document = lib$a.Document;

/*
  Parser
*/
exports = module.exports = function parse(content, options, isDocument) {
  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {
    content = content.toString();
  }

  if (typeof content === 'string') {
    return options.xmlMode || options._useHtmlParser2
      ? parseWithHtmlparser2(content, options)
      : parseWithParse5(content, options, isDocument);
  }

  if (
    typeof content === 'object' &&
    content != null &&
    content.type === 'root'
  ) {
    // If `content` is already a root, just return it
    return content;
  }

  // Add conent to new root element
  var root = new Document(content);

  // Update the DOM using the root
  exports.update(content, root);

  return root;
};

/**
 * Update the dom structure, for one changed layer.
 *
 * @param {Node[] | Node} arr - The new children.
 * @param {NodeWithChildren} parent - The new parent.
 * @returns {Node} The parent node.
 */
exports.update = function (arr, parent) {
  // normalize
  if (!Array.isArray(arr)) arr = [arr];

  // Update parent
  if (parent) {
    parent.children = arr;
  } else {
    parent = null;
  }

  // Update neighbors
  for (var i = 0; i < arr.length; i++) {
    var node = arr[i];

    // Cleanly remove existing nodes from their previous structures.
    if (node.parent && node.parent.children !== arr) {
      DomUtils.removeElement(node);
    }

    if (parent) {
      node.prev = arr[i - 1] || null;
      node.next = arr[i + 1] || null;
    } else {
      node.prev = node.next = null;
    }

    node.parent = parent;
  }

  return parent;
};
}(parse$e, parse$e.exports));

var options = {};

/** Cheerio default options. */
options.default = {
  xml: false,
  decodeEntities: true,
};

var xmlModeDefault = { _useHtmlParser2: true, xmlMode: true };

options.flatten = function (options) {
  return options && options.xml
    ? typeof options.xml === 'boolean'
      ? xmlModeDefault
      : Object.assign({}, xmlModeDefault, options.xml)
    : options;
};

var utils$n = {};

var htmlparser2 = lib$b;
var domhandler = lib$a;

/**
 * Check if the DOM element is a tag.
 *
 * `isTag(type)` includes `<script>` and `<style>` tags.
 *
 * @private
 * @param {Node} type - DOM node to check.
 * @returns {boolean}
 */
utils$n.isTag = htmlparser2.DomUtils.isTag;

/**
 * Convert a string to camel case notation.
 *
 * @private
 * @param {string} str - String to be converted.
 * @returns {string} String in camel case notation.
 */
utils$n.camelCase = function (str) {
  return str.replace(/[_.-](\w|$)/g, function (_, x) {
    return x.toUpperCase();
  });
};

/**
 * Convert a string from camel case to "CSS case", where word boundaries are
 * described by hyphens ("-") and all characters are lower-case.
 *
 * @private
 * @param {string} str - String to be converted.
 * @returns {string} String in "CSS case".
 */
utils$n.cssCase = function (str) {
  return str.replace(/[A-Z]/g, '-$&').toLowerCase();
};

/**
 * Iterate over each DOM element without creating intermediary Cheerio instances.
 *
 * This is indented for use internally to avoid otherwise unnecessary memory
 * pressure introduced by _make.
 *
 * @param {Cheerio} cheerio - Cheerio object.
 * @param {Function} fn - Function to call.
 * @returns {Cheerio} The original instance.
 */
utils$n.domEach = function (cheerio, fn) {
  var i = 0;
  var len = cheerio.length;
  while (i < len && fn.call(cheerio, i, cheerio[i]) !== false) ++i;
  return cheerio;
};

/**
 * Create a deep copy of the given DOM structure. Sets the parents of the copies
 * of the passed nodes to `null`.
 *
 * @private
 * @param {Node | Node[]} dom - The htmlparser2-compliant DOM structure.
 * @returns {Node[]} - The cloned DOM.
 */
utils$n.cloneDom = function (dom) {
  var clone =
    'length' in dom
      ? Array.prototype.map.call(dom, function (el) {
          return domhandler.cloneNode(el, true);
        })
      : [domhandler.cloneNode(dom, true)];

  // Add a root node around the cloned nodes
  var root = new domhandler.Document(clone);
  clone.forEach(function (node) {
    node.parent = root;
  });

  return clone;
};

/**
 * A simple way to check for HTML strings. Tests for a `<` within a string,
 * immediate followed by a letter and eventually followed by a `>`.
 *
 * @private
 */
var quickExpr = /<[a-zA-Z][^]*>/;

/**
 * Check if string is HTML.
 *
 * @private
 * @param {string} str - String to check.
 * @returns {boolean} Indicates if `str` is HTML.
 */
utils$n.isHtml = function (str) {
  // Run the regex
  return quickExpr.test(str);
};

var attributes$2 = {};

var _static = {};

var lib$3 = {};

var lib$2 = {};

var parse$d = {};

var __spreadArray$4 = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(parse$d, "__esModule", { value: true });
parse$d.isTraversal = void 0;
var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
// Modified version of https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L87
var reAttr = /^\s*(?:(\*|[-\w]*)\|)?((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])((?:[^\\]|\\[^])*?)\4|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*([iIsS])?\s*\]/;
var actionTypes$1 = {
    undefined: "exists",
    "": "equals",
    "~": "element",
    "^": "start",
    $: "end",
    "*": "any",
    "!": "not",
    "|": "hyphen",
};
var Traversals = {
    ">": "child",
    "<": "parent",
    "~": "sibling",
    "+": "adjacent",
};
var attribSelectors = {
    "#": ["id", "equals"],
    ".": ["class", "element"],
};
// Pseudos, whose data property is parsed as well.
var unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "host",
    "host-context",
]);
var traversalNames = new Set(__spreadArray$4([
    "descendant"
], Object.keys(Traversals).map(function (k) { return Traversals[k]; })));
/**
 * Attributes that are case-insensitive in HTML.
 *
 * @private
 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
 */
var caseInsensitiveAttributes = new Set([
    "accept",
    "accept-charset",
    "align",
    "alink",
    "axis",
    "bgcolor",
    "charset",
    "checked",
    "clear",
    "codetype",
    "color",
    "compact",
    "declare",
    "defer",
    "dir",
    "direction",
    "disabled",
    "enctype",
    "face",
    "frame",
    "hreflang",
    "http-equiv",
    "lang",
    "language",
    "link",
    "media",
    "method",
    "multiple",
    "nohref",
    "noresize",
    "noshade",
    "nowrap",
    "readonly",
    "rel",
    "rev",
    "rules",
    "scope",
    "scrolling",
    "selected",
    "shape",
    "target",
    "text",
    "type",
    "valign",
    "valuetype",
    "vlink",
]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal(selector) {
    return traversalNames.has(selector.type);
}
parse$d.isTraversal = isTraversal;
var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
var quotes = new Set(['"', "'"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
    var high = parseInt(escaped, 16) - 0x10000;
    // NaN means non-codepoint
    return high !== high || escapedWhitespace
        ? escaped
        : high < 0
            ? // BMP codepoint
                String.fromCharCode(high + 0x10000)
            : // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
}
function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
}
function isWhitespace(c) {
    return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse$c(selector, options) {
    var subselects = [];
    var endIndex = parseSelector(subselects, "" + selector, options, 0);
    if (endIndex < selector.length) {
        throw new Error("Unmatched selector: " + selector.slice(endIndex));
    }
    return subselects;
}
parse$d.default = parse$c;
function parseSelector(subselects, selector, options, selectorIndex) {
    var _a, _b;
    if (options === void 0) { options = {}; }
    var tokens = [];
    var sawWS = false;
    function getName(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
            throw new Error("Expected name, found " + selector.slice(selectorIndex));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
        while (isWhitespace(selector.charAt(selectorIndex + offset)))
            offset++;
        selectorIndex += offset;
    }
    function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charAt(--pos) === "\\")
            slashCount++;
        return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
        }
    }
    stripWhitespace(0);
    while (selector !== "") {
        var firstChar = selector.charAt(selectorIndex);
        if (isWhitespace(firstChar)) {
            sawWS = true;
            stripWhitespace(1);
        }
        else if (firstChar in Traversals) {
            ensureNotTraversal();
            tokens.push({ type: Traversals[firstChar] });
            sawWS = false;
            stripWhitespace(1);
        }
        else if (firstChar === ",") {
            if (tokens.length === 0) {
                throw new Error("Empty sub-selector");
            }
            subselects.push(tokens);
            tokens = [];
            sawWS = false;
            stripWhitespace(1);
        }
        else if (firstChar === "/" &&
            selector.charAt(selectorIndex + 1) === "*") {
            var endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
                throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
        }
        else {
            if (sawWS) {
                ensureNotTraversal();
                tokens.push({ type: "descendant" });
                sawWS = false;
            }
            if (firstChar in attribSelectors) {
                var _c = attribSelectors[firstChar], name_1 = _c[0], action = _c[1];
                tokens.push({
                    type: "attribute",
                    name: name_1,
                    action: action,
                    value: getName(1),
                    namespace: null,
                    // TODO: Add quirksMode option, which makes `ignoreCase` `true` for HTML.
                    ignoreCase: options.xmlMode ? null : false,
                });
            }
            else if (firstChar === "[") {
                var attributeMatch = selector
                    .slice(selectorIndex + 1)
                    .match(reAttr);
                if (!attributeMatch) {
                    throw new Error("Malformed attribute selector: " + selector.slice(selectorIndex));
                }
                var completeSelector = attributeMatch[0], _d = attributeMatch[1], namespace = _d === void 0 ? null : _d, baseName = attributeMatch[2], actionType = attributeMatch[3], _e = attributeMatch[5], quotedValue = _e === void 0 ? "" : _e, _f = attributeMatch[6], value = _f === void 0 ? quotedValue : _f, forceIgnore = attributeMatch[7];
                selectorIndex += completeSelector.length + 1;
                var name_2 = unescapeCSS(baseName);
                if ((_a = options.lowerCaseAttributeNames) !== null && _a !== void 0 ? _a : !options.xmlMode) {
                    name_2 = name_2.toLowerCase();
                }
                var ignoreCase = 
                // If the forceIgnore flag is set (either `i` or `s`), use that value
                forceIgnore
                    ? forceIgnore.toLowerCase() === "i"
                    : // If `xmlMode` is set, there are no rules; return `null`.
                        options.xmlMode
                            ? null
                            : // Otherwise, use the `caseInsensitiveAttributes` list.
                                caseInsensitiveAttributes.has(name_2);
                var attributeSelector = {
                    type: "attribute",
                    name: name_2,
                    action: actionTypes$1[actionType],
                    value: unescapeCSS(value),
                    namespace: namespace,
                    ignoreCase: ignoreCase,
                };
                tokens.push(attributeSelector);
            }
            else if (firstChar === ":") {
                if (selector.charAt(selectorIndex + 1) === ":") {
                    tokens.push({
                        type: "pseudo-element",
                        name: getName(2).toLowerCase(),
                    });
                    continue;
                }
                var name_3 = getName(1).toLowerCase();
                var data = null;
                if (selector.charAt(selectorIndex) === "(") {
                    if (unpackPseudos.has(name_3)) {
                        if (quotes.has(selector.charAt(selectorIndex + 1))) {
                            throw new Error("Pseudo-selector " + name_3 + " cannot be quoted");
                        }
                        data = [];
                        selectorIndex = parseSelector(data, selector, options, selectorIndex + 1);
                        if (selector.charAt(selectorIndex) !== ")") {
                            throw new Error("Missing closing parenthesis in :" + name_3 + " (" + selector + ")");
                        }
                        selectorIndex += 1;
                    }
                    else {
                        selectorIndex += 1;
                        var start = selectorIndex;
                        var counter = 1;
                        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
                            if (selector.charAt(selectorIndex) === "(" &&
                                !isEscaped(selectorIndex)) {
                                counter++;
                            }
                            else if (selector.charAt(selectorIndex) === ")" &&
                                !isEscaped(selectorIndex)) {
                                counter--;
                            }
                        }
                        if (counter) {
                            throw new Error("Parenthesis not matched");
                        }
                        data = selector.slice(start, selectorIndex - 1);
                        if (stripQuotesFromPseudos.has(name_3)) {
                            var quot = data.charAt(0);
                            if (quot === data.slice(-1) && quotes.has(quot)) {
                                data = data.slice(1, -1);
                            }
                            data = unescapeCSS(data);
                        }
                    }
                }
                tokens.push({ type: "pseudo", name: name_3, data: data });
            }
            else {
                var namespace = null;
                var name_4 = void 0;
                if (firstChar === "*") {
                    selectorIndex += 1;
                    name_4 = "*";
                }
                else if (reName.test(selector.slice(selectorIndex))) {
                    if (selector.charAt(selectorIndex) === "|") {
                        namespace = "";
                        selectorIndex += 1;
                    }
                    name_4 = getName(0);
                }
                else {
                    /*
                     * We have finished parsing the selector.
                     * Remove descendant tokens at the end if they exist,
                     * and return the last index, so that parsing can be
                     * picked up from here.
                     */
                    if (tokens.length &&
                        tokens[tokens.length - 1].type === "descendant") {
                        tokens.pop();
                    }
                    addToken(subselects, tokens);
                    return selectorIndex;
                }
                if (selector.charAt(selectorIndex) === "|") {
                    namespace = name_4;
                    if (selector.charAt(selectorIndex + 1) === "*") {
                        name_4 = "*";
                        selectorIndex += 2;
                    }
                    else {
                        name_4 = getName(1);
                    }
                }
                if (name_4 === "*") {
                    tokens.push({ type: "universal", namespace: namespace });
                }
                else {
                    if ((_b = options.lowerCaseTags) !== null && _b !== void 0 ? _b : !options.xmlMode) {
                        name_4 = name_4.toLowerCase();
                    }
                    tokens.push({ type: "tag", name: name_4, namespace: namespace });
                }
            }
        }
    }
    addToken(subselects, tokens);
    return selectorIndex;
}
function addToken(subselects, tokens) {
    if (subselects.length > 0 && tokens.length === 0) {
        throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
}

var stringify$b = {};

var __spreadArray$3 = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(stringify$b, "__esModule", { value: true });
var actionTypes = {
    equals: "",
    element: "~",
    start: "^",
    end: "$",
    any: "*",
    not: "!",
    hyphen: "|",
};
var charsToEscape = new Set(__spreadArray$3(__spreadArray$3([], Object.keys(actionTypes)
    .map(function (typeKey) { return actionTypes[typeKey]; })
    .filter(Boolean)), [
    ":",
    "[",
    "]",
    " ",
    "\\",
    "(",
    ")",
]));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify$a(selector) {
    return selector.map(stringifySubselector).join(", ");
}
stringify$b.default = stringify$a;
function stringifySubselector(token) {
    return token.map(stringifyToken).join("");
}
function stringifyToken(token) {
    switch (token.type) {
        // Simple types
        case "child":
            return " > ";
        case "parent":
            return " < ";
        case "sibling":
            return " ~ ";
        case "adjacent":
            return " + ";
        case "descendant":
            return " ";
        case "universal":
            return getNamespace(token.namespace) + "*";
        case "tag":
            return getNamespacedName(token);
        case "pseudo-element":
            return "::" + escapeName(token.name);
        case "pseudo":
            if (token.data === null)
                return ":" + escapeName(token.name);
            if (typeof token.data === "string") {
                return ":" + escapeName(token.name) + "(" + escapeName(token.data) + ")";
            }
            return ":" + escapeName(token.name) + "(" + stringify$a(token.data) + ")";
        case "attribute": {
            if (token.name === "id" &&
                token.action === "equals" &&
                !token.ignoreCase &&
                !token.namespace) {
                return "#" + escapeName(token.value);
            }
            if (token.name === "class" &&
                token.action === "element" &&
                !token.ignoreCase &&
                !token.namespace) {
                return "." + escapeName(token.value);
            }
            var name_1 = getNamespacedName(token);
            if (token.action === "exists") {
                return "[" + name_1 + "]";
            }
            return "[" + name_1 + actionTypes[token.action] + "='" + escapeName(token.value) + "'" + (token.ignoreCase ? "i" : token.ignoreCase === false ? "s" : "") + "]";
        }
    }
}
function getNamespacedName(token) {
    return "" + getNamespace(token.namespace) + escapeName(token.name);
}
function getNamespace(namespace) {
    return namespace !== null
        ? (namespace === "*" ? "*" : escapeName(namespace)) + "|"
        : "";
}
function escapeName(str) {
    return str
        .split("")
        .map(function (c) { return (charsToEscape.has(c) ? "\\" + c : c); })
        .join("");
}

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringify = exports.parse = void 0;
__exportStar(parse$d, exports);
var parse_1 = parse$d;
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return __importDefault(parse_1).default; } });
var stringify_1 = stringify$b;
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return __importDefault(stringify_1).default; } });
}(lib$2));

var lib$1 = {};

var boolbase = {
	trueFunc: function trueFunc(){
		return true;
	},
	falseFunc: function falseFunc(){
		return false;
	}
};

var compile$5 = {};

var sort = {};

var procedure = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTraversal = exports.procedure = void 0;
exports.procedure = {
    universal: 50,
    tag: 30,
    attribute: 1,
    pseudo: 0,
    "pseudo-element": 0,
    descendant: -1,
    child: -1,
    parent: -1,
    sibling: -1,
    adjacent: -1,
    _flexibleDescendant: -1,
};
function isTraversal(t) {
    return exports.procedure[t.type] < 0;
}
exports.isTraversal = isTraversal;
}(procedure));

Object.defineProperty(sort, "__esModule", { value: true });
var procedure_1$1 = procedure;
var attributes$1 = {
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4,
};
/**
 * Sort the parts of the passed selector,
 * as there is potential for optimization
 * (some types of selectors are faster than others)
 *
 * @param arr Selector to sort
 */
function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
            continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
        }
    }
}
sort.default = sortByProcedure;
function getProcedure(token) {
    var proc = procedure_1$1.procedure[token.type];
    if (token.type === "attribute") {
        proc = attributes$1[token.action];
        if (proc === attributes$1.equals && token.name === "id") {
            // Prefer ID selectors (eg. #ID)
            proc = 9;
        }
        if (token.ignoreCase) {
            /*
             * IgnoreCase adds some overhead, prefer "normal" token
             * this is a binary operation, to ensure it's still an int
             */
            proc >>= 1;
        }
    }
    else if (token.type === "pseudo") {
        if (!token.data) {
            proc = 3;
        }
        else if (token.name === "has" || token.name === "contains") {
            proc = 0; // Expensive in any case
        }
        else if (Array.isArray(token.data)) {
            // "matches" and "not"
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
                // TODO better handling of complex selectors
                if (token.data[i].length !== 1)
                    continue;
                var cur = getProcedure(token.data[i][0]);
                // Avoid executing :has or :contains
                if (cur === 0) {
                    proc = 0;
                    break;
                }
                if (cur > proc)
                    proc = cur;
            }
            if (token.data.length > 1 && proc > 0)
                proc -= 1;
        }
        else {
            proc = 1;
        }
    }
    return proc;
}

var general = {};

var attributes = {};

Object.defineProperty(attributes, "__esModule", { value: true });
attributes.attributeRules = void 0;
var boolbase_1$2 = boolbase;
/**
 * All reserved characters in a regex, used for escaping.
 *
 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
 */
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
    return value.replace(reChars, "\\$&");
}
/**
 * Attribute selectors
 */
attributes.attributeRules = {
    equals: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length === value.length &&
                    attr.toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
    },
    hyphen: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function hyphenIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    (attr.length === len || attr.charAt(len) === "-") &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                (attr.length === len || attr.charAt(len) === "-") &&
                attr.substr(0, len) === value &&
                next(elem));
        };
    },
    element: function (next, _a, _b) {
        var name = _a.name, value = _a.value, ignoreCase = _a.ignoreCase;
        var adapter = _b.adapter;
        if (/\s/.test(value)) {
            return boolbase_1$2.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)" + escapeRegex(value) + "(?:$|\\s)", ignoreCase ? "i" : "");
        return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr != null &&
                attr.length >= value.length &&
                regex.test(attr) &&
                next(elem));
        };
    },
    exists: function (next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };
    },
    start: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
            return boolbase_1$2.falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= len &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
                next(elem);
        };
    },
    end: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
            return boolbase_1$2.falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var _a;
                return ((_a = adapter
                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
                next(elem);
        };
    },
    any: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
            return boolbase_1$2.falseFunc;
        }
        if (data.ignoreCase) {
            var regex_1 = new RegExp(escapeRegex(value), "i");
            return function anyIC(elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= value.length &&
                    regex_1.test(attr) &&
                    next(elem));
            };
        }
        return function (elem) {
            var _a;
            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
                next(elem);
        };
    },
    not: function (next, data, _a) {
        var adapter = _a.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
            return function (elem) {
                return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
        }
        else if (data.ignoreCase) {
            value = value.toLowerCase();
            return function (elem) {
                var attr = adapter.getAttributeValue(elem, name);
                return ((attr == null ||
                    attr.length !== value.length ||
                    attr.toLowerCase() !== value) &&
                    next(elem));
            };
        }
        return function (elem) {
            return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
    },
};

var pseudoSelectors = {};

var filters = {};

var lib = {};

var parse$b = {};

// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
Object.defineProperty(parse$b, "__esModule", { value: true });
parse$b.parse = void 0;
// [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
var RE_NTH_ELEMENT = /^([+-]?\d*n)?\s*(?:([+-]?)\s*(\d+))?$/;
/**
 * Parses an expression.
 *
 * @throws An `Error` if parsing fails.
 * @returns An array containing the integer step size and the integer offset of the nth rule.
 * @example nthCheck.parse("2n+3"); // returns [2, 3]
 */
function parse$a(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === "even") {
        return [2, 0];
    }
    else if (formula === "odd") {
        return [2, 1];
    }
    var parsed = formula.match(RE_NTH_ELEMENT);
    if (!parsed) {
        throw new Error("n-th rule couldn't be parsed ('" + formula + "')");
    }
    var a;
    if (parsed[1]) {
        a = parseInt(parsed[1], 10);
        if (isNaN(a)) {
            a = parsed[1].startsWith("-") ? -1 : 1;
        }
    }
    else
        a = 0;
    var b = (parsed[2] === "-" ? -1 : 1) *
        (parsed[3] ? parseInt(parsed[3], 10) : 0);
    return [a, b];
}
parse$b.parse = parse$a;

var compile$4 = {};

Object.defineProperty(compile$4, "__esModule", { value: true });
compile$4.compile = void 0;
var boolbase_1$1 = boolbase;
/**
 * Returns a function that checks if an elements index matches the given rule
 * highly optimized to return the fastest solution.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A highly optimized function that returns whether an index matches the nth-check.
 * @example
 * const check = nthCheck.compile([2, 3]);
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function compile$3(parsed) {
    var a = parsed[0];
    // Subtract 1 from `b`, to convert from one- to zero-indexed.
    var b = parsed[1] - 1;
    /*
     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
     * Besides, the specification states that no elements are
     * matched when `a` and `b` are 0.
     *
     * `b < 0` here as we subtracted 1 from `b` above.
     */
    if (b < 0 && a <= 0)
        return boolbase_1$1.falseFunc;
    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
    if (a === -1)
        return function (index) { return index <= b; };
    if (a === 0)
        return function (index) { return index === b; };
    // When `b <= 0` and `a === 1`, they match any element.
    if (a === 1)
        return b < 0 ? boolbase_1$1.trueFunc : function (index) { return index >= b; };
    /*
     * Otherwise, modulo can be used to check if there is a match.
     *
     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
     */
    var absA = Math.abs(a);
    // Get `b mod a`, + a if this is negative.
    var bMod = ((b % absA) + absA) % absA;
    return a > 1
        ? function (index) { return index >= b && index % absA === bMod; }
        : function (index) { return index <= b && index % absA === bMod; };
}
compile$4.compile = compile$3;

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.compile = exports.parse = void 0;
var parse_1 = parse$b;
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parse_1.parse; } });
var compile_1 = compile$4;
Object.defineProperty(exports, "compile", { enumerable: true, get: function () { return compile_1.compile; } });
/**
 * Parses and compiles a formula to a highly optimized function.
 * Combination of `parse` and `compile`.
 *
 * If the formula doesn't match any elements,
 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
 * Otherwise, a function accepting an _index_ is returned, which returns
 * whether or not the passed _index_ matches the formula.
 *
 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
 *
 * @param formula The formula to compile.
 * @example
 * const check = nthCheck("2n+3");
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function nthCheck(formula) {
    return compile_1.compile(parse_1.parse(formula));
}
exports.default = nthCheck;
}(lib));

(function (exports) {
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filters = void 0;
var nth_check_1 = __importDefault(lib);
var boolbase_1 = boolbase;
function getChildFunc(next, adapter) {
    return function (elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
    };
}
exports.filters = {
    contains: function (next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
            return next(elem) && adapter.getText(elem).includes(text);
        };
    },
    icontains: function (next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
            return (next(elem) &&
                adapter.getText(elem).toLowerCase().includes(itext));
        };
    },
    // Location specific methods
    "nth-child": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
                if (equals(elem, siblings[i]))
                    break;
                if (adapter.isTag(siblings[i])) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-last-child": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
                if (equals(elem, siblings[i]))
                    break;
                if (adapter.isTag(siblings[i])) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-of-type": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    break;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === adapter.getName(elem)) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    "nth-last-of-type": function (next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = nth_check_1.default(rule);
        if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    break;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === adapter.getName(elem)) {
                    pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    // TODO determine the actual root element
    root: function (next, _rule, _a) {
        var adapter = _a.adapter;
        return function (elem) {
            var parent = adapter.getParent(elem);
            return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
    },
    scope: function (next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
            // Equivalent to :root
            return exports.filters.root(next, rule, options);
        }
        if (context.length === 1) {
            // NOTE: can't be unpacked, as :has uses this for side-effects
            return function (elem) { return equals(context[0], elem) && next(elem); };
        }
        return function (elem) { return context.includes(elem) && next(elem); };
    },
    hover: dynamicStatePseudo("isHovered"),
    visited: dynamicStatePseudo("isVisited"),
    active: dynamicStatePseudo("isActive"),
};
/**
 * Dynamic state pseudos. These depend on optional Adapter methods.
 *
 * @param name The name of the adapter method to call.
 * @returns Pseudo for the `filters` object.
 */
function dynamicStatePseudo(name) {
    return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
            return boolbase_1.falseFunc;
        }
        return function active(elem) {
            return func(elem) && next(elem);
        };
    };
}
}(filters));

var pseudos = {};

Object.defineProperty(pseudos, "__esModule", { value: true });
pseudos.verifyPseudoArgs = pseudos.pseudos = void 0;
// While filters are precompiled, pseudos get called when they are needed
pseudos.pseudos = {
    empty: function (elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function (elem) {
            // FIXME: `getText` call is potentially expensive.
            return adapter.isTag(elem) || adapter.getText(elem) !== "";
        });
    },
    "first-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var firstChild = adapter
            .getSiblings(elem)
            .find(function (elem) { return adapter.isTag(elem); });
        return firstChild != null && equals(elem, firstChild);
    },
    "last-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
                return true;
            if (adapter.isTag(siblings[i]))
                break;
        }
        return false;
    },
    "first-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "last-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
                return true;
            if (adapter.isTag(currentSibling) &&
                adapter.getName(currentSibling) === elemName) {
                break;
            }
        }
        return false;
    },
    "only-of-type": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter
            .getSiblings(elem)
            .every(function (sibling) {
            return equals(elem, sibling) ||
                !adapter.isTag(sibling) ||
                adapter.getName(sibling) !== elemName;
        });
    },
    "only-child": function (elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter
            .getSiblings(elem)
            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });
    },
};
function verifyPseudoArgs(func, name, subselect) {
    if (subselect === null) {
        if (func.length > 2) {
            throw new Error("pseudo-selector :" + name + " requires an argument");
        }
    }
    else if (func.length === 2) {
        throw new Error("pseudo-selector :" + name + " doesn't have any arguments");
    }
}
pseudos.verifyPseudoArgs = verifyPseudoArgs;

var aliases = {};

Object.defineProperty(aliases, "__esModule", { value: true });
aliases.aliases = void 0;
/**
 * Aliases are pseudos that are expressed as selectors.
 */
aliases.aliases = {
    // Links
    "any-link": ":is(a, area, link)[href]",
    link: ":any-link:not(:visited)",
    // Forms
    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
    disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
    enabled: ":not(:disabled)",
    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
    required: ":is(input, select, textarea)[required]",
    optional: ":is(input, select, textarea):not([required])",
    // JQuery extensions
    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
    checkbox: "[type=checkbox]",
    file: "[type=file]",
    password: "[type=password]",
    radio: "[type=radio]",
    reset: "[type=reset]",
    image: "[type=image]",
    submit: "[type=submit]",
    parent: ":not(:empty)",
    header: ":is(h1, h2, h3, h4, h5, h6)",
    button: ":is(button, input[type=button])",
    input: ":is(input, textarea, select, button)",
    text: "input:is(:not([type!='']), [type=text])",
};

var subselects = {};

(function (exports) {
var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
var boolbase_1 = boolbase;
var procedure_1 = procedure;
/** Used as a placeholder for :has. Will be replaced with the actual element. */
exports.PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next, adapter) {
    if (next === boolbase_1.falseFunc)
        return next;
    return function (elem) { return adapter.isTag(elem) && next(elem); };
}
exports.ensureIsTag = ensureIsTag;
function getNextSiblings(elem, adapter) {
    var siblings = adapter.getSiblings(elem);
    if (siblings.length <= 1)
        return [];
    var elemIndex = siblings.indexOf(elem);
    if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
}
exports.getNextSiblings = getNextSiblings;
var is = function (next, token, options, context, compileToken) {
    var opts = {
        xmlMode: !!options.xmlMode,
        adapter: options.adapter,
        equals: options.equals,
    };
    var func = compileToken(token, opts, context);
    return function (elem) { return func(elem) && next(elem); };
};
/*
 * :not, :has, :is and :matches have to compile selectors
 * doing this in src/pseudos.ts would lead to circular dependencies,
 * so we add them here
 */
exports.subselects = {
    is: is,
    /**
     * `:matches` is an alias for `:is`.
     */
    matches: is,
    not: function (next, token, options, context, compileToken) {
        var opts = {
            xmlMode: !!options.xmlMode,
            adapter: options.adapter,
            equals: options.equals,
        };
        var func = compileToken(token, opts, context);
        if (func === boolbase_1.falseFunc)
            return next;
        if (func === boolbase_1.trueFunc)
            return boolbase_1.falseFunc;
        return function not(elem) {
            return !func(elem) && next(elem);
        };
    },
    has: function (next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = {
            xmlMode: !!options.xmlMode,
            adapter: adapter,
            equals: options.equals,
        };
        // @ts-expect-error Uses an array as a pointer to the current element (side effects)
        var context = subselect.some(function (s) {
            return s.some(procedure_1.isTraversal);
        })
            ? [exports.PLACEHOLDER_ELEMENT]
            : undefined;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
        if (compiled === boolbase_1.trueFunc) {
            return function (elem) {
                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
            };
        }
        var hasElement = ensureIsTag(compiled, adapter);
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;
        /*
         * `shouldTestNextSiblings` will only be true if the query starts with
         * a traversal (sibling or adjacent). That means we will always have a context.
         */
        if (context) {
            return function (elem) {
                context[0] = elem;
                var childs = adapter.getChildren(elem);
                var nextElements = shouldTestNextSiblings
                    ? __spreadArray(__spreadArray([], childs), getNextSiblings(elem, adapter)) : childs;
                return (next(elem) && adapter.existsOne(hasElement, nextElements));
            };
        }
        return function (elem) {
            return next(elem) &&
                adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
    },
};
}(subselects));

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
/*
 * Pseudo selectors
 *
 * Pseudo selectors are available in three forms:
 *
 * 1. Filters are called when the selector is compiled and return a function
 *  that has to return either false, or the results of `next()`.
 * 2. Pseudos are called on execution. They have to return a boolean.
 * 3. Subselects work like filters, but have an embedded selector that will be run separately.
 *
 * Filters are great if you want to do some pre-processing, or change the call order
 * of `next()` and your code.
 * Pseudos should be used to implement simple checks.
 */
var boolbase_1 = boolbase;
var css_what_1 = lib$2;
var filters_1 = filters;
Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return filters_1.filters; } });
var pseudos_1 = pseudos;
Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudos_1.pseudos; } });
var aliases_1 = aliases;
Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return aliases_1.aliases; } });
var subselects_1 = subselects;
function compilePseudoSelector(next, selector, options, context, compileToken) {
    var name = selector.name, data = selector.data;
    if (Array.isArray(data)) {
        return subselects_1.subselects[name](next, data, options, context, compileToken);
    }
    if (name in aliases_1.aliases) {
        if (data != null) {
            throw new Error("Pseudo " + name + " doesn't have any arguments");
        }
        // The alias has to be parsed here, to make sure options are respected.
        var alias = css_what_1.parse(aliases_1.aliases[name], options);
        return subselects_1.subselects.is(next, alias, options, context, compileToken);
    }
    if (name in filters_1.filters) {
        return filters_1.filters[name](next, data, options, context);
    }
    if (name in pseudos_1.pseudos) {
        var pseudo_1 = pseudos_1.pseudos[name];
        pseudos_1.verifyPseudoArgs(pseudo_1, name, data);
        return pseudo_1 === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : next === boolbase_1.trueFunc
                ? function (elem) { return pseudo_1(elem, options, data); }
                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };
    }
    throw new Error("unmatched pseudo-class :" + name);
}
exports.compilePseudoSelector = compilePseudoSelector;
}(pseudoSelectors));

Object.defineProperty(general, "__esModule", { value: true });
general.compileGeneralSelector = void 0;
var attributes_1 = attributes;
var pseudo_selectors_1 = pseudoSelectors;
/*
 * All available rules
 */
function compileGeneralSelector(next, selector, options, context, compileToken) {
    var adapter = options.adapter, equals = options.equals;
    switch (selector.type) {
        case "pseudo-element":
            throw new Error("Pseudo-elements are not supported by css-select");
        case "attribute":
            return attributes_1.attributeRules[selector.action](next, selector, options);
        case "pseudo":
            return pseudo_selectors_1.compilePseudoSelector(next, selector, options, context, compileToken);
        // Tags
        case "tag":
            return function tag(elem) {
                return adapter.getName(elem) === selector.name && next(elem);
            };
        // Traversal
        case "descendant":
            if (options.cacheResults === false ||
                typeof WeakSet === "undefined") {
                return function descendant(elem) {
                    var current = elem;
                    while ((current = adapter.getParent(current))) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            // @ts-expect-error `ElementNode` is not extending object
            // eslint-disable-next-line no-case-declarations
            var isFalseCache_1 = new WeakSet();
            return function cachedDescendant(elem) {
                var current = elem;
                while ((current = adapter.getParent(current))) {
                    if (!isFalseCache_1.has(current)) {
                        if (adapter.isTag(current) && next(current)) {
                            return true;
                        }
                        isFalseCache_1.add(current);
                    }
                }
                return false;
            };
        case "_flexibleDescendant":
            // Include element itself, only used while querying an array
            return function flexibleDescendant(elem) {
                var current = elem;
                do {
                    if (adapter.isTag(current) && next(current))
                        return true;
                } while ((current = adapter.getParent(current)));
                return false;
            };
        case "parent":
            return function parent(elem) {
                return adapter
                    .getChildren(elem)
                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });
            };
        case "child":
            return function child(elem) {
                var parent = adapter.getParent(elem);
                return parent != null && adapter.isTag(parent) && next(parent);
            };
        case "sibling":
            return function sibling(elem) {
                var siblings = adapter.getSiblings(elem);
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling) && next(currentSibling)) {
                        return true;
                    }
                }
                return false;
            };
        case "adjacent":
            return function adjacent(elem) {
                var siblings = adapter.getSiblings(elem);
                var lastElement;
                for (var i = 0; i < siblings.length; i++) {
                    var currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling)) {
                        lastElement = currentSibling;
                    }
                }
                return !!lastElement && next(lastElement);
            };
        case "universal":
            return next;
    }
}
general.compileGeneralSelector = compileGeneralSelector;

var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(compile$5, "__esModule", { value: true });
compile$5.compileToken = compile$5.compileUnsafe = compile$5.compile = void 0;
var css_what_1 = lib$2;
var boolbase_1 = boolbase;
var sort_1 = __importDefault(sort);
var procedure_1 = procedure;
var general_1 = general;
var subselects_1 = subselects;
/**
 * Compiles a selector to an executable function.
 *
 * @param selector Selector to compile.
 * @param options Compilation options.
 * @param context Optional context for the selector.
 */
function compile$2(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return subselects_1.ensureIsTag(next, options.adapter);
}
compile$5.compile = compile$2;
function compileUnsafe(selector, options, context) {
    var token = typeof selector === "string" ? css_what_1.parse(selector, options) : selector;
    return compileToken(token, options, context);
}
compile$5.compileUnsafe = compileUnsafe;
function includesScopePseudo(t) {
    return (t.type === "pseudo" &&
        (t.name === "scope" ||
            (Array.isArray(t.data) &&
                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
}
var DESCENDANT_TOKEN = { type: "descendant" };
var FLEXIBLE_DESCENDANT_TOKEN = {
    type: "_flexibleDescendant",
};
var SCOPE_TOKEN = { type: "pseudo", name: "scope", data: null };
/*
 * CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
 * http://www.w3.org/TR/selectors4/#absolutizing
 */
function absolutize(token, _a, context) {
    var adapter = _a.adapter;
    // TODO Use better check if the context is a document
    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return e === subselects_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
    }));
    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t = token_1[_i];
        if (t.length > 0 && procedure_1.isTraversal(t[0]) && t[0].type !== "descendant") ;
        else if (hasContext && !t.some(includesScopePseudo)) {
            t.unshift(DESCENDANT_TOKEN);
        }
        else {
            continue;
        }
        t.unshift(SCOPE_TOKEN);
    }
}
function compileToken(token, options, context) {
    var _a;
    token = token.filter(function (t) { return t.length > 0; });
    token.forEach(sort_1.default);
    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
    var isArrayContext = Array.isArray(context);
    var finalContext = context && (Array.isArray(context) ? context : [context]);
    absolutize(token, options, finalContext);
    var shouldTestNextSiblings = false;
    var query = token
        .map(function (rules) {
        if (rules.length >= 2) {
            var first = rules[0], second = rules[1];
            if (first.type !== "pseudo" || first.name !== "scope") ;
            else if (isArrayContext && second.type === "descendant") {
                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
            }
            else if (second.type === "adjacent" ||
                second.type === "sibling") {
                shouldTestNextSiblings = true;
            }
        }
        return compileRules(rules, options, finalContext);
    })
        .reduce(reduceRules, boolbase_1.falseFunc);
    query.shouldTestNextSiblings = shouldTestNextSiblings;
    return query;
}
compile$5.compileToken = compileToken;
function compileRules(rules, options, context) {
    var _a;
    return rules.reduce(function (previous, rule) {
        return previous === boolbase_1.falseFunc
            ? boolbase_1.falseFunc
            : general_1.compileGeneralSelector(previous, rule, options, context, compileToken);
    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
}
function reduceRules(a, b) {
    if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
        return a;
    }
    if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
        return b;
    }
    return function combine(elem) {
        return a(elem) || b(elem);
    };
}

(function (exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
var DomUtils = __importStar(lib$8);
var boolbase_1 = boolbase;
var compile_1 = compile$5;
var subselects_1 = subselects;
var defaultEquals = function (a, b) { return a === b; };
var defaultOptions = {
    adapter: DomUtils,
    equals: defaultEquals,
};
function convertOptionFormats(options) {
    var _a, _b, _c, _d;
    /*
     * We force one format of options to the other one.
     */
    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
    var opts = options !== null && options !== void 0 ? options : defaultOptions;
    // @ts-expect-error Same as above.
    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
    // @ts-expect-error `equals` does not exist on `Options`
    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
    return opts;
}
function wrapCompile(func) {
    return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
    };
}
/**
 * Compiles the query, returns a function.
 */
exports.compile = wrapCompile(compile_1.compile);
exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
exports._compileToken = wrapCompile(compile_1.compileToken);
function getSelectorFunc(searchFunc) {
    return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
            query = compile_1.compileUnsafe(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
    };
}
function prepareContext(elems, adapter, shouldTestNextSiblings) {
    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }
    /*
     * Add siblings if the query requires them.
     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
     */
    if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
    }
    return Array.isArray(elems)
        ? adapter.removeSubsets(elems)
        : adapter.getChildren(elems);
}
exports.prepareContext = prepareContext;
function appendNextSiblings(elem, adapter) {
    // Order matters because jQuery seems to check the children before the siblings
    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
    for (var i = 0; i < elems.length; i++) {
        var nextSiblings = subselects_1.getNextSiblings(elems[i], adapter);
        elems.push.apply(elems, nextSiblings);
    }
    return elems;
}
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns All matching elements.
 *
 */
exports.selectAll = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.falseFunc || !elems || elems.length === 0
        ? []
        : options.adapter.findAll(query, elems);
});
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns the first match, or null if there was no match.
 */
exports.selectOne = getSelectorFunc(function (query, elems, options) {
    return query === boolbase_1.falseFunc || !elems || elems.length === 0
        ? null
        : options.adapter.findOne(query, elems);
});
/**
 * Tests whether or not an element is matched by query.
 *
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elem The element to test if it matches the query.
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns
 */
function is(elem, query, options) {
    var opts = convertOptionFormats(options);
    return (typeof query === "function" ? query : compile_1.compile(query, opts))(elem);
}
exports.is = is;
/**
 * Alias for selectAll(query, elems, options).
 * @see [compile] for supported selector queries.
 */
exports.default = exports.selectAll;
// Export filters, pseudos and aliases to allow users to supply their own.
var pseudo_selectors_1 = pseudoSelectors;
Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return pseudo_selectors_1.filters; } });
Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudo_selectors_1.pseudos; } });
Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return pseudo_selectors_1.aliases; } });
}(lib$1));

var helpers = {};

var positionals = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLimit = exports.isFilter = exports.filterNames = void 0;
exports.filterNames = new Set([
    "first",
    "last",
    "eq",
    "gt",
    "nth",
    "lt",
    "even",
    "odd",
]);
function isFilter(s) {
    if (s.type !== "pseudo")
        return false;
    if (exports.filterNames.has(s.name))
        return true;
    if (s.name === "not" && Array.isArray(s.data)) {
        // Only consider `:not` with embedded filters
        return s.data.some(function (s) { return s.some(isFilter); });
    }
    return false;
}
exports.isFilter = isFilter;
function getLimit(filter, data) {
    var num = data != null ? parseInt(data, 10) : NaN;
    switch (filter) {
        case "first":
            return 1;
        case "nth":
        case "eq":
            return isFinite(num) ? (num >= 0 ? num + 1 : Infinity) : 0;
        case "lt":
            return isFinite(num) ? (num >= 0 ? num : Infinity) : 0;
        case "gt":
            return isFinite(num) ? Infinity : 0;
        default:
            return Infinity;
    }
}
exports.getLimit = getLimit;
}(positionals));

Object.defineProperty(helpers, "__esModule", { value: true });
helpers.groupSelectors = helpers.getDocumentRoot = void 0;
var positionals_1 = positionals;
function getDocumentRoot(node) {
    while (node.parent)
        node = node.parent;
    return node;
}
helpers.getDocumentRoot = getDocumentRoot;
function groupSelectors(selectors) {
    var filteredSelectors = [];
    var plainSelectors = [];
    for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
        var selector = selectors_1[_i];
        if (selector.some(positionals_1.isFilter)) {
            filteredSelectors.push(selector);
        }
        else {
            plainSelectors.push(selector);
        }
    }
    return [plainSelectors, filteredSelectors];
}
helpers.groupSelectors = groupSelectors;

(function (exports) {
var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.select = exports.filter = exports.some = exports.is = exports.aliases = exports.pseudos = exports.filters = void 0;
var css_what_1 = lib$2;
var css_select_1 = lib$1;
var DomUtils = __importStar(lib$8);
var helpers_1 = helpers;
var positionals_1 = positionals;
// Re-export pseudo extension points
var css_select_2 = lib$1;
Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return css_select_2.filters; } });
Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return css_select_2.pseudos; } });
Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return css_select_2.aliases; } });
/** Used to indicate a scope should be filtered. Might be ignored when filtering. */
var SCOPE_PSEUDO = {
    type: "pseudo",
    name: "scope",
    data: null,
};
/** Used for actually filtering for scope. */
var CUSTOM_SCOPE_PSEUDO = __assign({}, SCOPE_PSEUDO);
var UNIVERSAL_SELECTOR = { type: "universal", namespace: null };
function is(element, selector, options) {
    if (options === void 0) { options = {}; }
    if (typeof selector === "function")
        return selector(element);
    var _a = helpers_1.groupSelectors(css_what_1.parse(selector, options)), plain = _a[0], filtered = _a[1];
    return ((plain.length > 0 && css_select_1.is(element, plain, options)) ||
        filtered.some(function (sel) { return filterBySelector(sel, [element], options).length > 0; }));
}
exports.is = is;
function some(elements, selector, options) {
    if (options === void 0) { options = {}; }
    if (typeof selector === "function")
        return elements.some(selector);
    var _a = helpers_1.groupSelectors(css_what_1.parse(selector, options)), plain = _a[0], filtered = _a[1];
    return ((plain.length > 0 && elements.some(css_select_1._compileToken(plain, options))) ||
        filtered.some(function (sel) { return filterBySelector(sel, elements, options).length > 0; }));
}
exports.some = some;
function filterByPosition(filter, elems, data, options) {
    var num = typeof data === "string" ? parseInt(data, 10) : NaN;
    switch (filter) {
        case "first":
        case "lt":
            // Already done in `getLimit`
            return elems;
        case "last":
            return elems.length > 0 ? [elems[elems.length - 1]] : elems;
        case "nth":
        case "eq":
            return isFinite(num) && Math.abs(num) < elems.length
                ? [num < 0 ? elems[elems.length + num] : elems[num]]
                : [];
        case "gt":
            return isFinite(num) ? elems.slice(num + 1) : [];
        case "even":
            return elems.filter(function (_, i) { return i % 2 === 0; });
        case "odd":
            return elems.filter(function (_, i) { return i % 2 === 1; });
        case "not": {
            var filtered_1 = new Set(filterParsed(data, elems, options));
            return elems.filter(function (e) { return !filtered_1.has(e); });
        }
    }
}
function filter(selector, elements, options) {
    if (options === void 0) { options = {}; }
    return filterParsed(css_what_1.parse(selector, options), elements, options);
}
exports.filter = filter;
/**
 * Filter a set of elements by a selector.
 *
 * Will return elements in the original order.
 *
 * @param selector Selector to filter by.
 * @param elements Elements to filter.
 * @param options Options for selector.
 */
function filterParsed(selector, elements, options) {
    if (elements.length === 0)
        return [];
    var _a = helpers_1.groupSelectors(selector), plainSelectors = _a[0], filteredSelectors = _a[1];
    var found;
    if (plainSelectors.length) {
        var filtered = filterElements(elements, plainSelectors, options);
        // If there are no filters, just return
        if (filteredSelectors.length === 0) {
            return filtered;
        }
        // Otherwise, we have to do some filtering
        if (filtered.length) {
            found = new Set(filtered);
        }
    }
    for (var i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
        var filteredSelector = filteredSelectors[i];
        var missing = found
            ? elements.filter(function (e) { return !found.has(e); })
            : elements;
        if (missing.length === 0)
            break;
        var filtered = filterBySelector(filteredSelector, elements, options);
        if (filtered.length) {
            if (!found) {
                /*
                 * If we haven't found anything before the last selector,
                 * just return what we found now.
                 */
                if (i === filteredSelectors.length - 1) {
                    return filtered;
                }
                found = new Set(filtered);
            }
            else {
                filtered.forEach(function (el) { return found.add(el); });
            }
        }
    }
    return typeof found !== "undefined"
        ? found.size === elements.length
            ? elements
            : elements.filter(function (el) { return found.has(el); })
        : [];
}
function filterBySelector(selector, elements, options) {
    if (selector.some(css_what_1.isTraversal)) {
        /*
         * Get one root node, run selector with the scope
         * set to all of our nodes.
         */
        var root = helpers_1.getDocumentRoot(elements[0]);
        var sel = __spreadArray(__spreadArray([], selector), [CUSTOM_SCOPE_PSEUDO]);
        return findFilterElements(root, sel, options, true, elements);
    }
    // Performance optimization: If we don't have to traverse, just filter set.
    return findFilterElements(elements, selector, options, false);
}
function select(selector, root, options) {
    if (options === void 0) { options = {}; }
    if (typeof selector === "function") {
        return find(root, selector);
    }
    var _a = helpers_1.groupSelectors(css_what_1.parse(selector, options)), plain = _a[0], filtered = _a[1];
    var results = filtered.map(function (sel) {
        return findFilterElements(root, sel, options, true);
    });
    // Plain selectors can be queried in a single go
    if (plain.length) {
        results.push(findElements(root, plain, options, Infinity));
    }
    // If there was only a single selector, just return the result
    if (results.length === 1) {
        return results[0];
    }
    // Sort results, filtering for duplicates
    return DomUtils.uniqueSort(results.reduce(function (a, b) { return __spreadArray(__spreadArray([], a), b); }));
}
exports.select = select;
// Traversals that are treated differently in css-select.
var specialTraversal = new Set(["descendant", "adjacent"]);
function includesScopePseudo(t) {
    return (t !== SCOPE_PSEUDO &&
        t.type === "pseudo" &&
        (t.name === "scope" ||
            (Array.isArray(t.data) &&
                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
}
function addContextIfScope(selector, options, scopeContext) {
    return scopeContext && selector.some(includesScopePseudo)
        ? __assign(__assign({}, options), { context: scopeContext }) : options;
}
/**
 *
 * @param root Element(s) to search from.
 * @param selector Selector to look for.
 * @param options Options for querying.
 * @param queryForSelector Query multiple levels deep for the initial selector, even if it doesn't contain a traversal.
 * @param scopeContext Optional context for a :scope.
 */
function findFilterElements(root, selector, options, queryForSelector, scopeContext) {
    var filterIndex = selector.findIndex(positionals_1.isFilter);
    var sub = selector.slice(0, filterIndex);
    var filter = selector[filterIndex];
    /*
     * Set the number of elements to retrieve.
     * Eg. for :first, we only have to get a single element.
     */
    var limit = positionals_1.getLimit(filter.name, filter.data);
    if (limit === 0)
        return [];
    var subOpts = addContextIfScope(sub, options, scopeContext);
    /*
     * Skip `findElements` call if our selector starts with a positional
     * pseudo.
     */
    var elemsNoLimit = sub.length === 0 && !Array.isArray(root)
        ? DomUtils.getChildren(root).filter(DomUtils.isTag)
        : sub.length === 0 || (sub.length === 1 && sub[0] === SCOPE_PSEUDO)
            ? (Array.isArray(root) ? root : [root]).filter(DomUtils.isTag)
            : queryForSelector || sub.some(css_what_1.isTraversal)
                ? findElements(root, [sub], subOpts, limit)
                : filterElements(root, [sub], subOpts);
    var elems = elemsNoLimit.slice(0, limit);
    var result = filterByPosition(filter.name, elems, filter.data, options);
    if (result.length === 0 || selector.length === filterIndex + 1) {
        return result;
    }
    var remainingSelector = selector.slice(filterIndex + 1);
    var remainingHasTraversal = remainingSelector.some(css_what_1.isTraversal);
    var remainingOpts = addContextIfScope(remainingSelector, options, scopeContext);
    if (remainingHasTraversal) {
        /*
         * Some types of traversals have special logic when they start a selector
         * in css-select. If this is the case, add a universal selector in front of
         * the selector to avoid this behavior.
         */
        if (specialTraversal.has(remainingSelector[0].type)) {
            remainingSelector.unshift(UNIVERSAL_SELECTOR);
        }
        /*
         * Add a scope token in front of the remaining selector,
         * to make sure traversals don't match elements that aren't a
         * part of the considered tree.
         */
        remainingSelector.unshift(SCOPE_PSEUDO);
    }
    /*
     * If we have another filter, recursively call `findFilterElements`,
     * with the `recursive` flag disabled. We only have to look for more
     * elements when we see a traversal.
     *
     * Otherwise,
     */
    return remainingSelector.some(positionals_1.isFilter)
        ? findFilterElements(result, remainingSelector, options, false, scopeContext)
        : remainingHasTraversal
            ? // Query existing elements to resolve traversal.
                findElements(result, [remainingSelector], remainingOpts, Infinity)
            : // If we don't have any more traversals, simply filter elements.
                filterElements(result, [remainingSelector], remainingOpts);
}
function findElements(root, sel, options, limit) {
    if (limit === 0)
        return [];
    var query = css_select_1._compileToken(sel, options, root);
    return find(root, query, limit);
}
function find(root, query, limit) {
    if (limit === void 0) { limit = Infinity; }
    var elems = css_select_1.prepareContext(root, DomUtils, query.shouldTestNextSiblings);
    return DomUtils.find(function (node) { return DomUtils.isTag(node) && query(node); }, elems, true, limit);
}
function filterElements(elements, sel, options) {
    var els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);
    if (els.length === 0)
        return els;
    var query = css_select_1._compileToken(sel, options);
    return els.filter(query);
}
}(lib$3));

(function (exports) {
/**
 * @module cheerio/static
 * @ignore
 */
var defaultOptions = options.default;
var flattenOptions = options.flatten;
var select = lib$3.select;
var renderWithParse5 = parse5$1.render;
var renderWithHtmlparser2 = htmlparser2$1.render;

/**
 * Helper function to render a DOM.
 *
 * @param {Cheerio} that - Cheerio instance to render.
 * @param {Node[] | undefined} dom - The DOM to render. Defaults to `that`'s root.
 * @param {object} options - Options for rendering.
 * @returns {string} The rendered document.
 */
function render(that, dom, options) {
  if (!dom) {
    if (that._root && that._root.children) {
      dom = that._root.children;
    } else {
      return '';
    }
  } else if (typeof dom === 'string') {
    dom = select(dom, that._root, options);
  }

  return options.xmlMode || options._useHtmlParser2
    ? renderWithHtmlparser2(dom, options)
    : renderWithParse5(dom);
}

/**
 * Renders the document.
 *
 * @param {string | Cheerio | Node | object} [dom] - Element to render.
 * @param {object} [options] - Options for the renderer.
 * @returns {string} The rendered document.
 */
exports.html = function (dom, options) {
  // be flexible about parameters, sometimes we call html(),
  // with options as only parameter
  // check dom argument for dom element specific properties
  // assume there is no 'length' or 'type' properties in the options object
  if (
    Object.prototype.toString.call(dom) === '[object Object]' &&
    !options &&
    !('length' in dom) &&
    !('type' in dom)
  ) {
    options = dom;
    dom = undefined;
  }

  // Sometimes `$.html()` is used without preloading html,
  // so fallback non-existing options to the default ones.
  options = Object.assign(
    {},
    defaultOptions,
    this ? this._options : {},
    flattenOptions(options || {})
  );

  return render(this, dom, options);
};

/**
 * Render the document as XML.
 *
 * @param {string | Cheerio | Node} [dom] - Element to render.
 * @returns {string} THe rendered document.
 */
exports.xml = function (dom) {
  var options = Object.assign({}, this._options, { xmlMode: true });

  return render(this, dom, options);
};

/**
 * Render the document as text.
 *
 * @param {Cheerio | Node[]} [elems] - Elements to render.
 * @returns {string} The rendered document.
 */
exports.text = function (elems) {
  if (!elems) {
    elems = this.root();
  }

  var ret = '';
  var len = elems.length;

  for (var i = 0; i < len; i++) {
    var elem = elems[i];
    if (elem.type === 'text') ret += elem.data;
    else if (
      elem.children &&
      elem.type !== 'comment' &&
      elem.tagName !== 'script' &&
      elem.tagName !== 'style'
    ) {
      ret += exports.text(elem.children);
    }
  }

  return ret;
};

/**
 * Parses a string into an array of DOM nodes. The `context` argument has no
 * meaning for Cheerio, but it is maintained for API compatibility with jQuery.
 *
 * @param {string} data - Markup that will be parsed.
 * @param {any | boolean} [context] - Will be ignored. If it is a boolean it
 *   will be used as the value of `keepScripts`.
 * @param {boolean} [keepScripts] - If false all scripts will be removed.
 * @returns {Node[]} The parsed DOM.
 * @alias Cheerio.parseHTML
 * @see {@link https://api.jquery.com/jQuery.parseHTML/}
 */
exports.parseHTML = function (data, context, keepScripts) {
  if (!data || typeof data !== 'string') {
    return null;
  }

  if (typeof context === 'boolean') {
    keepScripts = context;
  }

  var parsed = this.load(data, defaultOptions, false);
  if (!keepScripts) {
    parsed('script').remove();
  }

  // The `children` array is used by Cheerio internally to group elements that
  // share the same parents. When nodes created through `parseHTML` are
  // inserted into previously-existing DOM structures, they will be removed
  // from the `children` array. The results of `parseHTML` should remain
  // constant across these operations, so a shallow copy should be returned.
  return parsed.root()[0].children.slice();
};

/**
 * Sometimes you need to work with the top-level root element. To query it, you
 * can use `$.root()`.
 *
 * @example
 *   $.root().append('<ul id="vegetables"></ul>').html();
 *   //=> <ul id="fruits">...</ul><ul id="vegetables"></ul>
 *
 * @returns {Cheerio} Cheerio instance wrapping the root node.
 * @alias Cheerio.root
 */
exports.root = function () {
  return this(this._root);
};

/**
 * Checks to see if the `contained` DOM element is a descendant of the
 * `container` DOM element.
 *
 * @param {Node} container - Potential parent node.
 * @param {Node} contained - Potential child node.
 * @returns {boolean} Indicates if the nodes contain one another.
 * @alias Cheerio.contains
 * @see {@link https://api.jquery.com/jQuery.contains/}
 */
exports.contains = function (container, contained) {
  // According to the jQuery API, an element does not "contain" itself
  if (contained === container) {
    return false;
  }

  // Step up the descendants, stopping when the root element is reached
  // (signaled by `.parent` returning a reference to the same object)
  while (contained && contained !== contained.parent) {
    contained = contained.parent;
    if (contained === container) {
      return true;
    }
  }

  return false;
};

/**
 * $.merge().
 *
 * @param {Array | Cheerio} arr1 - First array.
 * @param {Array | Cheerio} arr2 - Second array.
 * @returns {Array | Cheerio} `arr1`, with elements of `arr2` inserted.
 * @alias Cheerio.merge
 * @see {@link https://api.jquery.com/jQuery.merge/}
 */
exports.merge = function (arr1, arr2) {
  if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
    return;
  }
  var newLength = arr1.length;
  var len = +arr2.length;

  for (var i = 0; i < len; i++) {
    arr1[newLength++] = arr2[i];
  }
  arr1.length = newLength;
  return arr1;
};

/**
 * @param {any} item - Item to check.
 * @returns {boolean} Indicates if the item is array-like.
 */
function isArrayLike(item) {
  if (Array.isArray(item)) {
    return true;
  }

  if (
    typeof item !== 'object' ||
    !Object.prototype.hasOwnProperty.call(item, 'length') ||
    typeof item.length !== 'number' ||
    item.length < 0
  ) {
    return false;
  }

  for (var i = 0; i < item.length; i++) {
    if (!(i in item)) {
      return false;
    }
  }
  return true;
}
}(_static));

(function (exports) {
/**
 * Methods for getting and modifying attributes.
 *
 * @module cheerio/attributes
 */

var text = _static.text;
var utils = utils$n;
var isTag = utils.isTag;
var domEach = utils.domEach;
var hasOwn = Object.prototype.hasOwnProperty;
var camelCase = utils.camelCase;
var cssCase = utils.cssCase;
var rspace = /\s+/;
var dataAttrPrefix = 'data-';
// Lookup table for coercing string data-* attributes to their corresponding
// JavaScript primitives
var primitives = {
  null: null,
  true: true,
  false: false,
};
// Attributes that are booleans
var rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
// Matches strings that look like JSON objects or arrays
var rbrace = /^(?:{[\w\W]*}|\[[\w\W]*])$/;

/**
 * Gets a node's attribute. For boolean attributes, it will return the value's
 * name should it be set.
 *
 * Also supports getting the `value` of several form elements.
 *
 * @private
 * @param {Element} elem - Elenent to get the attribute of.
 * @param {string} name - Name of the attribute.
 * @returns {object | string | undefined} The attribute's value.
 */
function getAttr(elem, name) {
  if (!elem || !isTag(elem)) return;

  if (!elem.attribs) {
    elem.attribs = {};
  }

  // Return the entire attribs object if no attribute specified
  if (!name) {
    return elem.attribs;
  }

  if (hasOwn.call(elem.attribs, name)) {
    // Get the (decoded) attribute
    return rboolean.test(name) ? name : elem.attribs[name];
  }

  // Mimic the DOM and return text content as value for `option's`
  if (elem.name === 'option' && name === 'value') {
    return text(elem.children);
  }

  // Mimic DOM with default value for radios/checkboxes
  if (
    elem.name === 'input' &&
    (elem.attribs.type === 'radio' || elem.attribs.type === 'checkbox') &&
    name === 'value'
  ) {
    return 'on';
  }
}

/**
 * Sets the value of an attribute. The attribute will be deleted if the value is `null`.
 *
 * @private
 * @param {Element} el - The element to set the attribute on.
 * @param {string} name - The attribute's name.
 * @param {string | null} value - The attribute's value.
 */
function setAttr(el, name, value) {
  if (value === null) {
    removeAttribute(el, name);
  } else {
    el.attribs[name] = value + '';
  }
}

/**
 * Method for getting and setting attributes. Gets the attribute value for only
 * the first element in the matched set. If you set an attribute's value to
 * `null`, you remove that attribute. You may also pass a `map` and `function`
 * like jQuery.
 *
 * @example
 *   $('ul').attr('id');
 *   //=> fruits
 *
 *   $('.apple').attr('id', 'favorite').html();
 *   //=> <li class="apple" id="favorite">Apple</li>
 *
 * @param {string} name - Name of the attribute.
 * @param {string | Function} [value] - If specified sets the value of the attribute.
 * @returns {string | Cheerio} If `value` is specified the instance itself,
 *   otherwise the attribute's value.
 * @see {@link https://api.jquery.com/attr/}
 */
exports.attr = function (name, value) {
  // Set the value (with attr map support)
  if (typeof name === 'object' || value !== undefined) {
    if (typeof value === 'function') {
      return domEach(this, function (i, el) {
        setAttr(el, name, value.call(el, i, el.attribs[name]));
      });
    }
    return domEach(this, function (i, el) {
      if (!isTag(el)) return;

      if (typeof name === 'object') {
        Object.keys(name).forEach(function (objName) {
          var objValue = name[objName];
          setAttr(el, objName, objValue);
        });
      } else {
        setAttr(el, name, value);
      }
    });
  }

  return arguments.length > 1 ? this : getAttr(this[0], name);
};

/**
 * Gets a node's prop.
 *
 * @private
 * @param {Node} el - Elenent to get the prop of.
 * @param {string} name - Name of the prop.
 * @returns {string | undefined} The prop's value.
 */
function getProp(el, name) {
  if (!el || !isTag(el)) return;

  return name in el
    ? el[name]
    : rboolean.test(name)
    ? getAttr(el, name) !== undefined
    : getAttr(el, name);
}

/**
 * Sets the value of a prop.
 *
 * @private
 * @param {Element} el - The element to set the prop on.
 * @param {string} name - The prop's name.
 * @param {string | null} value - The prop's value.
 */
function setProp(el, name, value) {
  if (name in el) {
    el[name] = value;
  } else {
    setAttr(el, name, rboolean.test(name) ? (value ? '' : null) : value);
  }
}

/**
 * Method for getting and setting properties. Gets the property value for only
 * the first element in the matched set.
 *
 * @example
 *   $('input[type="checkbox"]').prop('checked');
 *   //=> false
 *
 *   $('input[type="checkbox"]').prop('checked', true).val();
 *   //=> ok
 *
 * @param {string} name - Name of the property.
 * @param {any} [value] - If specified set the property to this.
 * @returns {string | Cheerio} If `value` is specified the instance itself,
 *   otherwise the prop's value.
 * @see {@link https://api.jquery.com/prop/}
 */
exports.prop = function (name, value) {
  if (typeof name === 'string' && value === undefined) {
    switch (name) {
      case 'style': {
        var property = this.css();
        var keys = Object.keys(property);
        keys.forEach(function (p, i) {
          property[i] = p;
        });

        property.length = keys.length;

        return property;
      }
      case 'tagName':
      case 'nodeName':
        return this[0].name.toUpperCase();

      case 'outerHTML':
        return this.clone().wrap('<container />').parent().html();

      case 'innerHTML':
        return this.html();

      default:
        return getProp(this[0], name);
    }
  }

  if (typeof name === 'object' || value !== undefined) {
    if (typeof value === 'function') {
      return domEach(this, function (j, el) {
        setProp(el, name, value.call(el, j, getProp(el, name)));
      });
    }

    return domEach(this, function (__, el) {
      if (!isTag(el)) return;

      if (typeof name === 'object') {
        Object.keys(name).forEach(function (key) {
          var val = name[key];
          setProp(el, key, val);
        });
      } else {
        setProp(el, name, value);
      }
    });
  }
};

/**
 * Sets the value of a data attribute.
 *
 * @private
 * @param {Element} el - The element to set the data attribute on.
 * @param {string | object} name - The data attribute's name.
 * @param {string | null} value - The data attribute's value.
 */
function setData(el, name, value) {
  if (!el.data) {
    el.data = {};
  }

  if (typeof name === 'object') Object.assign(el.data, name);
  else if (typeof name === 'string' && value !== undefined) {
    el.data[name] = value;
  }
}

/**
 * Read the specified attribute from the equivalent HTML5 `data-*` attribute,
 * and (if present) cache the value in the node's internal data store. If no
 * attribute name is specified, read *all* HTML5 `data-*` attributes in this manner.
 *
 * @private
 * @param {Element} el - Elenent to get the data attribute of.
 * @param {string} [name] - Name of the data attribute.
 * @returns {any} The data attribute's value, or a map with all of the data attribute.
 */
function readData(el, name) {
  var readAll = arguments.length === 1;
  var domNames;
  var jsNames;
  var value;

  if (readAll) {
    domNames = Object.keys(el.attribs).filter(function (attrName) {
      return attrName.slice(0, dataAttrPrefix.length) === dataAttrPrefix;
    });
    jsNames = domNames.map(function (_domName) {
      return camelCase(_domName.slice(dataAttrPrefix.length));
    });
  } else {
    domNames = [dataAttrPrefix + cssCase(name)];
    jsNames = [name];
  }

  for (var idx = 0; idx < domNames.length; ++idx) {
    var domName = domNames[idx];
    var jsName = jsNames[idx];
    if (hasOwn.call(el.attribs, domName) && !hasOwn.call(el.data, jsName)) {
      value = el.attribs[domName];

      if (hasOwn.call(primitives, value)) {
        value = primitives[value];
      } else if (value === String(Number(value))) {
        value = Number(value);
      } else if (rbrace.test(value)) {
        try {
          value = JSON.parse(value);
        } catch (e) {
          /* ignore */
        }
      }

      el.data[jsName] = value;
    }
  }

  return readAll ? el.data : value;
}

/**
 * Method for getting and setting data attributes. Gets or sets the data
 * attribute value for only the first element in the matched set.
 *
 * @example
 *   $('<div data-apple-color="red"></div>').data();
 *   //=> { appleColor: 'red' }
 *
 *   $('<div data-apple-color="red"></div>').data('apple-color');
 *   //=> 'red'
 *
 *   const apple = $('.apple').data('kind', 'mac');
 *   apple.data('kind');
 *   //=> 'mac'
 *
 * @param {string} name - Name of the attribute.
 * @param {any} [value] - If specified new value.
 * @returns {string | Cheerio | undefined} If `value` is specified the instance
 *   itself, otherwise the data attribute's value.
 * @see {@link https://api.jquery.com/data/}
 */
exports.data = function (name, value) {
  var elem = this[0];

  if (!elem || !isTag(elem)) return;

  if (!elem.data) {
    elem.data = {};
  }

  // Return the entire data object if no data specified
  if (!name) {
    return readData(elem);
  }

  // Set the value (with attr map support)
  if (typeof name === 'object' || value !== undefined) {
    domEach(this, function (i, el) {
      setData(el, name, value);
    });
    return this;
  }
  if (hasOwn.call(elem.data, name)) {
    return elem.data[name];
  }

  return readData(elem, name);
};

/**
 * Method for getting and setting the value of input, select, and textarea.
 * Note: Support for `map`, and `function` has not been added yet.
 *
 * @example
 *   $('input[type="text"]').val();
 *   //=> input_text
 *
 *   $('input[type="text"]').val('test').html();
 *   //=> <input type="text" value="test"/>
 *
 * @param {string | string[]} [value] - If specified new value.
 * @returns {string | Cheerio | undefined} If a new `value` is specified the
 *   instance itself, otherwise the value.
 * @see {@link https://api.jquery.com/val/}
 */
exports.val = function (value) {
  var querying = arguments.length === 0;
  var element = this[0];

  if (!element) return;

  switch (element.name) {
    case 'textarea':
      return this.text(value);
    case 'select': {
      var option = this.find('option:selected');
      if (!option) return;
      if (!querying) {
        if (this.attr('multiple') == null && typeof value === 'object') {
          return this;
        }
        if (typeof value !== 'object') {
          value = [value];
        }
        this.find('option').removeAttr('selected');
        for (var i = 0; i < value.length; i++) {
          this.find('option[value="' + value[i] + '"]').attr('selected', '');
        }
        return this;
      }

      return this.attr('multiple')
        ? option.toArray().map(function (el) {
            return getAttr(el, 'value');
          })
        : option.attr('value');
    }
    case 'input':
    case 'option':
      return querying ? this.attr('value') : this.attr('value', value);
  }
};

/**
 * Remove an attribute.
 *
 * @private
 * @param {Element} elem - Node to remove attribute from.
 * @param {string} name - Name of the attribute to remove.
 */
function removeAttribute(elem, name) {
  if (!elem.attribs || !hasOwn.call(elem.attribs, name)) return;

  delete elem.attribs[name];
}

/**
 * Splits a space-separated list of names to individual names.
 *
 * @param {string} names - Names to split.
 * @returns {string[]} - Split names.
 */
function splitNames(names) {
  return names ? names.trim().split(rspace) : [];
}

/**
 * Method for removing attributes by `name`.
 *
 * @example
 *   $('.pear').removeAttr('class').html();
 *   //=> <li>Pear</li>
 *
 *   $('.apple').attr('id', 'favorite');
 *   $('.apple').removeAttr('id class').html();
 *   //=> <li>Apple</li>
 *
 * @param {string} name - Name of the attribute.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/removeAttr/}
 */
exports.removeAttr = function (name) {
  var attrNames = splitNames(name);

  for (var i = 0; i < attrNames.length; i++) {
    domEach(this, function (_, elem) {
      removeAttribute(elem, attrNames[i]);
    });
  }

  return this;
};

/**
 * Check to see if *any* of the matched elements have the given `className`.
 *
 * @example
 *   $('.pear').hasClass('pear');
 *   //=> true
 *
 *   $('apple').hasClass('fruit');
 *   //=> false
 *
 *   $('li').hasClass('pear');
 *   //=> true
 *
 * @param {string} className - Name of the class.
 * @returns {boolean} Indicates if an element has the given `className`.
 * @see {@link https://api.jquery.com/hasClass/}
 */
exports.hasClass = function (className) {
  return this.toArray().some(function (elem) {
    var clazz = elem.attribs && elem.attribs['class'];
    var idx = -1;

    if (clazz && className.length) {
      while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
        var end = idx + className.length;

        if (
          (idx === 0 || rspace.test(clazz[idx - 1])) &&
          (end === clazz.length || rspace.test(clazz[end]))
        ) {
          return true;
        }
      }
    }

    return false;
  });
};

/**
 * Adds class(es) to all of the matched elements. Also accepts a `function` like jQuery.
 *
 * @example
 *   $('.pear').addClass('fruit').html();
 *   //=> <li class="pear fruit">Pear</li>
 *
 *   $('.apple').addClass('fruit red').html();
 *   //=> <li class="apple fruit red">Apple</li>
 *
 * @param {string | Function} value - Name of new class.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/addClass/}
 */
exports.addClass = function (value) {
  // Support functions
  if (typeof value === 'function') {
    return domEach(this, function (i, el) {
      var className = el.attribs['class'] || '';
      exports.addClass.call([el], value.call(el, i, className));
    });
  }

  // Return if no value or not a string or function
  if (!value || typeof value !== 'string') return this;

  var classNames = value.split(rspace);
  var numElements = this.length;

  for (var i = 0; i < numElements; i++) {
    // If selected element isn't a tag, move on
    if (!isTag(this[i])) continue;

    // If we don't already have classes
    var className = getAttr(this[i], 'class');

    if (!className) {
      setAttr(this[i], 'class', classNames.join(' ').trim());
    } else {
      var setClass = ' ' + className + ' ';

      // Check if class already exists
      for (var j = 0; j < classNames.length; j++) {
        var appendClass = classNames[j] + ' ';
        if (setClass.indexOf(' ' + appendClass) < 0) setClass += appendClass;
      }

      setAttr(this[i], 'class', setClass.trim());
    }
  }

  return this;
};

/**
 * Removes one or more space-separated classes from the selected elements. If no
 * `className` is defined, all classes will be removed. Also accepts a
 * `function` like jQuery.
 *
 * @example
 *   $('.pear').removeClass('pear').html();
 *   //=> <li class="">Pear</li>
 *
 *   $('.apple').addClass('red').removeClass().html();
 *   //=> <li class="">Apple</li>
 *
 * @param {string | Function} value - Name of the class.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/removeClass/}
 */
exports.removeClass = function (value) {
  // Handle if value is a function
  if (typeof value === 'function') {
    return domEach(this, function (i, el) {
      exports.removeClass.call(
        [el],
        value.call(el, i, el.attribs['class'] || '')
      );
    });
  }

  var classes = splitNames(value);
  var numClasses = classes.length;
  var removeAll = arguments.length === 0;

  return domEach(this, function (_, el) {
    if (!isTag(el)) return;

    if (removeAll) {
      // Short circuit the remove all case as this is the nice one
      el.attribs.class = '';
    } else {
      var elClasses = splitNames(el.attribs.class);
      var changed = false;

      for (var j = 0; j < numClasses; j++) {
        var index = elClasses.indexOf(classes[j]);

        if (index >= 0) {
          elClasses.splice(index, 1);
          changed = true;

          // We have to do another pass to ensure that there are not duplicate
          // classes listed
          j--;
        }
      }
      if (changed) {
        el.attribs.class = elClasses.join(' ');
      }
    }
  });
};

/**
 * Add or remove class(es) from the matched elements, depending on either the
 * class's presence or the value of the switch argument. Also accepts a
 * `function` like jQuery.
 *
 * @example
 *   $('.apple.green').toggleClass('fruit green red').html();
 *   //=> <li class="apple fruit red">Apple</li>
 *
 *   $('.apple.green').toggleClass('fruit green red', true).html();
 *   //=> <li class="apple green fruit red">Apple</li>
 *
 * @param {string | Function} value - Name of the class. Can also be a function.
 * @param {boolean} [stateVal] - If specified the state of the class.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/toggleClass/}
 */
exports.toggleClass = function (value, stateVal) {
  // Support functions
  if (typeof value === 'function') {
    return domEach(this, function (i, el) {
      exports.toggleClass.call(
        [el],
        value.call(el, i, el.attribs['class'] || '', stateVal),
        stateVal
      );
    });
  }

  // Return if no value or not a string or function
  if (!value || typeof value !== 'string') return this;

  var classNames = value.split(rspace);
  var numClasses = classNames.length;
  var state = typeof stateVal === 'boolean' ? (stateVal ? 1 : -1) : 0;
  var numElements = this.length;

  for (var i = 0; i < numElements; i++) {
    // If selected element isn't a tag, move on
    if (!isTag(this[i])) continue;

    var elementClasses = splitNames(this[i].attribs.class);

    // Check if class already exists
    for (var j = 0; j < numClasses; j++) {
      // Check if the class name is currently defined
      var index = elementClasses.indexOf(classNames[j]);

      // Add if stateValue === true or we are toggling and there is no value
      if (state >= 0 && index < 0) {
        elementClasses.push(classNames[j]);
      } else if (state <= 0 && index >= 0) {
        // Otherwise remove but only if the item exists
        elementClasses.splice(index, 1);
      }
    }

    this[i].attribs.class = elementClasses.join(' ');
  }

  return this;
};

/**
 * Checks the current list of elements and returns `true` if _any_ of the
 * elements match the selector. If using an element or Cheerio selection,
 * returns `true` if _any_ of the elements match. If using a predicate function,
 * the function is executed in the context of the selected element, so `this`
 * refers to the current element.
 *
 * @param {string | Function | Cheerio | Node} selector - Selector for the selection.
 * @returns {boolean} Whether or not the selector matches an element of the instance.
 * @see {@link https://api.jquery.com/is/}
 */
exports.is = function (selector) {
  if (selector) {
    return this.filter(selector).length > 0;
  }
  return false;
};
}(attributes$2));

var traversing = {};

(function (exports) {
/**
 * Methods for traversing the DOM structure.
 *
 * @module cheerio/traversing
 */

var select = lib$3;
var utils = utils$n;
var domEach = utils.domEach;
var uniqueSort = lib$b.DomUtils.uniqueSort;
var isTag = utils.isTag;
var slice = Array.prototype.slice;
var reSiblingSelector = /^\s*[~+]/;

/**
 * Get the descendants of each element in the current set of matched elements,
 * filtered by a selector, jQuery object, or element.
 *
 * @example
 *   $('#fruits').find('li').length;
 *   //=> 3
 *   $('#fruits').find($('.apple')).length;
 *   //=> 1
 *
 * @param {string | Cheerio | Node} selectorOrHaystack - Element to look for.
 * @returns {Cheerio} The found elements.
 * @see {@link https://api.jquery.com/find/}
 */
exports.find = function (selectorOrHaystack) {
  if (!selectorOrHaystack) {
    return this._make([]);
  }

  var context = this.toArray();

  if (typeof selectorOrHaystack !== 'string') {
    var contains = this.constructor.contains;
    var haystack = selectorOrHaystack.cheerio
      ? selectorOrHaystack.get()
      : [selectorOrHaystack];

    return this._make(
      haystack.filter(function (elem) {
        return context.some(function (node) {
          return contains(node, elem);
        });
      })
    );
  }

  var elems = reSiblingSelector.test(selectorOrHaystack)
    ? context
    : context.reduce(function (newElems, elem) {
        return Array.isArray(elem.children)
          ? newElems.concat(elem.children.filter(isTag))
          : newElems;
      }, []);

  var options = Object.assign({ context: context }, this.options);

  return this._make(select.select(selectorOrHaystack, elems, options));
};

/**
 * Get the parent of each element in the current set of matched elements,
 * optionally filtered by a selector.
 *
 * @example
 *   $('.pear').parent().attr('id');
 *   //=> fruits
 *
 * @param {string} [selector] - If specified filter for parent.
 * @returns {Cheerio} The parents.
 * @see {@link https://api.jquery.com/parent/}
 */
exports.parent = function (selector) {
  var set = [];

  domEach(this, function (_, elem) {
    var parentElem = elem.parent;
    if (
      parentElem &&
      parentElem.type !== 'root' &&
      set.indexOf(parentElem) < 0
    ) {
      set.push(parentElem);
    }
  });

  if (selector) {
    set = exports.filter.call(set, selector, this);
  }

  return this._make(set);
};

/**
 * Get a set of parents filtered by `selector` of each element in the current
 * set of match elements.
 *
 * @example
 *   $('.orange').parents().length;
 *   // => 2
 *   $('.orange').parents('#fruits').length;
 *   // => 1
 *
 * @param {string} [selector] - If specified filter for parents.
 * @returns {Cheerio} The parents.
 * @see {@link https://api.jquery.com/parents/}
 */
exports.parents = function (selector) {
  var parentNodes = [];

  // When multiple DOM elements are in the original set, the resulting set will
  // be in *reverse* order of the original elements as well, with duplicates
  // removed.
  this.get()
    .reverse()
    .forEach(function (elem) {
      traverseParents(this, elem.parent, selector, Infinity).forEach(function (
        node
      ) {
        if (parentNodes.indexOf(node) === -1) {
          parentNodes.push(node);
        }
      });
    }, this);

  return this._make(parentNodes);
};

/**
 * Get the ancestors of each element in the current set of matched elements, up
 * to but not including the element matched by the selector, DOM node, or cheerio object.
 *
 * @example
 *   $('.orange').parentsUntil('#food').length;
 *   // => 1
 *
 * @param {string | Node | Cheerio} selector - Selector for element to stop at.
 * @param {string | Function} [filter] - Optional filter for parents.
 * @returns {Cheerio} The parents.
 * @see {@link https://api.jquery.com/parentsUntil/}
 */
exports.parentsUntil = function (selector, filter) {
  var parentNodes = [];
  var untilNode;
  var untilNodes;

  if (typeof selector === 'string') {
    untilNodes = this.parents(selector).toArray();
  } else if (selector && selector.cheerio) {
    untilNodes = selector.toArray();
  } else if (selector) {
    untilNode = selector;
  }

  // When multiple DOM elements are in the original set, the resulting set will
  // be in *reverse* order of the original elements as well, with duplicates
  // removed.

  this.toArray()
    .reverse()
    .forEach(function (elem) {
      while ((elem = elem.parent)) {
        if (
          (untilNode && elem !== untilNode) ||
          (untilNodes && untilNodes.indexOf(elem) === -1) ||
          (!untilNode && !untilNodes)
        ) {
          if (isTag(elem) && parentNodes.indexOf(elem) === -1) {
            parentNodes.push(elem);
          }
        } else {
          break;
        }
      }
    }, this);

  return filter
    ? exports.filter.call(parentNodes, filter, this)
    : this._make(parentNodes);
};

/**
 * For each element in the set, get the first element that matches the selector
 * by testing the element itself and traversing up through its ancestors in the DOM tree.
 *
 * @example
 *   $('.orange').closest();
 *   // => []
 *   $('.orange').closest('.apple');
 *   // => []
 *   $('.orange').closest('li');
 *   // => [<li class="orange">Orange</li>]
 *   $('.orange').closest('#fruits');
 *   // => [<ul id="fruits"> ... </ul>]
 *
 * @param {string} [selector] - Selector for the element to find.
 * @returns {Cheerio} The closest nodes.
 * @see {@link https://api.jquery.com/closest/}
 */
exports.closest = function (selector) {
  var set = [];

  if (!selector) {
    return this._make(set);
  }

  domEach(this, function (_, elem) {
    var closestElem = traverseParents(this, elem, selector, 1)[0];

    // Do not add duplicate elements to the set
    if (closestElem && set.indexOf(closestElem) < 0) {
      set.push(closestElem);
    }
  });

  return this._make(set);
};

/**
 * Gets the next sibling of the first selected element, optionally filtered by a selector.
 *
 * @example
 *   $('.apple').next().hasClass('orange');
 *   //=> true
 *
 * @param {string} [selector] - If specified filter for sibling.
 * @returns {Cheerio} The next nodes.
 * @see {@link https://api.jquery.com/next/}
 */
exports.next = function (selector) {
  if (!this[0]) {
    return this;
  }
  var elems = [];

  domEach(this, function (_, elem) {
    while ((elem = elem.next)) {
      if (isTag(elem)) {
        elems.push(elem);
        return;
      }
    }
  });

  return selector
    ? exports.filter.call(elems, selector, this)
    : this._make(elems);
};

/**
 * Gets all the following siblings of the first selected element, optionally
 * filtered by a selector.
 *
 * @example
 *   $('.apple').nextAll();
 *   //=> [<li class="orange">Orange</li>, <li class="pear">Pear</li>]
 *   $('.apple').nextAll('.orange');
 *   //=> [<li class="orange">Orange</li>]
 *
 * @param {string} [selector] - If specified filter for siblings.
 * @returns {Cheerio} The next nodes.
 * @see {@link https://api.jquery.com/nextAll/}
 */
exports.nextAll = function (selector) {
  if (!this[0]) {
    return this;
  }
  var elems = [];

  domEach(this, function (_, elem) {
    while ((elem = elem.next)) {
      if (isTag(elem) && elems.indexOf(elem) === -1) {
        elems.push(elem);
      }
    }
  });

  return selector
    ? exports.filter.call(elems, selector, this)
    : this._make(elems);
};

/**
 * Gets all the following siblings up to but not including the element matched
 * by the selector, optionally filtered by another selector.
 *
 * @example
 *   $('.apple').nextUntil('.pear');
 *   //=> [<li class="orange">Orange</li>]
 *
 * @param {string | Cheerio | Node} selector - Selector for element to stop at.
 * @param {string} [filterSelector] - If specified filter for siblings.
 * @returns {Cheerio} The next nodes.
 * @see {@link https://api.jquery.com/nextUntil/}
 */
exports.nextUntil = function (selector, filterSelector) {
  if (!this[0]) {
    return this;
  }
  var elems = [];
  var untilNode;
  var untilNodes;

  if (typeof selector === 'string') {
    untilNodes = this.nextAll(selector).toArray();
  } else if (selector && selector.cheerio) {
    untilNodes = selector.get();
  } else if (selector) {
    untilNode = selector;
  }

  domEach(this, function (_, elem) {
    while ((elem = elem.next)) {
      if (
        (untilNode && elem !== untilNode) ||
        (untilNodes && untilNodes.indexOf(elem) === -1) ||
        (!untilNode && !untilNodes)
      ) {
        if (isTag(elem) && elems.indexOf(elem) === -1) {
          elems.push(elem);
        }
      } else {
        break;
      }
    }
  });

  return filterSelector
    ? exports.filter.call(elems, filterSelector, this)
    : this._make(elems);
};

/**
 * Gets the previous sibling of the first selected element optionally filtered
 * by a selector.
 *
 * @example
 *   $('.orange').prev().hasClass('apple');
 *   //=> true
 *
 * @param {string} [selector] - If specified filter for siblings.
 * @returns {Cheerio} The previous nodes.
 * @see {@link https://api.jquery.com/prev/}
 */
exports.prev = function (selector) {
  if (!this[0]) {
    return this;
  }
  var elems = [];

  domEach(this, function (_, elem) {
    while ((elem = elem.prev)) {
      if (isTag(elem)) {
        elems.push(elem);
        return;
      }
    }
  });

  return selector
    ? exports.filter.call(elems, selector, this)
    : this._make(elems);
};

/**
 * Gets all the preceding siblings of the first selected element, optionally
 * filtered by a selector.
 *
 * @example
 *   $('.pear').prevAll();
 *   //=> [<li class="orange">Orange</li>, <li class="apple">Apple</li>]
 *   $('.pear').prevAll('.orange');
 *   //=> [<li class="orange">Orange</li>]
 *
 * @param {string} [selector] - If specified filter for siblings.
 * @returns {Cheerio} The previous nodes.
 * @see {@link https://api.jquery.com/prevAll/}
 */
exports.prevAll = function (selector) {
  if (!this[0]) {
    return this;
  }
  var elems = [];

  domEach(this, function (_, elem) {
    while ((elem = elem.prev)) {
      if (isTag(elem) && elems.indexOf(elem) === -1) {
        elems.push(elem);
      }
    }
  });

  return selector
    ? exports.filter.call(elems, selector, this)
    : this._make(elems);
};

/**
 * Gets all the preceding siblings up to but not including the element matched
 * by the selector, optionally filtered by another selector.
 *
 * @example
 *   $('.pear').prevUntil('.apple');
 *   //=> [<li class="orange">Orange</li>]
 *
 * @param {string | Cheerio | Node} selector - Selector for element to stop at.
 * @param {string} [filterSelector] - If specified filter for siblings.
 * @returns {Cheerio} The previous nodes.
 * @see {@link https://api.jquery.com/prevUntil/}
 */
exports.prevUntil = function (selector, filterSelector) {
  if (!this[0]) {
    return this;
  }
  var elems = [];
  var untilNode;
  var untilNodes;

  if (typeof selector === 'string') {
    untilNodes = this.prevAll(selector).toArray();
  } else if (selector && selector.cheerio) {
    untilNodes = selector.get();
  } else if (selector) {
    untilNode = selector;
  }

  domEach(this, function (_, elem) {
    while ((elem = elem.prev)) {
      if (
        (untilNode && elem !== untilNode) ||
        (untilNodes && untilNodes.indexOf(elem) === -1) ||
        (!untilNode && !untilNodes)
      ) {
        if (isTag(elem) && elems.indexOf(elem) === -1) {
          elems.push(elem);
        }
      } else {
        break;
      }
    }
  });

  return filterSelector
    ? exports.filter.call(elems, filterSelector, this)
    : this._make(elems);
};

/**
 * Gets the first selected element's siblings, excluding itself.
 *
 * @example
 *   $('.pear').siblings().length;
 *   //=> 2
 *
 *   $('.pear').siblings('.orange').length;
 *   //=> 1
 *
 * @param {string} [selector] - If specified filter for siblings.
 * @returns {Cheerio} The siblings.
 * @see {@link https://api.jquery.com/siblings/}
 */
exports.siblings = function (selector) {
  var parent = this.parent();

  var elems = (parent ? parent.children() : this.siblingsAndMe())
    .toArray()
    .filter(function (elem) {
      return isTag(elem) && !this.is(elem);
    }, this);

  if (selector !== undefined) {
    return exports.filter.call(elems, selector, this);
  }
  return this._make(elems);
};

/**
 * Gets the children of the first selected element.
 *
 * @example
 *   $('#fruits').children().length;
 *   //=> 3
 *
 *   $('#fruits').children('.pear').text();
 *   //=> Pear
 *
 * @param {string} [selector] - If specified filter for children.
 * @returns {Cheerio} The children.
 * @see {@link https://api.jquery.com/children/}
 */
exports.children = function (selector) {
  var elems = this.toArray().reduce(function (newElems, elem) {
    return newElems.concat(elem.children.filter(isTag));
  }, []);

  if (selector === undefined) return this._make(elems);

  return exports.filter.call(elems, selector, this);
};

/**
 * Gets the children of each element in the set of matched elements, including
 * text and comment nodes.
 *
 * @example
 *   $('#fruits').contents().length;
 *   //=> 3
 *
 * @returns {Cheerio} The children.
 * @see {@link https://api.jquery.com/contents/}
 */
exports.contents = function () {
  var elems = this.toArray().reduce(function (newElems, elem) {
    return newElems.concat(elem.children);
  }, []);
  return this._make(elems);
};

/**
 * Iterates over a cheerio object, executing a function for each matched
 * element. When the callback is fired, the function is fired in the context of
 * the DOM element, so `this` refers to the current element, which is equivalent
 * to the function parameter `element`. To break out of the `each` loop early,
 * return with `false`.
 *
 * @example
 *   const fruits = [];
 *
 *   $('li').each(function (i, elem) {
 *     fruits[i] = $(this).text();
 *   });
 *
 *   fruits.join(', ');
 *   //=> Apple, Orange, Pear
 *
 * @param {Function} fn - Function to execute.
 * @returns {Cheerio} The instance itself, useful for chaining.
 * @see {@link https://api.jquery.com/each/}
 */
exports.each = function (fn) {
  var i = 0;
  var len = this.length;
  while (i < len && fn.call(this[i], i, this[i]) !== false) ++i;
  return this;
};

/**
 * Pass each element in the current matched set through a function, producing a
 * new Cheerio object containing the return values. The function can return an
 * individual data item or an array of data items to be inserted into the
 * resulting set. If an array is returned, the elements inside the array are
 * inserted into the set. If the function returns null or undefined, no element
 * will be inserted.
 *
 * @example
 *   $('li')
 *     .map(function (i, el) {
 *       // this === el
 *       return $(this).text();
 *     })
 *     .get()
 *     .join(' ');
 *   //=> "apple orange pear"
 *
 * @param {Function} fn - Function to execute.
 * @returns {Cheerio} The mapped elements, wrapped in a Cheerio collection.
 * @see {@link https://api.jquery.com/map/}
 */
exports.map = function (fn) {
  var elems = [];
  for (var i = 0; i < this.length; i++) {
    var el = this[i];
    var val = fn.call(el, i, el);
    if (val != null) {
      elems = elems.concat(val);
    }
  }
  return this._make(elems);
};

function getFilterFn(match) {
  if (typeof match === 'function') {
    return function (el, i) {
      return match.call(el, i, el);
    };
  }
  if (match.cheerio) {
    return match.is.bind(match);
  }
  return function (el) {
    return match === el;
  };
}

/**
 * Iterates over a cheerio object, reducing the set of selector elements to
 * those that match the selector or pass the function's test. When a Cheerio
 * selection is specified, return only the elements contained in that selection.
 * When an element is specified, return only that element (if it is contained in
 * the original selection). If using the function method, the function is
 * executed in the context of the selected element, so `this` refers to the
 * current element.
 *
 * @example <caption>Selector</caption>
 *   $('li').filter('.orange').attr('class');
 *   //=> orange
 *
 * @example <caption>Function</caption>
 *   $('li')
 *     .filter(function (i, el) {
 *       // this === el
 *       return $(this).attr('class') === 'orange';
 *     })
 *     .attr('class');
 *   //=> orange
 *
 * @function
 * @param {string | Function} match - Value to look for, following the rules above.
 * @param {Cheerio} [container] - Optional node to filter instead.
 * @returns {Cheerio} The filtered collection.
 * @see {@link https://api.jquery.com/filter/}
 */
exports.filter = function (match, container) {
  container = container || this;
  var elements = this.toArray ? this.toArray() : this;

  elements =
    typeof match === 'string'
      ? select.filter(match, elements, container.options)
      : elements.filter(getFilterFn(match));

  return container._make(elements);
};

/**
 * Remove elements from the set of matched elements. Given a jQuery object that
 * represents a set of DOM elements, the `.not()` method constructs a new jQuery
 * object from a subset of the matching elements. The supplied selector is
 * tested against each element; the elements that don't match the selector will
 * be included in the result. The `.not()` method can take a function as its
 * argument in the same way that `.filter()` does. Elements for which the
 * function returns true are excluded from the filtered set; all other elements
 * are included.
 *
 * @example <caption>Selector</caption>
 *   $('li').not('.apple').length;
 *   //=> 2
 *
 * @example <caption>Function</caption>
 *   $('li').not(function (i, el) {
 *     // this === el
 *     return $(this).attr('class') === 'orange';
 *   }).length;
 *   //=> 2
 *
 * @function
 * @param {string | Function} match - Value to look for, following the rules above.
 * @param {Node[] | Cheerio} [container] - Optional node to filter instead.
 * @returns {Cheerio} The filtered collection.
 * @see {@link https://api.jquery.com/not/}
 */
exports.not = function (match, container) {
  container = container || this;
  var elements = container.toArray ? container.toArray() : container;

  if (typeof match === 'string') {
    var matches = new Set(select.filter(match, elements, this.options));
    elements = elements.filter(function (el) {
      return !matches.has(el);
    });
  } else {
    var filterFn = getFilterFn(match);
    elements = elements.filter(function (el, i) {
      return !filterFn(el, i);
    });
  }

  return container._make(elements);
};

/**
 * Filters the set of matched elements to only those which have the given DOM
 * element as a descendant or which have a descendant that matches the given
 * selector. Equivalent to `.filter(':has(selector)')`.
 *
 * @example <caption>Selector</caption>
 *   $('ul').has('.pear').attr('id');
 *   //=> fruits
 *
 * @example <caption>Element</caption>
 *   $('ul').has($('.pear')[0]).attr('id');
 *   //=> fruits
 *
 * @param {string | Cheerio | Node} selectorOrHaystack - Element to look for.
 * @returns {Cheerio} The filtered collection.
 * @see {@link https://api.jquery.com/has/}
 */
exports.has = function (selectorOrHaystack) {
  var that = this;
  return exports.filter.call(this, function (_, el) {
    return that._make(el).find(selectorOrHaystack).length > 0;
  });
};

/**
 * Will select the first element of a cheerio object.
 *
 * @example
 *   $('#fruits').children().first().text();
 *   //=> Apple
 *
 * @returns {Cheerio} The first element.
 * @see {@link https://api.jquery.com/first/}
 */
exports.first = function () {
  return this.length > 1 ? this._make(this[0]) : this;
};

/**
 * Will select the last element of a cheerio object.
 *
 * @example
 *   $('#fruits').children().last().text();
 *   //=> Pear
 *
 * @returns {Cheerio} The last element.
 * @see {@link https://api.jquery.com/last/}
 */
exports.last = function () {
  return this.length > 1 ? this._make(this[this.length - 1]) : this;
};

/**
 * Reduce the set of matched elements to the one at the specified index. Use
 * `.eq(-i)` to count backwards from the last selected element.
 *
 * @example
 *   $('li').eq(0).text();
 *   //=> Apple
 *
 *   $('li').eq(-1).text();
 *   //=> Pear
 *
 * @param {number} i - Index of the element to select.
 * @returns {Cheerio} The element at the `i`th position.
 * @see {@link https://api.jquery.com/eq/}
 */
exports.eq = function (i) {
  i = +i;

  // Use the first identity optimization if possible
  if (i === 0 && this.length <= 1) return this;

  if (i < 0) i = this.length + i;
  return this[i] ? this._make(this[i]) : this._make([]);
};

/**
 * Retrieve the DOM elements matched by the Cheerio object. If an index is
 * specified, retrieve one of the elements matched by the Cheerio object.
 *
 * @example
 *   $('li').get(0).tagName
 *   //=> li
 *
 *   If no index is specified, retrieve all elements matched by the Cheerio object:
 *
 * @example
 *   $('li').get().length;
 *   //=> 3
 *
 * @param {number} [i] - Element to retrieve.
 * @returns {Node} The node at the `i`th position.
 * @see {@link https://api.jquery.com/get/}
 */
exports.get = function (i) {
  if (i == null) {
    return slice.call(this);
  }
  return this[i < 0 ? this.length + i : i];
};

/**
 * Search for a given element from among the matched elements.
 *
 * @example
 *   $('.pear').index();
 *   //=> 2
 *   $('.orange').index('li');
 *   //=> 1
 *   $('.apple').index($('#fruit, li'));
 *   //=> 1
 *
 * @param {string | Cheerio | Node} [selectorOrNeedle] - Element to look for.
 * @returns {number} The index of the element.
 * @see {@link https://api.jquery.com/index/}
 */
exports.index = function (selectorOrNeedle) {
  var $haystack;
  var needle;

  if (arguments.length === 0) {
    $haystack = this.parent().children();
    needle = this[0];
  } else if (typeof selectorOrNeedle === 'string') {
    $haystack = this._make(selectorOrNeedle);
    needle = this[0];
  } else {
    $haystack = this;
    needle = selectorOrNeedle.cheerio ? selectorOrNeedle[0] : selectorOrNeedle;
  }

  return $haystack.get().indexOf(needle);
};

/**
 * Gets the elements matching the specified range (0-based position).
 *
 * @example
 *   $('li').slice(1).eq(0).text();
 *   //=> 'Orange'
 *
 *   $('li').slice(1, 2).length;
 *   //=> 1
 *
 * @param {number} [start] - An position at which the elements begin to be
 *   selected. If negative, it indicates an offset from the end of the set.
 * @param {number} [end] - An position at which the elements stop being
 *   selected. If negative, it indicates an offset from the end of the set. If
 *   omitted, the range continues until the end of the set.
 * @returns {Cheerio} The elements matching the specified range.
 * @see {@link https://api.jquery.com/slice/}
 */
exports.slice = function (start, end) {
  return this._make(slice.call(this, start, end));
};

function traverseParents(self, elem, selector, limit) {
  var elems = [];
  while (elem && elems.length < limit && elem.type !== 'root') {
    if (!selector || exports.filter.call([elem], selector, self).length) {
      elems.push(elem);
    }
    elem = elem.parent;
  }
  return elems;
}

/**
 * End the most recent filtering operation in the current chain and return the
 * set of matched elements to its previous state.
 *
 * @example
 *   $('li').eq(0).end().length;
 *   //=> 3
 *
 * @returns {Cheerio} The previous state of the set of matched elements.
 * @see {@link https://api.jquery.com/end/}
 */
exports.end = function () {
  return this.prevObject || this._make([]);
};

/**
 * Add elements to the set of matched elements.
 *
 * @example
 *   $('.apple').add('.orange').length;
 *   //=> 2
 *
 * @param {string | Cheerio} other - Elements to add.
 * @param {Cheerio} [context] - Optionally the context of the new selection.
 * @returns {Cheerio} The combined set.
 * @see {@link https://api.jquery.com/add/}
 */
exports.add = function (other, context) {
  var selection = this._make(other, context);
  var contents = uniqueSort(this.get().concat(selection.get()));
  return this._make(contents);
};

/**
 * Add the previous set of elements on the stack to the current set, optionally
 * filtered by a selector.
 *
 * @example
 *   $('li').eq(0).addBack('.orange').length;
 *   //=> 2
 *
 * @param {string} selector - Selector for the elements to add.
 * @returns {Cheerio} The combined set.
 * @see {@link https://api.jquery.com/addBack/}
 */
exports.addBack = function (selector) {
  return this.add(
    arguments.length ? this.prevObject.filter(selector) : this.prevObject
  );
};
}(traversing));

var manipulation = {};

(function (exports) {
/**
 * Methods for modifying the DOM structure.
 *
 * @module cheerio/manipulation
 */

var parse = parse$e.exports;
var html = _static.html;
var text = _static.text;
var updateDOM = parse.update;
var utils = utils$n;
var domEach = utils.domEach;
var cloneDom = utils.cloneDom;
var isHtml = utils.isHtml;
var slice = Array.prototype.slice;
var domhandler = lib$a;
var DomUtils = lib$b.DomUtils;

/**
 * Create an array of nodes, recursing into arrays and parsing strings if necessary.
 *
 * @private
 * @param {Cheerio | string | Cheerio[] | string[]} [elem] - Elements to make an array of.
 * @param {boolean} [clone] - Optionally clone nodes.
 * @returns {Node[]} The array of nodes.
 */
exports._makeDomArray = function makeDomArray(elem, clone) {
  if (elem == null) {
    return [];
  }
  if (elem.cheerio) {
    return clone ? cloneDom(elem.get()) : elem.get();
  }
  if (Array.isArray(elem)) {
    return elem.reduce(
      function (newElems, el) {
        return newElems.concat(this._makeDomArray(el, clone));
      }.bind(this),
      []
    );
  }
  if (typeof elem === 'string') {
    return parse(elem, this.options, false).children;
  }
  return clone ? cloneDom([elem]) : [elem];
};

function _insert(concatenator) {
  return function () {
    var elems = slice.call(arguments);
    var lastIdx = this.length - 1;

    return domEach(this, function (i, el) {
      var domSrc =
        typeof elems[0] === 'function'
          ? elems[0].call(el, i, html(el.children))
          : elems;

      var dom = this._makeDomArray(domSrc, i < lastIdx);
      concatenator(dom, el.children, el);
    });
  };
}

/**
 * Modify an array in-place, removing some number of elements and adding new
 * elements directly following them.
 *
 * @private
 * @param {Node[]} array - Target array to splice.
 * @param {number} spliceIdx - Index at which to begin changing the array.
 * @param {number} spliceCount - Number of elements to remove from the array.
 * @param {Node[]} newElems - Elements to insert into the array.
 * @param {NodeWithChildren} parent - The parent of the node.
 * @returns {Node[]} The spliced array.
 */
function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent) {
  var spliceArgs = [spliceIdx, spliceCount].concat(newElems);
  var prev = array[spliceIdx - 1] || null;
  var next = array[spliceIdx + spliceCount] || null;

  // Before splicing in new elements, ensure they do not already appear in the
  // current array.
  for (var idx = 0; idx < newElems.length; ++idx) {
    var node = newElems[idx];
    var oldParent = node.parent;
    var prevIdx = oldParent && oldParent.children.indexOf(newElems[idx]);

    if (oldParent && prevIdx > -1) {
      oldParent.children.splice(prevIdx, 1);
      if (parent === oldParent && spliceIdx > prevIdx) {
        spliceArgs[0]--;
      }
    }

    node.parent = parent;

    if (node.prev) {
      node.prev.next = node.next || null;
    }

    if (node.next) {
      node.next.prev = node.prev || null;
    }

    node.prev = newElems[idx - 1] || prev;
    node.next = newElems[idx + 1] || next;
  }

  if (prev) {
    prev.next = newElems[0];
  }
  if (next) {
    next.prev = newElems[newElems.length - 1];
  }
  return array.splice.apply(array, spliceArgs);
}

/**
 * Insert every element in the set of matched elements to the end of the target.
 *
 * @example
 *   $('<li class="plum">Plum</li>').appendTo('#fruits');
 *   $.html();
 *   //=>  <ul id="fruits">
 *   //      <li class="apple">Apple</li>
 *   //      <li class="orange">Orange</li>
 *   //      <li class="pear">Pear</li>
 *   //      <li class="plum">Plum</li>
 *   //    </ul>
 *
 * @param {string | Cheerio} target - Element to append elements to.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/appendTo/}
 */
exports.appendTo = function (target) {
  if (!target.cheerio) {
    target = this.constructor.call(
      this.constructor,
      target,
      null,
      this._originalRoot
    );
  }

  target.append(this);

  return this;
};

/**
 * Insert every element in the set of matched elements to the beginning of the target.
 *
 * @example
 *   $('<li class="plum">Plum</li>').prependTo('#fruits');
 *   $.html();
 *   //=>  <ul id="fruits">
 *   //      <li class="plum">Plum</li>
 *   //      <li class="apple">Apple</li>
 *   //      <li class="orange">Orange</li>
 *   //      <li class="pear">Pear</li>
 *   //    </ul>
 *
 * @param {string | Cheerio} target - Element to prepend elements to.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/prependTo/}
 */
exports.prependTo = function (target) {
  if (!target.cheerio) {
    target = this.constructor.call(
      this.constructor,
      target,
      null,
      this._originalRoot
    );
  }

  target.prepend(this);

  return this;
};

/**
 * Inserts content as the *last* child of each of the selected elements.
 *
 * @example
 *   $('ul').append('<li class="plum">Plum</li>');
 *   $.html();
 *   //=>  <ul id="fruits">
 *   //      <li class="apple">Apple</li>
 *   //      <li class="orange">Orange</li>
 *   //      <li class="pear">Pear</li>
 *   //      <li class="plum">Plum</li>
 *   //    </ul>
 *
 * @function
 * @see {@link https://api.jquery.com/append/}
 */
exports.append = _insert(function (dom, children, parent) {
  uniqueSplice(children, children.length, 0, dom, parent);
});

/**
 * Inserts content as the *first* child of each of the selected elements.
 *
 * @example
 *   $('ul').prepend('<li class="plum">Plum</li>');
 *   $.html();
 *   //=>  <ul id="fruits">
 *   //      <li class="plum">Plum</li>
 *   //      <li class="apple">Apple</li>
 *   //      <li class="orange">Orange</li>
 *   //      <li class="pear">Pear</li>
 *   //    </ul>
 *
 * @function
 * @see {@link https://api.jquery.com/prepend/}
 */
exports.prepend = _insert(function (dom, children, parent) {
  uniqueSplice(children, 0, 0, dom, parent);
});

function _wrap(insert) {
  return function (wrapper) {
    var wrapperFn = typeof wrapper === 'function' && wrapper;
    var lastIdx = this.length - 1;
    var lastParent = this.parents().last();

    for (var i = 0; i < this.length; i++) {
      var el = this[i];

      if (wrapperFn) {
        wrapper = wrapperFn.call(el, i);
      }

      if (typeof wrapper === 'string' && !isHtml(wrapper)) {
        wrapper = lastParent.find(wrapper).clone();
      }

      var wrapperDom = this._makeDomArray(wrapper, i < lastIdx).slice(0, 1);
      var elInsertLocation = wrapperDom[0];
      // Find the deepest child. Only consider the first tag child of each node
      // (ignore text); stop if no children are found.
      var j = 0;

      while (
        elInsertLocation &&
        elInsertLocation.children &&
        j < elInsertLocation.children.length
      ) {
        if (elInsertLocation.children[j].type === 'tag') {
          elInsertLocation = elInsertLocation.children[j];
          j = 0;
        } else {
          j++;
        }
      }

      insert(el, elInsertLocation, wrapperDom);
    }

    return this;
  };
}

/**
 * The .wrap() function can take any string or object that could be passed to
 * the $() factory function to specify a DOM structure. This structure may be
 * nested several levels deep, but should contain only one inmost element. A
 * copy of this structure will be wrapped around each of the elements in the set
 * of matched elements. This method returns the original set of elements for
 * chaining purposes.
 *
 * @example
 *   const redFruit = $('<div class="red-fruit"></div>');
 *   $('.apple').wrap(redFruit);
 *
 *   //=> <ul id="fruits">
 *   //     <div class="red-fruit">
 *   //      <li class="apple">Apple</li>
 *   //     </div>
 *   //     <li class="orange">Orange</li>
 *   //     <li class="plum">Plum</li>
 *   //   </ul>
 *
 *   const healthy = $('<div class="healthy"></div>');
 *   $('li').wrap(healthy);
 *
 *   //=> <ul id="fruits">
 *   //     <div class="healthy">
 *   //       <li class="apple">Apple</li>
 *   //     </div>
 *   //     <div class="healthy">
 *   //       <li class="orange">Orange</li>
 *   //     </div>
 *   //     <div class="healthy">
 *   //        <li class="plum">Plum</li>
 *   //     </div>
 *   //   </ul>
 *
 * @function
 * @param {Cheerio} wrapper - The DOM structure to wrap around each element in
 *   the selection.
 * @see {@link https://api.jquery.com/wrap/}
 */
exports.wrap = _wrap(function (el, elInsertLocation, wrapperDom) {
  var parent = el.parent;
  var siblings = parent.children;
  var index = siblings.indexOf(el);

  updateDOM([el], elInsertLocation);
  // The previous operation removed the current element from the `siblings`
  // array, so the `dom` array can be inserted without removing any
  // additional elements.
  uniqueSplice(siblings, index, 0, wrapperDom, parent);
});

/**
 * The .wrapInner() function can take any string or object that could be passed
 * to the $() factory function to specify a DOM structure. This structure may be
 * nested several levels deep, but should contain only one inmost element. The
 * structure will be wrapped around the content of each of the elements in the
 * set of matched elements.
 *
 * @example
 *   const redFruit = $('<div class="red-fruit"></div>');
 *   $('.apple').wrapInner(redFruit);
 *
 *   //=> <ul id="fruits">
 *   //     <li class="apple">
 *   //       <div class="red-fruit">Apple</div>
 *   //     </li>
 *   //     <li class="orange">Orange</li>
 *   //     <li class="pear">Pear</li>
 *   //   </ul>
 *
 *   const healthy = $('<div class="healthy"></div>');
 *   $('li').wrapInner(healthy);
 *
 *   //=> <ul id="fruits">
 *   //     <li class="apple">
 *   //       <div class="healthy">Apple</div>
 *   //     </li>
 *   //     <li class="orange">
 *   //       <div class="healthy">Orange</div>
 *   //     </li>
 *   //     <li class="pear">
 *   //       <div class="healthy">Pear</div>
 *   //     </li>
 *   //   </ul>
 *
 * @function
 * @param {Cheerio} wrapper - The DOM structure to wrap around the content of
 *   each element in the selection.
 * @see {@link https://api.jquery.com/wrapInner/}
 */
exports.wrapInner = _wrap(function (el, elInsertLocation, wrapperDom) {
  updateDOM(el.children, elInsertLocation);
  updateDOM(wrapperDom, el);
});

/**
 * The .unwrap() function, removes the parents of the set of matched elements
 * from the DOM, leaving the matched elements in their place.
 *
 * @example <caption>without selector</caption>
 *   const $ = cheerio.load(
 *     '<div id=test>\n  <div><p>Hello</p></div>\n  <div><p>World</p></div>\n</div>'
 *   );
 *   $('#test p').unwrap();
 *
 *   //=> <div id=test>
 *   //     <p>Hello</p>
 *   //     <p>World</p>
 *   //   </div>
 *
 * @example <caption>with selector</caption>
 *   const $ = cheerio.load(
 *     '<div id=test>\n  <p>Hello</p>\n  <b><p>World</p></b>\n</div>'
 *   );
 *   $('#test p').unwrap('b');
 *
 *   //=> <div id=test>
 *   //     <p>Hello</p>
 *   //     <p>World</p>
 *   //   </div>
 *
 * @param {string} [selector] - A selector to check the parent element against.
 *   If an element's parent does not match the selector, the element won't be unwrapped.
 * @returns {Cheerio} The instance itself, for chaining.
 * @see {@link https://api.jquery.com/unwrap/}
 */
exports.unwrap = function (selector) {
  var self = this;
  this.parent(selector)
    .not('body')
    .each(function (i, el) {
      self._make(el).replaceWith(el.children);
    });
  return this;
};

/**
 * The .wrapAll() function can take any string or object that could be passed to
 * the $() function to specify a DOM structure. This structure may be nested
 * several levels deep, but should contain only one inmost element. The
 * structure will be wrapped around all of the elements in the set of matched
 * elements, as a single group.
 *
 * @example <caption>With markup passed to `wrapAll`</caption>
 *   const $ = cheerio.load(
 *     '<div class="container"><div class="inner">First</div><div class="inner">Second</div></div>'
 *   );
 *   $('.inner').wrapAll("<div class='new'></div>");
 *
 *   //=> <div class="container">
 *   //     <div class='new'>
 *   //       <div class="inner">First</div>
 *   //       <div class="inner">Second</div>
 *   //     </div>
 *   //   </div>
 *
 * @example <caption>With an existing cheerio instance</caption>
 *   const $ = cheerio.load(
 *     '<span>Span 1</span><strong>Strong</strong><span>Span 2</span>'
 *   );
 *   const wrap = $('<div><p><em><b></b></em></p></div>');
 *   $('span').wrapAll(wrap);
 *
 *   //=> <div>
 *   //     <p>
 *   //       <em>
 *   //         <b>
 *   //           <span>Span 1</span>
 *   //           <span>Span 2</span>
 *   //         </b>
 *   //       </em>
 *   //     </p>
 *   //   </div>
 *   //   <strong>Strong</strong>
 *
 * @param {Cheerio | string | Element | Element[] | Function} wrapper - The DOM
 *   structure to wrap around all matched elements in the selection.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/wrapAll/}
 */
exports.wrapAll = function (wrapper) {
  if (this[0]) {
    if (typeof wrapper === 'function') {
      wrapper = wrapper.call(this[0]);
    }

    var wrap = this._make(wrapper).insertBefore(this[0]);

    // if html is given as wrapper, wrap may contain text elements
    var elInsertLocation = { children: wrap };
    var j = 0;

    // Find the deepest child. Only consider the first tag child of each node
    // (ignore text); stop if no children are found.
    while (
      elInsertLocation &&
      elInsertLocation.children &&
      j < elInsertLocation.children.length
    ) {
      if (elInsertLocation.children[j].type === 'tag') {
        elInsertLocation = elInsertLocation.children[j];
        j = 0;
      } else {
        j++;
      }
    }

    this._make(elInsertLocation).append(this);
  }
  return this;
};

/*eslint-disable jsdoc/check-param-names*/

/**
 * Insert content next to each element in the set of matched elements.
 *
 * @example
 *   $('.apple').after('<li class="plum">Plum</li>');
 *   $.html();
 *   //=>  <ul id="fruits">
 *   //      <li class="apple">Apple</li>
 *   //      <li class="plum">Plum</li>
 *   //      <li class="orange">Orange</li>
 *   //      <li class="pear">Pear</li>
 *   //    </ul>
 *
 * @param {...(string | Element | Element[] | Cheerio | Function)} content -
 *   HTML string, DOM element, array of DOM elements or Cheerio to insert after
 *   each element in the set of matched elements.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/after/}
 */
exports.after = function () {
  var elems = slice.call(arguments);
  var lastIdx = this.length - 1;

  return domEach(this, function (i, el) {
    var parent = el.parent;
    if (!parent) {
      return;
    }

    var siblings = parent.children;
    var index = siblings.indexOf(el);

    // If not found, move on
    /* istanbul ignore next */
    if (index < 0) return;

    var domSrc =
      typeof elems[0] === 'function'
        ? elems[0].call(el, i, html(el.children))
        : elems;

    var dom = this._makeDomArray(domSrc, i < lastIdx);

    // Add element after `this` element
    uniqueSplice(siblings, index + 1, 0, dom, parent);
  });
};

/*eslint-enable jsdoc/check-param-names*/

/**
 * Insert every element in the set of matched elements after the target.
 *
 * @example
 *   $('<li class="plum">Plum</li>').insertAfter('.apple');
 *   $.html();
 *   //=>  <ul id="fruits">
 *   //      <li class="apple">Apple</li>
 *   //      <li class="plum">Plum</li>
 *   //      <li class="orange">Orange</li>
 *   //      <li class="pear">Pear</li>
 *   //    </ul>
 *
 * @param {string | Cheerio} target - Element to insert elements after.
 * @returns {Cheerio} The set of newly inserted elements.
 * @see {@link https://api.jquery.com/insertAfter/}
 */
exports.insertAfter = function (target) {
  var clones = [];
  var self = this;
  if (typeof target === 'string') {
    target = this.constructor.call(
      this.constructor,
      target,
      null,
      this._originalRoot
    );
  }
  target = this._makeDomArray(target);
  self.remove();
  domEach(target, function (i, el) {
    var clonedSelf = self._makeDomArray(self.clone());
    var parent = el.parent;
    if (!parent) {
      return;
    }

    var siblings = parent.children;
    var index = siblings.indexOf(el);

    // If not found, move on
    /* istanbul ignore next */
    if (index < 0) return;

    // Add cloned `this` element(s) after target element
    uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);
    clones.push(clonedSelf);
  });
  return this.constructor.call(this.constructor, this._makeDomArray(clones));
};

/*eslint-disable jsdoc/check-param-names*/

/**
 * Insert content previous to each element in the set of matched elements.
 *
 * @example
 *   $('.apple').before('<li class="plum">Plum</li>');
 *   $.html();
 *   //=>  <ul id="fruits">
 *   //      <li class="plum">Plum</li>
 *   //      <li class="apple">Apple</li>
 *   //      <li class="orange">Orange</li>
 *   //      <li class="pear">Pear</li>
 *   //    </ul>
 *
 * @param {...(string | Element | Element[] | Cheerio | Function)} content -
 *   HTML string, DOM element, array of DOM elements or Cheerio to insert before
 *   each element in the set of matched elements.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/before/}
 */
exports.before = function () {
  var elems = slice.call(arguments);
  var lastIdx = this.length - 1;

  return domEach(this, function (i, el) {
    var parent = el.parent;
    if (!parent) {
      return;
    }

    var siblings = parent.children;
    var index = siblings.indexOf(el);

    // If not found, move on
    /* istanbul ignore next */
    if (index < 0) return;

    var domSrc =
      typeof elems[0] === 'function'
        ? elems[0].call(el, i, html(el.children))
        : elems;

    var dom = this._makeDomArray(domSrc, i < lastIdx);

    // Add element before `el` element
    uniqueSplice(siblings, index, 0, dom, parent);
  });
};

/*eslint-enable jsdoc/check-param-names*/

/**
 * Insert every element in the set of matched elements before the target.
 *
 * @example
 *   $('<li class="plum">Plum</li>').insertBefore('.apple');
 *   $.html();
 *   //=>  <ul id="fruits">
 *   //      <li class="plum">Plum</li>
 *   //      <li class="apple">Apple</li>
 *   //      <li class="orange">Orange</li>
 *   //      <li class="pear">Pear</li>
 *   //    </ul>
 *
 * @param {string | Cheerio} target - Element to insert elements before.
 * @returns {Cheerio} The set of newly inserted elements.
 * @see {@link https://api.jquery.com/insertBefore/}
 */
exports.insertBefore = function (target) {
  var clones = [];
  var self = this;
  if (typeof target === 'string') {
    target = this.constructor.call(
      this.constructor,
      target,
      null,
      this._originalRoot
    );
  }
  target = this._makeDomArray(target);
  self.remove();
  domEach(target, function (_, el) {
    var clonedSelf = self._makeDomArray(self.clone());
    var parent = el.parent;
    if (!parent) {
      return;
    }

    var siblings = parent.children;
    var index = siblings.indexOf(el);

    // If not found, move on
    /* istanbul ignore next */
    if (index < 0) return;

    // Add cloned `this` element(s) after target element
    uniqueSplice(siblings, index, 0, clonedSelf, parent);
    clones.push(clonedSelf);
  });
  return this.constructor.call(this.constructor, this._makeDomArray(clones));
};

/**
 * Removes the set of matched elements from the DOM and all their children.
 * `selector` filters the set of matched elements to be removed.
 *
 * @example
 *   $('.pear').remove();
 *   $.html();
 *   //=>  <ul id="fruits">
 *   //      <li class="apple">Apple</li>
 *   //      <li class="orange">Orange</li>
 *   //    </ul>
 *
 * @param {string} [selector] - Optional selector for elements to remove.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/remove/}
 */
exports.remove = function (selector) {
  // Filter if we have selector
  var elems = selector ? this.filter(selector) : this;

  domEach(elems, function (_, el) {
    DomUtils.removeElement(el);
    el.prev = el.next = el.parent = null;
  });

  return this;
};

/**
 * Replaces matched elements with `content`.
 *
 * @example
 *   const plum = $('<li class="plum">Plum</li>');
 *   $('.pear').replaceWith(plum);
 *   $.html();
 *   //=> <ul id="fruits">
 *   //     <li class="apple">Apple</li>
 *   //     <li class="orange">Orange</li>
 *   //     <li class="plum">Plum</li>
 *   //   </ul>
 *
 * @param {Cheerio | Function} content - Replacement for matched elements.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/replaceWith/}
 */
exports.replaceWith = function (content) {
  return domEach(this, function (i, el) {
    var parent = el.parent;
    if (!parent) {
      return;
    }

    var siblings = parent.children;
    var dom = this._makeDomArray(
      typeof content === 'function' ? content.call(el, i, el) : content
    );

    // In the case that `dom` contains nodes that already exist in other
    // structures, ensure those nodes are properly removed.
    updateDOM(dom, null);

    var index = siblings.indexOf(el);

    // Completely remove old element
    uniqueSplice(siblings, index, 1, dom, parent);

    if (dom.indexOf(el) < 0) {
      el.parent = el.prev = el.next = null;
    }
  });
};

/**
 * Empties an element, removing all its children.
 *
 * @example
 *   $('ul').empty();
 *   $.html();
 *   //=>  <ul id="fruits"></ul>
 *
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/empty/}
 */
exports.empty = function () {
  return domEach(this, function (_, el) {
    el.children.forEach(function (child) {
      child.next = child.prev = child.parent = null;
    });

    el.children.length = 0;
  });
};

/**
 * Gets an HTML content string from the first selected element. If `htmlString`
 * is specified, each selected element's content is replaced by the new content.
 *
 * @example
 *   $('.orange').html();
 *   //=> Orange
 *
 *   $('#fruits').html('<li class="mango">Mango</li>').html();
 *   //=> <li class="mango">Mango</li>
 *
 * @param {string | Cheerio} str - If specified used to replace selection's contents.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/html/}
 */
exports.html = function (str) {
  if (str === undefined) {
    if (!this[0] || !this[0].children) return null;
    return html(this[0].children, this.options);
  }

  var opts = Object.apply({}, this.options); // keep main options

  return domEach(this, function (_, el) {
    el.children.forEach(function (child) {
      child.next = child.prev = child.parent = null;
    });

    opts.context = el;

    var content = str.cheerio
      ? str.clone().get()
      : parse('' + str, opts, false).children;

    updateDOM(content, el);
  });
};

/**
 * Turns the collection to a string. Alias for `.html()`.
 *
 * @returns {string} The rendered document.
 */
exports.toString = function () {
  return html(this, this.options);
};

/**
 * Get the combined text contents of each element in the set of matched
 * elements, including their descendants. If `textString` is specified, each
 * selected element's content is replaced by the new text content.
 *
 * @example
 *   $('.orange').text();
 *   //=> Orange
 *
 *   $('ul').text();
 *   //=>  Apple
 *   //    Orange
 *   //    Pear
 *
 * @param {string | Function} [str] - If specified replacement for the selected
 *   element's contents.
 * @returns {Cheerio | string} The instance itself when setting text, otherwise
 *   the rendered document.
 * @see {@link https://api.jquery.com/text/}
 */
exports.text = function (str) {
  // If `str` is undefined, act as a "getter"
  if (str === undefined) {
    return text(this);
  }
  if (typeof str === 'function') {
    // Function support
    return domEach(this, function (i, el) {
      return exports.text.call(this._make(el), str.call(el, i, text([el])));
    });
  }

  // Append text node to each selected elements
  return domEach(this, function (_, el) {
    el.children.forEach(function (child) {
      child.next = child.prev = child.parent = null;
    });

    var textNode = new domhandler.Text(str);

    updateDOM(textNode, el);
  });
};

/**
 * Clone the cheerio object.
 *
 * @example
 *   const moreFruit = $('#fruits').clone();
 *
 * @returns {Cheerio} The cloned object.
 * @see {@link https://api.jquery.com/clone/}
 */
exports.clone = function () {
  return this._make(cloneDom(this.get()));
};
}(manipulation));

var css = {};

/** @module cheerio/css */

var domEach = utils$n.domEach;

var toString$1 = Object.prototype.toString;

/**
 * Get the value of a style property for the first element in the set of matched
 * elements or set one or more CSS properties for every matched element.
 *
 * @param {string | object} prop - The name of the property.
 * @param {string} [val] - If specified the new value.
 * @returns {Cheerio} The instance itself.
 * @see {@link https://api.jquery.com/css/}
 */
css.css = function (prop, val) {
  if (
    arguments.length === 2 ||
    // When `prop` is a "plain" object
    toString$1.call(prop) === '[object Object]'
  ) {
    return domEach(this, function (idx, el) {
      setCss(el, prop, val, idx);
    });
  }
  return getCss(this[0], prop);
};

/**
 * Set styles of all elements.
 *
 * @private
 * @param {Element} el - Element to set style of.
 * @param {string | object} prop - Name of property.
 * @param {string | Function} val - Value to set property to.
 * @param {number} [idx] - Optional index within the selection.
 */
function setCss(el, prop, val, idx) {
  if (typeof prop === 'string') {
    var styles = getCss(el);
    if (typeof val === 'function') {
      val = val.call(el, idx, styles[prop]);
    }

    if (val === '') {
      delete styles[prop];
    } else if (val != null) {
      styles[prop] = val;
    }

    el.attribs.style = stringify$9(styles);
  } else if (typeof prop === 'object') {
    Object.keys(prop).forEach(function (k) {
      setCss(el, k, prop[k]);
    });
  }
}

/**
 * Get parsed styles of the first element.
 *
 * @private
 * @param {Element} el - Element to get styles from.
 * @param {string | string[]} [prop] - Name of the prop.
 * @returns {object | undefined} The parsed styles.
 */
function getCss(el, prop) {
  if (!el || !el.attribs) return;

  var styles = parse$9(el.attribs.style);
  if (typeof prop === 'string') {
    return styles[prop];
  }
  if (Array.isArray(prop)) {
    var newStyles = {};
    prop.forEach(function (item) {
      if (styles[item] != null) {
        newStyles[item] = styles[item];
      }
    });
    return newStyles;
  }
  return styles;
}

/**
 * Stringify `obj` to styles.
 *
 * @private
 * @param {object} obj - Object to stringify.
 * @returns {string} The serialized styles.
 */
function stringify$9(obj) {
  return Object.keys(obj || {}).reduce(function (str, prop) {
    return (str += '' + (str ? ' ' : '') + prop + ': ' + obj[prop] + ';');
  }, '');
}

/**
 * Parse `styles`.
 *
 * @private
 * @param {string} styles - Styles to be parsed.
 * @returns {object} The parsed styles.
 */
function parse$9(styles) {
  styles = (styles || '').trim();

  if (!styles) return {};

  return styles.split(';').reduce(function (obj, str) {
    var n = str.indexOf(':');
    // skip if there is no :, or if it is the first/last character
    if (n < 1 || n === str.length - 1) return obj;
    obj[str.slice(0, n).trim()] = str.slice(n + 1).trim();
    return obj;
  }, {});
}

var forms = {};

/** @module cheerio/forms */

// https://github.com/jquery/jquery/blob/2.1.3/src/manipulation/var/rcheckableType.js
// https://github.com/jquery/jquery/blob/2.1.3/src/serialize.js
var submittableSelector = 'input,select,textarea,keygen';
var r20 = /%20/g;
var rCRLF = /\r?\n/g;

/**
 * Encode a set of form elements as a string for submission.
 *
 * @returns {string} The serialized form.
 * @see {@link https://api.jquery.com/serialize/}
 */
forms.serialize = function () {
  // Convert form elements into name/value objects
  var arr = this.serializeArray();

  // Serialize each element into a key/value string
  var retArr = arr.map(function (data) {
    return encodeURIComponent(data.name) + '=' + encodeURIComponent(data.value);
  });

  // Return the resulting serialization
  return retArr.join('&').replace(r20, '+');
};

/**
 * Encode a set of form elements as an array of names and values.
 *
 * @example
 *   $('<form><input name="foo" value="bar" /></form>').serializeArray();
 *   //=> [ { name: 'foo', value: 'bar' } ]
 *
 * @returns {object[]} The serialized form.
 * @this {Cheerio}
 * @see {@link https://api.jquery.com/serializeArray/}
 */
forms.serializeArray = function () {
  // Resolve all form elements from either forms or collections of form elements
  var Cheerio = this.constructor;
  return this.map(function (_, elem) {
    var $elem = Cheerio(elem);
    if (elem.name === 'form') {
      return $elem.find(submittableSelector).toArray();
    }
    return $elem.filter(submittableSelector).toArray();
  })
    .filter(
      // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
      '[name!=""]:enabled' +
        // and cannot be clicked (`[type=submit]`) or are used in `x-www-form-urlencoded` (`[type=file]`)
        ':not(:submit, :button, :image, :reset, :file)' +
        // and are either checked/don't have a checkable state
        ':matches([checked], :not(:checkbox, :radio))'
      // Convert each of the elements to its value(s)
    )
    .map(function (_, elem) {
      var $elem = Cheerio(elem);
      var name = $elem.attr('name');
      var value = $elem.val();

      // If there is no value set (e.g. `undefined`, `null`), then default value to empty
      if (value == null) {
        value = '';
      }

      // If we have an array of values (e.g. `<select multiple>`), return an array of key/value pairs
      if (Array.isArray(value)) {
        return value.map(function (val) {
          // We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
          //   These can occur inside of `<textarea>'s`
          return { name: name, value: val.replace(rCRLF, '\r\n') };
        });
        // Otherwise (e.g. `<input type="text">`, return only one key/value pair
      }
      return { name: name, value: value.replace(rCRLF, '\r\n') };

      // Convert our result to an array
    })
    .get();
};

/*
  Module dependencies
*/

var parse$8 = parse$e.exports;
var defaultOptions = options.default;
var flattenOptions = options.flatten;
var isHtml = utils$n.isHtml;

/*
 * The API
 */
var api = [
  attributes$2,
  traversing,
  manipulation,
  css,
  forms,
];

/**
 * Instance of cheerio. Methods are specified in the modules. Usage of this
 * constructor is not recommended. Please use $.load instead.
 *
 * @class
 * @param {string | Cheerio | Node | Node[]} selector - The new selection.
 * @param {string | Cheerio | Node | Node[]} [context] - Context of the selection.
 * @param {string | Cheerio | Node | Node[]} [root] - Sets the root node.
 * @param {object} [options] - Options for the instance.
 * @hideconstructor
 * @mixes module:cheerio/attributes
 * @mixes module:cheerio/css
 * @mixes module:cheerio/forms
 * @mixes module:cheerio/manipulation
 * @mixes module:cheerio/traversing
 */
var Cheerio = (cheerio.exports = function (selector, context, root, options) {
  if (!(this instanceof Cheerio)) {
    return new Cheerio(selector, context, root, options);
  }

  this.length = 0;
  this.options = Object.assign(
    {},
    defaultOptions,
    this.options,
    flattenOptions(options)
  );

  // $(), $(null), $(undefined), $(false)
  if (!selector) return this;

  if (root) {
    if (typeof root === 'string') root = parse$8(root, this.options, false);
    this._root = Cheerio.call(this, root);
  }

  // $(<html>)
  if (typeof selector === 'string' && isHtml(selector)) {
    selector = parse$8(selector, this.options, false).children;
  }

  // $($)
  if (selector.cheerio) return selector;

  // $(dom)
  if (isNode(selector)) selector = [selector];

  // $([dom])
  if (Array.isArray(selector)) {
    selector.forEach(function (elem, idx) {
      this[idx] = elem;
    }, this);
    this.length = selector.length;
    return this;
  }

  // If we don't have a context, maybe we have a root, from loading
  if (!context) {
    context = this._root;
  } else if (typeof context === 'string') {
    if (isHtml(context)) {
      // $('li', '<ul>...</ul>')
      context = parse$8(context, this.options, false);
      context = Cheerio.call(this, context);
    } else {
      // $('li', 'ul')
      selector = context + ' ' + selector;
      context = this._root;
    }
  } else if (!context.cheerio) {
    // $('li', node), $('li', [nodes])
    context = Cheerio.call(this, context);
  }

  // If we still don't have a context, return
  if (!context) return this;

  // #id, .class, tag
  return context.find(selector);
});

/** Set a signature of the object. */
Cheerio.prototype.cheerio = '[cheerio object]';

/*
 * Make cheerio an array-like object
 */
Cheerio.prototype.splice = Array.prototype.splice;

/**
 * Make a cheerio object.
 *
 * @private
 * @param {Node[]} dom - The contents of the new object.
 * @param {Node[]} [context] - The context of the new object.
 * @returns {Cheerio} The new cheerio object.
 */
Cheerio.prototype._make = function (dom, context) {
  var cheerio = new this.constructor(dom, context, this._root, this.options);
  cheerio.prevObject = this;
  return cheerio;
};

/**
 * Retrieve all the DOM elements contained in the jQuery set as an array.
 *
 * @example
 *   $('li').toArray(); //=> [ {...}, {...}, {...} ]
 *
 * @returns {Node[]} The contained items.
 */
Cheerio.prototype.toArray = function () {
  return this.get();
};

// Support for (const element of $(...)) iteration:
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];

// Plug in the API
api.forEach(function (mod) {
  Object.assign(Cheerio.prototype, mod);
});

function isNode(obj) {
  return (
    obj.name ||
    obj.type === 'root' ||
    obj.type === 'text' ||
    obj.type === 'comment'
  );
}

var load = {};

(function (exports) {
/**
 * @module cheerio/load
 * @ignore
 */
var defaultOptions = options.default;
var flattenOptions = options.flatten;
var staticMethods = _static;
var Cheerio = cheerio.exports;
var parse = parse$e.exports;

/**
 * Create a querying function, bound to a document created from the provided
 * markup. Note that similar to web browser contexts, this operation may
 * introduce `<html>`, `<head>`, and `<body>` elements; set `isDocument` to
 * `false` to switch to fragment mode and disable this.
 *
 * See the README section titled "Loading" for additional usage information.
 *
 * @param {string} content - Markup to be loaded.
 * @param {object} [options] - Options for the created instance.
 * @param {boolean} [isDocument] - Allows parser to be switched to fragment mode.
 * @returns {Cheerio} - The loaded document.
 */
exports.load = function (content, options, isDocument) {
  if (content === null || content === undefined) {
    throw new Error('cheerio.load() expects a string');
  }

  options = Object.assign({}, defaultOptions, flattenOptions(options));

  if (typeof isDocument === 'undefined') isDocument = true;

  var root = parse(content, options, isDocument);

  function initialize(selector, context, r, opts) {
    if (!(this instanceof initialize)) {
      return new initialize(selector, context, r, opts);
    }
    opts = Object.assign({}, options, opts);
    return Cheerio.call(this, selector, context, r || root, opts);
  }

  // Ensure that selections created by the "loaded" `initialize` function are
  // true Cheerio instances.
  initialize.prototype = Object.create(Cheerio.prototype);
  initialize.prototype.constructor = initialize;

  // Mimic jQuery's prototype alias for plugin authors.
  initialize.fn = initialize.prototype;

  // Keep a reference to the top-level scope so we can chain methods that implicitly
  // resolve selectors; e.g. $("<span>").(".bar"), which otherwise loses ._root
  initialize.prototype._originalRoot = root;

  // Add in the static methods
  Object.assign(initialize, staticMethods, exports);

  // Add in the root
  initialize._root = root;
  // store options
  initialize._options = options;

  return initialize;
};
}(load));

var name = "cheerio";
var version = "1.0.0-rc.6";
var description = "Tiny, fast, and elegant implementation of core jQuery designed specifically for the server";
var author = "Matt Mueller <mattmuelle@gmail.com> (mat.io)";
var license = "MIT";
var keywords = [
	"htmlparser",
	"jquery",
	"selector",
	"scraper",
	"parser",
	"html"
];
var repository = {
	type: "git",
	url: "git://github.com/cheeriojs/cheerio.git"
};
var bugs = {
	url: "https://github.com/cheeriojs/cheerio/issues"
};
var homepage = "https://cheerio.js.org/";
var main = "./index.js";
var types = "types/index.d.ts";
var files = [
	"index.js",
	"types/index.d.ts",
	"lib"
];
var engines = {
	node: ">= 0.12"
};
var dependencies = {
	"cheerio-select": "^1.3.0",
	"dom-serializer": "^1.3.1",
	domhandler: "^4.1.0",
	htmlparser2: "^6.1.0",
	parse5: "^6.0.1",
	"parse5-htmlparser2-tree-adapter": "^6.0.1"
};
var devDependencies = {
	"@types/node": "^14.14.37",
	benchmark: "^2.1.4",
	"clean-jsdoc-theme": "^3.1.2",
	eslint: "^7.23.0",
	"eslint-config-prettier": "^8.1.0",
	"eslint-plugin-jest": "^24.3.4",
	"eslint-plugin-jsdoc": "^32.3.0",
	"eslint-plugin-node": "^11.1.0",
	husky: "^4.3.8",
	jest: "^26.6.3",
	jquery: "^3.6.0",
	jsdoc: "^3.6.6",
	jsdom: "^16.5.2",
	"lint-staged": "^10.5.4",
	prettier: "^2.2.1",
	"prettier-plugin-jsdoc": "0.3.14",
	tsd: "^0.14.0"
};
var scripts = {
	test: "npm run lint && npm run test:jest && npm run test:types",
	"test:jest": "jest",
	"test:jest:cov": "npm run test:jest -- --coverage",
	"test:types": "tsd",
	lint: "npm run lint:es && npm run lint:prettier",
	"lint:es": "eslint --ignore-path .gitignore .",
	"lint:prettier": "npm run format:prettier:raw -- --check",
	format: "npm run format:es && npm run format:prettier",
	"format:es": "npm run lint:es -- --fix",
	"format:prettier": "npm run format:prettier:raw -- --write",
	"format:prettier:raw": "prettier \"**/*.{js,ts,md,json,yml}\" --ignore-path .gitignore",
	"build:docs": "jsdoc --configure jsdoc-config.json",
	benchmark: "node benchmark/benchmark.js --regex \"^(?!.*highmem)\"",
	bench: "npm run benchmark",
	"pre-commit": "lint-staged"
};
var prettier = {
	singleQuote: true,
	tabWidth: 2
};
var jest = {
	testEnvironment: "node",
	testMatch: [
		"<rootDir>/test/**/*.js"
	],
	testPathIgnorePatterns: [
		"/__fixtures__/"
	]
};
var _resolved = "https://registry.npmjs.org/cheerio/-/cheerio-1.0.0-rc.6.tgz";
var _integrity = "sha512-hjx1XE1M/D5pAtMgvWwE21QClmAEeGHOIDfycgmndisdNgI6PE1cGRQkMGBcsbUbmEQyWu5PJLUcAOjtQS8DWw==";
var _from = "cheerio@1.0.0-rc.6";
var require$$3 = {
	name: name,
	version: version,
	description: description,
	author: author,
	license: license,
	keywords: keywords,
	repository: repository,
	bugs: bugs,
	homepage: homepage,
	main: main,
	types: types,
	files: files,
	engines: engines,
	dependencies: dependencies,
	devDependencies: devDependencies,
	scripts: scripts,
	prettier: prettier,
	"lint-staged": {
	"*.js": [
		"prettier --write",
		"npm run test:lint -- --fix"
	],
	"*.{json,md,ts,yml}": [
		"prettier --write"
	]
},
	jest: jest,
	_resolved: _resolved,
	_integrity: _integrity,
	_from: _from
};

(function (module, exports) {
/**
 * @module cheerio
 * @borrows load.load as load
 * @borrows static.html as html
 * @borrows static.text as text
 * @borrows static.xml as xml
 */
exports = module.exports = cheerio.exports;

var staticMethods = _static;
var loadMethod = load;

/**
 * An identifier describing the version of Cheerio which has been executed.
 *
 * @type {string}
 */
exports.version = require$$3.version;

exports.load = loadMethod.load;
exports.html = staticMethods.html;
exports.text = staticMethods.text;
exports.xml = staticMethods.xml;

/**
 * In order to promote consistency with the jQuery library, users are encouraged
 * to instead use the static method of the same name.
 *
 * @deprecated
 * @example
 *   var $ = cheerio.load('<div><p></p></div>');
 *   $.contains($('div').get(0), $('p').get(0)); // true
 *   $.contains($('p').get(0), $('div').get(0)); // false
 *
 * @function
 * @returns {boolean}
 */
exports.contains = staticMethods.contains;

/**
 * In order to promote consistency with the jQuery library, users are encouraged
 * to instead use the static method of the same name.
 *
 * @deprecated
 * @example
 *   var $ = cheerio.load('');
 *   $.merge([1, 2], [3, 4]); // [1, 2, 3, 4]
 *
 * @function
 */
exports.merge = staticMethods.merge;

/**
 * In order to promote consistency with the jQuery library, users are encouraged
 * to instead use the static method of the same name as it is defined on the
 * "loaded" Cheerio factory function.
 *
 * @deprecated See {@link static/parseHTML}.
 * @example
 *   var $ = cheerio.load('');
 *   $.parseHTML('<b>markup</b>');
 *
 * @function
 */
exports.parseHTML = staticMethods.parseHTML;

/**
 * Users seeking to access the top-level element of a parsed document should
 * instead use the `root` static method of a "loaded" Cheerio function.
 *
 * @deprecated
 * @example
 *   var $ = cheerio.load('');
 *   $.root();
 *
 * @function
 */
exports.root = staticMethods.root;
}(cheerio$1, cheerio$1.exports));

Object.defineProperty(dist, '__esModule', { value: true });

const cheerio2 = cheerio$1.exports;

function _interopDefaultLegacy$1 (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const cheerio2__default = /*#__PURE__*/_interopDefaultLegacy$1(cheerio2);

function declass(html) {
  const {items, map} = parseHTML(html);
  const groups = makeGroups(items).filter((item) => item.uses.size > 5 && getClasses(item).length > 2).sort((a, b) => b.uses.size - a.uses.size);
  return groups.map((g) => ({
    class: g.class,
    uses: Array.from(g.uses).map((u) => map[u])
  }));
}
function makeGroups(items) {
  const itemGroups = {};
  for (let i = 0; i < items.length; i++) {
    for (let j = i + 1; j < items.length; j++) {
      const commonClasses = intersect(getClasses(items[i]), getClasses(items[j]));
      if (commonClasses.length > 1) {
        const uClass = commonClasses.join(" ");
        if (!itemGroups[uClass]) {
          itemGroups[uClass] = {class: uClass, uses: new Set()};
        }
        itemGroups[uClass].uses = union(itemGroups[uClass].uses, items[i].uses, items[j].uses);
      }
    }
  }
  return Object.values(itemGroups);
}
function getClasses(item) {
  if (!item._class) {
    item._class = uniq$1(item.class.split(" ").map((x) => x.trim()).filter(Boolean).sort());
  }
  return item._class;
}
function uniq$1(arr) {
  return Array.from(new Set(arr));
}
function intersect(a, b) {
  return a.filter((item) => b.includes(item));
}
function union(...args) {
  const r = new Set();
  for (const arg of args) {
    arg.forEach((x) => {
      r.add(x);
    });
  }
  return r;
}
function parseHTML(html) {
  const items = [];
  const map = {};
  const $ = cheerio2__default['default'].load(html);
  $("*").each((id, el) => {
    map[id] = `<${el.tagName} ${Object.entries(el.attribs).map((a) => `${a[0]}="${a[1]}"`).join(" ")}>`;
    const item = {
      uses: new Set(),
      class: el.attribs.class || ""
    };
    item.uses.add(id);
    if (getClasses(item).length > 1) {
      items.push(item);
    }
  });
  return {
    items,
    map
  };
}

var declass_1 = dist.declass = declass;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$2 = function(d, b) {
    extendStatics$2 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics$2(d, b);
};

function __extends$2(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$2(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __spreadArray$2(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

function toArray$3(v) {
    if (Array.isArray(v))
        return v;
    return [v];
}
function hash$1(str) {
    str = str.replace(/\r/g, '');
    var hash = 5381;
    var i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return (hash >>> 0).toString(36);
}
function indent$2(code, tab) {
    if (tab === void 0) { tab = 2; }
    var spaces = Array(tab).fill(' ').join('');
    return code
        .split('\n')
        .map(function (line) { return spaces + line; })
        .join('\n');
}
function wrapit$2(code, start, end, tab, minify) {
    if (start === void 0) { start = '{'; }
    if (end === void 0) { end = '}'; }
    if (tab === void 0) { tab = 2; }
    if (minify === void 0) { minify = false; }
    if (minify)
        return "" + start + code + end;
    return start + "\n" + indent$2(code, tab) + "\n" + end;
}
function camelToDash$2(str) {
    // Use exact the same regex as Post CSS
    return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}
function searchFrom$2(text, target, startIndex, endIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    // search from partial of string
    var subText = text.substring(startIndex, endIndex);
    var relativeIndex = subText.search(target);
    return relativeIndex === -1 ? -1 : startIndex + relativeIndex;
}
function connectList$2(a, b, append) {
    if (append === void 0) { append = true; }
    return append ? __spreadArray$2(__spreadArray$2([], (a !== null && a !== void 0 ? a : [])), (b !== null && b !== void 0 ? b : [])) : __spreadArray$2(__spreadArray$2([], (b !== null && b !== void 0 ? b : [])), (a !== null && a !== void 0 ? a : []));
}
function deepCopy$2(source) {
    return Array.isArray(source)
        ? source.map(function (item) { return deepCopy$2(item); })
        : source instanceof Date
            ? new Date(source.getTime())
            : source && typeof source === 'object'
                ? Object.getOwnPropertyNames(source).reduce(function (o, prop) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, prop);
                    if (descriptor) {
                        Object.defineProperty(o, prop, descriptor);
                        if (source && typeof source === 'object') {
                            o[prop] = deepCopy$2(source[prop]);
                        }
                    }
                    return o;
                }, Object.create(Object.getPrototypeOf(source)))
                : source;
}
function isTagName$2(name) {
    return ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embd', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].includes(name);
}
function searchPropEnd$2(text, startIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    var index = startIndex;
    var output = -1;
    var openSingleQuote = false;
    var openDoubleQuote = false;
    var openBracket = false;
    var isEscaped = false;
    while (index < text.length) {
        switch (text.charAt(index)) {
            case '\\':
                isEscaped = !isEscaped;
                break;
            case '\'':
                if (!openDoubleQuote && !openBracket && !isEscaped)
                    openSingleQuote = !openSingleQuote;
                isEscaped = false;
                break;
            case '"':
                if (!openSingleQuote && !openBracket && !isEscaped)
                    openDoubleQuote = !openDoubleQuote;
                isEscaped = false;
                break;
            case '(':
                if (!openBracket && !openSingleQuote && !openDoubleQuote && !isEscaped)
                    openBracket = true;
                isEscaped = false;
                break;
            case ')':
                if (openBracket && !isEscaped)
                    openBracket = false;
                isEscaped = false;
                break;
            case ';':
                if (!isEscaped && !openSingleQuote && !openDoubleQuote && !openBracket)
                    output = index;
                isEscaped = false;
                break;
            default:
                isEscaped = false;
                break;
        }
        if (output !== -1)
            break;
        index++;
    }
    return output;
}

var Property$2 = /** @class */ (function () {
    function Property(name, value, comment, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'utilities', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.name = name;
        this.value = value;
        this.comment = comment;
        this.important = important;
    }
    Property._singleParse = function (css) {
        css = css.trim();
        if (!css)
            return;
        if (css.charAt(0) === '@')
            return InlineAtRule$2.parse(css);
        var split = css.search(':');
        var end = searchPropEnd$2(css);
        if (split === -1)
            return;
        var important = false;
        var prop = css.substring(split + 1, end === -1 ? undefined : end).trim();
        if (/!important;?$/.test(prop)) {
            important = true;
            prop = prop.replace(/!important/, '').trimRight();
        }
        return new Property(css.substring(0, split).trim(), prop, undefined, important);
    };
    Property.parse = function (css) {
        if (!/;\s*$/.test(css))
            css += ';'; // Fix for the situation where the last semicolon is omitted
        var properties = [];
        var index = 0;
        var end = searchPropEnd$2(css, index);
        while (end !== -1) {
            var parsed = this._singleParse(css.substring(searchFrom$2(css, /\S/, index), end + 1));
            if (parsed)
                properties.push(parsed);
            index = end + 1;
            end = searchPropEnd$2(css, index);
        }
        var count = properties.length;
        if (count > 1)
            return properties;
        if (count === 1)
            return properties[0];
    };
    Property.prototype.clone = function () {
        return deepCopy$2(this);
    };
    Property.prototype.toStyle = function (selector) {
        var style = new Style$2(selector, this, this.important);
        style.meta = this.meta;
        return style;
    };
    Property.prototype.build = function (minify) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        var createProperty = function (name, value) {
            if (minify) {
                return name + ":" + value + (_this.important ? '!important' : '') + ";";
            }
            else {
                var p = name + ": " + value + (_this.important ? ' !important' : '') + ";";
                return _this.comment ? p + (" /* " + _this.comment + " */") : p;
            }
        };
        if (!this.value)
            return '';
        return typeof this.name === 'string'
            ? createProperty(this.name, this.value)
            : this.name
                .map(function (i) { return createProperty(i, _this.value); })
                .join(minify ? '' : '\n');
    };
    Property.prototype.updateMeta = function (type, group, order, offset, corePlugin) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
        };
        return this;
    };
    return Property;
}());
var InlineAtRule$2 = /** @class */ (function (_super) {
    __extends$2(InlineAtRule, _super);
    function InlineAtRule(name, value, important) {
        if (important === void 0) { important = false; }
        var _this = _super.call(this, name, value, undefined, important) || this;
        _this.name = name;
        return _this;
    }
    InlineAtRule.parse = function (css) {
        var _a;
        var matchName = css.match(/@[^\s;{}]+/);
        if (matchName) {
            var name_1 = matchName[0].substring(1);
            var important = false;
            var expression = matchName.index !== undefined
                ? (_a = css
                    .substring(matchName.index + name_1.length + 1)
                    .match(/(?:(['"]).*?\1|[^;])*/)) === null || _a === void 0 ? void 0 : _a[0].trim()
                : undefined;
            if (expression && /!important;?$/.test(expression)) {
                important = true;
                expression = expression.replace(/!important/, '').trimRight();
            }
            return new InlineAtRule(name_1, expression === '' ? undefined : expression, important);
        }
    };
    InlineAtRule.prototype.build = function () {
        return this.value
            ? "@" + this.name + " " + this.value + (this.important ? ' !important' : '') + ";"
            : "@" + this.name + (this.important ? ' !important' : '') + ";";
    };
    return InlineAtRule;
}(Property$2));
var Style$2 = /** @class */ (function () {
    function Style(selector, property, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'components', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.selector = selector;
        this.important = important;
        this.property = toArray$3(property || []);
    }
    Object.defineProperty(Style.prototype, "rule", {
        get: function () {
            var _this = this;
            var _a, _b, _c;
            var selectors = ((_a = this.selector) !== null && _a !== void 0 ? _a : '').trim().split(/\s*,\s*/g);
            this._parentSelectors && (selectors = selectors.map(function (i) { var _a; return ((_a = _this._parentSelectors) === null || _a === void 0 ? void 0 : _a.join(' ')) + " " + i; }));
            ((_b = this._wrapSelectors) !== null && _b !== void 0 ? _b : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            this._pseudoClasses && (selectors = selectors.map(function (i) { var _a; return i + (":" + ((_a = _this._pseudoClasses) === null || _a === void 0 ? void 0 : _a.join(':'))); }));
            this._pseudoElements && (selectors = selectors.map(function (i) { var _a; return i + ("::" + ((_a = _this._pseudoElements) === null || _a === void 0 ? void 0 : _a.join('::'))); }));
            this._brotherSelectors && (selectors = selectors.map(function (i) { var _a; return i + ("." + ((_a = _this._brotherSelectors) === null || _a === void 0 ? void 0 : _a.join('.'))); }));
            this._childSelectors && (selectors = selectors.map(function (i) { var _a; return i + (" " + ((_a = _this._childSelectors) === null || _a === void 0 ? void 0 : _a.join(' '))); }));
            ((_c = this._wrapRules) !== null && _c !== void 0 ? _c : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            return selectors.join(', ');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoClasses", {
        get: function () {
            return this._pseudoClasses;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoElements", {
        get: function () {
            return this._pseudoElements;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "parentSelectors", {
        get: function () {
            return this._parentSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "childSelectors", {
        get: function () {
            return this._childSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "brotherSelectors", {
        get: function () {
            return this._brotherSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapProperties", {
        get: function () {
            return this._wrapProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapSelectors", {
        get: function () {
            return this._wrapSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapRules", {
        get: function () {
            return this._wrapRules;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "simple", {
        get: function () {
            // is this style only has property and no wrap?
            return !(this.atRules || this._pseudoClasses || this._pseudoElements || this._parentSelectors || this._childSelectors || this._brotherSelectors || this._wrapProperties || this._wrapSelectors || this._wrapRules);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "isAtrule", {
        get: function () {
            return !(this.atRules === undefined || this.atRules.length === 0);
        },
        enumerable: false,
        configurable: true
    });
    Style.generate = function (parent, property, root) {
        if (!root)
            root = (parent === null || parent === void 0 ? void 0 : parent.startsWith('@'))
                ? new Style().atRule(parent)
                : new Style(parent);
        var output = [];
        var _loop_1 = function (key, value) {
            if (typeof value === 'string') {
                root.add(new Property$2(camelToDash$2(key), value));
            }
            else if (Array.isArray(value)) {
                value.map(function (i) { return root === null || root === void 0 ? void 0 : root.add(new Property$2(camelToDash$2(key), i)); });
            }
            else {
                var wrap = deepCopy$2(root);
                wrap.property = [];
                var child = void 0;
                if (key.startsWith('@')) {
                    child = wrap.atRule(key, false);
                }
                else {
                    if (wrap.selector === undefined) {
                        wrap.selector = key;
                        child = wrap;
                    }
                    else {
                        if (/^[a-z]+$/.test(key) && !isTagName$2(key)) {
                            wrap.wrapProperty(function (property) { return key + "-" + property; });
                            child = wrap;
                        }
                        else {
                            var _hKey_1 = function (selector, key) { return (/&/.test(key) ? key : "& " + key).replace('&', selector); };
                            wrap.wrapSelector(function (selector) {
                                return selector
                                    .trim()
                                    .split(/\s*,\s*/g)
                                    .map(function (s) {
                                    return key
                                        .split(/\s*,\s*/g)
                                        .map(function (i) { return _hKey_1(s, i); })
                                        .join(', ');
                                })
                                    .join(', ');
                            });
                            child = wrap;
                        }
                    }
                }
                output = output.concat(Style.generate(key.startsWith('@') ? undefined : key, value, child));
            }
        };
        for (var _i = 0, _a = Object.entries(property !== null && property !== void 0 ? property : {}); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
        if (root.property.length > 0)
            output.unshift(root);
        return output;
    };
    Style.prototype.atRule = function (atrule, append) {
        if (append === void 0) { append = true; }
        if (!atrule)
            return this;
        if (this.atRules) {
            append ? this.atRules.push(atrule) : this.atRules.unshift(atrule);
        }
        else {
            this.atRules = [atrule];
        }
        return this;
    };
    Style.prototype.pseudoClass = function (string) {
        if (this._pseudoClasses) {
            this._pseudoClasses.push(string);
        }
        else {
            this._pseudoClasses = [string];
        }
        return this;
    };
    Style.prototype.pseudoElement = function (string) {
        if (this._pseudoElements) {
            this._pseudoElements.push(string);
        }
        else {
            this._pseudoElements = [string];
        }
        return this;
    };
    Style.prototype.brother = function (string) {
        if (this._brotherSelectors) {
            this._brotherSelectors.push(string);
        }
        else {
            this._brotherSelectors = [string];
        }
        return this;
    };
    Style.prototype.parent = function (string) {
        if (this._parentSelectors) {
            this._parentSelectors.push(string);
        }
        else {
            this._parentSelectors = [string];
        }
        return this;
    };
    Style.prototype.child = function (string) {
        if (this._childSelectors) {
            this._childSelectors.push(string);
        }
        else {
            this._childSelectors = [string];
        }
        return this;
    };
    Style.prototype.wrapProperty = function (func) {
        if (this._wrapProperties) {
            this._wrapProperties.push(func);
        }
        else {
            this._wrapProperties = [func];
        }
        return this;
    };
    Style.prototype.wrapSelector = function (func) {
        if (this._wrapSelectors) {
            this._wrapSelectors.push(func);
        }
        else {
            this._wrapSelectors = [func];
        }
        return this;
    };
    Style.prototype.wrapRule = function (func) {
        if (this._wrapRules) {
            this._wrapRules.push(func);
        }
        else {
            this._wrapRules = [func];
        }
        return this;
    };
    Style.prototype.add = function (item) {
        item = toArray$3(item);
        if (this.important)
            item.forEach(function (i) { return (i.important = true); });
        this.property = __spreadArray$2(__spreadArray$2([], this.property), item);
        return this;
    };
    Style.prototype.extend = function (item, onlyProperty, append) {
        if (onlyProperty === void 0) { onlyProperty = false; }
        if (append === void 0) { append = true; }
        if (!item)
            return this;
        if (item.wrapProperties) {
            var props_1 = [];
            item.property.forEach(function (p) {
                var _a;
                var pc = new Property$2(p.name, p.value, p.comment);
                (_a = item.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) {
                    pc.name = Array.isArray(pc.name)
                        ? pc.name.map(function (i) { return wrap(i); })
                        : wrap(pc.name);
                });
                if (item.important)
                    pc.important = true;
                props_1.push(pc);
            });
            this.property = connectList$2(this.property, props_1, append);
        }
        else {
            if (item.important)
                item.property.forEach(function (i) { return (i.important = true); });
            this.property = connectList$2(this.property, item.property, append);
        }
        if (onlyProperty)
            return this;
        item.selector && (this.selector = item.selector);
        this.meta = item.meta;
        item.atRules &&
            (this.atRules = connectList$2(item.atRules, this.atRules, append)); // atrule is build in reverse
        item._brotherSelectors &&
            (this._brotherSelectors = connectList$2(this._brotherSelectors, item._brotherSelectors, append));
        item._childSelectors &&
            (this._childSelectors = connectList$2(this._childSelectors, item._childSelectors, append));
        item._parentSelectors &&
            (this._parentSelectors = connectList$2(this._parentSelectors, item._parentSelectors, append));
        item._pseudoClasses &&
            (this._pseudoClasses = connectList$2(this._pseudoClasses, item._pseudoClasses, append));
        item._pseudoElements &&
            (this._pseudoElements = connectList$2(this._pseudoElements, item._pseudoElements, append));
        item._wrapRules &&
            (this._wrapRules = connectList$2(this._wrapRules, item._wrapRules, append));
        item._wrapSelectors &&
            (this._wrapSelectors = connectList$2(this._wrapSelectors, item._wrapSelectors, append));
        return this;
    };
    Style.prototype.clean = function () {
        // remove duplicated property
        var property = [];
        var cache = [];
        this.property.forEach(function (i) {
            var inline = i.build();
            if (!cache.includes(inline)) {
                cache.push(inline);
                property.push(i);
            }
        });
        this.property = property;
        return this;
    };
    Style.prototype.flat = function () {
        var properties = [];
        this.property.forEach(function (p) {
            if (Array.isArray(p.name)) {
                p.name.forEach(function (i) {
                    properties.push(new Property$2(i, p.value, p.comment));
                });
            }
            else {
                properties.push(p);
            }
        });
        this.property = properties;
        return this;
    };
    Style.prototype.clone = function (selector, property) {
        var newStyle = deepCopy$2(this);
        if (selector)
            newStyle.selector = selector;
        if (property)
            newStyle.property = Array.isArray(property) ? property : [property];
        return newStyle;
    };
    Style.prototype.sort = function () {
        // sort property
        this.property = this.property.sort(function (a, b) {
            return ("" + a.name).substring(0, 2) > ("" + b.name).substring(0, 2) ? 1 : -1;
        });
        return this;
    };
    Style.prototype.build = function (minify, prefixer) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        if (prefixer === void 0) { prefixer = true; }
        var properties = this.property;
        if (!prefixer)
            properties = properties.filter(function (p) {
                if (p.value && /-(webkit|ms|moz|o)-/.test(p.value))
                    return false;
                if (Array.isArray(p.name)) {
                    p.name = p.name.filter(function (i) { return !/^-(webkit|ms|moz|o)-/.test(i); });
                    return true;
                }
                return !/^-(webkit|ms|moz|o)-/.test(p.name);
            });
        var result = properties.map(function (p) {
            if (_this._wrapProperties) {
                var name_2 = p.name;
                _this._wrapProperties.forEach(function (w) { return (name_2 = Array.isArray(name_2) ? name_2.map(function (n) { return w(n); }) : w(name_2)); });
                return new Property$2(name_2, p.value, p.comment, _this.important ? true : p.important).build(minify);
            }
            return _this.important ? new Property$2(p.name, p.value, p.comment, true).build(minify) : p.build(minify);
        }).join(minify ? '' : '\n');
        if (!this.selector && !this.atRules)
            return result.replace(/;}/g, '}');
        if (this.selector)
            result = (minify ? this.rule.replace(/,\s/g, ',') : this.rule + ' ') + wrapit$2(result, undefined, undefined, undefined, result !== '' ? minify : true);
        if (this.atRules) {
            for (var _i = 0, _a = this.atRules; _i < _a.length; _i++) {
                var rule = _a[_i];
                result = minify ? "" + rule.replace(/\s/g, '') + wrapit$2(result, undefined, undefined, undefined, minify) : rule + " " + wrapit$2(result, undefined, undefined, undefined, result !== '' ? minify : true);
            }
        }
        return minify ? result.replace(/;}/g, '}') : result;
    };
    Style.prototype.updateMeta = function (type, group, order, offset, corePlugin, respectSelector) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        if (respectSelector === void 0) { respectSelector = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
            respectSelector: respectSelector,
        };
        return this;
    };
    return Style;
}());
/** @class */ ((function (_super) {
    __extends$2(GlobalStyle, _super);
    function GlobalStyle(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return GlobalStyle;
})(Style$2));
/** @class */ ((function (_super) {
    __extends$2(Keyframes, _super);
    function Keyframes(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    // root param only for consist with style
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Keyframes.generate = function (name, children, root, prefixer) {
        if (prefixer === void 0) { prefixer = true; }
        var styles = [];
        var webkitStyles = [];
        for (var _i = 0, _a = Object.entries(children); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var style = new Keyframes(key).atRule("@keyframes " + name);
            var webkitStyle = new Keyframes(key).atRule("@-webkit-keyframes " + name);
            for (var _c = 0, _d = Object.entries(value); _c < _d.length; _c++) {
                var _e = _d[_c], pkey = _e[0], pvalue = _e[1];
                var prop = pkey;
                if (pkey === 'transform') {
                    prop = prefixer ? ['-webkit-transform', 'transform'] : 'transform';
                }
                else if (['animationTimingFunction', 'animation-timing-function'].includes(pkey)) {
                    prop = prefixer ? [
                        '-webkit-animation-timing-function',
                        'animation-timing-function',
                    ] : 'animation-timing-function';
                }
                style.add(new Property$2(prop, pvalue));
                webkitStyle.add(new Property$2(prop, pvalue));
            }
            styles.push(style);
            if (prefixer)
                webkitStyles.push(webkitStyle);
        }
        return __spreadArray$2(__spreadArray$2([], styles), webkitStyles);
    };
    return Keyframes;
})(Style$2));
/** @class */ ((function (_super) {
    __extends$2(Container, _super);
    function Container(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return Container;
})(Style$2));

var minMaxWidth$1 = /(!?\(\s*min(-device-)?-width).+\(\s*max(-device)?-width/i;
var minWidth$1 = /\(\s*min(-device)?-width/i;
var maxMinWidth$1 = /(!?\(\s*max(-device)?-width).+\(\s*min(-device)?-width/i;
var maxWidth$1 = /\(\s*max(-device)?-width/i;
var isMinWidth$1 = _testQuery$1(minMaxWidth$1, maxMinWidth$1, minWidth$1);
var isMaxWidth$1 = _testQuery$1(maxMinWidth$1, minMaxWidth$1, maxWidth$1);
var minMaxHeight$1 = /(!?\(\s*min(-device)?-height).+\(\s*max(-device)?-height/i;
var minHeight$1 = /\(\s*min(-device)?-height/i;
var maxMinHeight$1 = /(!?\(\s*max(-device)?-height).+\(\s*min(-device)?-height/i;
var maxHeight$1 = /\(\s*max(-device)?-height/i;
var isMinHeight$1 = _testQuery$1(minMaxHeight$1, maxMinHeight$1, minHeight$1);
var isMaxHeight$1 = _testQuery$1(maxMinHeight$1, minMaxHeight$1, maxHeight$1);
var isPrint$1 = /print/i;
var isPrintOnly$1 = /^print\$/i;
var isAtRule$1 = /^\s*@/i;
var isMedia$1 = /^\s*@media/i;
var maxValue$1 = Number.MAX_VALUE;
function _getQueryLength$1(length) {
    var result = /(-?\d*\.?\d+)(ch|em|ex|px|rpx|rem)/.exec(length);
    if (result === null) {
        return maxValue$1;
    }
    var number = result[1];
    var unit = result[2];
    switch (unit) {
        case 'ch':
            return parseFloat(number) * 8.8984375;
        case 'em':
        case 'rem':
            return parseFloat(number) * 16;
        case 'ex':
            return parseFloat(number) * 8.296875;
        case 'px':
        case 'rpx':
            return parseFloat(number);
    }
    return +number;
}
function _testQuery$1(doubleTestTrue, doubleTestFalse, singleTest) {
    return function (query) {
        if (doubleTestTrue.test(query)) {
            return true;
        }
        else if (doubleTestFalse.test(query)) {
            return false;
        }
        return singleTest.test(query);
    };
}
function _testAtRule$1(a, b) {
    var isMediaA = isMedia$1.test(a);
    var isMediaB = isMedia$1.test(b);
    if (isMediaA && isMediaB)
        return null;
    var isAtRuleA = isAtRule$1.test(a);
    var isAtRuleB = isAtRule$1.test(b);
    if (isAtRuleA)
        return 1;
    if (isAtRuleB)
        return -1;
    return 0; // don't sort selector name, may cause overwrite bug.
}
function _testIsPrint$1(a, b) {
    var isPrintA = isPrint$1.test(a);
    var isPrintOnlyA = isPrintOnly$1.test(a);
    var isPrintB = isPrint$1.test(b);
    var isPrintOnlyB = isPrintOnly$1.test(b);
    if (isPrintA && isPrintB) {
        if (!isPrintOnlyA && isPrintOnlyB) {
            return 1;
        }
        if (isPrintOnlyA && !isPrintOnlyB) {
            return -1;
        }
        return a.localeCompare(b);
    }
    if (isPrintA) {
        return 1;
    }
    if (isPrintB) {
        return -1;
    }
    return null;
}
function sortMediaQuery$1(a, b) {
    var testAtRule = _testAtRule$1(a, b);
    if (testAtRule !== null)
        return testAtRule;
    var testIsPrint = _testIsPrint$1(a, b);
    if (testIsPrint !== null)
        return testIsPrint;
    var minA = isMinWidth$1(a) || isMinHeight$1(a);
    var maxA = isMaxWidth$1(a) || isMaxHeight$1(a);
    var minB = isMinWidth$1(b) || isMinHeight$1(b);
    var maxB = isMaxWidth$1(b) || isMaxHeight$1(b);
    if (minA && maxB) {
        return -1;
    }
    if (maxA && minB) {
        return 1;
    }
    var lengthA = _getQueryLength$1(a);
    var lengthB = _getQueryLength$1(b);
    if (lengthA === maxValue$1 && lengthB === maxValue$1) {
        return a.localeCompare(b);
    }
    else if (lengthA === maxValue$1) {
        return 1;
    }
    else if (lengthB === maxValue$1) {
        return -1;
    }
    if (lengthA > lengthB) {
        if (maxA) {
            return -1;
        }
        return 1;
    }
    if (lengthA < lengthB) {
        if (maxA) {
            return 1;
        }
        return -1;
    }
    return a.localeCompare(b);
}

function getWeights$1(a) {
    var first = a.charAt(0);
    var second = a.charAt(1);
    if (first === ':' && second === ':')
        return 59; // ::moz ...
    if (first === '#')
        return 500; // #id ...
    if (first !== '.')
        return first.charCodeAt(0); // html, body ...
    return 499;
}
function sortMeta$1(a, b) {
    var _a, _b, _c, _d;
    if (a.meta.type === 'base' && b.meta.type === 'base')
        return getWeights$1((_a = a.selector) !== null && _a !== void 0 ? _a : '') - getWeights$1((_b = b.selector) !== null && _b !== void 0 ? _b : '');
    return sortMediaQuery$1(((_c = a.meta.variants) === null || _c === void 0 ? void 0 : _c[0]) || '', ((_d = b.meta.variants) === null || _d === void 0 ? void 0 : _d[0]) || '') || (a.meta.order - b.meta.order) || (a.meta.offset - b.meta.offset) || +b.meta.corePlugin - +a.meta.corePlugin;
}

function _buildAtrule$1(atrule, children, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return "" + atrule + (minify ? '' : ' ') + wrapit$2(_buildStyleList$1(children, minify, prefixer), undefined, undefined, undefined, minify);
}
function _buildStyleList$1(styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    var currentAtrule;
    var currentStyle;
    var styleStack = [];
    var output = [];
    var _loop_1 = function (style) {
        if (style.isAtrule) {
            if (currentStyle) {
                output.push(currentStyle.clean().build(minify, prefixer));
                currentStyle = undefined;
            }
            var newAtrule = style.atRules.pop();
            if (currentAtrule) {
                if (currentAtrule === newAtrule && newAtrule !== '@font-face') { // @font-face shouldn't been combined
                    styleStack.push(style);
                }
                else {
                    output.push(_buildAtrule$1(currentAtrule, styleStack, minify, prefixer));
                    currentAtrule = newAtrule;
                    styleStack = [style];
                }
            }
            else {
                currentAtrule = newAtrule;
                styleStack = [style];
            }
        }
        else {
            if (currentAtrule) {
                output.push(_buildAtrule$1(currentAtrule, styleStack, minify, prefixer));
                currentAtrule = undefined;
                styleStack = [];
            }
            if (currentStyle) {
                if (style.rule === currentStyle.rule) {
                    if (style.important)
                        style.property.forEach(function (p) { return p.important = true; });
                    if (style.wrapProperties)
                        style.property.forEach(function (p) { var _a; return (_a = style.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) { return p.name = Array.isArray(p.name) ? p.name.map(function (i) { return wrap(i); }) : wrap(p.name); }); });
                    currentStyle.add(style.property);
                }
                else {
                    output.push(currentStyle.clean().build(minify, prefixer));
                    currentStyle = style;
                }
            }
            else {
                currentStyle = style;
            }
        }
    };
    for (var _i = 0, styleList_1 = styleList; _i < styleList_1.length; _i++) {
        var style = styleList_1[_i];
        _loop_1(style);
    }
    if (currentAtrule)
        output.push(_buildAtrule$1(currentAtrule, styleStack, minify, prefixer));
    if (currentStyle)
        output.push(currentStyle.clean().build(minify, prefixer));
    return output.join(minify ? '' : '\n');
}
function compileStyleSheet$1 (styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return _buildStyleList$1(deepCopy$2(styleList), minify, prefixer);
}

var StyleSheet$1 = /** @class */ (function () {
    function StyleSheet(children) {
        this.prefixer = true;
        this.children = children || [];
    }
    StyleSheet.prototype.add = function (item) {
        if (!item)
            return this;
        if (Array.isArray(item)) {
            this.children = __spreadArray$2(__spreadArray$2([], this.children), item);
        }
        else {
            this.children.push(item);
        }
        return this;
    };
    StyleSheet.prototype.extend = function (styleSheet, append, dedup) {
        if (append === void 0) { append = true; }
        if (dedup === void 0) { dedup = false; }
        if (styleSheet) {
            var extended = styleSheet.children;
            if (dedup) {
                var hashes_1 = extended.map(function (i) { return hash$1(i.build()); });
                extended = extended.filter(function (i) { return !hashes_1.includes(hash$1(i.build())); });
            }
            this.prefixer = styleSheet.prefixer;
            this.children = append ? __spreadArray$2(__spreadArray$2([], this.children), extended) : __spreadArray$2(__spreadArray$2([], extended), this.children);
        }
        return this;
    };
    StyleSheet.prototype.combine = function () {
        var styleMap = {};
        this.children.forEach(function (style, index) {
            var _a;
            var hashValue = hash$1(style.atRules + style.rule);
            if (hashValue in styleMap) {
                if ((_a = style.atRules) === null || _a === void 0 ? void 0 : _a.includes('@font-face')) {
                    // keeps multiple @font-face
                    styleMap[hashValue + index] = style;
                }
                else {
                    styleMap[hashValue] = styleMap[hashValue].extend(style, true);
                }
            }
            else {
                styleMap[hashValue] = style;
            }
        });
        this.children = Object.values(styleMap).map(function (i) { return i.clean(); });
        return this;
    };
    StyleSheet.prototype.layer = function (type) {
        var styleSheet = new StyleSheet(this.children.filter(function (i) { return i.meta.type === type; }));
        styleSheet.prefixer = this.prefixer;
        return styleSheet;
    };
    StyleSheet.prototype.split = function () {
        return {
            base: this.layer('base'),
            components: this.layer('components'),
            utilities: this.layer('utilities'),
        };
    };
    StyleSheet.prototype.clone = function () {
        return deepCopy$2(this);
    };
    StyleSheet.prototype.sort = function () {
        this.children = this.children.sort(sortMeta$1);
        return this;
    };
    StyleSheet.prototype.sortby = function (compareFn) {
        this.children = this.children.sort(compareFn);
        return this;
    };
    StyleSheet.prototype.build = function (minify) {
        if (minify === void 0) { minify = false; }
        return compileStyleSheet$1(this.children, minify, this.prefixer);
    };
    return StyleSheet;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$1 = function(d, b) {
    extendStatics$1 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics$1(d, b);
};

function __extends$1(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$1(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __spreadArray$1(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

function toArray$2(v) {
    if (Array.isArray(v))
        return v;
    return [v];
}
function hash(str) {
    str = str.replace(/\r/g, '');
    var hash = 5381;
    var i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return (hash >>> 0).toString(36);
}
function indent$1(code, tab) {
    if (tab === void 0) { tab = 2; }
    var spaces = Array(tab).fill(' ').join('');
    return code
        .split('\n')
        .map(function (line) { return spaces + line; })
        .join('\n');
}
function wrapit$1(code, start, end, tab, minify) {
    if (start === void 0) { start = '{'; }
    if (end === void 0) { end = '}'; }
    if (tab === void 0) { tab = 2; }
    if (minify === void 0) { minify = false; }
    if (minify)
        return "" + start + code + end;
    return start + "\n" + indent$1(code, tab) + "\n" + end;
}
function isSpace(str) {
    return /^\s*$/.test(str);
}
function camelToDash$1(str) {
    // Use exact the same regex as Post CSS
    return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}
function searchFrom$1(text, target, startIndex, endIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    // search from partial of string
    var subText = text.substring(startIndex, endIndex);
    var relativeIndex = subText.search(target);
    return relativeIndex === -1 ? -1 : startIndex + relativeIndex;
}
function connectList$1(a, b, append) {
    if (append === void 0) { append = true; }
    return append ? __spreadArray$1(__spreadArray$1([], (a !== null && a !== void 0 ? a : [])), (b !== null && b !== void 0 ? b : [])) : __spreadArray$1(__spreadArray$1([], (b !== null && b !== void 0 ? b : [])), (a !== null && a !== void 0 ? a : []));
}
function deepCopy$1(source) {
    return Array.isArray(source)
        ? source.map(function (item) { return deepCopy$1(item); })
        : source instanceof Date
            ? new Date(source.getTime())
            : source && typeof source === 'object'
                ? Object.getOwnPropertyNames(source).reduce(function (o, prop) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, prop);
                    if (descriptor) {
                        Object.defineProperty(o, prop, descriptor);
                        if (source && typeof source === 'object') {
                            o[prop] = deepCopy$1(source[prop]);
                        }
                    }
                    return o;
                }, Object.create(Object.getPrototypeOf(source)))
                : source;
}
function isTagName$1(name) {
    return ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embd', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].includes(name);
}
function searchPropEnd$1(text, startIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    var index = startIndex;
    var output = -1;
    var openSingleQuote = false;
    var openDoubleQuote = false;
    var openBracket = false;
    var isEscaped = false;
    while (index < text.length) {
        switch (text.charAt(index)) {
            case '\\':
                isEscaped = !isEscaped;
                break;
            case '\'':
                if (!openDoubleQuote && !openBracket && !isEscaped)
                    openSingleQuote = !openSingleQuote;
                isEscaped = false;
                break;
            case '"':
                if (!openSingleQuote && !openBracket && !isEscaped)
                    openDoubleQuote = !openDoubleQuote;
                isEscaped = false;
                break;
            case '(':
                if (!openBracket && !openSingleQuote && !openDoubleQuote && !isEscaped)
                    openBracket = true;
                isEscaped = false;
                break;
            case ')':
                if (openBracket && !isEscaped)
                    openBracket = false;
                isEscaped = false;
                break;
            case ';':
                if (!isEscaped && !openSingleQuote && !openDoubleQuote && !openBracket)
                    output = index;
                isEscaped = false;
                break;
            default:
                isEscaped = false;
                break;
        }
        if (output !== -1)
            break;
        index++;
    }
    return output;
}

var Property$1 = /** @class */ (function () {
    function Property(name, value, comment, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'utilities', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.name = name;
        this.value = value;
        this.comment = comment;
        this.important = important;
    }
    Property._singleParse = function (css) {
        css = css.trim();
        if (!css)
            return;
        if (css.charAt(0) === '@')
            return InlineAtRule$1.parse(css);
        var split = css.search(':');
        var end = searchPropEnd$1(css);
        if (split === -1)
            return;
        var important = false;
        var prop = css.substring(split + 1, end === -1 ? undefined : end).trim();
        if (/!important;?$/.test(prop)) {
            important = true;
            prop = prop.replace(/!important/, '').trimRight();
        }
        return new Property(css.substring(0, split).trim(), prop, undefined, important);
    };
    Property.parse = function (css) {
        if (!/;\s*$/.test(css))
            css += ';'; // Fix for the situation where the last semicolon is omitted
        var properties = [];
        var index = 0;
        var end = searchPropEnd$1(css, index);
        while (end !== -1) {
            var parsed = this._singleParse(css.substring(searchFrom$1(css, /\S/, index), end + 1));
            if (parsed)
                properties.push(parsed);
            index = end + 1;
            end = searchPropEnd$1(css, index);
        }
        var count = properties.length;
        if (count > 1)
            return properties;
        if (count === 1)
            return properties[0];
    };
    Property.prototype.clone = function () {
        return deepCopy$1(this);
    };
    Property.prototype.toStyle = function (selector) {
        var style = new Style$1(selector, this, this.important);
        style.meta = this.meta;
        return style;
    };
    Property.prototype.build = function (minify) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        var createProperty = function (name, value) {
            if (minify) {
                return name + ":" + value + (_this.important ? '!important' : '') + ";";
            }
            else {
                var p = name + ": " + value + (_this.important ? ' !important' : '') + ";";
                return _this.comment ? p + (" /* " + _this.comment + " */") : p;
            }
        };
        if (!this.value)
            return '';
        return typeof this.name === 'string'
            ? createProperty(this.name, this.value)
            : this.name
                .map(function (i) { return createProperty(i, _this.value); })
                .join(minify ? '' : '\n');
    };
    Property.prototype.updateMeta = function (type, group, order, offset, corePlugin) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
        };
        return this;
    };
    return Property;
}());
var InlineAtRule$1 = /** @class */ (function (_super) {
    __extends$1(InlineAtRule, _super);
    function InlineAtRule(name, value, important) {
        if (important === void 0) { important = false; }
        var _this = _super.call(this, name, value, undefined, important) || this;
        _this.name = name;
        return _this;
    }
    InlineAtRule.parse = function (css) {
        var _a;
        var matchName = css.match(/@[^\s;{}]+/);
        if (matchName) {
            var name_1 = matchName[0].substring(1);
            var important = false;
            var expression = matchName.index !== undefined
                ? (_a = css
                    .substring(matchName.index + name_1.length + 1)
                    .match(/(?:(['"]).*?\1|[^;])*/)) === null || _a === void 0 ? void 0 : _a[0].trim()
                : undefined;
            if (expression && /!important;?$/.test(expression)) {
                important = true;
                expression = expression.replace(/!important/, '').trimRight();
            }
            return new InlineAtRule(name_1, expression === '' ? undefined : expression, important);
        }
    };
    InlineAtRule.prototype.build = function () {
        return this.value
            ? "@" + this.name + " " + this.value + (this.important ? ' !important' : '') + ";"
            : "@" + this.name + (this.important ? ' !important' : '') + ";";
    };
    return InlineAtRule;
}(Property$1));
var Style$1 = /** @class */ (function () {
    function Style(selector, property, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'components', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.selector = selector;
        this.important = important;
        this.property = toArray$2(property || []);
    }
    Object.defineProperty(Style.prototype, "rule", {
        get: function () {
            var _this = this;
            var _a, _b, _c;
            var selectors = ((_a = this.selector) !== null && _a !== void 0 ? _a : '').trim().split(/\s*,\s*/g);
            this._parentSelectors && (selectors = selectors.map(function (i) { var _a; return ((_a = _this._parentSelectors) === null || _a === void 0 ? void 0 : _a.join(' ')) + " " + i; }));
            ((_b = this._wrapSelectors) !== null && _b !== void 0 ? _b : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            this._pseudoClasses && (selectors = selectors.map(function (i) { var _a; return i + (":" + ((_a = _this._pseudoClasses) === null || _a === void 0 ? void 0 : _a.join(':'))); }));
            this._pseudoElements && (selectors = selectors.map(function (i) { var _a; return i + ("::" + ((_a = _this._pseudoElements) === null || _a === void 0 ? void 0 : _a.join('::'))); }));
            this._brotherSelectors && (selectors = selectors.map(function (i) { var _a; return i + ("." + ((_a = _this._brotherSelectors) === null || _a === void 0 ? void 0 : _a.join('.'))); }));
            this._childSelectors && (selectors = selectors.map(function (i) { var _a; return i + (" " + ((_a = _this._childSelectors) === null || _a === void 0 ? void 0 : _a.join(' '))); }));
            ((_c = this._wrapRules) !== null && _c !== void 0 ? _c : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            return selectors.join(', ');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoClasses", {
        get: function () {
            return this._pseudoClasses;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoElements", {
        get: function () {
            return this._pseudoElements;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "parentSelectors", {
        get: function () {
            return this._parentSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "childSelectors", {
        get: function () {
            return this._childSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "brotherSelectors", {
        get: function () {
            return this._brotherSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapProperties", {
        get: function () {
            return this._wrapProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapSelectors", {
        get: function () {
            return this._wrapSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapRules", {
        get: function () {
            return this._wrapRules;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "simple", {
        get: function () {
            // is this style only has property and no wrap?
            return !(this.atRules || this._pseudoClasses || this._pseudoElements || this._parentSelectors || this._childSelectors || this._brotherSelectors || this._wrapProperties || this._wrapSelectors || this._wrapRules);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "isAtrule", {
        get: function () {
            return !(this.atRules === undefined || this.atRules.length === 0);
        },
        enumerable: false,
        configurable: true
    });
    Style.generate = function (parent, property, root) {
        if (!root)
            root = (parent === null || parent === void 0 ? void 0 : parent.startsWith('@'))
                ? new Style().atRule(parent)
                : new Style(parent);
        var output = [];
        var _loop_1 = function (key, value) {
            if (typeof value === 'string') {
                root.add(new Property$1(camelToDash$1(key), value));
            }
            else if (Array.isArray(value)) {
                value.map(function (i) { return root === null || root === void 0 ? void 0 : root.add(new Property$1(camelToDash$1(key), i)); });
            }
            else {
                var wrap = deepCopy$1(root);
                wrap.property = [];
                var child = void 0;
                if (key.startsWith('@')) {
                    child = wrap.atRule(key, false);
                }
                else {
                    if (wrap.selector === undefined) {
                        wrap.selector = key;
                        child = wrap;
                    }
                    else {
                        if (/^[a-z]+$/.test(key) && !isTagName$1(key)) {
                            wrap.wrapProperty(function (property) { return key + "-" + property; });
                            child = wrap;
                        }
                        else {
                            var _hKey_1 = function (selector, key) { return (/&/.test(key) ? key : "& " + key).replace('&', selector); };
                            wrap.wrapSelector(function (selector) {
                                return selector
                                    .trim()
                                    .split(/\s*,\s*/g)
                                    .map(function (s) {
                                    return key
                                        .split(/\s*,\s*/g)
                                        .map(function (i) { return _hKey_1(s, i); })
                                        .join(', ');
                                })
                                    .join(', ');
                            });
                            child = wrap;
                        }
                    }
                }
                output = output.concat(Style.generate(key.startsWith('@') ? undefined : key, value, child));
            }
        };
        for (var _i = 0, _a = Object.entries(property !== null && property !== void 0 ? property : {}); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
        if (root.property.length > 0)
            output.unshift(root);
        return output;
    };
    Style.prototype.atRule = function (atrule, append) {
        if (append === void 0) { append = true; }
        if (!atrule)
            return this;
        if (this.atRules) {
            append ? this.atRules.push(atrule) : this.atRules.unshift(atrule);
        }
        else {
            this.atRules = [atrule];
        }
        return this;
    };
    Style.prototype.pseudoClass = function (string) {
        if (this._pseudoClasses) {
            this._pseudoClasses.push(string);
        }
        else {
            this._pseudoClasses = [string];
        }
        return this;
    };
    Style.prototype.pseudoElement = function (string) {
        if (this._pseudoElements) {
            this._pseudoElements.push(string);
        }
        else {
            this._pseudoElements = [string];
        }
        return this;
    };
    Style.prototype.brother = function (string) {
        if (this._brotherSelectors) {
            this._brotherSelectors.push(string);
        }
        else {
            this._brotherSelectors = [string];
        }
        return this;
    };
    Style.prototype.parent = function (string) {
        if (this._parentSelectors) {
            this._parentSelectors.push(string);
        }
        else {
            this._parentSelectors = [string];
        }
        return this;
    };
    Style.prototype.child = function (string) {
        if (this._childSelectors) {
            this._childSelectors.push(string);
        }
        else {
            this._childSelectors = [string];
        }
        return this;
    };
    Style.prototype.wrapProperty = function (func) {
        if (this._wrapProperties) {
            this._wrapProperties.push(func);
        }
        else {
            this._wrapProperties = [func];
        }
        return this;
    };
    Style.prototype.wrapSelector = function (func) {
        if (this._wrapSelectors) {
            this._wrapSelectors.push(func);
        }
        else {
            this._wrapSelectors = [func];
        }
        return this;
    };
    Style.prototype.wrapRule = function (func) {
        if (this._wrapRules) {
            this._wrapRules.push(func);
        }
        else {
            this._wrapRules = [func];
        }
        return this;
    };
    Style.prototype.add = function (item) {
        item = toArray$2(item);
        if (this.important)
            item.forEach(function (i) { return (i.important = true); });
        this.property = __spreadArray$1(__spreadArray$1([], this.property), item);
        return this;
    };
    Style.prototype.extend = function (item, onlyProperty, append) {
        if (onlyProperty === void 0) { onlyProperty = false; }
        if (append === void 0) { append = true; }
        if (!item)
            return this;
        if (item.wrapProperties) {
            var props_1 = [];
            item.property.forEach(function (p) {
                var _a;
                var pc = new Property$1(p.name, p.value, p.comment);
                (_a = item.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) {
                    pc.name = Array.isArray(pc.name)
                        ? pc.name.map(function (i) { return wrap(i); })
                        : wrap(pc.name);
                });
                if (item.important)
                    pc.important = true;
                props_1.push(pc);
            });
            this.property = connectList$1(this.property, props_1, append);
        }
        else {
            if (item.important)
                item.property.forEach(function (i) { return (i.important = true); });
            this.property = connectList$1(this.property, item.property, append);
        }
        if (onlyProperty)
            return this;
        item.selector && (this.selector = item.selector);
        this.meta = item.meta;
        item.atRules &&
            (this.atRules = connectList$1(item.atRules, this.atRules, append)); // atrule is build in reverse
        item._brotherSelectors &&
            (this._brotherSelectors = connectList$1(this._brotherSelectors, item._brotherSelectors, append));
        item._childSelectors &&
            (this._childSelectors = connectList$1(this._childSelectors, item._childSelectors, append));
        item._parentSelectors &&
            (this._parentSelectors = connectList$1(this._parentSelectors, item._parentSelectors, append));
        item._pseudoClasses &&
            (this._pseudoClasses = connectList$1(this._pseudoClasses, item._pseudoClasses, append));
        item._pseudoElements &&
            (this._pseudoElements = connectList$1(this._pseudoElements, item._pseudoElements, append));
        item._wrapRules &&
            (this._wrapRules = connectList$1(this._wrapRules, item._wrapRules, append));
        item._wrapSelectors &&
            (this._wrapSelectors = connectList$1(this._wrapSelectors, item._wrapSelectors, append));
        return this;
    };
    Style.prototype.clean = function () {
        // remove duplicated property
        var property = [];
        var cache = [];
        this.property.forEach(function (i) {
            var inline = i.build();
            if (!cache.includes(inline)) {
                cache.push(inline);
                property.push(i);
            }
        });
        this.property = property;
        return this;
    };
    Style.prototype.flat = function () {
        var properties = [];
        this.property.forEach(function (p) {
            if (Array.isArray(p.name)) {
                p.name.forEach(function (i) {
                    properties.push(new Property$1(i, p.value, p.comment));
                });
            }
            else {
                properties.push(p);
            }
        });
        this.property = properties;
        return this;
    };
    Style.prototype.clone = function (selector, property) {
        var newStyle = deepCopy$1(this);
        if (selector)
            newStyle.selector = selector;
        if (property)
            newStyle.property = Array.isArray(property) ? property : [property];
        return newStyle;
    };
    Style.prototype.sort = function () {
        // sort property
        this.property = this.property.sort(function (a, b) {
            return ("" + a.name).substring(0, 2) > ("" + b.name).substring(0, 2) ? 1 : -1;
        });
        return this;
    };
    Style.prototype.build = function (minify, prefixer) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        if (prefixer === void 0) { prefixer = true; }
        var properties = this.property;
        if (!prefixer)
            properties = properties.filter(function (p) {
                if (p.value && /-(webkit|ms|moz|o)-/.test(p.value))
                    return false;
                if (Array.isArray(p.name)) {
                    p.name = p.name.filter(function (i) { return !/^-(webkit|ms|moz|o)-/.test(i); });
                    return true;
                }
                return !/^-(webkit|ms|moz|o)-/.test(p.name);
            });
        var result = properties.map(function (p) {
            if (_this._wrapProperties) {
                var name_2 = p.name;
                _this._wrapProperties.forEach(function (w) { return (name_2 = Array.isArray(name_2) ? name_2.map(function (n) { return w(n); }) : w(name_2)); });
                return new Property$1(name_2, p.value, p.comment, _this.important ? true : p.important).build(minify);
            }
            return _this.important ? new Property$1(p.name, p.value, p.comment, true).build(minify) : p.build(minify);
        }).join(minify ? '' : '\n');
        if (!this.selector && !this.atRules)
            return result.replace(/;}/g, '}');
        if (this.selector)
            result = (minify ? this.rule.replace(/,\s/g, ',') : this.rule + ' ') + wrapit$1(result, undefined, undefined, undefined, result !== '' ? minify : true);
        if (this.atRules) {
            for (var _i = 0, _a = this.atRules; _i < _a.length; _i++) {
                var rule = _a[_i];
                result = minify ? "" + rule.replace(/\s/g, '') + wrapit$1(result, undefined, undefined, undefined, minify) : rule + " " + wrapit$1(result, undefined, undefined, undefined, result !== '' ? minify : true);
            }
        }
        return minify ? result.replace(/;}/g, '}') : result;
    };
    Style.prototype.updateMeta = function (type, group, order, offset, corePlugin, respectSelector) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        if (respectSelector === void 0) { respectSelector = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
            respectSelector: respectSelector,
        };
        return this;
    };
    return Style;
}());
/** @class */ ((function (_super) {
    __extends$1(GlobalStyle, _super);
    function GlobalStyle(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return GlobalStyle;
})(Style$1));
var Keyframes = /** @class */ (function (_super) {
    __extends$1(Keyframes, _super);
    function Keyframes(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    // root param only for consist with style
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Keyframes.generate = function (name, children, root, prefixer) {
        if (prefixer === void 0) { prefixer = true; }
        var styles = [];
        var webkitStyles = [];
        for (var _i = 0, _a = Object.entries(children); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var style = new Keyframes(key).atRule("@keyframes " + name);
            var webkitStyle = new Keyframes(key).atRule("@-webkit-keyframes " + name);
            for (var _c = 0, _d = Object.entries(value); _c < _d.length; _c++) {
                var _e = _d[_c], pkey = _e[0], pvalue = _e[1];
                var prop = pkey;
                if (pkey === 'transform') {
                    prop = prefixer ? ['-webkit-transform', 'transform'] : 'transform';
                }
                else if (['animationTimingFunction', 'animation-timing-function'].includes(pkey)) {
                    prop = prefixer ? [
                        '-webkit-animation-timing-function',
                        'animation-timing-function',
                    ] : 'animation-timing-function';
                }
                style.add(new Property$1(prop, pvalue));
                webkitStyle.add(new Property$1(prop, pvalue));
            }
            styles.push(style);
            if (prefixer)
                webkitStyles.push(webkitStyle);
        }
        return __spreadArray$1(__spreadArray$1([], styles), webkitStyles);
    };
    return Keyframes;
}(Style$1));
/** @class */ ((function (_super) {
    __extends$1(Container, _super);
    function Container(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return Container;
})(Style$1));

var minMaxWidth = /(!?\(\s*min(-device-)?-width).+\(\s*max(-device)?-width/i;
var minWidth = /\(\s*min(-device)?-width/i;
var maxMinWidth = /(!?\(\s*max(-device)?-width).+\(\s*min(-device)?-width/i;
var maxWidth = /\(\s*max(-device)?-width/i;
var isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth);
var isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth);
var minMaxHeight = /(!?\(\s*min(-device)?-height).+\(\s*max(-device)?-height/i;
var minHeight = /\(\s*min(-device)?-height/i;
var maxMinHeight = /(!?\(\s*max(-device)?-height).+\(\s*min(-device)?-height/i;
var maxHeight = /\(\s*max(-device)?-height/i;
var isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight);
var isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight);
var isPrint = /print/i;
var isPrintOnly = /^print\$/i;
var isAtRule = /^\s*@/i;
var isMedia = /^\s*@media/i;
var maxValue = Number.MAX_VALUE;
function _getQueryLength(length) {
    var result = /(-?\d*\.?\d+)(ch|em|ex|px|rpx|rem)/.exec(length);
    if (result === null) {
        return maxValue;
    }
    var number = result[1];
    var unit = result[2];
    switch (unit) {
        case 'ch':
            return parseFloat(number) * 8.8984375;
        case 'em':
        case 'rem':
            return parseFloat(number) * 16;
        case 'ex':
            return parseFloat(number) * 8.296875;
        case 'px':
        case 'rpx':
            return parseFloat(number);
    }
    return +number;
}
function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
    return function (query) {
        if (doubleTestTrue.test(query)) {
            return true;
        }
        else if (doubleTestFalse.test(query)) {
            return false;
        }
        return singleTest.test(query);
    };
}
function _testAtRule(a, b) {
    var isMediaA = isMedia.test(a);
    var isMediaB = isMedia.test(b);
    if (isMediaA && isMediaB)
        return null;
    var isAtRuleA = isAtRule.test(a);
    var isAtRuleB = isAtRule.test(b);
    if (isAtRuleA)
        return 1;
    if (isAtRuleB)
        return -1;
    return 0; // don't sort selector name, may cause overwrite bug.
}
function _testIsPrint(a, b) {
    var isPrintA = isPrint.test(a);
    var isPrintOnlyA = isPrintOnly.test(a);
    var isPrintB = isPrint.test(b);
    var isPrintOnlyB = isPrintOnly.test(b);
    if (isPrintA && isPrintB) {
        if (!isPrintOnlyA && isPrintOnlyB) {
            return 1;
        }
        if (isPrintOnlyA && !isPrintOnlyB) {
            return -1;
        }
        return a.localeCompare(b);
    }
    if (isPrintA) {
        return 1;
    }
    if (isPrintB) {
        return -1;
    }
    return null;
}
function sortMediaQuery(a, b) {
    var testAtRule = _testAtRule(a, b);
    if (testAtRule !== null)
        return testAtRule;
    var testIsPrint = _testIsPrint(a, b);
    if (testIsPrint !== null)
        return testIsPrint;
    var minA = isMinWidth(a) || isMinHeight(a);
    var maxA = isMaxWidth(a) || isMaxHeight(a);
    var minB = isMinWidth(b) || isMinHeight(b);
    var maxB = isMaxWidth(b) || isMaxHeight(b);
    if (minA && maxB) {
        return -1;
    }
    if (maxA && minB) {
        return 1;
    }
    var lengthA = _getQueryLength(a);
    var lengthB = _getQueryLength(b);
    if (lengthA === maxValue && lengthB === maxValue) {
        return a.localeCompare(b);
    }
    else if (lengthA === maxValue) {
        return 1;
    }
    else if (lengthB === maxValue) {
        return -1;
    }
    if (lengthA > lengthB) {
        if (maxA) {
            return -1;
        }
        return 1;
    }
    if (lengthA < lengthB) {
        if (maxA) {
            return 1;
        }
        return -1;
    }
    return a.localeCompare(b);
}

function getWeights(a) {
    var first = a.charAt(0);
    var second = a.charAt(1);
    if (first === ':' && second === ':')
        return 59; // ::moz ...
    if (first === '#')
        return 500; // #id ...
    if (first !== '.')
        return first.charCodeAt(0); // html, body ...
    return 499;
}
function sortMeta(a, b) {
    var _a, _b, _c, _d;
    if (a.meta.type === 'base' && b.meta.type === 'base')
        return getWeights((_a = a.selector) !== null && _a !== void 0 ? _a : '') - getWeights((_b = b.selector) !== null && _b !== void 0 ? _b : '');
    return sortMediaQuery(((_c = a.meta.variants) === null || _c === void 0 ? void 0 : _c[0]) || '', ((_d = b.meta.variants) === null || _d === void 0 ? void 0 : _d[0]) || '') || (a.meta.order - b.meta.order) || (a.meta.offset - b.meta.offset) || +b.meta.corePlugin - +a.meta.corePlugin;
}

function _buildAtrule(atrule, children, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return "" + atrule + (minify ? '' : ' ') + wrapit$1(_buildStyleList(children, minify, prefixer), undefined, undefined, undefined, minify);
}
function _buildStyleList(styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    var currentAtrule;
    var currentStyle;
    var styleStack = [];
    var output = [];
    var _loop_1 = function (style) {
        if (style.isAtrule) {
            if (currentStyle) {
                output.push(currentStyle.clean().build(minify, prefixer));
                currentStyle = undefined;
            }
            var newAtrule = style.atRules.pop();
            if (currentAtrule) {
                if (currentAtrule === newAtrule && newAtrule !== '@font-face') { // @font-face shouldn't been combined
                    styleStack.push(style);
                }
                else {
                    output.push(_buildAtrule(currentAtrule, styleStack, minify, prefixer));
                    currentAtrule = newAtrule;
                    styleStack = [style];
                }
            }
            else {
                currentAtrule = newAtrule;
                styleStack = [style];
            }
        }
        else {
            if (currentAtrule) {
                output.push(_buildAtrule(currentAtrule, styleStack, minify, prefixer));
                currentAtrule = undefined;
                styleStack = [];
            }
            if (currentStyle) {
                if (style.rule === currentStyle.rule) {
                    if (style.important)
                        style.property.forEach(function (p) { return p.important = true; });
                    if (style.wrapProperties)
                        style.property.forEach(function (p) { var _a; return (_a = style.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) { return p.name = Array.isArray(p.name) ? p.name.map(function (i) { return wrap(i); }) : wrap(p.name); }); });
                    currentStyle.add(style.property);
                }
                else {
                    output.push(currentStyle.clean().build(minify, prefixer));
                    currentStyle = style;
                }
            }
            else {
                currentStyle = style;
            }
        }
    };
    for (var _i = 0, styleList_1 = styleList; _i < styleList_1.length; _i++) {
        var style = styleList_1[_i];
        _loop_1(style);
    }
    if (currentAtrule)
        output.push(_buildAtrule(currentAtrule, styleStack, minify, prefixer));
    if (currentStyle)
        output.push(currentStyle.clean().build(minify, prefixer));
    return output.join(minify ? '' : '\n');
}
function compileStyleSheet (styleList, minify, prefixer) {
    if (minify === void 0) { minify = false; }
    if (prefixer === void 0) { prefixer = true; }
    return _buildStyleList(deepCopy$1(styleList), minify, prefixer);
}

var StyleSheet = /** @class */ (function () {
    function StyleSheet(children) {
        this.prefixer = true;
        this.children = children || [];
    }
    StyleSheet.prototype.add = function (item) {
        if (!item)
            return this;
        if (Array.isArray(item)) {
            this.children = __spreadArray$1(__spreadArray$1([], this.children), item);
        }
        else {
            this.children.push(item);
        }
        return this;
    };
    StyleSheet.prototype.extend = function (styleSheet, append, dedup) {
        if (append === void 0) { append = true; }
        if (dedup === void 0) { dedup = false; }
        if (styleSheet) {
            var extended = styleSheet.children;
            if (dedup) {
                var hashes_1 = extended.map(function (i) { return hash(i.build()); });
                extended = extended.filter(function (i) { return !hashes_1.includes(hash(i.build())); });
            }
            this.prefixer = styleSheet.prefixer;
            this.children = append ? __spreadArray$1(__spreadArray$1([], this.children), extended) : __spreadArray$1(__spreadArray$1([], extended), this.children);
        }
        return this;
    };
    StyleSheet.prototype.combine = function () {
        var styleMap = {};
        this.children.forEach(function (style, index) {
            var _a;
            var hashValue = hash(style.atRules + style.rule);
            if (hashValue in styleMap) {
                if ((_a = style.atRules) === null || _a === void 0 ? void 0 : _a.includes('@font-face')) {
                    // keeps multiple @font-face
                    styleMap[hashValue + index] = style;
                }
                else {
                    styleMap[hashValue] = styleMap[hashValue].extend(style, true);
                }
            }
            else {
                styleMap[hashValue] = style;
            }
        });
        this.children = Object.values(styleMap).map(function (i) { return i.clean(); });
        return this;
    };
    StyleSheet.prototype.layer = function (type) {
        var styleSheet = new StyleSheet(this.children.filter(function (i) { return i.meta.type === type; }));
        styleSheet.prefixer = this.prefixer;
        return styleSheet;
    };
    StyleSheet.prototype.split = function () {
        return {
            base: this.layer('base'),
            components: this.layer('components'),
            utilities: this.layer('utilities'),
        };
    };
    StyleSheet.prototype.clone = function () {
        return deepCopy$1(this);
    };
    StyleSheet.prototype.sort = function () {
        this.children = this.children.sort(sortMeta);
        return this;
    };
    StyleSheet.prototype.sortby = function (compareFn) {
        this.children = this.children.sort(compareFn);
        return this;
    };
    StyleSheet.prototype.build = function (minify) {
        if (minify === void 0) { minify = false; }
        return compileStyleSheet(this.children, minify, this.prefixer);
    };
    return StyleSheet;
}());

var layerOrder;
(function (layerOrder) {
    layerOrder[layerOrder["base"] = 10] = "base";
    layerOrder[layerOrder["components"] = 150] = "components";
    layerOrder[layerOrder["shortcuts"] = 160] = "shortcuts";
    layerOrder[layerOrder["utilities"] = 20000] = "utilities";
})(layerOrder || (layerOrder = {}));
var pluginOrder;
(function (pluginOrder) {
    pluginOrder[pluginOrder["container"] = 100] = "container";
    pluginOrder[pluginOrder["space"] = 200] = "space";
    pluginOrder[pluginOrder["divideWidth"] = 300] = "divideWidth";
    pluginOrder[pluginOrder["divideColor"] = 400] = "divideColor";
    pluginOrder[pluginOrder["divideStyle"] = 500] = "divideStyle";
    pluginOrder[pluginOrder["divideOpacity"] = 600] = "divideOpacity";
    pluginOrder[pluginOrder["accessibility"] = 700] = "accessibility";
    pluginOrder[pluginOrder["appearance"] = 800] = "appearance";
    pluginOrder[pluginOrder["backgroundAttachment"] = 900] = "backgroundAttachment";
    pluginOrder[pluginOrder["backgroundClip"] = 1000] = "backgroundClip";
    pluginOrder[pluginOrder["backgroundColor"] = 1100] = "backgroundColor";
    pluginOrder[pluginOrder["backgroundImage"] = 1200] = "backgroundImage";
    pluginOrder[pluginOrder["gradientColorStops"] = 1300] = "gradientColorStops";
    pluginOrder[pluginOrder["backgroundOpacity"] = 1400] = "backgroundOpacity";
    pluginOrder[pluginOrder["backgroundPosition"] = 1500] = "backgroundPosition";
    pluginOrder[pluginOrder["backgroundRepeat"] = 1600] = "backgroundRepeat";
    pluginOrder[pluginOrder["backgroundSize"] = 1700] = "backgroundSize";
    pluginOrder[pluginOrder["backgroundOrigin"] = 1750] = "backgroundOrigin";
    pluginOrder[pluginOrder["borderCollapse"] = 1800] = "borderCollapse";
    pluginOrder[pluginOrder["borderColor"] = 1900] = "borderColor";
    pluginOrder[pluginOrder["borderOpacity"] = 2000] = "borderOpacity";
    pluginOrder[pluginOrder["borderRadius"] = 2100] = "borderRadius";
    pluginOrder[pluginOrder["borderStyle"] = 2200] = "borderStyle";
    pluginOrder[pluginOrder["borderWidth"] = 2300] = "borderWidth";
    pluginOrder[pluginOrder["boxDecorationBreak"] = 2350] = "boxDecorationBreak";
    pluginOrder[pluginOrder["boxSizing"] = 2400] = "boxSizing";
    pluginOrder[pluginOrder["cursor"] = 2500] = "cursor";
    pluginOrder[pluginOrder["captionSide"] = 2550] = "captionSide";
    pluginOrder[pluginOrder["emptyCells"] = 2560] = "emptyCells";
    pluginOrder[pluginOrder["display"] = 2600] = "display";
    pluginOrder[pluginOrder["flexDirection"] = 2700] = "flexDirection";
    pluginOrder[pluginOrder["flexWrap"] = 2800] = "flexWrap";
    pluginOrder[pluginOrder["placeItems"] = 2900] = "placeItems";
    pluginOrder[pluginOrder["placeContent"] = 3000] = "placeContent";
    pluginOrder[pluginOrder["placeSelf"] = 3100] = "placeSelf";
    pluginOrder[pluginOrder["alignItems"] = 3200] = "alignItems";
    pluginOrder[pluginOrder["alignContent"] = 3300] = "alignContent";
    pluginOrder[pluginOrder["alignSelf"] = 3400] = "alignSelf";
    pluginOrder[pluginOrder["justifyItems"] = 3500] = "justifyItems";
    pluginOrder[pluginOrder["justifyContent"] = 3600] = "justifyContent";
    pluginOrder[pluginOrder["justifySelf"] = 3700] = "justifySelf";
    pluginOrder[pluginOrder["flex"] = 3800] = "flex";
    pluginOrder[pluginOrder["flexGrow"] = 3900] = "flexGrow";
    pluginOrder[pluginOrder["flexShrink"] = 4000] = "flexShrink";
    pluginOrder[pluginOrder["order"] = 4100] = "order";
    pluginOrder[pluginOrder["float"] = 4200] = "float";
    pluginOrder[pluginOrder["clear"] = 4300] = "clear";
    pluginOrder[pluginOrder["fontFamily"] = 4400] = "fontFamily";
    pluginOrder[pluginOrder["fontWeight"] = 4500] = "fontWeight";
    pluginOrder[pluginOrder["height"] = 4600] = "height";
    pluginOrder[pluginOrder["fontSize"] = 4700] = "fontSize";
    pluginOrder[pluginOrder["lineHeight"] = 4800] = "lineHeight";
    pluginOrder[pluginOrder["listStylePosition"] = 4900] = "listStylePosition";
    pluginOrder[pluginOrder["listStyleType"] = 5000] = "listStyleType";
    pluginOrder[pluginOrder["margin"] = 5100] = "margin";
    pluginOrder[pluginOrder["maxHeight"] = 5200] = "maxHeight";
    pluginOrder[pluginOrder["maxWidth"] = 5300] = "maxWidth";
    pluginOrder[pluginOrder["minHeight"] = 5400] = "minHeight";
    pluginOrder[pluginOrder["minWidth"] = 5500] = "minWidth";
    pluginOrder[pluginOrder["objectFit"] = 5600] = "objectFit";
    pluginOrder[pluginOrder["objectPosition"] = 5700] = "objectPosition";
    pluginOrder[pluginOrder["opacity"] = 5800] = "opacity";
    pluginOrder[pluginOrder["outline"] = 5900] = "outline";
    pluginOrder[pluginOrder["overflow"] = 6000] = "overflow";
    pluginOrder[pluginOrder["overscrollBehavior"] = 6100] = "overscrollBehavior";
    pluginOrder[pluginOrder["padding"] = 6200] = "padding";
    pluginOrder[pluginOrder["placeholderColor"] = 6300] = "placeholderColor";
    pluginOrder[pluginOrder["placeholderOpacity"] = 6400] = "placeholderOpacity";
    pluginOrder[pluginOrder["caretColor"] = 6450] = "caretColor";
    pluginOrder[pluginOrder["caretOpacity"] = 6460] = "caretOpacity";
    pluginOrder[pluginOrder["tabSize"] = 6470] = "tabSize";
    pluginOrder[pluginOrder["pointerEvents"] = 6500] = "pointerEvents";
    pluginOrder[pluginOrder["position"] = 6600] = "position";
    pluginOrder[pluginOrder["inset"] = 6700] = "inset";
    pluginOrder[pluginOrder["resize"] = 6800] = "resize";
    pluginOrder[pluginOrder["boxShadow"] = 6900] = "boxShadow";
    pluginOrder[pluginOrder["boxShadowColor"] = 6950] = "boxShadowColor";
    pluginOrder[pluginOrder["ringWidth"] = 7000] = "ringWidth";
    pluginOrder[pluginOrder["ringOffsetColor"] = 7100] = "ringOffsetColor";
    pluginOrder[pluginOrder["ringOffsetWidth"] = 7200] = "ringOffsetWidth";
    pluginOrder[pluginOrder["ringColor"] = 7300] = "ringColor";
    pluginOrder[pluginOrder["ringOpacity"] = 7400] = "ringOpacity";
    pluginOrder[pluginOrder["fill"] = 7500] = "fill";
    pluginOrder[pluginOrder["stroke"] = 7600] = "stroke";
    pluginOrder[pluginOrder["strokeWidth"] = 7700] = "strokeWidth";
    pluginOrder[pluginOrder["strokeDashArray"] = 7750] = "strokeDashArray";
    pluginOrder[pluginOrder["strokeDashOffset"] = 7760] = "strokeDashOffset";
    pluginOrder[pluginOrder["tableLayout"] = 7800] = "tableLayout";
    pluginOrder[pluginOrder["textAlign"] = 7900] = "textAlign";
    pluginOrder[pluginOrder["textColor"] = 8000] = "textColor";
    pluginOrder[pluginOrder["textOpacity"] = 8100] = "textOpacity";
    pluginOrder[pluginOrder["textOverflow"] = 8200] = "textOverflow";
    pluginOrder[pluginOrder["textShadow"] = 8250] = "textShadow";
    pluginOrder[pluginOrder["fontStyle"] = 8300] = "fontStyle";
    pluginOrder[pluginOrder["textTransform"] = 8400] = "textTransform";
    pluginOrder[pluginOrder["textDecorationStyle"] = 8450] = "textDecorationStyle";
    pluginOrder[pluginOrder["textDecorationLength"] = 8455] = "textDecorationLength";
    pluginOrder[pluginOrder["textDecorationColor"] = 8460] = "textDecorationColor";
    pluginOrder[pluginOrder["textDecorationOpacity"] = 8470] = "textDecorationOpacity";
    pluginOrder[pluginOrder["textDecorationOffset"] = 8480] = "textDecorationOffset";
    pluginOrder[pluginOrder["textDecoration"] = 8500] = "textDecoration";
    pluginOrder[pluginOrder["textIndent"] = 8550] = "textIndent";
    pluginOrder[pluginOrder["textStrokeColor"] = 8560] = "textStrokeColor";
    pluginOrder[pluginOrder["textStrokeWidth"] = 8570] = "textStrokeWidth";
    pluginOrder[pluginOrder["content"] = 8580] = "content";
    pluginOrder[pluginOrder["fontSmoothing"] = 8600] = "fontSmoothing";
    pluginOrder[pluginOrder["fontVariantNumeric"] = 8700] = "fontVariantNumeric";
    pluginOrder[pluginOrder["letterSpacing"] = 8800] = "letterSpacing";
    pluginOrder[pluginOrder["userSelect"] = 8900] = "userSelect";
    pluginOrder[pluginOrder["verticalAlign"] = 9000] = "verticalAlign";
    pluginOrder[pluginOrder["visibility"] = 9100] = "visibility";
    pluginOrder[pluginOrder["backfaceVisibility"] = 9150] = "backfaceVisibility";
    pluginOrder[pluginOrder["whitespace"] = 9200] = "whitespace";
    pluginOrder[pluginOrder["wordBreak"] = 9300] = "wordBreak";
    pluginOrder[pluginOrder["writingMode"] = 9340] = "writingMode";
    pluginOrder[pluginOrder["hyphens"] = 9350] = "hyphens";
    pluginOrder[pluginOrder["width"] = 9400] = "width";
    pluginOrder[pluginOrder["zIndex"] = 9500] = "zIndex";
    pluginOrder[pluginOrder["isolation"] = 9550] = "isolation";
    pluginOrder[pluginOrder["gap"] = 9600] = "gap";
    pluginOrder[pluginOrder["gridAutoFlow"] = 9700] = "gridAutoFlow";
    pluginOrder[pluginOrder["gridTemplateColumns"] = 9800] = "gridTemplateColumns";
    pluginOrder[pluginOrder["gridAutoColumns"] = 9900] = "gridAutoColumns";
    pluginOrder[pluginOrder["gridColumn"] = 10000] = "gridColumn";
    pluginOrder[pluginOrder["gridColumnStart"] = 10100] = "gridColumnStart";
    pluginOrder[pluginOrder["gridColumnEnd"] = 10200] = "gridColumnEnd";
    pluginOrder[pluginOrder["gridTemplateRows"] = 10300] = "gridTemplateRows";
    pluginOrder[pluginOrder["gridAutoRows"] = 10400] = "gridAutoRows";
    pluginOrder[pluginOrder["gridRow"] = 10500] = "gridRow";
    pluginOrder[pluginOrder["gridRowStart"] = 10600] = "gridRowStart";
    pluginOrder[pluginOrder["gridRowEnd"] = 10700] = "gridRowEnd";
    pluginOrder[pluginOrder["transform"] = 10800] = "transform";
    pluginOrder[pluginOrder["transformOrigin"] = 10900] = "transformOrigin";
    pluginOrder[pluginOrder["scale"] = 11000] = "scale";
    pluginOrder[pluginOrder["rotate"] = 11100] = "rotate";
    pluginOrder[pluginOrder["translate"] = 11200] = "translate";
    pluginOrder[pluginOrder["skew"] = 11300] = "skew";
    pluginOrder[pluginOrder["perspective"] = 11350] = "perspective";
    pluginOrder[pluginOrder["perspectiveOrigin"] = 11360] = "perspectiveOrigin";
    pluginOrder[pluginOrder["transitionProperty"] = 11400] = "transitionProperty";
    pluginOrder[pluginOrder["transitionTimingFunction"] = 11500] = "transitionTimingFunction";
    pluginOrder[pluginOrder["transitionDuration"] = 11600] = "transitionDuration";
    pluginOrder[pluginOrder["transitionDelay"] = 11700] = "transitionDelay";
    pluginOrder[pluginOrder["keyframes"] = 11800] = "keyframes";
    pluginOrder[pluginOrder["animation"] = 11900] = "animation";
    pluginOrder[pluginOrder["imageRendering"] = 11950] = "imageRendering";
    pluginOrder[pluginOrder["mixBlendMode"] = 12000] = "mixBlendMode";
    pluginOrder[pluginOrder["backgroundBlendMode"] = 12100] = "backgroundBlendMode";
    pluginOrder[pluginOrder["filter"] = 12200] = "filter";
    pluginOrder[pluginOrder["blur"] = 12300] = "blur";
    pluginOrder[pluginOrder["brightness"] = 12400] = "brightness";
    pluginOrder[pluginOrder["contrast"] = 12500] = "contrast";
    pluginOrder[pluginOrder["dropShadow"] = 12600] = "dropShadow";
    pluginOrder[pluginOrder["grayscale"] = 12700] = "grayscale";
    pluginOrder[pluginOrder["hueRotate"] = 12800] = "hueRotate";
    pluginOrder[pluginOrder["invert"] = 12900] = "invert";
    pluginOrder[pluginOrder["saturate"] = 13000] = "saturate";
    pluginOrder[pluginOrder["sepia"] = 13100] = "sepia";
    pluginOrder[pluginOrder["backdropFilter"] = 13200] = "backdropFilter";
    pluginOrder[pluginOrder["backdropBlur"] = 13300] = "backdropBlur";
    pluginOrder[pluginOrder["backdropBrightness"] = 13400] = "backdropBrightness";
    pluginOrder[pluginOrder["backdropContrast"] = 13500] = "backdropContrast";
    pluginOrder[pluginOrder["backdropGrayscale"] = 13600] = "backdropGrayscale";
    pluginOrder[pluginOrder["backdropHueRotate"] = 13700] = "backdropHueRotate";
    pluginOrder[pluginOrder["backdropInvert"] = 13800] = "backdropInvert";
    pluginOrder[pluginOrder["backdropOpacity"] = 13900] = "backdropOpacity";
    pluginOrder[pluginOrder["backdropSaturate"] = 14000] = "backdropSaturate";
    pluginOrder[pluginOrder["backdropSepia"] = 14100] = "backdropSepia";
})(pluginOrder || (pluginOrder = {}));

var CSSParser = /** @class */ (function () {
    function CSSParser(css, processor) {
        this.variables = {};
        this._cache = {};
        this.css = css;
        this.processor = processor;
    }
    CSSParser.prototype._addCache = function (style) {
        var rule = style.rule;
        if (['.', '#'].includes(rule.charAt(0)))
            this._cache[rule] = (rule in this._cache) ? __spreadArray$1(__spreadArray$1([], this._cache[rule]), [deepCopy$1(style)]) : [deepCopy$1(style)];
    };
    CSSParser.prototype._searchGroup = function (text, startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        var level = 1;
        var endBracket = searchFrom$1(text, '}', startIndex);
        while (endBracket !== -1) {
            var nextBracket = searchFrom$1(text, '{', startIndex);
            if (endBracket < nextBracket || nextBracket === -1) {
                level--;
                startIndex = endBracket + 1;
                if (level === 0)
                    return endBracket;
            }
            else {
                level++;
                startIndex = nextBracket + 1;
            }
            endBracket = searchFrom$1(text, '}', startIndex);
        }
        return -1;
    };
    CSSParser.prototype._loadTheme = function (prop) {
        if (!prop)
            return;
        if (!this.processor)
            return prop;
        var index = 0;
        var output = [];
        while (index < prop.length) {
            var matched = prop.slice(index).match(/theme\([^)]*?\)/);
            if (!matched || matched.index === undefined)
                break;
            output.push(prop.slice(index, index + matched.index));
            var args = matched[0].slice(6, -1).split(/\s*,\s*/).map(function (i) { return i.trim().replace(/^['"]+|['"]+$/g, ''); });
            output.push(this.processor.theme(args[0], args[1]));
            index += matched.index + matched[0].length;
        }
        output.push(prop.slice(index));
        return output.join('');
    };
    CSSParser.prototype._handleDirectives = function (atrule) {
        var _a, _b, _c;
        if (!this.processor)
            return { atrule: atrule };
        var iatrule = InlineAtRule$1.parse(atrule);
        if (!iatrule)
            return;
        if (iatrule.name === 'apply')
            return { apply: iatrule.value, important: iatrule.important };
        if (iatrule.name === 'layer')
            return { layer: ((_a = iatrule.value) !== null && _a !== void 0 ? _a : 'components') };
        if (iatrule.name === 'variants' && iatrule.value)
            return { variants: iatrule.value.split(',').map(function (i) { return i.trim().split(':'); }) };
        if (iatrule.name === 'screen' && iatrule.value) {
            var screens = this.processor.resolveVariants('screen');
            if (iatrule.value in screens)
                return { atrule: (_c = (_b = screens[iatrule.value]().atRules) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : atrule };
            if (['dark', 'light'].includes(iatrule.value))
                return { atrule: "@media (prefers-color-scheme: " + iatrule.value + ")" };
        }
        return { atrule: atrule };
    };
    CSSParser.prototype._generateNestProperty = function (props, parent, parentType) {
        var style = new Style$1(undefined, props);
        if (!parent || !parentType)
            return style;
        if (parentType === 'selector') {
            style.selector = parent;
            return style;
        }
        return style.atRule(parent);
    };
    CSSParser.prototype._generateNestStyle = function (styles, parent, parentType) {
        var _this = this;
        var layer = 'utilities';
        var order = layerOrder['utilities'] + 1;
        var group = 'block';
        if (!parent)
            return styles;
        if (parentType === 'selector') {
            styles.forEach(function (i) {
                if (i instanceof Keyframes)
                    return;
                if (!i.selector) {
                    i.selector = parent;
                }
                else {
                    var selector_1 = i.selector;
                    selector_1 = selector_1.trim().split(/\s*,\s*/g).map(function (i) { return /&/.test(i) ? i : "& " + i; }).join(', ');
                    i.selector = /\s*,\s*/.test(parent) ? parent.trim().split(/\s*,\s*/g).map(function (i) { return selector_1.replace(/&/g, i); }).join(', ') : selector_1.replace(/&/g, parent);
                }
                i.updateMeta(layer, group, order);
                _this._addCache(i);
            });
        }
        else if (parentType === 'atRule') {
            var atrule_1 = parent;
            if (this.processor) {
                // handle directives
                var directives = this._handleDirectives(parent);
                if (directives) {
                    if ('atrule' in directives) {
                        // @screen
                        atrule_1 = directives.atrule;
                    }
                    else if ('layer' in directives) {
                        // @layer
                        atrule_1 = undefined;
                        layer = directives.layer;
                        order = layerOrder[layer];
                        group = 'layer-block';
                    }
                    else if ('variants' in directives) {
                        // @variants
                        var output = [];
                        for (var _i = 0, _a = directives.variants; _i < _a.length; _i++) {
                            var variant = _a[_i];
                            var wrapper = this.processor.wrapWithVariants(variant, styles);
                            if (wrapper)
                                output = output.concat(wrapper);
                        }
                        output.map(function (i) {
                            i.updateMeta(layer, group, order);
                            _this._addCache(i);
                        });
                        return output;
                    }
                }
            }
            styles.filter(function (i) { return !(i instanceof Keyframes); }).forEach(function (i) {
                i.atRule(atrule_1);
                i.updateMeta(layer, group, order);
                _this._addCache(i);
            });
        }
        return styles;
    };
    CSSParser.prototype.parse = function (css, parent, parentType) {
        var _this = this;
        var _a;
        if (css === void 0) { css = this.css; }
        var styleSheet = new StyleSheet();
        if (!css || isSpace(css))
            return styleSheet;
        var index = 0;
        var firstLetter = searchFrom$1(css, /\S/, index);
        var len = css.length;
        var _loop_1 = function () {
            var propEnd = searchPropEnd$1(css, index);
            var nestStart = searchFrom$1(css, '{', firstLetter);
            var firstChar = css.charAt(firstLetter);
            if (firstChar === '/') {
                // remove comment
                switch (css.charAt(firstLetter + 1)) {
                    case '/':
                        index = firstLetter + 2;
                        while (index < len) {
                            if (css.charAt(index) === '\n')
                                break;
                            index++;
                        }
                        index += 1;
                        break;
                    case '*':
                        index = firstLetter + 2;
                        while (index < len) {
                            if (css.charAt(index) === '*' && css.charAt(index + 1) === '/')
                                break;
                            index++;
                        }
                        index += 2;
                        break;
                }
            }
            else if (propEnd === -1 || (nestStart !== -1 && propEnd > nestStart)) {
                // nested AtRule or Selector
                var selector = css.substring(firstLetter, nestStart).trim();
                index = nestStart + 1;
                var nestEnd = this_1._searchGroup(css, index);
                if (nestEnd === -1)
                    return "break"; // doesn't close block
                // allow last rule without semicolon
                var rule = css.slice(index, nestEnd);
                if (!/[};]\s*$/.test(rule))
                    rule = rule + ';';
                var content = this_1.parse(rule, selector);
                index = nestEnd + 1;
                styleSheet.add(this_1._generateNestStyle(content.children, selector, firstChar === '@' ? 'atRule' : 'selector'));
            }
            else if (firstChar === '$') {
                // define variable
                var prop = Property$1.parse(css.slice(firstLetter, propEnd));
                if (prop && !Array.isArray(prop) && !Array.isArray(prop.name) && prop.value) {
                    this_1.variables[prop.name.slice(1)] = prop.value;
                }
                index = propEnd + 1;
            }
            else if (firstChar === '@') {
                // inline AtRule
                var data = css.slice(firstLetter, propEnd);
                if (this_1.processor) {
                    // handle directives
                    var directives_1 = this_1._handleDirectives(data.trim());
                    if (directives_1) {
                        if ('atrule' in directives_1) {
                            var atRule = InlineAtRule$1.parse(directives_1.atrule);
                            if (atRule)
                                styleSheet.add(this_1._generateNestProperty(atRule, parent, parentType));
                        }
                        else if ('apply' in directives_1 && directives_1.apply) {
                            var result = this_1.processor.compile(directives_1.apply, undefined, false, false, function (ignored) {
                                if (('.' + ignored) in _this._cache)
                                    return _this._cache['.' + ignored];
                            });
                            styleSheet.add(result.styleSheet.clone().children.map(function (i) {
                                if (!(i instanceof Keyframes)) {
                                    i.selector = undefined;
                                    if (directives_1.important) {
                                        i.property.map(function (i) { return i.important = true; });
                                    }
                                }
                                return i;
                            }));
                        }
                    }
                }
                else {
                    // normal atrule
                    var atRule = InlineAtRule$1.parse(data);
                    if (atRule)
                        styleSheet.add(this_1._generateNestProperty(atRule, parent, parentType));
                }
                index = propEnd + 1;
            }
            else {
                // inline Property
                var prop = Property$1.parse(css.slice(firstLetter, propEnd));
                index = propEnd + 1;
                if (prop) {
                    // handle theme function
                    if (Array.isArray(prop)) {
                        prop.filter(function (p) { var _a; return (_a = p.value) === null || _a === void 0 ? void 0 : _a.match(/theme\([^)]*\)/); }).forEach(function (p) { return p.value = _this._loadTheme(p.value); });
                    }
                    else if ((_a = prop.value) === null || _a === void 0 ? void 0 : _a.match(/theme\([^)]*\)/)) {
                        prop.value = this_1._loadTheme(prop.value);
                    }
                    styleSheet.add(this_1._generateNestProperty(prop, parent, parentType));
                }
            }
            firstLetter = searchFrom$1(css, /\S/, index);
        };
        var this_1 = this;
        while (firstLetter !== -1) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
        if (!parent)
            this._cache = {};
        return styleSheet.combine();
    };
    return CSSParser;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

function toArray$1(v) {
    if (Array.isArray(v))
        return v;
    return [v];
}
function indent(code, tab) {
    if (tab === void 0) { tab = 2; }
    var spaces = Array(tab).fill(' ').join('');
    return code
        .split('\n')
        .map(function (line) { return spaces + line; })
        .join('\n');
}
function wrapit(code, start, end, tab, minify) {
    if (start === void 0) { start = '{'; }
    if (end === void 0) { end = '}'; }
    if (tab === void 0) { tab = 2; }
    if (minify === void 0) { minify = false; }
    if (minify)
        return "" + start + code + end;
    return start + "\n" + indent(code, tab) + "\n" + end;
}
function camelToDash(str) {
    // Use exact the same regex as Post CSS
    return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}
function searchFrom(text, target, startIndex, endIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    // search from partial of string
    var subText = text.substring(startIndex, endIndex);
    var relativeIndex = subText.search(target);
    return relativeIndex === -1 ? -1 : startIndex + relativeIndex;
}
function connectList(a, b, append) {
    if (append === void 0) { append = true; }
    return append ? __spreadArray(__spreadArray([], (a !== null && a !== void 0 ? a : [])), (b !== null && b !== void 0 ? b : [])) : __spreadArray(__spreadArray([], (b !== null && b !== void 0 ? b : [])), (a !== null && a !== void 0 ? a : []));
}
function deepCopy(source) {
    return Array.isArray(source)
        ? source.map(function (item) { return deepCopy(item); })
        : source instanceof Date
            ? new Date(source.getTime())
            : source && typeof source === 'object'
                ? Object.getOwnPropertyNames(source).reduce(function (o, prop) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, prop);
                    if (descriptor) {
                        Object.defineProperty(o, prop, descriptor);
                        if (source && typeof source === 'object') {
                            o[prop] = deepCopy(source[prop]);
                        }
                    }
                    return o;
                }, Object.create(Object.getPrototypeOf(source)))
                : source;
}
function isTagName(name) {
    return ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embd', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].includes(name);
}
function flatColors$1(colors, head) {
    var flatten = {};
    for (var _i = 0, _a = Object.entries(colors); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        if (typeof value === 'string' || typeof value === 'function') {
            flatten[(head && key === 'DEFAULT') ? head : head ? head + "-" + key : key] = value;
        }
        else {
            flatten = __assign(__assign({}, flatten), flatColors$1(value, head ? head + "-" + key : key));
        }
    }
    return flatten;
}
function searchPropEnd(text, startIndex) {
    if (startIndex === void 0) { startIndex = 0; }
    var index = startIndex;
    var output = -1;
    var openSingleQuote = false;
    var openDoubleQuote = false;
    var openBracket = false;
    var isEscaped = false;
    while (index < text.length) {
        switch (text.charAt(index)) {
            case '\\':
                isEscaped = !isEscaped;
                break;
            case '\'':
                if (!openDoubleQuote && !openBracket && !isEscaped)
                    openSingleQuote = !openSingleQuote;
                isEscaped = false;
                break;
            case '"':
                if (!openSingleQuote && !openBracket && !isEscaped)
                    openDoubleQuote = !openDoubleQuote;
                isEscaped = false;
                break;
            case '(':
                if (!openBracket && !openSingleQuote && !openDoubleQuote && !isEscaped)
                    openBracket = true;
                isEscaped = false;
                break;
            case ')':
                if (openBracket && !isEscaped)
                    openBracket = false;
                isEscaped = false;
                break;
            case ';':
                if (!isEscaped && !openSingleQuote && !openDoubleQuote && !openBracket)
                    output = index;
                isEscaped = false;
                break;
            default:
                isEscaped = false;
                break;
        }
        if (output !== -1)
            break;
        index++;
    }
    return output;
}

var Property = /** @class */ (function () {
    function Property(name, value, comment, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'utilities', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.name = name;
        this.value = value;
        this.comment = comment;
        this.important = important;
    }
    Property._singleParse = function (css) {
        css = css.trim();
        if (!css)
            return;
        if (css.charAt(0) === '@')
            return InlineAtRule.parse(css);
        var split = css.search(':');
        var end = searchPropEnd(css);
        if (split === -1)
            return;
        var important = false;
        var prop = css.substring(split + 1, end === -1 ? undefined : end).trim();
        if (/!important;?$/.test(prop)) {
            important = true;
            prop = prop.replace(/!important/, '').trimRight();
        }
        return new Property(css.substring(0, split).trim(), prop, undefined, important);
    };
    Property.parse = function (css) {
        if (!/;\s*$/.test(css))
            css += ';'; // Fix for the situation where the last semicolon is omitted
        var properties = [];
        var index = 0;
        var end = searchPropEnd(css, index);
        while (end !== -1) {
            var parsed = this._singleParse(css.substring(searchFrom(css, /\S/, index), end + 1));
            if (parsed)
                properties.push(parsed);
            index = end + 1;
            end = searchPropEnd(css, index);
        }
        var count = properties.length;
        if (count > 1)
            return properties;
        if (count === 1)
            return properties[0];
    };
    Property.prototype.clone = function () {
        return deepCopy(this);
    };
    Property.prototype.toStyle = function (selector) {
        var style = new Style(selector, this, this.important);
        style.meta = this.meta;
        return style;
    };
    Property.prototype.build = function (minify) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        var createProperty = function (name, value) {
            if (minify) {
                return name + ":" + value + (_this.important ? '!important' : '') + ";";
            }
            else {
                var p = name + ": " + value + (_this.important ? ' !important' : '') + ";";
                return _this.comment ? p + (" /* " + _this.comment + " */") : p;
            }
        };
        if (!this.value)
            return '';
        return typeof this.name === 'string'
            ? createProperty(this.name, this.value)
            : this.name
                .map(function (i) { return createProperty(i, _this.value); })
                .join(minify ? '' : '\n');
    };
    Property.prototype.updateMeta = function (type, group, order, offset, corePlugin) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
        };
        return this;
    };
    return Property;
}());
var InlineAtRule = /** @class */ (function (_super) {
    __extends(InlineAtRule, _super);
    function InlineAtRule(name, value, important) {
        if (important === void 0) { important = false; }
        var _this = _super.call(this, name, value, undefined, important) || this;
        _this.name = name;
        return _this;
    }
    InlineAtRule.parse = function (css) {
        var _a;
        var matchName = css.match(/@[^\s;{}]+/);
        if (matchName) {
            var name_1 = matchName[0].substring(1);
            var important = false;
            var expression = matchName.index !== undefined
                ? (_a = css
                    .substring(matchName.index + name_1.length + 1)
                    .match(/(?:(['"]).*?\1|[^;])*/)) === null || _a === void 0 ? void 0 : _a[0].trim()
                : undefined;
            if (expression && /!important;?$/.test(expression)) {
                important = true;
                expression = expression.replace(/!important/, '').trimRight();
            }
            return new InlineAtRule(name_1, expression === '' ? undefined : expression, important);
        }
    };
    InlineAtRule.prototype.build = function () {
        return this.value
            ? "@" + this.name + " " + this.value + (this.important ? ' !important' : '') + ";"
            : "@" + this.name + (this.important ? ' !important' : '') + ";";
    };
    return InlineAtRule;
}(Property));
var Style = /** @class */ (function () {
    function Style(selector, property, important) {
        if (important === void 0) { important = false; }
        this.meta = { type: 'components', group: 'plugin', order: 0, offset: 0, corePlugin: false };
        this.selector = selector;
        this.important = important;
        this.property = toArray$1(property || []);
    }
    Object.defineProperty(Style.prototype, "rule", {
        get: function () {
            var _this = this;
            var _a, _b, _c;
            var selectors = ((_a = this.selector) !== null && _a !== void 0 ? _a : '').trim().split(/\s*,\s*/g);
            this._parentSelectors && (selectors = selectors.map(function (i) { var _a; return ((_a = _this._parentSelectors) === null || _a === void 0 ? void 0 : _a.join(' ')) + " " + i; }));
            ((_b = this._wrapSelectors) !== null && _b !== void 0 ? _b : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            this._pseudoClasses && (selectors = selectors.map(function (i) { var _a; return i + (":" + ((_a = _this._pseudoClasses) === null || _a === void 0 ? void 0 : _a.join(':'))); }));
            this._pseudoElements && (selectors = selectors.map(function (i) { var _a; return i + ("::" + ((_a = _this._pseudoElements) === null || _a === void 0 ? void 0 : _a.join('::'))); }));
            this._brotherSelectors && (selectors = selectors.map(function (i) { var _a; return i + ("." + ((_a = _this._brotherSelectors) === null || _a === void 0 ? void 0 : _a.join('.'))); }));
            this._childSelectors && (selectors = selectors.map(function (i) { var _a; return i + (" " + ((_a = _this._childSelectors) === null || _a === void 0 ? void 0 : _a.join(' '))); }));
            ((_c = this._wrapRules) !== null && _c !== void 0 ? _c : []).forEach(function (func) { return (selectors = selectors.map(function (i) { return func(i); })); });
            return selectors.join(', ');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoClasses", {
        get: function () {
            return this._pseudoClasses;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "pseudoElements", {
        get: function () {
            return this._pseudoElements;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "parentSelectors", {
        get: function () {
            return this._parentSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "childSelectors", {
        get: function () {
            return this._childSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "brotherSelectors", {
        get: function () {
            return this._brotherSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapProperties", {
        get: function () {
            return this._wrapProperties;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapSelectors", {
        get: function () {
            return this._wrapSelectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "wrapRules", {
        get: function () {
            return this._wrapRules;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "simple", {
        get: function () {
            // is this style only has property and no wrap?
            return !(this.atRules || this._pseudoClasses || this._pseudoElements || this._parentSelectors || this._childSelectors || this._brotherSelectors || this._wrapProperties || this._wrapSelectors || this._wrapRules);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "isAtrule", {
        get: function () {
            return !(this.atRules === undefined || this.atRules.length === 0);
        },
        enumerable: false,
        configurable: true
    });
    Style.generate = function (parent, property, root) {
        if (!root)
            root = (parent === null || parent === void 0 ? void 0 : parent.startsWith('@'))
                ? new Style().atRule(parent)
                : new Style(parent);
        var output = [];
        var _loop_1 = function (key, value) {
            if (typeof value === 'string') {
                root.add(new Property(camelToDash(key), value));
            }
            else if (Array.isArray(value)) {
                value.map(function (i) { return root === null || root === void 0 ? void 0 : root.add(new Property(camelToDash(key), i)); });
            }
            else {
                var wrap = deepCopy(root);
                wrap.property = [];
                var child = void 0;
                if (key.startsWith('@')) {
                    child = wrap.atRule(key, false);
                }
                else {
                    if (wrap.selector === undefined) {
                        wrap.selector = key;
                        child = wrap;
                    }
                    else {
                        if (/^[a-z]+$/.test(key) && !isTagName(key)) {
                            wrap.wrapProperty(function (property) { return key + "-" + property; });
                            child = wrap;
                        }
                        else {
                            var _hKey_1 = function (selector, key) { return (/&/.test(key) ? key : "& " + key).replace('&', selector); };
                            wrap.wrapSelector(function (selector) {
                                return selector
                                    .trim()
                                    .split(/\s*,\s*/g)
                                    .map(function (s) {
                                    return key
                                        .split(/\s*,\s*/g)
                                        .map(function (i) { return _hKey_1(s, i); })
                                        .join(', ');
                                })
                                    .join(', ');
                            });
                            child = wrap;
                        }
                    }
                }
                output = output.concat(Style.generate(key.startsWith('@') ? undefined : key, value, child));
            }
        };
        for (var _i = 0, _a = Object.entries(property !== null && property !== void 0 ? property : {}); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            _loop_1(key, value);
        }
        if (root.property.length > 0)
            output.unshift(root);
        return output;
    };
    Style.prototype.atRule = function (atrule, append) {
        if (append === void 0) { append = true; }
        if (!atrule)
            return this;
        if (this.atRules) {
            append ? this.atRules.push(atrule) : this.atRules.unshift(atrule);
        }
        else {
            this.atRules = [atrule];
        }
        return this;
    };
    Style.prototype.pseudoClass = function (string) {
        if (this._pseudoClasses) {
            this._pseudoClasses.push(string);
        }
        else {
            this._pseudoClasses = [string];
        }
        return this;
    };
    Style.prototype.pseudoElement = function (string) {
        if (this._pseudoElements) {
            this._pseudoElements.push(string);
        }
        else {
            this._pseudoElements = [string];
        }
        return this;
    };
    Style.prototype.brother = function (string) {
        if (this._brotherSelectors) {
            this._brotherSelectors.push(string);
        }
        else {
            this._brotherSelectors = [string];
        }
        return this;
    };
    Style.prototype.parent = function (string) {
        if (this._parentSelectors) {
            this._parentSelectors.push(string);
        }
        else {
            this._parentSelectors = [string];
        }
        return this;
    };
    Style.prototype.child = function (string) {
        if (this._childSelectors) {
            this._childSelectors.push(string);
        }
        else {
            this._childSelectors = [string];
        }
        return this;
    };
    Style.prototype.wrapProperty = function (func) {
        if (this._wrapProperties) {
            this._wrapProperties.push(func);
        }
        else {
            this._wrapProperties = [func];
        }
        return this;
    };
    Style.prototype.wrapSelector = function (func) {
        if (this._wrapSelectors) {
            this._wrapSelectors.push(func);
        }
        else {
            this._wrapSelectors = [func];
        }
        return this;
    };
    Style.prototype.wrapRule = function (func) {
        if (this._wrapRules) {
            this._wrapRules.push(func);
        }
        else {
            this._wrapRules = [func];
        }
        return this;
    };
    Style.prototype.add = function (item) {
        item = toArray$1(item);
        if (this.important)
            item.forEach(function (i) { return (i.important = true); });
        this.property = __spreadArray(__spreadArray([], this.property), item);
        return this;
    };
    Style.prototype.extend = function (item, onlyProperty, append) {
        if (onlyProperty === void 0) { onlyProperty = false; }
        if (append === void 0) { append = true; }
        if (!item)
            return this;
        if (item.wrapProperties) {
            var props_1 = [];
            item.property.forEach(function (p) {
                var _a;
                var pc = new Property(p.name, p.value, p.comment);
                (_a = item.wrapProperties) === null || _a === void 0 ? void 0 : _a.forEach(function (wrap) {
                    pc.name = Array.isArray(pc.name)
                        ? pc.name.map(function (i) { return wrap(i); })
                        : wrap(pc.name);
                });
                if (item.important)
                    pc.important = true;
                props_1.push(pc);
            });
            this.property = connectList(this.property, props_1, append);
        }
        else {
            if (item.important)
                item.property.forEach(function (i) { return (i.important = true); });
            this.property = connectList(this.property, item.property, append);
        }
        if (onlyProperty)
            return this;
        item.selector && (this.selector = item.selector);
        this.meta = item.meta;
        item.atRules &&
            (this.atRules = connectList(item.atRules, this.atRules, append)); // atrule is build in reverse
        item._brotherSelectors &&
            (this._brotherSelectors = connectList(this._brotherSelectors, item._brotherSelectors, append));
        item._childSelectors &&
            (this._childSelectors = connectList(this._childSelectors, item._childSelectors, append));
        item._parentSelectors &&
            (this._parentSelectors = connectList(this._parentSelectors, item._parentSelectors, append));
        item._pseudoClasses &&
            (this._pseudoClasses = connectList(this._pseudoClasses, item._pseudoClasses, append));
        item._pseudoElements &&
            (this._pseudoElements = connectList(this._pseudoElements, item._pseudoElements, append));
        item._wrapRules &&
            (this._wrapRules = connectList(this._wrapRules, item._wrapRules, append));
        item._wrapSelectors &&
            (this._wrapSelectors = connectList(this._wrapSelectors, item._wrapSelectors, append));
        return this;
    };
    Style.prototype.clean = function () {
        // remove duplicated property
        var property = [];
        var cache = [];
        this.property.forEach(function (i) {
            var inline = i.build();
            if (!cache.includes(inline)) {
                cache.push(inline);
                property.push(i);
            }
        });
        this.property = property;
        return this;
    };
    Style.prototype.flat = function () {
        var properties = [];
        this.property.forEach(function (p) {
            if (Array.isArray(p.name)) {
                p.name.forEach(function (i) {
                    properties.push(new Property(i, p.value, p.comment));
                });
            }
            else {
                properties.push(p);
            }
        });
        this.property = properties;
        return this;
    };
    Style.prototype.clone = function (selector, property) {
        var newStyle = deepCopy(this);
        if (selector)
            newStyle.selector = selector;
        if (property)
            newStyle.property = Array.isArray(property) ? property : [property];
        return newStyle;
    };
    Style.prototype.sort = function () {
        // sort property
        this.property = this.property.sort(function (a, b) {
            return ("" + a.name).substring(0, 2) > ("" + b.name).substring(0, 2) ? 1 : -1;
        });
        return this;
    };
    Style.prototype.build = function (minify, prefixer) {
        var _this = this;
        if (minify === void 0) { minify = false; }
        if (prefixer === void 0) { prefixer = true; }
        var properties = this.property;
        if (!prefixer)
            properties = properties.filter(function (p) {
                if (p.value && /-(webkit|ms|moz|o)-/.test(p.value))
                    return false;
                if (Array.isArray(p.name)) {
                    p.name = p.name.filter(function (i) { return !/^-(webkit|ms|moz|o)-/.test(i); });
                    return true;
                }
                return !/^-(webkit|ms|moz|o)-/.test(p.name);
            });
        var result = properties.map(function (p) {
            if (_this._wrapProperties) {
                var name_2 = p.name;
                _this._wrapProperties.forEach(function (w) { return (name_2 = Array.isArray(name_2) ? name_2.map(function (n) { return w(n); }) : w(name_2)); });
                return new Property(name_2, p.value, p.comment, _this.important ? true : p.important).build(minify);
            }
            return _this.important ? new Property(p.name, p.value, p.comment, true).build(minify) : p.build(minify);
        }).join(minify ? '' : '\n');
        if (!this.selector && !this.atRules)
            return result.replace(/;}/g, '}');
        if (this.selector)
            result = (minify ? this.rule.replace(/,\s/g, ',') : this.rule + ' ') + wrapit(result, undefined, undefined, undefined, result !== '' ? minify : true);
        if (this.atRules) {
            for (var _i = 0, _a = this.atRules; _i < _a.length; _i++) {
                var rule = _a[_i];
                result = minify ? "" + rule.replace(/\s/g, '') + wrapit(result, undefined, undefined, undefined, minify) : rule + " " + wrapit(result, undefined, undefined, undefined, result !== '' ? minify : true);
            }
        }
        return minify ? result.replace(/;}/g, '}') : result;
    };
    Style.prototype.updateMeta = function (type, group, order, offset, corePlugin, respectSelector) {
        if (offset === void 0) { offset = 0; }
        if (corePlugin === void 0) { corePlugin = false; }
        if (respectSelector === void 0) { respectSelector = false; }
        this.meta = {
            type: type,
            group: group,
            order: order,
            offset: offset,
            corePlugin: corePlugin,
            respectSelector: respectSelector,
        };
        return this;
    };
    return Style;
}());
/** @class */ ((function (_super) {
    __extends(GlobalStyle, _super);
    function GlobalStyle(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return GlobalStyle;
})(Style));
/** @class */ ((function (_super) {
    __extends(Keyframes, _super);
    function Keyframes(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    // root param only for consist with style
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Keyframes.generate = function (name, children, root, prefixer) {
        if (prefixer === void 0) { prefixer = true; }
        var styles = [];
        var webkitStyles = [];
        for (var _i = 0, _a = Object.entries(children); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var style = new Keyframes(key).atRule("@keyframes " + name);
            var webkitStyle = new Keyframes(key).atRule("@-webkit-keyframes " + name);
            for (var _c = 0, _d = Object.entries(value); _c < _d.length; _c++) {
                var _e = _d[_c], pkey = _e[0], pvalue = _e[1];
                var prop = pkey;
                if (pkey === 'transform') {
                    prop = prefixer ? ['-webkit-transform', 'transform'] : 'transform';
                }
                else if (['animationTimingFunction', 'animation-timing-function'].includes(pkey)) {
                    prop = prefixer ? [
                        '-webkit-animation-timing-function',
                        'animation-timing-function',
                    ] : 'animation-timing-function';
                }
                style.add(new Property(prop, pvalue));
                webkitStyle.add(new Property(prop, pvalue));
            }
            styles.push(style);
            if (prefixer)
                webkitStyles.push(webkitStyle);
        }
        return __spreadArray(__spreadArray([], styles), webkitStyles);
    };
    return Keyframes;
})(Style));
/** @class */ ((function (_super) {
    __extends(Container, _super);
    function Container(selector, property, important) {
        return _super.call(this, selector, property, important) || this;
    }
    return Container;
})(Style));

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var isArrayish = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var simpleSwizzle = createCommonjsModule(function (module) {



var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};
});

/* MIT license */

createCommonjsModule(function (module) {
var reverseNames = {};

// create a list of reverse color names
for (var name in colorName) {
	if (colorName.hasOwnProperty(name)) {
		reverseNames[colorName[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorName[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = (parseFloat(match[1]) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = simpleSwizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = simpleSwizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = simpleSwizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = simpleSwizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = simpleSwizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}
});

var utilities = {
    // Layout
    container: [
        'container',
    ],
    objectPosition: [
        'object-${static}',
    ],
    inset: [
        'inset-${static}',
        'inset-${float}',
        'inset-${fraction}',
        'inset-${size}',
        'inset-y-${static}',
        'inset-y-${float}',
        'inset-y-${fraction}',
        'inset-y-${size}',
        'inset-x-${static}',
        'inset-x-${float}',
        'inset-x-${fraction}',
        'inset-x-${size}',
        'top-${static}',
        'top-${float}',
        'top-${fraction}',
        'top-${size}',
        'right-${static}',
        'right-${float}',
        'right-${fraction}',
        'right-${size}',
        'bottom-${static}',
        'bottom-${float}',
        'bottom-${fraction}',
        'bottom-${size}',
        'left-${static}',
        'left-${float}',
        'left-${fraction}',
        'left-${size}',
    ],
    zIndex: [
        'z-${static}',
        'z-${int}',
    ],
    // Flexbox
    flex: [
        'flex-${static}',
    ],
    flexGrow: [
        'flex-grow-${static}',
    ],
    flexShrink: [
        'flex-shrink-${static}',
    ],
    order: [
        'order-${static}',
        'order-${int}',
    ],
    // Grid
    gridTemplateColumns: [
        'grid-cols-${static}',
        'grid-cols-${int}',
    ],
    gridTemplateRows: [
        'grid-rows-${static}',
        'grid-rows-${int}',
    ],
    gridColumn: [
        'col-${static}',
        'col-span-${int}',
    ],
    gridColumnEnd: [
        'col-end-${static}',
        'col-end-${int}',
    ],
    gridColumnStart: [
        'col-start-${static}',
        'col-start-${int}',
    ],
    gridRow: [
        'row-${static}',
        'row-span-${int}',
    ],
    gridRowEnd: [
        'row-end-${static}',
        'row-end-${int}',
    ],
    gridRowStart: [
        'row-start-${static}',
        'row-start-${int}',
    ],
    gap: [
        'gap-${static}',
        'gap-x-${static}',
        'gap-y-${static}',
        'gap-${float}',
        'gap-x-${float}',
        'gap-y-${float}',
        'gap-${size}',
        'gap-x-${size}',
        'gap-y-${size}',
    ],
    // Box Alignment
    // Spacing
    padding: [
        'p-${static}',
        'py-${static}',
        'px-${static}',
        'pt-${static}',
        'pr-${static}',
        'pb-${static}',
        'pl-${static}',
        'p-${float}',
        'py-${float}',
        'px-${float}',
        'pt-${float}',
        'pr-${float}',
        'pb-${float}',
        'pl-${float}',
        'p-${size}',
        'py-${size}',
        'px-${size}',
        'pt-${size}',
        'pr-${size}',
        'pb-${size}',
        'pl-${size}',
    ],
    margin: [
        'm-${static}',
        'my-${static}',
        'mx-${static}',
        'mt-${static}',
        'mr-${static}',
        'mb-${static}',
        'ml-${static}',
        'm-${float}',
        'my-${float}',
        'mx-${float}',
        'mt-${float}',
        'mr-${float}',
        'mb-${float}',
        'ml-${float}',
        'm-${size}',
        'my-${size}',
        'mx-${size}',
        'mt-${size}',
        'mr-${size}',
        'mb-${size}',
        'ml-${size}',
    ],
    space: [
        'space-y-${static}',
        'space-y-reverse',
        'space-x-${static}',
        'space-x-reverse',
        'space-y-${float}',
        'space-x-${float}',
    ],
    width: [
        'w-${static}',
        'w-${float}',
        'w-${fraction}',
        'w-${int}xl',
        'w-${size}',
    ],
    minWidth: [
        'min-w-${static}',
        'min-w-${float}',
        'min-w-${fraction}',
        'min-w-${int}xl',
        'min-w-${size}',
    ],
    maxWidth: [
        'max-w-${static}',
        'max-w-${float}',
        'max-w-${fraction}',
        'max-w-${int}xl',
        'max-w-${size}',
    ],
    height: [
        'h-${static}',
        'h-${float}',
        'h-${fraction}',
        'h-${int}xl',
        'h-${size}',
    ],
    minHeight: [
        'min-h-${static}',
        'min-h-${float}',
        'min-h-${fraction}',
        'min-h-${int}xl',
        'min-h-${size}',
    ],
    maxHeight: [
        'max-h-${static}',
        'max-h-${float}',
        'max-h-${fraction}',
        'max-h-${int}xl',
        'max-h-${size}',
    ],
    // Typography
    fontSize: [
        'text-${static}',
        'text-${int}xl',
    ],
    textOpacity: [
        'text-opacity-${static}',
        'text-opacity-${int<=100}',
    ],
    textColor: [
        'text-${color}',
    ],
    fontFamily: [
        'font-${static}',
    ],
    fontWeight: [
        'font-${static}',
        'font-${int}',
    ],
    letterSpacing: [
        'tracking-${static}',
        'tracking-${size}',
    ],
    lineHeight: [
        'leading-${static}',
        'leading-${int}',
        'leading-${size}',
    ],
    listStyleType: [
        'list-${static}',
    ],
    placeholderColor: [
        'placeholder-${color}',
    ],
    placeholderOpacity: [
        'placeholder-opacity-${static}',
        'placeholder-opacity-${int<=100}',
    ],
    // Backgrounds
    backgroundColor: [
        'bg-${color}',
    ],
    backgroundOpacity: [
        'bg-opacity-${static}',
        'bg-opacity-${int<=100}',
    ],
    backgroundPosition: [
        'bg-${static}',
    ],
    backgroundSize: [
        'bg-${static}',
    ],
    backgroundImage: [
        'bg-${static}',
    ],
    gradientColorStops: [
        'from-${color}',
        'via-${color}',
        'to-${color}',
    ],
    // Borders
    borderRadius: [
        'rounded-${static}',
        'rounded-t-${static}',
        'rounded-l-${static}',
        'rounded-r-${static}',
        'rounded-b-${static}',
        'rounded-tl-${static}',
        'rounded-tr-${static}',
        'rounded-br-${static}',
        'rounded-bl-${static}',
        'rounded-${int}xl',
        'rounded-${size}',
        'rounded-t-${int}xl',
        'rounded-t-${size}',
        'rounded-l-${int}xl',
        'rounded-l-${size}',
        'rounded-r-${int}xl',
        'rounded-r-${size}',
        'rounded-b-${int}xl',
        'rounded-b-${size}',
        'rounded-tl-${int}xl',
        'rounded-tl-${size}',
        'rounded-tr-${int}xl',
        'rounded-tr-${size}',
        'rounded-br-${int}xl',
        'rounded-br-${size}',
        'rounded-bl-${int}xl',
        'rounded-bl-${size}',
    ],
    borderWidth: [
        'border-${static}',
        'border-${int}',
        'border-${size}',
        'border-t-${int}',
        'border-t-${size}',
        'border-r-${int}',
        'border-r-${size}',
        'border-b-${int}',
        'border-b-${size}',
        'border-l-${int}',
        'border-l-${size}',
    ],
    borderColor: [
        'border-${color}',
    ],
    borderOpacity: [
        'border-opacity-${static}',
        'border-opacity-${int<=100}',
    ],
    divideWidth: [
        'divide-y-reverse',
        'divide-x-reverse',
        'divide-y-${int}',
        'divide-x-${int}',
    ],
    divideColor: [
        'divide-${color}',
    ],
    divideOpacity: [
        'divide-${static}',
        'divide-opacity-${int<=100}',
    ],
    ringOffsetWidth: [
        'ring-offset-${static}',
        'ring-offset-${int}',
    ],
    ringOffsetColor: [
        'ring-offset-${color}',
    ],
    ringWidth: [
        'ring-${static}',
        'ring-${int}',
    ],
    ringColor: [
        'ring-${color}',
    ],
    ringOpacity: [
        'ring-${static}',
        'ring-opacity-${int<=100}',
    ],
    // Effects
    boxShadow: [
        'shadow-${static}',
    ],
    opacity: [
        'opacity-${static}',
        'opacity-${int<=100}',
    ],
    transition: [
        'transition-${static}',
    ],
    transitionDuration: [
        'duration-${static}',
        'duration-${int}',
    ],
    transitionTimingFunction: [
        'ease-${static}',
    ],
    transitionDelay: [
        'delay-${static}',
        'delay-${int}',
    ],
    animation: [
        'animate-${static}',
    ],
    // Transforms
    transformOrigin: [
        'origin-${static}',
    ],
    scale: [
        'scale-${static}',
        'scale-${int}',
        'scale-x-${static}',
        'scale-x-${int}',
        'scale-y-${static}',
        'scale-y-${int}',
    ],
    rotate: [
        'rotate-${static}',
        'rotate-${float}',
    ],
    translate: [
        'translate-${static}',
        'translate-x-${static}',
        'translate-y-${static}',
        'translate-x-${float}',
        'translate-x-${fraction}',
        'translate-x-${size}',
        'translate-y-${float}',
        'translate-y-${fraction}',
        'translate-y-${size}',
    ],
    skew: [
        'skew-x-${static}',
        'skew-x-${float}',
        'skew-y-${static}',
        'skew-y-${float}',
    ],
    cursor: [
        'cursor-${static}',
    ],
    // Interactivity
    outline: [
        'outline-${static}',
    ],
    outlineColor: [
        'outline-${color}',
        'outline-solid-${color}',
        'outline-dotted-${color}',
    ],
    // SVG
    fill: [
        'fill-${color}',
    ],
    // Stroke
    stroke: [
        'stroke-${color}',
    ],
    strokeWidth: [
        'stroke-${int}',
    ],
    // Plugins
    typography: [
        'prose-sm',
        'prose',
        'prose-lg',
        'prose-xl',
        'prose-2xl',
        'prose-red',
        'prose-yellow',
        'prose-green',
        'prose-blue',
        'prose-indigo',
        'prose-purple',
        'prose-pink',
    ],
    aspectRatio: [
        'aspect-none',
        'aspect-w-${float}',
        'aspect-h-${float}',
        'aspect-${fraction}',
    ],
    lineClamp: [
        'line-clamp-none',
        'line-clamp-${int}',
    ],
    filter: [
        'filter-${static}',
    ],
    backdropFilter: [
        'backdrop-${static}',
    ],
    blur: [
        'blur-${static}',
        'blur-${float}',
        'blur-${size}',
    ],
};
var negative = {
    inset: true,
    zIndex: true,
    order: true,
    margin: true,
    space: true,
    letterSpacing: true,
    rotate: true,
    translate: true,
    skew: true,
};
function generateCompletions(processor) {
    var completions = { static: [], color: [], dynamic: [] };
    var colors = flatColors$1(processor.theme('colors'));
    var _loop_1 = function (config, list) {
        list.forEach(function (utility) {
            var mark = utility.search(/\$/);
            if (mark === -1) {
                completions.static.push(utility);
            }
            else {
                var prefix_1 = utility.slice(0, mark - 1);
                var suffix = utility.slice(mark);
                switch (suffix) {
                    case '${static}':
                        completions.static = completions.static.concat(Object.keys(processor.theme(config, {})).map(function (i) { return i === 'DEFAULT' ? prefix_1 : i.charAt(0) === '-' ? "-" + prefix_1 + i : prefix_1 + "-" + i; }));
                        break;
                    case '${color}':
                        for (var _i = 0, _a = Object.keys(flatColors$1(processor.theme(config, colors))); _i < _a.length; _i++) {
                            var key = _a[_i];
                            if (key !== 'DEFAULT')
                                completions.color.push(prefix_1 + "-" + key);
                        }
                        break;
                    default:
                        completions.dynamic.push(utility);
                        if (config in negative)
                            completions.dynamic.push("-" + utility);
                        break;
                }
            }
        });
    };
    for (var _i = 0, _a = Object.entries(utilities); _i < _a.length; _i++) {
        var _b = _a[_i], config = _b[0], list = _b[1];
        _loop_1(config, list);
    }
    return completions;
}

// src/math.ts

// src/array.ts
function toArray(array) {
  array = array || [];
  if (Array.isArray(array))
    return array;
  return [array];
}
function partition(array, filter) {
  const pass = [];
  const fail = [];
  array.forEach((e, idx, arr) => (filter(e, idx, arr) ? pass : fail).push(e));
  return [pass, fail];
}

// src/string.ts
function slash$1(str) {
  return str.replace(/\\/g, "/");
}

// src/promise.ts
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}

var tasks = {};

var utils$m = {};

var array$1 = {};

Object.defineProperty(array$1, "__esModule", { value: true });
array$1.splitWhen = array$1.flatten = void 0;
function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
}
array$1.flatten = flatten;
function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
        if (predicate(item)) {
            groupIndex++;
            result[groupIndex] = [];
        }
        else {
            result[groupIndex].push(item);
        }
    }
    return result;
}
array$1.splitWhen = splitWhen;

var errno$1 = {};

Object.defineProperty(errno$1, "__esModule", { value: true });
errno$1.isEnoentCodeError = void 0;
function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
}
errno$1.isEnoentCodeError = isEnoentCodeError;

var fs$q = {};

Object.defineProperty(fs$q, "__esModule", { value: true });
fs$q.createDirentFromStats = void 0;
class DirentFromStats$1 {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats$1(name, stats) {
    return new DirentFromStats$1(name, stats);
}
fs$q.createDirentFromStats = createDirentFromStats$1;

var path$m = {};

Object.defineProperty(path$m, "__esModule", { value: true });
path$m.removeLeadingDotSegment = path$m.escape = path$m.makeAbsolute = path$m.unixify = void 0;
const path$l = require$$0__default$1['default'];
const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\
const UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
/**
 * Designed to work only with simple paths: `dir\\file`.
 */
function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
}
path$m.unixify = unixify;
function makeAbsolute(cwd, filepath) {
    return path$l.resolve(cwd, filepath);
}
path$m.makeAbsolute = makeAbsolute;
function escape(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}
path$m.escape = escape;
function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === '/' || secondCharactery === '\\') {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
    }
    return entry;
}
path$m.removeLeadingDotSegment = removeLeadingDotSegment;

var pattern$1 = {};

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

var isExtglob$1 = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = isExtglob$1;
var chars$1 = { '{': '}', '(': ')', '[': ']'};
var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

var isGlob$1 = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var regex = strictRegex;
  var match;

  // optionally relax regex
  if (options && options.strict === false) {
    regex = relaxedRegex;
  }

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    var idx = match.index + match[0].length;

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    var open = match[1];
    var close = open ? chars$1[open] : null;
    if (open && close) {
      var n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }

    str = str.slice(idx);
  }
  return false;
};

var isGlob = isGlob$1;
var pathPosixDirname = require$$0__default$1['default'].posix.dirname;
var isWin32 = require$$3__default['default'].platform() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */
var globParent$1 = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};

var utils$l = {};

(function (exports) {

exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
    }
    return result;
  };
  flat(args);
  return result;
};
}(utils$l));

const utils$k = utils$l;

var stringify$8 = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && utils$k.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils$k.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};

/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */

var isNumber$2 = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};

/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */

const isNumber$1 = isNumber$2;

const toRegexRange$1 = (min, max, options) => {
  if (isNumber$1(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber$1(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange$1.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange$1.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false) || [];
  let intersected = filterPatterns(neg, pos, '-?', true) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange$1.cache = {};
toRegexRange$1.clearCache = () => (toRegexRange$1.cache = {});

/**
 * Expose `toRegexRange`
 */

var toRegexRange_1 = toRegexRange$1;

/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */

const util$3 = require$$1__default['default'];
const toRegexRange = toRegexRange_1;

const isObject$2 = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify$7 = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util$3.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify$7(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill$2 = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill$2(start, end, 1, { transform: step });
  }

  if (isObject$2(step)) {
    return fill$2(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject$2(step)) return invalidStep(step, opts);
    return fill$2(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

var fillRange = fill$2;

const fill$1 = fillRange;
const utils$j = utils$l;

const compile$1 = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils$j.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return invalid ? (prefix + node.value) : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils$j.reduce(node.nodes);
      let range = fill$1(...args, { ...options, wrap: false, toRegex: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };

  return walk(ast);
};

var compile_1 = compile$1;

const fill = fillRange;
const stringify$6 = stringify$8;
const utils$i = utils$l;

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils$i.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
      }
    }
  }
  return utils$i.flatten(result);
};

const expand$1 = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify$6(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils$i.reduce(node.nodes);

      if (utils$i.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify$6(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = utils$i.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils$i.flatten(walk(ast));
};

var expand_1 = expand$1;

var constants$5 = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};

const stringify$5 = stringify$8;

/**
 * Constants
 */

const {
  MAX_LENGTH: MAX_LENGTH$1,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA: CHAR_COMMA$1, /* , */
  CHAR_DOT: CHAR_DOT$1, /* . */
  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1, /* ( */
  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1, /* ) */
  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1, /* { */
  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1, /* } */
  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = constants$5;

/**
 * parse
 */

const parse$7 = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET$1) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET$1) {
      brackets++;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET$1) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES$1) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES$1) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE$1) {
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE$1) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA$1 && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify$5(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT$1 && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

var parse_1$1 = parse$7;

const stringify$4 = stringify$8;
const compile = compile_1;
const expand = expand_1;
const parse$6 = parse_1$1;

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces$1 = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = braces$1.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces$1.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces$1.parse = (input, options = {}) => parse$6(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify$4(braces$1.parse(input, options), options);
  }
  return stringify$4(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces$1.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces$1.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces$1.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

 return options.expand !== true
    ? braces$1.compile(input, options)
    : braces$1.expand(input, options);
};

/**
 * Expose "braces"
 */

var braces_1 = braces$1;

var utils$h = {};

const path$k = require$$0__default$1['default'];
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE$1 = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

var constants$4 = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path$k.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};

(function (exports) {

const path = require$$0__default$1['default'];
const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = constants$4;

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};
}(utils$h));

const utils$g = utils$h;
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = constants$4;

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan$1 = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils$g.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils$g.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

var scan_1 = scan$1;

const constants$3 = constants$4;
const utils$f = utils$h;

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants$3;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils$f.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse$5 = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils$f.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants$3.globChars(win32);
  const EXTGLOB_CHARS = constants$3.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = (opts) => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils$f.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index];
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };
  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils$f.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance() || '';
      } else {
        value += advance() || '';
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils$f.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils$f.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils$f.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils$f.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils$f.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils$f.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils$f.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse$5.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils$f.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants$3.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = (opts) => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils$f.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

var parse_1 = parse$5;

const path$j = require$$0__default$1['default'];
const scan = scan_1;
const parse$4 = parse_1;
const utils$e = utils$h;
const constants$2 = constants$4;
const isObject$1 = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch$2 = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch$2(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject$1(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils$e.isWindows(options);
  const regex = isState
    ? picomatch$2.compileRe(glob, options)
    : picomatch$2.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch$2(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch$2.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch$2.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils$e.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch$2.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch$2.matchBase = (input, glob, options, posix = utils$e.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch$2.makeRe(glob, options);
  return regex.test(path$j.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch$2.isMatch = (str, patterns, options) => picomatch$2(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch$2.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch$2.parse(p, options));
  return parse$4(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch$2.scan = (input, options) => scan(input, options);

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch$2.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return parsed.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${parsed.output})${append}`;
  if (parsed && parsed.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch$2.toRegex(source, options);
  if (returnState === true) {
    regex.state = parsed;
  }

  return regex;
};

picomatch$2.makeRe = (input, options, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  const opts = options || {};
  let parsed = { negated: false, fastpaths: true };
  let prefix = '';
  let output;

  if (input.startsWith('./')) {
    input = input.slice(2);
    prefix = parsed.prefix = './';
  }

  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    output = parse$4.fastpaths(input, options);
  }

  if (output === undefined) {
    parsed = parse$4(input, options);
    parsed.prefix = prefix + (parsed.prefix || '');
  } else {
    parsed.output = output;
  }

  return picomatch$2.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch$2.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch$2.constants = constants$2;

/**
 * Expose "picomatch"
 */

var picomatch_1 = picomatch$2;

var picomatch$1 = picomatch_1;

const util$2 = require$$1__default['default'];
const braces = braces_1;
const picomatch = picomatch$1;
const utils$d = utils$h;
const isEmptyString = val => val === '' || val === './';

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} `list` List of strings to match.
 * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch$1 = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);
    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch$1.match = micromatch$1;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch$1.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `[options]` See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch$1.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch$1.any = micromatch$1.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch$1.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = micromatch$1(list, patterns, { ...options, onResult });

  for (let item of items) {
    if (!matches.includes(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
 * @api public
 */

micromatch$1.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util$2.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => micromatch$1.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch$1.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch$1.matchKeys = (obj, patterns, options) => {
  if (!utils$d.isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch$1(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
 * @api public
 */

micromatch$1.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
 * @api public
 */

micromatch$1.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item => isMatch(item))) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch$1.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util$2.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => picomatch(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch$1.capture = (glob, input, options) => {
  let posix = utils$d.isWindows(options);
  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils$d.toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch$1.makeRe = (...args) => picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch$1.scan = (...args) => picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch$1.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch$1.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch$1.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch$1.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

var micromatch_1 = micromatch$1;

Object.defineProperty(pattern$1, "__esModule", { value: true });
pattern$1.matchAny = pattern$1.convertPatternsToRe = pattern$1.makeRe = pattern$1.getPatternParts = pattern$1.expandBraceExpansion = pattern$1.expandPatternsWithBraceExpansion = pattern$1.isAffectDepthOfReadingPattern = pattern$1.endsWithSlashGlobStar = pattern$1.hasGlobStar = pattern$1.getBaseDirectory = pattern$1.isPatternRelatedToParentDirectory = pattern$1.getPatternsOutsideCurrentDirectory = pattern$1.getPatternsInsideCurrentDirectory = pattern$1.getPositivePatterns = pattern$1.getNegativePatterns = pattern$1.isPositivePattern = pattern$1.isNegativePattern = pattern$1.convertToNegativePattern = pattern$1.convertToPositivePattern = pattern$1.isDynamicPattern = pattern$1.isStaticPattern = void 0;
const path$i = require$$0__default$1['default'];
const globParent = globParent$1;
const micromatch = micromatch_1;
const GLOBSTAR = '**';
const ESCAPE_SYMBOL = '\\';
const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
const BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
}
pattern$1.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern, options = {}) {
    /**
     * A special case with an empty string is necessary for matching patterns that start with a forward slash.
     * An empty string cannot be a dynamic pattern.
     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
     */
    if (pattern === '') {
        return false;
    }
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    return false;
}
pattern$1.isDynamicPattern = isDynamicPattern;
function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
}
pattern$1.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern) {
    return '!' + pattern;
}
pattern$1.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
}
pattern$1.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
}
pattern$1.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
}
pattern$1.getNegativePatterns = getNegativePatterns;
function getPositivePatterns$1(patterns) {
    return patterns.filter(isPositivePattern);
}
pattern$1.getPositivePatterns = getPositivePatterns$1;
/**
 * Returns patterns that can be applied inside the current directory.
 *
 * @example
 * // ['./*', '*', 'a/*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsInsideCurrentDirectory(patterns) {
    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
}
pattern$1.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
/**
 * Returns patterns to be expanded relative to (outside) the current directory.
 *
 * @example
 * // ['../*', './../*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsOutsideCurrentDirectory(patterns) {
    return patterns.filter(isPatternRelatedToParentDirectory);
}
pattern$1.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
function isPatternRelatedToParentDirectory(pattern) {
    return pattern.startsWith('..') || pattern.startsWith('./..');
}
pattern$1.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
function getBaseDirectory(pattern) {
    return globParent(pattern, { flipBackslashes: false });
}
pattern$1.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
}
pattern$1.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
}
pattern$1.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern) {
    const basename = path$i.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
}
pattern$1.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
    }, []);
}
pattern$1.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern) {
    return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
    });
}
pattern$1.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern, options) {
    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
    /**
     * The scan method returns an empty array in some cases.
     * See micromatch/picomatch#58 for more details.
     */
    if (parts.length === 0) {
        parts = [pattern];
    }
    /**
     * The scan method does not return an empty part for the pattern with a forward slash.
     * This is another part of micromatch/picomatch#58.
     */
    if (parts[0].startsWith('/')) {
        parts[0] = parts[0].slice(1);
        parts.unshift('');
    }
    return parts;
}
pattern$1.getPatternParts = getPatternParts;
function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
}
pattern$1.makeRe = makeRe;
function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
}
pattern$1.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
}
pattern$1.matchAny = matchAny;

var stream$4 = {};

/*
 * merge2
 * https://github.com/teambition/merge2
 *
 * Copyright (c) 2014-2020 Teambition
 * Licensed under the MIT license.
 */
const Stream$1 = require$$0__default$4['default'];
const PassThrough = Stream$1.PassThrough;
const slice = Array.prototype.slice;

var merge2_1 = merge2$1;

function merge2$1 () {
  const streamsQueue = [];
  const args = slice.call(arguments);
  let merging = false;
  let options = args[args.length - 1];

  if (options && !Array.isArray(options) && options.pipe == null) {
    args.pop();
  } else {
    options = {};
  }

  const doEnd = options.end !== false;
  const doPipeError = options.pipeError === true;
  if (options.objectMode == null) {
    options.objectMode = true;
  }
  if (options.highWaterMark == null) {
    options.highWaterMark = 64 * 1024;
  }
  const mergedStream = PassThrough(options);

  function addStream () {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options));
    }
    mergeStream();
    return this
  }

  function mergeStream () {
    if (merging) {
      return
    }
    merging = true;

    let streams = streamsQueue.shift();
    if (!streams) {
      process.nextTick(endStream);
      return
    }
    if (!Array.isArray(streams)) {
      streams = [streams];
    }

    let pipesCount = streams.length + 1;

    function next () {
      if (--pipesCount > 0) {
        return
      }
      merging = false;
      mergeStream();
    }

    function pipe (stream) {
      function onend () {
        stream.removeListener('merge2UnpipeEnd', onend);
        stream.removeListener('end', onend);
        if (doPipeError) {
          stream.removeListener('error', onerror);
        }
        next();
      }
      function onerror (err) {
        mergedStream.emit('error', err);
      }
      // skip ended stream
      if (stream._readableState.endEmitted) {
        return next()
      }

      stream.on('merge2UnpipeEnd', onend);
      stream.on('end', onend);

      if (doPipeError) {
        stream.on('error', onerror);
      }

      stream.pipe(mergedStream, { end: false });
      // compatible for old stream
      stream.resume();
    }

    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i]);
    }

    next();
  }

  function endStream () {
    merging = false;
    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain');
    if (doEnd) {
      mergedStream.end();
    }
  }

  mergedStream.setMaxListeners(0);
  mergedStream.add = addStream;
  mergedStream.on('unpipe', function (stream) {
    stream.emit('merge2UnpipeEnd');
  });

  if (args.length) {
    addStream.apply(null, args);
  }
  return mergedStream
}

// check and pause streams for pipe.
function pauseStreams (streams, options) {
  if (!Array.isArray(streams)) {
    // Backwards-compat with old-style streams
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options));
    }
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error('Only readable stream can be merged.')
    }
    streams.pause();
  } else {
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options);
    }
  }
  return streams
}

Object.defineProperty(stream$4, "__esModule", { value: true });
stream$4.merge = void 0;
const merge2 = merge2_1;
function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
        stream.once('error', (error) => mergedStream.emit('error', error));
    });
    mergedStream.once('close', () => propagateCloseEventToSources(streams));
    mergedStream.once('end', () => propagateCloseEventToSources(streams));
    return mergedStream;
}
stream$4.merge = merge;
function propagateCloseEventToSources(streams) {
    streams.forEach((stream) => stream.emit('close'));
}

var string$1 = {};

Object.defineProperty(string$1, "__esModule", { value: true });
string$1.isEmpty = string$1.isString = void 0;
function isString(input) {
    return typeof input === 'string';
}
string$1.isString = isString;
function isEmpty(input) {
    return input === '';
}
string$1.isEmpty = isEmpty;

Object.defineProperty(utils$m, "__esModule", { value: true });
utils$m.string = utils$m.stream = utils$m.pattern = utils$m.path = utils$m.fs = utils$m.errno = utils$m.array = void 0;
const array = array$1;
utils$m.array = array;
const errno = errno$1;
utils$m.errno = errno;
const fs$p = fs$q;
utils$m.fs = fs$p;
const path$h = path$m;
utils$m.path = path$h;
const pattern = pattern$1;
utils$m.pattern = pattern;
const stream$3 = stream$4;
utils$m.stream = stream$3;
const string = string$1;
utils$m.string = string;

Object.defineProperty(tasks, "__esModule", { value: true });
tasks.convertPatternGroupToTask = tasks.convertPatternGroupsToTasks = tasks.groupPatternsByBaseDirectory = tasks.getNegativePatternsAsPositive = tasks.getPositivePatterns = tasks.convertPatternsToTasks = tasks.generate = void 0;
const utils$c = utils$m;
function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils$c.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils$c.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);
    return staticTasks.concat(dynamicTasks);
}
tasks.generate = generate;
/**
 * Returns tasks grouped by basic pattern directories.
 *
 * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.
 * This is necessary because directory traversal starts at the base directory and goes deeper.
 */
function convertPatternsToTasks(positive, negative, dynamic) {
    const tasks = [];
    const patternsOutsideCurrentDirectory = utils$c.pattern.getPatternsOutsideCurrentDirectory(positive);
    const patternsInsideCurrentDirectory = utils$c.pattern.getPatternsInsideCurrentDirectory(positive);
    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, [], dynamic));
    /*
     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory
     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.
     */
    if ('.' in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));
    }
    else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
    }
    return tasks;
}
tasks.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns) {
    return utils$c.pattern.getPositivePatterns(patterns);
}
tasks.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils$c.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils$c.pattern.convertToPositivePattern);
    return positive;
}
tasks.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
        const base = utils$c.pattern.getBaseDirectory(pattern);
        if (base in collection) {
            collection[base].push(pattern);
        }
        else {
            collection[base] = [pattern];
        }
        return collection;
    }, group);
}
tasks.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
}
tasks.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils$c.pattern.convertToNegativePattern))
    };
}
tasks.convertPatternGroupToTask = convertPatternGroupToTask;

var async$6 = {};

var stream$2 = {};

var out$3 = {};

var async$5 = {};

Object.defineProperty(async$5, "__esModule", { value: true });
async$5.read = void 0;
function read$3(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
            return callFailureCallback$2(callback, lstatError);
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            return callSuccessCallback$2(callback, lstat);
        }
        settings.fs.stat(path, (statError, stat) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    return callFailureCallback$2(callback, statError);
                }
                return callSuccessCallback$2(callback, lstat);
            }
            if (settings.markSymbolicLink) {
                stat.isSymbolicLink = () => true;
            }
            callSuccessCallback$2(callback, stat);
        });
    });
}
async$5.read = read$3;
function callFailureCallback$2(callback, error) {
    callback(error);
}
function callSuccessCallback$2(callback, result) {
    callback(null, result);
}

var sync$7 = {};

Object.defineProperty(sync$7, "__esModule", { value: true });
sync$7.read = void 0;
function read$2(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
    }
    try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
        }
        return stat;
    }
    catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat;
        }
        throw error;
    }
}
sync$7.read = read$2;

var settings$3 = {};

var fs$o = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = fs__default['default'];
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;
}(fs$o));

Object.defineProperty(settings$3, "__esModule", { value: true });
const fs$n = fs$o;
class Settings$2 {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs$n.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
settings$3.default = Settings$2;

Object.defineProperty(out$3, "__esModule", { value: true });
out$3.statSync = out$3.stat = out$3.Settings = void 0;
const async$4 = async$5;
const sync$6 = sync$7;
const settings_1$3 = settings$3;
out$3.Settings = settings_1$3.default;
function stat$5(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return async$4.read(path, getSettings$2(), optionsOrSettingsOrCallback);
    }
    async$4.read(path, getSettings$2(optionsOrSettingsOrCallback), callback);
}
out$3.stat = stat$5;
function statSync(path, optionsOrSettings) {
    const settings = getSettings$2(optionsOrSettings);
    return sync$6.read(path, settings);
}
out$3.statSync = statSync;
function getSettings$2(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1$3.default) {
        return settingsOrOptions;
    }
    return new settings_1$3.default(settingsOrOptions);
}

var out$2 = {};

var async$3 = {};

var async$2 = {};

var out$1 = {};

var async$1 = {};

/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

let promise;

var queueMicrotask_1 = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : commonjsGlobal)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0));

/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var runParallel_1 = runParallel;

const queueMicrotask$1 = queueMicrotask_1;

function runParallel (tasks, cb) {
  let results, pending, keys;
  let isSync = true;

  if (Array.isArray(tasks)) {
    results = [];
    pending = tasks.length;
  } else {
    keys = Object.keys(tasks);
    results = {};
    pending = keys.length;
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results);
      cb = null;
    }
    if (isSync) queueMicrotask$1(end);
    else end();
  }

  function each (i, err, result) {
    results[i] = result;
    if (--pending === 0 || err) {
      done(err);
    }
  }

  if (!pending) {
    // empty
    done(null);
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result); });
    });
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result); });
    });
  }

  isSync = false;
}

var constants$1 = {};

Object.defineProperty(constants$1, "__esModule", { value: true });
constants$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
const MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
const MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
const SUPPORTED_MAJOR_VERSION = 10;
const SUPPORTED_MINOR_VERSION = 10;
const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
/**
 * IS `true` for Node.js 10.10 and greater.
 */
constants$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;

var utils$b = {};

var fs$m = {};

Object.defineProperty(fs$m, "__esModule", { value: true });
fs$m.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
fs$m.createDirentFromStats = createDirentFromStats;

Object.defineProperty(utils$b, "__esModule", { value: true });
utils$b.fs = void 0;
const fs$l = fs$m;
utils$b.fs = fs$l;

var common$7 = {};

Object.defineProperty(common$7, "__esModule", { value: true });
common$7.joinPathSegments = void 0;
function joinPathSegments$1(a, b, separator) {
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
common$7.joinPathSegments = joinPathSegments$1;

Object.defineProperty(async$1, "__esModule", { value: true });
async$1.readdir = async$1.readdirWithFileTypes = async$1.read = void 0;
const fsStat$5 = out$3;
const rpl = runParallel_1;
const constants_1$1 = constants$1;
const utils$a = utils$b;
const common$6 = common$7;
function read$1(directory, settings, callback) {
    if (!settings.stats && constants_1$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes$1(directory, settings, callback);
    }
    return readdir$1(directory, settings, callback);
}
async$1.read = read$1;
function readdirWithFileTypes$1(directory, settings, callback) {
    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
            return callFailureCallback$1(callback, readdirError);
        }
        const entries = dirents.map((dirent) => ({
            dirent,
            name: dirent.name,
            path: common$6.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
            return callSuccessCallback$1(callback, entries);
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
            if (rplError !== null) {
                return callFailureCallback$1(callback, rplError);
            }
            callSuccessCallback$1(callback, rplEntries);
        });
    });
}
async$1.readdirWithFileTypes = readdirWithFileTypes$1;
function makeRplTaskEntry(entry, settings) {
    return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
            return done(null, entry);
        }
        settings.fs.stat(entry.path, (statError, stats) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    return done(statError);
                }
                return done(null, entry);
            }
            entry.dirent = utils$a.fs.createDirentFromStats(entry.name, stats);
            return done(null, entry);
        });
    };
}
function readdir$1(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
            return callFailureCallback$1(callback, readdirError);
        }
        const filepaths = names.map((name) => common$6.joinPathSegments(directory, name, settings.pathSegmentSeparator));
        const tasks = filepaths.map((filepath) => {
            return (done) => fsStat$5.stat(filepath, settings.fsStatSettings, done);
        });
        rpl(tasks, (rplError, results) => {
            if (rplError !== null) {
                return callFailureCallback$1(callback, rplError);
            }
            const entries = [];
            names.forEach((name, index) => {
                const stats = results[index];
                const entry = {
                    name,
                    path: filepaths[index],
                    dirent: utils$a.fs.createDirentFromStats(name, stats)
                };
                if (settings.stats) {
                    entry.stats = stats;
                }
                entries.push(entry);
            });
            callSuccessCallback$1(callback, entries);
        });
    });
}
async$1.readdir = readdir$1;
function callFailureCallback$1(callback, error) {
    callback(error);
}
function callSuccessCallback$1(callback, result) {
    callback(null, result);
}

var sync$5 = {};

Object.defineProperty(sync$5, "__esModule", { value: true });
sync$5.readdir = sync$5.readdirWithFileTypes = sync$5.read = void 0;
const fsStat$4 = out$3;
const constants_1 = constants$1;
const utils$9 = utils$b;
const common$5 = common$7;
function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
}
sync$5.read = read;
function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
    return dirents.map((dirent) => {
        const entry = {
            dirent,
            name: dirent.name,
            path: common$5.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
                const stats = settings.fs.statSync(entry.path);
                entry.dirent = utils$9.fs.createDirentFromStats(entry.name, stats);
            }
            catch (error) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    throw error;
                }
            }
        }
        return entry;
    });
}
sync$5.readdirWithFileTypes = readdirWithFileTypes;
function readdir(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
        const entryPath = common$5.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat$4.statSync(entryPath, settings.fsStatSettings);
        const entry = {
            name,
            path: entryPath,
            dirent: utils$9.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
            entry.stats = stats;
        }
        return entry;
    });
}
sync$5.readdir = readdir;

var settings$2 = {};

var fs$k = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = fs__default['default'];
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;
}(fs$k));

Object.defineProperty(settings$2, "__esModule", { value: true });
const path$g = require$$0__default$1['default'];
const fsStat$3 = out$3;
const fs$j = fs$k;
class Settings$1 {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs$j.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$g.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat$3.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
settings$2.default = Settings$1;

Object.defineProperty(out$1, "__esModule", { value: true });
out$1.Settings = out$1.scandirSync = out$1.scandir = void 0;
const async = async$1;
const sync$4 = sync$5;
const settings_1$2 = settings$2;
out$1.Settings = settings_1$2.default;
function scandir(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return async.read(path, getSettings$1(), optionsOrSettingsOrCallback);
    }
    async.read(path, getSettings$1(optionsOrSettingsOrCallback), callback);
}
out$1.scandir = scandir;
function scandirSync(path, optionsOrSettings) {
    const settings = getSettings$1(optionsOrSettings);
    return sync$4.read(path, settings);
}
out$1.scandirSync = scandirSync;
function getSettings$1(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1$2.default) {
        return settingsOrOptions;
    }
    return new settings_1$2.default(settingsOrOptions);
}

var queue$1 = {exports: {}};

function reusify$1 (Constructor) {
  var head = new Constructor();
  var tail = head;

  function get () {
    var current = head;

    if (current.next) {
      head = current.next;
    } else {
      head = new Constructor();
      tail = head;
    }

    current.next = null;

    return current
  }

  function release (obj) {
    tail.next = obj;
    tail = obj;
  }

  return {
    get: get,
    release: release
  }
}

var reusify_1 = reusify$1;

var reusify = reusify_1;

function fastqueue (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker;
    worker = context;
    context = null;
  }

  if (concurrency < 1) {
    throw new Error('fastqueue concurrency must be greater than 1')
  }

  var cache = reusify(Task);
  var queueHead = null;
  var queueTail = null;
  var _running = 0;
  var errorHandler = null;

  var self = {
    push: push,
    drain: noop$1,
    saturated: noop$1,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    getQueue: getQueue,
    unshift: unshift,
    empty: noop$1,
    kill: kill,
    killAndDrain: killAndDrain,
    error: error
  };

  return self

  function running () {
    return _running
  }

  function pause () {
    self.paused = true;
  }

  function length () {
    var current = queueHead;
    var counter = 0;

    while (current) {
      current = current.next;
      counter++;
    }

    return counter
  }

  function getQueue () {
    var current = queueHead;
    var tasks = [];

    while (current) {
      tasks.push(current.value);
      current = current.next;
    }

    return tasks
  }

  function resume () {
    if (!self.paused) return
    self.paused = false;
    for (var i = 0; i < self.concurrency; i++) {
      _running++;
      release();
    }
  }

  function idle () {
    return _running === 0 && self.length() === 0
  }

  function push (value, done) {
    var current = cache.get();

    current.context = context;
    current.release = release;
    current.value = value;
    current.callback = done || noop$1;
    current.errorHandler = errorHandler;

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current;
        queueTail = current;
      } else {
        queueHead = current;
        queueTail = current;
        self.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }

  function unshift (value, done) {
    var current = cache.get();

    current.context = context;
    current.release = release;
    current.value = value;
    current.callback = done || noop$1;

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead;
        queueHead = current;
      } else {
        queueHead = current;
        queueTail = current;
        self.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }

  function release (holder) {
    if (holder) {
      cache.release(holder);
    }
    var next = queueHead;
    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null;
        }
        queueHead = next.next;
        next.next = null;
        worker.call(context, next.value, next.worked);
        if (queueTail === null) {
          self.empty();
        }
      } else {
        _running--;
      }
    } else if (--_running === 0) {
      self.drain();
    }
  }

  function kill () {
    queueHead = null;
    queueTail = null;
    self.drain = noop$1;
  }

  function killAndDrain () {
    queueHead = null;
    queueTail = null;
    self.drain();
    self.drain = noop$1;
  }

  function error (handler) {
    errorHandler = handler;
  }
}

function noop$1 () {}

function Task () {
  this.value = null;
  this.callback = noop$1;
  this.next = null;
  this.release = noop$1;
  this.context = null;
  this.errorHandler = null;

  var self = this;

  this.worked = function worked (err, result) {
    var callback = self.callback;
    var errorHandler = self.errorHandler;
    var val = self.value;
    self.value = null;
    self.callback = noop$1;
    if (self.errorHandler) {
      errorHandler(err, val);
    }
    callback.call(self.context, err, result);
    self.release(self);
  };
}

function queueAsPromised (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker;
    worker = context;
    context = null;
  }

  function asyncWrapper (arg, cb) {
    worker.call(this, arg)
      .then(function (res) {
        cb(null, res);
      }, cb);
  }

  var queue = fastqueue(context, asyncWrapper, concurrency);

  var pushCb = queue.push;
  var unshiftCb = queue.unshift;

  queue.push = push;
  queue.unshift = unshift;

  return queue

  function push (value) {
    return new Promise(function (resolve, reject) {
      pushCb(value, function (err, result) {
        if (err) {
          reject(err);
          return
        }
        resolve(result);
      });
    })
  }

  function unshift (value) {
    return new Promise(function (resolve, reject) {
      unshiftCb(value, function (err, result) {
        if (err) {
          reject(err);
          return
        }
        resolve(result);
      });
    })
  }
}

queue$1.exports = fastqueue;
queue$1.exports.promise = queueAsPromised;

var common$4 = {};

Object.defineProperty(common$4, "__esModule", { value: true });
common$4.joinPathSegments = common$4.replacePathSegmentSeparator = common$4.isAppliedFilter = common$4.isFatalError = void 0;
function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
        return true;
    }
    return !settings.errorFilter(error);
}
common$4.isFatalError = isFatalError;
function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
}
common$4.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
}
common$4.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a, b, separator) {
    if (a === '') {
        return b;
    }
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
common$4.joinPathSegments = joinPathSegments;

var reader$1 = {};

Object.defineProperty(reader$1, "__esModule", { value: true });
const common$3 = common$4;
class Reader$1 {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common$3.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
}
reader$1.default = Reader$1;

Object.defineProperty(async$2, "__esModule", { value: true });
const events_1 = require$$0__default$5['default'];
const fsScandir$2 = out$1;
const fastq = queue$1.exports;
const common$2 = common$4;
const reader_1$3 = reader$1;
class AsyncReader extends reader_1$3.default {
    constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir$2.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
            if (!this._isFatalError) {
                this._emitter.emit('end');
            }
        };
    }
    read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
            this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
    }
    get isDestroyed() {
        return this._isDestroyed;
    }
    destroy() {
        if (this._isDestroyed) {
            throw new Error('The reader is already destroyed');
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
    }
    onEntry(callback) {
        this._emitter.on('entry', callback);
    }
    onError(callback) {
        this._emitter.once('error', callback);
    }
    onEnd(callback) {
        this._emitter.once('end', callback);
    }
    _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
            if (error !== null) {
                this._handleError(error);
            }
        });
    }
    _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
            if (error !== null) {
                return done(error, undefined);
            }
            for (const entry of entries) {
                this._handleEntry(entry, item.base);
            }
            done(null, undefined);
        });
    }
    _handleError(error) {
        if (this._isDestroyed || !common$2.isFatalError(this._settings, error)) {
            return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit('error', error);
    }
    _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
            return;
        }
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common$2.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common$2.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common$2.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, entry.path);
        }
    }
    _emitEntry(entry) {
        this._emitter.emit('entry', entry);
    }
}
async$2.default = AsyncReader;

Object.defineProperty(async$3, "__esModule", { value: true });
const async_1$3 = async$2;
class AsyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1$3.default(this._root, this._settings);
        this._storage = new Set();
    }
    read(callback) {
        this._reader.onError((error) => {
            callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
            this._storage.add(entry);
        });
        this._reader.onEnd(() => {
            callSuccessCallback(callback, [...this._storage]);
        });
        this._reader.read();
    }
}
async$3.default = AsyncProvider;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, entries) {
    callback(null, entries);
}

var stream$1 = {};

Object.defineProperty(stream$1, "__esModule", { value: true });
const stream_1$5 = require$$0__default$4['default'];
const async_1$2 = async$2;
class StreamProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1$2.default(this._root, this._settings);
        this._stream = new stream_1$5.Readable({
            objectMode: true,
            read: () => { },
            destroy: () => {
                if (!this._reader.isDestroyed) {
                    this._reader.destroy();
                }
            }
        });
    }
    read() {
        this._reader.onError((error) => {
            this._stream.emit('error', error);
        });
        this._reader.onEntry((entry) => {
            this._stream.push(entry);
        });
        this._reader.onEnd(() => {
            this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
    }
}
stream$1.default = StreamProvider;

var sync$3 = {};

var sync$2 = {};

Object.defineProperty(sync$2, "__esModule", { value: true });
const fsScandir$1 = out$1;
const common$1 = common$4;
const reader_1$2 = reader$1;
class SyncReader extends reader_1$2.default {
    constructor() {
        super(...arguments);
        this._scandir = fsScandir$1.scandirSync;
        this._storage = new Set();
        this._queue = new Set();
    }
    read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return [...this._storage];
    }
    _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
    }
    _handleQueue() {
        for (const item of this._queue.values()) {
            this._handleDirectory(item.directory, item.base);
        }
    }
    _handleDirectory(directory, base) {
        try {
            const entries = this._scandir(directory, this._settings.fsScandirSettings);
            for (const entry of entries) {
                this._handleEntry(entry, base);
            }
        }
        catch (error) {
            this._handleError(error);
        }
    }
    _handleError(error) {
        if (!common$1.isFatalError(this._settings, error)) {
            return;
        }
        throw error;
    }
    _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common$1.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common$1.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common$1.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, entry.path);
        }
    }
    _pushToStorage(entry) {
        this._storage.add(entry);
    }
}
sync$2.default = SyncReader;

Object.defineProperty(sync$3, "__esModule", { value: true });
const sync_1$3 = sync$2;
class SyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1$3.default(this._root, this._settings);
    }
    read() {
        return this._reader.read();
    }
}
sync$3.default = SyncProvider;

var settings$1 = {};

Object.defineProperty(settings$1, "__esModule", { value: true });
const path$f = require$$0__default$1['default'];
const fsScandir = out$1;
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, undefined);
        this.concurrency = this._getValue(this._options.concurrency, Infinity);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$f.sep);
        this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
settings$1.default = Settings;

Object.defineProperty(out$2, "__esModule", { value: true });
out$2.Settings = out$2.walkStream = out$2.walkSync = out$2.walk = void 0;
const async_1$1 = async$3;
const stream_1$4 = stream$1;
const sync_1$2 = sync$3;
const settings_1$1 = settings$1;
out$2.Settings = settings_1$1.default;
function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return new async_1$1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    }
    new async_1$1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
out$2.walk = walk;
function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1$2.default(directory, settings);
    return provider.read();
}
out$2.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1$4.default(directory, settings);
    return provider.read();
}
out$2.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1$1.default) {
        return settingsOrOptions;
    }
    return new settings_1$1.default(settingsOrOptions);
}

var reader = {};

Object.defineProperty(reader, "__esModule", { value: true });
const path$e = require$$0__default$1['default'];
const fsStat$2 = out$3;
const utils$8 = utils$m;
class Reader {
    constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat$2.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
    }
    _getFullEntryPath(filepath) {
        return path$e.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
        const entry = {
            name: pattern,
            path: pattern,
            dirent: utils$8.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
            entry.stats = stats;
        }
        return entry;
    }
    _isFatalError(error) {
        return !utils$8.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
}
reader.default = Reader;

Object.defineProperty(stream$2, "__esModule", { value: true });
const stream_1$3 = require$$0__default$4['default'];
const fsStat$1 = out$3;
const fsWalk$1 = out$2;
const reader_1$1 = reader;
class ReaderStream extends reader_1$1.default {
    constructor() {
        super(...arguments);
        this._walkStream = fsWalk$1.walkStream;
        this._stat = fsStat$1.stat;
    }
    dynamic(root, options) {
        return this._walkStream(root, options);
    }
    static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1$3.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
            return this._getEntry(filepaths[index], patterns[index], options)
                .then((entry) => {
                if (entry !== null && options.entryFilter(entry)) {
                    stream.push(entry);
                }
                if (index === filepaths.length - 1) {
                    stream.end();
                }
                done();
            })
                .catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
            stream.write(i);
        }
        return stream;
    }
    _getEntry(filepath, pattern, options) {
        return this._getStat(filepath)
            .then((stats) => this._makeEntry(stats, pattern))
            .catch((error) => {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        });
    }
    _getStat(filepath) {
        return new Promise((resolve, reject) => {
            this._stat(filepath, this._fsStatSettings, (error, stats) => {
                return error === null ? resolve(stats) : reject(error);
            });
        });
    }
}
stream$2.default = ReaderStream;

var provider = {};

var deep = {};

var partial = {};

var matcher = {};

Object.defineProperty(matcher, "__esModule", { value: true });
const utils$7 = utils$m;
class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
    }
    _fillStorage() {
        /**
         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
         * So, before expand patterns with brace expansion into separated patterns.
         */
        const patterns = utils$7.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
            const segments = this._getPatternSegments(pattern);
            const sections = this._splitSegmentsIntoSections(segments);
            this._storage.push({
                complete: sections.length <= 1,
                pattern,
                segments,
                sections
            });
        }
    }
    _getPatternSegments(pattern) {
        const parts = utils$7.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
            const dynamic = utils$7.pattern.isDynamicPattern(part, this._settings);
            if (!dynamic) {
                return {
                    dynamic: false,
                    pattern: part
                };
            }
            return {
                dynamic: true,
                pattern: part,
                patternRe: utils$7.pattern.makeRe(part, this._micromatchOptions)
            };
        });
    }
    _splitSegmentsIntoSections(segments) {
        return utils$7.array.splitWhen(segments, (segment) => segment.dynamic && utils$7.pattern.hasGlobStar(segment.pattern));
    }
}
matcher.default = Matcher;

Object.defineProperty(partial, "__esModule", { value: true });
const matcher_1 = matcher;
class PartialMatcher extends matcher_1.default {
    match(filepath) {
        const parts = filepath.split('/');
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
            const section = pattern.sections[0];
            /**
             * In this case, the pattern has a globstar and we must read all directories unconditionally,
             * but only if the level has reached the end of the first group.
             *
             * fixtures/{a,b}/**
             *  ^ true/false  ^ always true
            */
            if (!pattern.complete && levels > section.length) {
                return true;
            }
            const match = parts.every((part, index) => {
                const segment = pattern.segments[index];
                if (segment.dynamic && segment.patternRe.test(part)) {
                    return true;
                }
                if (!segment.dynamic && segment.pattern === part) {
                    return true;
                }
                return false;
            });
            if (match) {
                return true;
            }
        }
        return false;
    }
}
partial.default = PartialMatcher;

Object.defineProperty(deep, "__esModule", { value: true });
const utils$6 = utils$m;
const partial_1 = partial;
class DeepFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils$6.pattern.isAffectDepthOfReadingPattern);
        return utils$6.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
            return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
            return false;
        }
        const filepath = utils$6.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath, entryPath) {
        /**
         * Avoid unnecessary depth calculations when it doesn't matter.
         */
        if (this._settings.deep === Infinity) {
            return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split('/').length;
        if (basePath === '') {
            return entryPathDepth;
        }
        const basePathDepth = basePath.split('/').length;
        return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils$6.pattern.matchAny(entryPath, patternsRe);
    }
}
deep.default = DeepFilter;

var entry$1 = {};

Object.defineProperty(entry$1, "__esModule", { value: true });
const utils$5 = utils$m;
class EntryFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
    }
    getFilter(positive, negative) {
        const positiveRe = utils$5.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils$5.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
            return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
            return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched) {
            this._createIndexRecord(entry);
        }
        return isMatched;
    }
    _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
    }
    _createIndexRecord(entry) {
        this.index.set(entry.path, undefined);
    }
    _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
            return false;
        }
        const fullpath = utils$5.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils$5.pattern.matchAny(fullpath, patternsRe);
    }
    _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils$5.path.removeLeadingDotSegment(entryPath);
        return utils$5.pattern.matchAny(filepath, patternsRe);
    }
}
entry$1.default = EntryFilter;

var error = {};

Object.defineProperty(error, "__esModule", { value: true });
const utils$4 = utils$m;
class ErrorFilter {
    constructor(_settings) {
        this._settings = _settings;
    }
    getFilter() {
        return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
        return utils$4.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
}
error.default = ErrorFilter;

var entry = {};

Object.defineProperty(entry, "__esModule", { value: true });
const utils$3 = utils$m;
class EntryTransformer {
    constructor(_settings) {
        this._settings = _settings;
    }
    getTransformer() {
        return (entry) => this._transform(entry);
    }
    _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
            filepath = utils$3.path.makeAbsolute(this._settings.cwd, filepath);
            filepath = utils$3.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += '/';
        }
        if (!this._settings.objectMode) {
            return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
    }
}
entry.default = EntryTransformer;

Object.defineProperty(provider, "__esModule", { value: true });
const path$d = require$$0__default$1['default'];
const deep_1 = deep;
const entry_1 = entry$1;
const error_1 = error;
const entry_2 = entry;
class Provider {
    constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
        return path$d.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
        const basePath = task.base === '.' ? '' : task.base;
        return {
            basePath,
            pathSegmentSeparator: '/',
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer()
        };
    }
    _getMicromatchOptions() {
        return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false
        };
    }
}
provider.default = Provider;

Object.defineProperty(async$6, "__esModule", { value: true });
const stream_1$2 = stream$2;
const provider_1$2 = provider;
class ProviderAsync extends provider_1$2.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_1$2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
            const stream = this.api(root, task, options);
            stream.once('error', reject);
            stream.on('data', (entry) => entries.push(options.transform(entry)));
            stream.once('end', () => resolve(entries));
        });
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
async$6.default = ProviderAsync;

var stream = {};

Object.defineProperty(stream, "__esModule", { value: true });
const stream_1$1 = require$$0__default$4['default'];
const stream_2 = stream$2;
const provider_1$1 = provider;
class ProviderStream extends provider_1$1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1$1.Readable({ objectMode: true, read: () => { } });
        source
            .once('error', (error) => destination.emit('error', error))
            .on('data', (entry) => destination.emit('data', options.transform(entry)))
            .once('end', () => destination.emit('end'));
        destination
            .once('close', () => source.destroy());
        return destination;
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
stream.default = ProviderStream;

var sync$1 = {};

var sync = {};

Object.defineProperty(sync, "__esModule", { value: true });
const fsStat = out$3;
const fsWalk = out$2;
const reader_1 = reader;
class ReaderSync extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
        return this._walkSync(root, options);
    }
    static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
            const filepath = this._getFullEntryPath(pattern);
            const entry = this._getEntry(filepath, pattern, options);
            if (entry === null || !options.entryFilter(entry)) {
                continue;
            }
            entries.push(entry);
        }
        return entries;
    }
    _getEntry(filepath, pattern, options) {
        try {
            const stats = this._getStat(filepath);
            return this._makeEntry(stats, pattern);
        }
        catch (error) {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        }
    }
    _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
    }
}
sync.default = ReaderSync;

Object.defineProperty(sync$1, "__esModule", { value: true });
const sync_1$1 = sync;
const provider_1 = provider;
class ProviderSync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new sync_1$1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
sync$1.default = ProviderSync;

var settings = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
const fs = fs__default['default'];
const os = require$$3__default['default'];
/**
 * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.
 * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107
 */
const CPU_COUNT = Math.max(os.cpus().length, 1);
exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
            this.onlyFiles = false;
        }
        if (this.stats) {
            this.objectMode = true;
        }
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
}
exports.default = Settings;
}(settings));

const taskManager = tasks;
const async_1 = async$6;
const stream_1 = stream;
const sync_1 = sync$1;
const settings_1 = settings;
const utils$2 = utils$m;
async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils$2.array.flatten(result);
}
// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function (FastGlob) {
    function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils$2.array.flatten(works);
    }
    FastGlob.sync = sync;
    function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        /**
         * The stream returned by the provider cannot work with an asynchronous iterator.
         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
         * This affects performance (+25%). I don't see best solution right now.
         */
        return utils$2.stream.merge(works);
    }
    FastGlob.stream = stream;
    function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
    }
    FastGlob.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils$2.pattern.isDynamicPattern(source, settings);
    }
    FastGlob.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
        assertPatternsInput(source);
        return utils$2.path.escape(source);
    }
    FastGlob.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options) {
    const patterns = [].concat(source);
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
}
function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils$2.string.isString(item) && !utils$2.string.isEmpty(item));
    if (!isValidSource) {
        throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
}
var out = FastGlob;

var src$2 = {exports: {}};

var browser$2 = {exports: {}};

/**
 * Helpers.
 */

var s$2 = 1000;
var m$2 = s$2 * 60;
var h$2 = m$2 * 60;
var d$2 = h$2 * 24;
var w = d$2 * 7;
var y$2 = d$2 * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$2 = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$3(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong$2(val) : fmtShort$2(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$3(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$2;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d$2;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$2;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$2;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$2;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort$2(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d$2) {
    return Math.round(ms / d$2) + 'd';
  }
  if (msAbs >= h$2) {
    return Math.round(ms / h$2) + 'h';
  }
  if (msAbs >= m$2) {
    return Math.round(ms / m$2) + 'm';
  }
  if (msAbs >= s$2) {
    return Math.round(ms / s$2) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong$2(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d$2) {
    return plural$2(ms, msAbs, d$2, 'day');
  }
  if (msAbs >= h$2) {
    return plural$2(ms, msAbs, h$2, 'hour');
  }
  if (msAbs >= m$2) {
    return plural$2(ms, msAbs, m$2, 'minute');
  }
  if (msAbs >= s$2) {
    return plural$2(ms, msAbs, s$2, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural$2(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = ms$2;
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

var common = setup;

/* eslint-env browser */

(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = common(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};
}(browser$2, browser$2.exports));

var node$2 = {exports: {}};

var hasFlag$1 = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};

const os = require$$3__default['default'];
const tty = require$$0__default$3['default'];
const hasFlag = hasFlag$1;

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

var supportsColor_1 = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};

/**
 * Module dependencies.
 */

(function (module, exports) {
const tty = require$$0__default$3['default'];
const util = require$$1__default['default'];

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = supportsColor_1;

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = common(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};
}(node$2, node$2.exports));

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	src$2.exports = browser$2.exports;
} else {
	src$2.exports = node$2.exports;
}

var _debug2 = src$2.exports;

var charToInteger = {};
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
for (var i = 0; i < chars.length; i++) {
    charToInteger[chars.charCodeAt(i)] = i;
}
function encode(decoded) {
    var sourceFileIndex = 0; // second field
    var sourceCodeLine = 0; // third field
    var sourceCodeColumn = 0; // fourth field
    var nameIndex = 0; // fifth field
    var mappings = '';
    for (var i = 0; i < decoded.length; i++) {
        var line = decoded[i];
        if (i > 0)
            mappings += ';';
        if (line.length === 0)
            continue;
        var generatedCodeColumn = 0; // first field
        var lineMappings = [];
        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
            var segment = line_1[_i];
            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
            generatedCodeColumn = segment[0];
            if (segment.length > 1) {
                segmentMappings +=
                    encodeInteger(segment[1] - sourceFileIndex) +
                        encodeInteger(segment[2] - sourceCodeLine) +
                        encodeInteger(segment[3] - sourceCodeColumn);
                sourceFileIndex = segment[1];
                sourceCodeLine = segment[2];
                sourceCodeColumn = segment[3];
            }
            if (segment.length === 5) {
                segmentMappings += encodeInteger(segment[4] - nameIndex);
                nameIndex = segment[4];
            }
            lineMappings.push(segmentMappings);
        }
        mappings += lineMappings.join(',');
    }
    return mappings;
}
function encodeInteger(num) {
    var result = '';
    num = num < 0 ? (-num << 1) | 1 : num << 1;
    do {
        var clamped = num & 31;
        num >>>= 5;
        if (num > 0) {
            clamped |= 32;
        }
        result += chars[clamped];
    } while (num > 0);
    return result;
}

var BitSet = function BitSet(arg) {
	this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
};

BitSet.prototype.add = function add (n) {
	this.bits[n >> 5] |= 1 << (n & 31);
};

BitSet.prototype.has = function has (n) {
	return !!(this.bits[n >> 5] & (1 << (n & 31)));
};

var Chunk = function Chunk(start, end, content) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties(this, {
		previous: { writable: true, value: null },
		next:     { writable: true, value: null }
	});
};

Chunk.prototype.appendLeft = function appendLeft (content) {
	this.outro += content;
};

Chunk.prototype.appendRight = function appendRight (content) {
	this.intro = this.intro + content;
};

Chunk.prototype.clone = function clone () {
	var chunk = new Chunk(this.start, this.end, this.original);

	chunk.intro = this.intro;
	chunk.outro = this.outro;
	chunk.content = this.content;
	chunk.storeName = this.storeName;
	chunk.edited = this.edited;

	return chunk;
};

Chunk.prototype.contains = function contains (index) {
	return this.start < index && index < this.end;
};

Chunk.prototype.eachNext = function eachNext (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.next;
	}
};

Chunk.prototype.eachPrevious = function eachPrevious (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.previous;
	}
};

Chunk.prototype.edit = function edit (content, storeName, contentOnly) {
	this.content = content;
	if (!contentOnly) {
		this.intro = '';
		this.outro = '';
	}
	this.storeName = storeName;

	this.edited = true;

	return this;
};

Chunk.prototype.prependLeft = function prependLeft (content) {
	this.outro = content + this.outro;
};

Chunk.prototype.prependRight = function prependRight (content) {
	this.intro = content + this.intro;
};

Chunk.prototype.split = function split (index) {
	var sliceIndex = index - this.start;

	var originalBefore = this.original.slice(0, sliceIndex);
	var originalAfter = this.original.slice(sliceIndex);

	this.original = originalBefore;

	var newChunk = new Chunk(index, this.end, originalAfter);
	newChunk.outro = this.outro;
	this.outro = '';

	this.end = index;

	if (this.edited) {
		// TODO is this block necessary?...
		newChunk.edit('', false);
		this.content = '';
	} else {
		this.content = originalBefore;
	}

	newChunk.next = this.next;
	if (newChunk.next) { newChunk.next.previous = newChunk; }
	newChunk.previous = this;
	this.next = newChunk;

	return newChunk;
};

Chunk.prototype.toString = function toString () {
	return this.intro + this.content + this.outro;
};

Chunk.prototype.trimEnd = function trimEnd (rx) {
	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.start + trimmed.length).edit('', undefined, true);
		}
		return true;

	} else {
		this.edit('', undefined, true);

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; }
	}
};

Chunk.prototype.trimStart = function trimStart (rx) {
	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.end - trimmed.length);
			this.edit('', undefined, true);
		}
		return true;

	} else {
		this.edit('', undefined, true);

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; }
	}
};

var btoa = function () {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
};
if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
} else if (typeof Buffer === 'function') {
	btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
}

var SourceMap = function SourceMap(properties) {
	this.version = 3;
	this.file = properties.file;
	this.sources = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names = properties.names;
	this.mappings = encode(properties.mappings);
};

SourceMap.prototype.toString = function toString () {
	return JSON.stringify(this);
};

SourceMap.prototype.toUrl = function toUrl () {
	return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
};

function guessIndent(code) {
	var lines = code.split('\n');

	var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
	var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce(function (previous, current) {
		var numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	var fromParts = from.split(/[/\\]/);
	var toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		var i = fromParts.length;
		while (i--) { fromParts[i] = '..'; }
	}

	return fromParts.concat(toParts).join('/');
}

var toString = Object.prototype.toString;

function isObject(thing) {
	return toString.call(thing) === '[object Object]';
}

function getLocator(source) {
	var originalLines = source.split('\n');
	var lineOffsets = [];

	for (var i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		var i = 0;
		var j = lineOffsets.length;
		while (i < j) {
			var m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		var line = i - 1;
		var column = index - lineOffsets[line];
		return { line: line, column: column };
	};
}

var Mappings = function Mappings(hires) {
	this.hires = hires;
	this.generatedCodeLine = 0;
	this.generatedCodeColumn = 0;
	this.raw = [];
	this.rawSegments = this.raw[this.generatedCodeLine] = [];
	this.pending = null;
};

Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
	if (content.length) {
		var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
		if (nameIndex >= 0) {
			segment.push(nameIndex);
		}
		this.rawSegments.push(segment);
	} else if (this.pending) {
		this.rawSegments.push(this.pending);
	}

	this.advance(content);
	this.pending = null;
};

Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
	var originalCharIndex = chunk.start;
	var first = true;

	while (originalCharIndex < chunk.end) {
		if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
			this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
		}

		if (original[originalCharIndex] === '\n') {
			loc.line += 1;
			loc.column = 0;
			this.generatedCodeLine += 1;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
			this.generatedCodeColumn = 0;
			first = true;
		} else {
			loc.column += 1;
			this.generatedCodeColumn += 1;
			first = false;
		}

		originalCharIndex += 1;
	}

	this.pending = null;
};

Mappings.prototype.advance = function advance (str) {
	if (!str) { return; }

	var lines = str.split('\n');

	if (lines.length > 1) {
		for (var i = 0; i < lines.length - 1; i++) {
			this.generatedCodeLine++;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
		}
		this.generatedCodeColumn = 0;
	}

	this.generatedCodeColumn += lines[lines.length - 1].length;
};

var n = '\n';

var warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};

var MagicString = function MagicString(string, options) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk(0, string.length, string);

	Object.defineProperties(this, {
		original:              { writable: true, value: string },
		outro:                 { writable: true, value: '' },
		intro:                 { writable: true, value: '' },
		firstChunk:            { writable: true, value: chunk },
		lastChunk:             { writable: true, value: chunk },
		lastSearchedChunk:     { writable: true, value: chunk },
		byStart:               { writable: true, value: {} },
		byEnd:                 { writable: true, value: {} },
		filename:              { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations:    { writable: true, value: new BitSet() },
		storedNames:           { writable: true, value: {} },
		indentStr:             { writable: true, value: guessIndent(string) }
	});

	this.byStart[0] = chunk;
	this.byEnd[string.length] = chunk;
};

MagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
	this.sourcemapLocations.add(char);
};

MagicString.prototype.append = function append (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.outro += content;
	return this;
};

MagicString.prototype.appendLeft = function appendLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.appendLeft(content);
	} else {
		this.intro += content;
	}
	return this;
};

MagicString.prototype.appendRight = function appendRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.appendRight(content);
	} else {
		this.outro += content;
	}
	return this;
};

MagicString.prototype.clone = function clone () {
	var cloned = new MagicString(this.original, { filename: this.filename });

	var originalChunk = this.firstChunk;
	var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

	while (originalChunk) {
		cloned.byStart[clonedChunk.start] = clonedChunk;
		cloned.byEnd[clonedChunk.end] = clonedChunk;

		var nextOriginalChunk = originalChunk.next;
		var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

		if (nextClonedChunk) {
			clonedChunk.next = nextClonedChunk;
			nextClonedChunk.previous = clonedChunk;

			clonedChunk = nextClonedChunk;
		}

		originalChunk = nextOriginalChunk;
	}

	cloned.lastChunk = clonedChunk;

	if (this.indentExclusionRanges) {
		cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
	}

	cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

	cloned.intro = this.intro;
	cloned.outro = this.outro;

	return cloned;
};

MagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1$1 = this;

	options = options || {};

	var sourceIndex = 0;
	var names = Object.keys(this.storedNames);
	var mappings = new Mappings(options.hires);

	var locate = getLocator(this.original);

	if (this.intro) {
		mappings.advance(this.intro);
	}

	this.firstChunk.eachNext(function (chunk) {
		var loc = locate(chunk.start);

		if (chunk.intro.length) { mappings.advance(chunk.intro); }

		if (chunk.edited) {
			mappings.addEdit(
				sourceIndex,
				chunk.content,
				loc,
				chunk.storeName ? names.indexOf(chunk.original) : -1
			);
		} else {
			mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
		}

		if (chunk.outro.length) { mappings.advance(chunk.outro); }
	});

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
		sourcesContent: options.includeContent ? [this.original] : [null],
		names: names,
		mappings: mappings.raw
	};
};

MagicString.prototype.generateMap = function generateMap (options) {
	return new SourceMap(this.generateDecodedMap(options));
};

MagicString.prototype.getIndentString = function getIndentString () {
	return this.indentStr === null ? '\t' : this.indentStr;
};

MagicString.prototype.indent = function indent (indentStr, options) {
	var pattern = /^[^\r\n]/gm;

	if (isObject(indentStr)) {
		options = indentStr;
		indentStr = undefined;
	}

	indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

	if (indentStr === '') { return this; } // noop

	options = options || {};

	// Process exclusion ranges
	var isExcluded = {};

	if (options.exclude) {
		var exclusions =
			typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
		exclusions.forEach(function (exclusion) {
			for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
				isExcluded[i] = true;
			}
		});
	}

	var shouldIndentNextCharacter = options.indentStart !== false;
	var replacer = function (match) {
		if (shouldIndentNextCharacter) { return ("" + indentStr + match); }
		shouldIndentNextCharacter = true;
		return match;
	};

	this.intro = this.intro.replace(pattern, replacer);

	var charIndex = 0;
	var chunk = this.firstChunk;

	while (chunk) {
		var end = chunk.end;

		if (chunk.edited) {
			if (!isExcluded[charIndex]) {
				chunk.content = chunk.content.replace(pattern, replacer);

				if (chunk.content.length) {
					shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
				}
			}
		} else {
			charIndex = chunk.start;

			while (charIndex < end) {
				if (!isExcluded[charIndex]) {
					var char = this.original[charIndex];

					if (char === '\n') {
						shouldIndentNextCharacter = true;
					} else if (char !== '\r' && shouldIndentNextCharacter) {
						shouldIndentNextCharacter = false;

						if (charIndex === chunk.start) {
							chunk.prependRight(indentStr);
						} else {
							this._splitChunk(chunk, charIndex);
							chunk = chunk.next;
							chunk.prependRight(indentStr);
						}
					}
				}

				charIndex += 1;
			}
		}

		charIndex = chunk.end;
		chunk = chunk.next;
	}

	this.outro = this.outro.replace(pattern, replacer);

	return this;
};

MagicString.prototype.insert = function insert () {
	throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
};

MagicString.prototype.insertLeft = function insertLeft (index, content) {
	if (!warned.insertLeft) {
		console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console
		warned.insertLeft = true;
	}

	return this.appendLeft(index, content);
};

MagicString.prototype.insertRight = function insertRight (index, content) {
	if (!warned.insertRight) {
		console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console
		warned.insertRight = true;
	}

	return this.prependRight(index, content);
};

MagicString.prototype.move = function move (start, end, index) {
	if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }

	this._split(start);
	this._split(end);
	this._split(index);

	var first = this.byStart[start];
	var last = this.byEnd[end];

	var oldLeft = first.previous;
	var oldRight = last.next;

	var newRight = this.byStart[index];
	if (!newRight && last === this.lastChunk) { return this; }
	var newLeft = newRight ? newRight.previous : this.lastChunk;

	if (oldLeft) { oldLeft.next = oldRight; }
	if (oldRight) { oldRight.previous = oldLeft; }

	if (newLeft) { newLeft.next = first; }
	if (newRight) { newRight.previous = last; }

	if (!first.previous) { this.firstChunk = last.next; }
	if (!last.next) {
		this.lastChunk = first.previous;
		this.lastChunk.next = null;
	}

	first.previous = newLeft;
	last.next = newRight || null;

	if (!newLeft) { this.firstChunk = first; }
	if (!newRight) { this.lastChunk = last; }
	return this;
};

MagicString.prototype.overwrite = function overwrite (start, end, content, options) {
	if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (end > this.original.length) { throw new Error('end is out of bounds'); }
	if (start === end)
		{ throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead'); }

	this._split(start);
	this._split(end);

	if (options === true) {
		if (!warned.storeName) {
			console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console
			warned.storeName = true;
		}

		options = { storeName: true };
	}
	var storeName = options !== undefined ? options.storeName : false;
	var contentOnly = options !== undefined ? options.contentOnly : false;

	if (storeName) {
		var original = this.original.slice(start, end);
		this.storedNames[original] = true;
	}

	var first = this.byStart[start];
	var last = this.byEnd[end];

	if (first) {
		if (end > first.end && first.next !== this.byStart[first.end]) {
			throw new Error('Cannot overwrite across a split point');
		}

		first.edit(content, storeName, contentOnly);

		if (first !== last) {
			var chunk = first.next;
			while (chunk !== last) {
				chunk.edit('', false);
				chunk = chunk.next;
			}

			chunk.edit('', false);
		}
	} else {
		// must be inserting at the end
		var newChunk = new Chunk(start, end, '').edit(content, storeName);

		// TODO last chunk in the array may not be the last chunk, if it's moved...
		last.next = newChunk;
		newChunk.previous = last;
	}
	return this;
};

MagicString.prototype.prepend = function prepend (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.intro = content + this.intro;
	return this;
};

MagicString.prototype.prependLeft = function prependLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.prependLeft(content);
	} else {
		this.intro = content + this.intro;
	}
	return this;
};

MagicString.prototype.prependRight = function prependRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.prependRight(content);
	} else {
		this.outro = content + this.outro;
	}
	return this;
};

MagicString.prototype.remove = function remove (start, end) {
	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (start === end) { return this; }

	if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }
	if (start > end) { throw new Error('end must be greater than start'); }

	this._split(start);
	this._split(end);

	var chunk = this.byStart[start];

	while (chunk) {
		chunk.intro = '';
		chunk.outro = '';
		chunk.edit('');

		chunk = end > chunk.end ? this.byStart[chunk.end] : null;
	}
	return this;
};

MagicString.prototype.lastChar = function lastChar () {
	if (this.outro.length)
		{ return this.outro[this.outro.length - 1]; }
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length)
			{ return chunk.outro[chunk.outro.length - 1]; }
		if (chunk.content.length)
			{ return chunk.content[chunk.content.length - 1]; }
		if (chunk.intro.length)
			{ return chunk.intro[chunk.intro.length - 1]; }
	} while (chunk = chunk.previous);
	if (this.intro.length)
		{ return this.intro[this.intro.length - 1]; }
	return '';
};

MagicString.prototype.lastLine = function lastLine () {
	var lineIndex = this.outro.lastIndexOf(n);
	if (lineIndex !== -1)
		{ return this.outro.substr(lineIndex + 1); }
	var lineStr = this.outro;
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length > 0) {
			lineIndex = chunk.outro.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.outro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.outro + lineStr;
		}

		if (chunk.content.length > 0) {
			lineIndex = chunk.content.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.content.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.content + lineStr;
		}

		if (chunk.intro.length > 0) {
			lineIndex = chunk.intro.lastIndexOf(n);
			if (lineIndex !== -1)
				{ return chunk.intro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.intro + lineStr;
		}
	} while (chunk = chunk.previous);
	lineIndex = this.intro.lastIndexOf(n);
	if (lineIndex !== -1)
		{ return this.intro.substr(lineIndex + 1) + lineStr; }
	return this.intro + lineStr;
};

MagicString.prototype.slice = function slice (start, end) {
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	var result = '';

	// find start chunk
	var chunk = this.firstChunk;
	while (chunk && (chunk.start > start || chunk.end <= start)) {
		// found end chunk before start
		if (chunk.start < end && chunk.end >= end) {
			return result;
		}

		chunk = chunk.next;
	}

	if (chunk && chunk.edited && chunk.start !== start)
		{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

	var startChunk = chunk;
	while (chunk) {
		if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
			result += chunk.intro;
		}

		var containsEnd = chunk.start < end && chunk.end >= end;
		if (containsEnd && chunk.edited && chunk.end !== end)
			{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

		var sliceStart = startChunk === chunk ? start - chunk.start : 0;
		var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

		result += chunk.content.slice(sliceStart, sliceEnd);

		if (chunk.outro && (!containsEnd || chunk.end === end)) {
			result += chunk.outro;
		}

		if (containsEnd) {
			break;
		}

		chunk = chunk.next;
	}

	return result;
};

// TODO deprecate this? not really very useful
MagicString.prototype.snip = function snip (start, end) {
	var clone = this.clone();
	clone.remove(0, start);
	clone.remove(end, clone.original.length);

	return clone;
};

MagicString.prototype._split = function _split (index) {
	if (this.byStart[index] || this.byEnd[index]) { return; }

	var chunk = this.lastSearchedChunk;
	var searchForward = index > chunk.end;

	while (chunk) {
		if (chunk.contains(index)) { return this._splitChunk(chunk, index); }

		chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
	}
};

MagicString.prototype._splitChunk = function _splitChunk (chunk, index) {
	if (chunk.edited && chunk.content.length) {
		// zero-length edited chunks are a special case (overlapping replacements)
		var loc = getLocator(this.original)(index);
		throw new Error(
			("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")")
		);
	}

	var newChunk = chunk.split(index);

	this.byEnd[index] = chunk;
	this.byStart[index] = newChunk;
	this.byEnd[newChunk.end] = newChunk;

	if (chunk === this.lastChunk) { this.lastChunk = newChunk; }

	this.lastSearchedChunk = chunk;
	return true;
};

MagicString.prototype.toString = function toString () {
	var str = this.intro;

	var chunk = this.firstChunk;
	while (chunk) {
		str += chunk.toString();
		chunk = chunk.next;
	}

	return str + this.outro;
};

MagicString.prototype.isEmpty = function isEmpty () {
	var chunk = this.firstChunk;
	do {
		if (chunk.intro.length && chunk.intro.trim() ||
				chunk.content.length && chunk.content.trim() ||
				chunk.outro.length && chunk.outro.trim())
			{ return false; }
	} while (chunk = chunk.next);
	return true;
};

MagicString.prototype.length = function length () {
	var chunk = this.firstChunk;
	var length = 0;
	do {
		length += chunk.intro.length + chunk.content.length + chunk.outro.length;
	} while (chunk = chunk.next);
	return length;
};

MagicString.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
};

MagicString.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
};

MagicString.prototype.trimEndAborted = function trimEndAborted (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var chunk = this.lastChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimEnd(rx);

		// if chunk was trimmed, we have a new lastChunk
		if (chunk.end !== end) {
			if (this.lastChunk === chunk) {
				this.lastChunk = chunk.next;
			}

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.previous;
	} while (chunk);

	return false;
};

MagicString.prototype.trimEnd = function trimEnd (charType) {
	this.trimEndAborted(charType);
	return this;
};
MagicString.prototype.trimStartAborted = function trimStartAborted (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');

	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var chunk = this.firstChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimStart(rx);

		if (chunk.end !== end) {
			// special case...
			if (chunk === this.lastChunk) { this.lastChunk = chunk.next; }

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.next;
	} while (chunk);

	return false;
};

MagicString.prototype.trimStart = function trimStart (charType) {
	this.trimStartAborted(charType);
	return this;
};

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __require$1 = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};

// src/constants.ts
var defaultConfigureFiles = [
  "windi.config.ts",
  "windi.config.js",
  "windi.config.mjs",
  "windi.config.cjs",
  "windicss.config.ts",
  "windicss.config.js",
  "windicss.config.mjs",
  "windicss.config.cjs",
  "tailwind.config.ts",
  "tailwind.config.js",
  "tailwind.config.mjs",
  "tailwind.config.cjs"
];
var defaultAlias = {
  "router-link": "a"
};
var preflightTags = ["html", "body", "div"];
var htmlTags = [
  "html",
  "body",
  "div",
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "base",
  "basefont",
  "bdo",
  "blink",
  "blockquote",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "col",
  "colgroup",
  "command",
  "comment",
  "datalist",
  "dd",
  "del",
  "details",
  "dir",
  "dl",
  "dt",
  "embed",
  "fieldset",
  "figure",
  "b",
  "big",
  "i",
  "small",
  "tt",
  "font",
  "footer",
  "form",
  "frame",
  "frameset",
  "head",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "isindex",
  "iframe",
  "ilayer",
  "img",
  "input",
  "ins",
  "keygen",
  "keygen",
  "label",
  "layer",
  "legend",
  "li",
  "link",
  "map",
  "mark",
  "marquee",
  "menu",
  "meta",
  "meter",
  "multicol",
  "nav",
  "nobr",
  "noembed",
  "noframes",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "cite",
  "code",
  "dfn",
  "em",
  "kbd",
  "samp",
  "strong",
  "var",
  "plaintext",
  "pre",
  "progress",
  "q",
  "ruby",
  "script",
  "section",
  "select",
  "spacer",
  "span",
  "s",
  "strike",
  "style",
  "sub",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "u",
  "ul",
  "video",
  "wbr",
  "wbr",
  "xmp"
];
function flattenArray(v) {
  return toArray(v).flat();
}
function mergeArrays(...args) {
  return args.flatMap((i) => flattenArray(i || []));
}
function kebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function include(set, v) {
  for (const i of v)
    set.add(i);
}
function exclude(set, v) {
  for (const i of v)
    set.delete(i);
}
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// src/regexes.ts
var regexHtmlTag = /<(\w[\w-]*)([\S\s]*?)\/?>/mg;
var regexClassSplitter = /[\s'"`{}]/g;
var regexClassGroup = /([!\w+-<@][\w+:_/-]*?\w):\(([!\w\s:/\\,%#\[\].$-]*?)\)/gm;
var regexAttributifyItem = /(?:\s|^)([\w+:_/-]+)=(['"])((?:\\\2|\\\\|\n|\r|.)*?)\2/gm;
var regexClassCheck1 = /^[!a-z\d@<>.+-](?:\([\w,.%#-]*\)|[\w:/\\,%#\[\].$-])*$/;
var regexClassCheck2 = /[a-z].*[\w)\]]$/;
var regexClassChecks = [
  regexClassCheck1,
  regexClassCheck2
];
function validClassName(i) {
  return regexClassChecks.every((r) => i.length > 2 && i.match(r));
}

// src/extractors/default.ts
function DefaultExtractor(code, id) {
  if ((id == null ? void 0 : id.endsWith(".css")) || (id == null ? void 0 : id.endsWith(".postcss"))) {
    return {
      classes: [],
      tags: []
    };
  }
  const tags = Array.from(code.matchAll(regexHtmlTag));
  const tagNames = tags.map((i) => i[1]);
  return {
    tags: tagNames,
    get classes() {
      return code.split(regexClassSplitter).filter(validClassName);
    },
    get attributes() {
      const attrRanges = [];
      const attributes = {
        names: [],
        values: []
      };
      const attributesBlocklist = ["class", "className"];
      const tagsBlocklist = ["meta", "script", "style", "link"];
      tags.filter((i) => !tagsBlocklist.includes(i[1])).forEach((i) => {
        return Array.from(i[2].matchAll(regexAttributifyItem) || []).forEach((match) => {
          let name = match[1];
          const [full, , , value] = match;
          name = name.replace(/^(:|v-bind:)/, "");
          if (attributesBlocklist.includes(name))
            return;
          attributes.names.push(name);
          attributes.values.push(value);
          if (match.index != null)
            attrRanges.push([match.index, match.index + full.length]);
        });
      });
      return attributes;
    }
  };
}

// src/extractors/pug.ts
var regexTemplate = /<template.*?lang=['"]pug['"][^>]*?>\n([\s\S]*?\n)<\/template>/gm;
function PugExtractor(code, id) {
  const Pug = __require$1("pug");
  const compile = (code2) => {
    try {
      return Pug.compile(code2, {filename: id})();
    } catch {
    }
  };
  let compiled;
  if (id && id.match(/\.vue$/)) {
    const matches = Array.from(code.matchAll(regexTemplate));
    let tail = "";
    for (const match of matches) {
      if (match && match[1])
        tail += `

${compile(match[1])}`;
    }
    if (tail)
      compiled = `${code}

${tail}`;
  } else {
    compiled = compile(code);
  }
  return DefaultExtractor(compiled || code);
}

// src/extractors/helper.ts
function getDefaultExtractors() {
  const extractors = [];
  try {
    __require$1("pug");
    extractors.push({
      extractor: PugExtractor,
      extensions: ["vue", "pug"]
    });
  } catch (e) {
  }
  return extractors;
}
async function applyExtractors(code, id, extractors = [], defaultExtract = DefaultExtractor) {
  let ext = id ? require$$0$4.extname(id) : "*";
  if (ext[0] === ".")
    ext = ext.slice(1);
  for (const {extractor, extensions} of extractors) {
    if (extensions.includes(ext))
      return extractor(code, id);
  }
  return defaultExtract(code, id);
}

// src/resolveOptions.ts
var jiti = lib$c(__filename, {requireCache: false, cache: false});
function isResolvedOptions(options) {
  return options.__windi_resolved;
}
function buildGlobs(dirs, fileExtensions) {
  dirs = toArray(dirs);
  const exts = toArray(fileExtensions);
  const globs = exts.length ? dirs.map((i) => require$$0__default$1['default'].posix.join(i, exts.length > 1 ? `**/*.{${exts.join(",")}}` : `**/*.${exts[0]}`)) : [];
  globs.push("index.html");
  return globs;
}
async function resolveOptions(options = {}, utilsOptions = {}, loadConfigFile = false) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (isResolvedOptions(options))
    return options;
  const {
    name = "windicss-plugin-utils"
  } = utilsOptions;
  const debugOptions = _debug2(`${name}:options`);
  let {resolved: config, configFilePath} = loadConfigFile ? await loadConfiguration(__spreadProps$1(__spreadValues$1({}, utilsOptions), {
    root: utilsOptions.root || options.root,
    config: options.config,
    configFiles: options.configFiles
  })) : {resolved: {}, configFilePath: void 0};
  const modifiedConfigs = await ((_a = options.onConfigResolved) == null ? void 0 : _a.call(options, config, configFilePath));
  if (modifiedConfigs != null)
    config = modifiedConfigs;
  const {
    root = utilsOptions.root || process.cwd(),
    scan = true,
    preflight = true,
    transformCSS = true,
    transformGroups: transformGroups2 = true,
    sortUtilities = true
  } = options;
  const preflightOptions = Object.assign({
    includeBase: true,
    includeGlobal: true,
    includePlugin: true,
    enableAll: false,
    includeAll: false,
    safelist: [],
    blocklist: [],
    alias: {}
  }, typeof config.preflight === "boolean" ? {} : config.preflight, typeof preflight === "boolean" ? {} : preflight);
  preflightOptions.includeAll = preflightOptions.includeAll || preflightOptions.enableAll;
  const scanOptions = Object.assign({
    fileExtensions: ["html", "vue", "md", "mdx", "pug", "jsx", "tsx", "svelte", "ts", "js", "css", "postcss", "pcss"],
    dirs: ["src"],
    exclude: [],
    include: [],
    runOnStartup: true,
    transformers: [],
    extractors: [],
    extraTransformTargets: {
      css: [],
      detect: []
    }
  }, typeof scan === "boolean" ? {} : scan);
  function resolveGlob(glob) {
    if (glob.startsWith("!"))
      return `!${slash$1(require$$0__default$1['default'].resolve(root, glob.slice(1)))}`;
    return slash$1(require$$0__default$1['default'].resolve(root, glob));
  }
  scanOptions.exclude = mergeArrays((_b = config.extract) == null ? void 0 : _b.exclude, scanOptions.exclude, ((_c = config.extract) == null ? void 0 : _c.exclude) ? [] : [
    "node_modules",
    ".git",
    "windi.config.{ts,js}",
    "tailwind.config.{ts,js}"
  ]).map(resolveGlob);
  scanOptions.include = mergeArrays((_d = config.extract) == null ? void 0 : _d.include, scanOptions.include, ((_e = config.extract) == null ? void 0 : _e.include) ? [] : buildGlobs(scanOptions.dirs, scanOptions.fileExtensions)).map(resolveGlob);
  scanOptions.extractors = mergeArrays(getDefaultExtractors(), (_f = config.extract) == null ? void 0 : _f.extractors);
  const safelist = new Set(mergeArrays(config.safelist, options.safelist).flatMap((i) => i.split(" ")));
  const blocklist = new Set(mergeArrays(config.blocklist, options.blocklist).flatMap((i) => i.split(" ")));
  const configPreflightOptions = typeof config.preflight === "boolean" ? {} : config.preflight || {};
  preflightOptions.safelist = new Set(mergeArrays(configPreflightOptions == null ? void 0 : configPreflightOptions.safelist, Array.from(preflightOptions.safelist)).flatMap((i) => i.split(" ")).map((i) => {
    var _a2;
    const match = (_a2 = i.match(/^\[(.*?)\]$/)) == null ? void 0 : _a2[1];
    if (match)
      return `div ${match}`;
    return i;
  }));
  preflightOptions.blocklist = new Set(mergeArrays(configPreflightOptions == null ? void 0 : configPreflightOptions.blocklist, Array.from(preflightOptions.blocklist)).flatMap((i) => i.split(" ")));
  preflightOptions.alias = Object.fromEntries(Object.entries(__spreadValues$1(__spreadValues$1(__spreadValues$1({}, defaultAlias), configPreflightOptions.alias), preflightOptions.alias)).filter(([k, v]) => [kebabCase(k), v]));
  let resolvedOptions = __spreadProps$1(__spreadValues$1({}, options), {
    root,
    config,
    configFilePath,
    enableScan: Boolean(scan),
    scanOptions,
    enablePreflight: config.preflight !== false && Boolean(preflight),
    preflightOptions,
    transformCSS,
    transformGroups: transformGroups2,
    sortUtilities,
    safelist,
    blocklist,
    __windi_resolved: true
  });
  const modifiedOptions = await ((_g = resolvedOptions.onOptionsResolved) == null ? void 0 : _g.call(resolvedOptions, resolvedOptions));
  if (modifiedOptions != null && modifiedOptions !== resolvedOptions)
    resolvedOptions = Object.assign(resolvedOptions, modifiedOptions);
  debugOptions(resolvedOptions);
  return resolvedOptions;
}
async function loadConfiguration(options) {
  let resolved = {};
  let configFilePath;
  let error;
  const {
    name = "windicss-plugin-utils",
    config,
    root = process.cwd(),
    configFiles: configureFiles = defaultConfigureFiles,
    onConfigurationError = (e) => console.error(e)
  } = options;
  const debugConfig = _debug2(`${name}:config`);
  if (typeof config === "string" || !config) {
    if (!config) {
      for (const name2 of configureFiles) {
        const tryPath = require$$0__default$1['default'].resolve(root, name2);
        if (fs__default['default'].existsSync(tryPath)) {
          configFilePath = tryPath;
          break;
        }
      }
    } else {
      configFilePath = require$$0__default$1['default'].resolve(root, config);
      if (!fs__default['default'].existsSync(configFilePath)) {
        console.warn(`[${name}] config file "${config}" not found, ignored`);
        configFilePath = void 0;
      }
    }
    if (configFilePath) {
      try {
        debugConfig("loading from ", configFilePath);
        resolved = jiti(configFilePath);
        if (resolved.default)
          resolved = resolved.default;
      } catch (e) {
        error = e;
        configFilePath = void 0;
        resolved = {};
        onConfigurationError == null ? void 0 : onConfigurationError(e);
      }
    }
  } else {
    resolved = config;
  }
  debugConfig(resolved);
  return {
    error,
    resolved,
    configFilePath
  };
}
function transformGroups(code, sourcemap = true) {
  const s = new MagicString(code);
  let hasReplaced = false;
  let match;
  regexClassGroup.lastIndex = 0;
  while (match = regexClassGroup.exec(code)) {
    hasReplaced = true;
    const start = match.index;
    const end = start + match[0].length;
    const a = match[1];
    const b = match[2];
    const replacement = b.split(/\s/g).map((i) => `${a}:${i}`).join(" ");
    s.overwrite(start, end, replacement);
  }
  if (!hasReplaced)
    return null;
  return {
    code: s.toString(),
    map: sourcemap ? s.generateMap({hires: true}) : void 0
  };
}
function buildAliasTransformer(alias) {
  if (!alias || !Object.keys(alias).length)
    return () => null;
  const keys = Object.keys(alias).sort((a, b) => b.length - a.length).map((i) => escapeRegExp(i)).join("|");
  const regexText = `\\*(?:${keys})(?<=[^w-])`;
  const regex = new RegExp(regexText, "g");
  return function transformAlias(code, sourcemap = true) {
    const s = new MagicString(code);
    let hasReplaced = false;
    let match;
    regex.lastIndex = 0;
    while (match = regex.exec(code)) {
      hasReplaced = true;
      const start = match.index;
      const end = start + match[0].length;
      const name = code.slice(start + 1, end);
      const replacement = alias[name];
      s.overwrite(start, end, replacement);
    }
    if (!hasReplaced)
      return null;
    return {
      code: s.toString(),
      map: sourcemap ? s.generateMap({hires: true}) : void 0
    };
  };
}

// src/createUtils.ts
var SupportedLayers = ["base", "utilities", "components"];
function createUtils(userOptions = {}, utilsOptions = {
  name: "windicss-plugin-utils"
}) {
  let options = {};
  const name = utilsOptions.name;
  const debug = {
    config: _debug2(`${name}:config`),
    debug: _debug2(`${name}:debug`),
    compile: _debug2(`${name}:compile`),
    scan: _debug2(`${name}:scan`),
    scanGlob: _debug2(`${name}:scan:glob`),
    scanTransform: _debug2(`${name}:scan:transform`),
    detectClass: _debug2(`${name}:detect:class`),
    detectTag: _debug2(`${name}:detect:tag`),
    detectAttrs: _debug2(`${name}:detect:attrs`),
    compileLayer: _debug2(`${name}:compile:layer`)
  };
  let processor;
  let completions;
  let files = [];
  const classesGenerated = new Set();
  const classesPending = new Set();
  const tagsGenerated = new Set();
  const tagsPending = new Set();
  const attrsGenerated = new Set();
  const tagsAvailable = new Set();
  const attributes = [];
  let _transformAlias = () => null;
  function getCompletions() {
    if (!completions)
      completions = generateCompletions(processor);
    return completions;
  }
  async function getFiles() {
    await ensureInit();
    debug.scanGlob("include", options.scanOptions.include);
    debug.scanGlob("exclude", options.scanOptions.exclude);
    const files2 = await out(options.scanOptions.include, {
      cwd: options.root,
      ignore: options.scanOptions.exclude,
      onlyFiles: true,
      absolute: true
    });
    files2.sort();
    debug.scanGlob("files", files2);
    return files2;
  }
  let scanned = false;
  const scan = createSingletonPromise(async () => {
    await ensureInit();
    debug.scan("started");
    files.push(...await getFiles());
    const contents = await Promise.all(files.filter((id) => isDetectTarget(id)).map(async (id) => [await fs__default['default'].promises.readFile(id, "utf-8"), id]));
    await Promise.all(contents.map(async ([content, id]) => {
      if (isCssTransformTarget(id))
        return transformCSS(content, id);
      else
        return extractFile(content, id, true);
    }));
    scanned = true;
    debug.scan("finished");
  });
  function isExcluded(id) {
    return micromatch_1.contains(slash$1(id), options.scanOptions.exclude, {dot: true});
  }
  function isIncluded(id) {
    return micromatch_1.isMatch(slash$1(id), options.scanOptions.include);
  }
  function isDetectTarget(id) {
    if (options.scanOptions.extraTransformTargets.detect.some((i) => typeof i === "string" ? i === id : i(id)))
      return true;
    if (files.includes(id) || files.includes(id.slice(0, id.indexOf("?"))))
      return true;
    id = slash$1(id);
    return isIncluded(id) && !isExcluded(id);
  }
  function isScanTarget(id) {
    return options.enableScan ? files.some((file) => id.startsWith(file)) : isDetectTarget(id);
  }
  function isCssTransformTarget(id) {
    if (options.scanOptions.extraTransformTargets.css.some((i) => typeof i === "string" ? i === id : i(id)))
      return true;
    if (id.match(/\.(?:postcss|scss|sass|css|stylus|less)(?:$|\?)/i) && !isExcluded(id))
      return true;
    return false;
  }
  function addClasses(classes) {
    let changed = false;
    classes.forEach((i) => {
      if (!i || classesGenerated.has(i) || classesPending.has(i) || options.blocklist.has(i))
        return;
      classesPending.add(i);
      changed = true;
    });
    return changed;
  }
  function addTags(tags) {
    if (options.preflightOptions.includeAll)
      return false;
    let changed = false;
    tags.forEach((tag) => {
      if (!tagsAvailable.has(tag))
        tag = options.preflightOptions.alias[kebabCase(tag)];
      if (options.preflightOptions.blocklist.has(tag))
        return;
      if (tagsAvailable.has(tag) && !tagsPending.has(tag)) {
        tagsPending.add(tag);
        tagsAvailable.delete(tag);
        changed = true;
      }
    });
    return changed;
  }
  async function applyExtractors2(code, id) {
    return await applyExtractors(code, id, options.scanOptions.extractors);
  }
  async function extractFile(code, id, applyTransform = true) {
    var _a, _b, _c, _d;
    if (applyTransform) {
      code = (_b = (_a = _transformAlias(code, false)) == null ? void 0 : _a.code) != null ? _b : code;
      if (options.transformGroups)
        code = (_d = (_c = transformGroups(code, false)) == null ? void 0 : _c.code) != null ? _d : code;
    }
    if (id) {
      debug.scanTransform(id);
      for (const trans of options.scanOptions.transformers) {
        const result = trans(code, id);
        if (result != null)
          code = result;
      }
    }
    const extractResult = await applyExtractors2(code, id);
    let changed = false;
    if (options.enablePreflight || !options.preflightOptions.includeAll) {
      changed = addTags(extractResult.tags || []) || changed;
    }
    if (options.config.attributify) {
      const extractedAttrs = extractResult.attributes;
      if (extractedAttrs == null ? void 0 : extractedAttrs.names.length) {
        extractedAttrs.names.forEach((name2, i) => {
          attributes.push([name2, extractedAttrs.values[i]]);
        });
        changed = true;
      }
      changed = addClasses((extractedAttrs == null ? void 0 : extractedAttrs.classes) || extractResult.classes || []) || changed;
    } else {
      changed = addClasses(extractResult.classes || []) || changed;
    }
    if (changed) {
      debug.detectClass(classesPending);
      debug.detectTag(tagsPending);
      debug.detectAttrs(attributes);
    }
    return changed;
  }
  function transformCSS(css, id, transformOptions) {
    var _a;
    if (!options.transformCSS)
      return css;
    const style = new CSSParser(css, processor).parse();
    if (transformOptions == null ? void 0 : transformOptions.globaliseKeyframes) {
      const [nonKeyframeBlocks, keyframeBlocks] = partition(style.children, (i) => !i.atRules || !i.atRules[0].match(/keyframes (pulse|spin|ping|bounce)/));
      updateLayers(keyframeBlocks, "__classes", false);
      style.children = nonKeyframeBlocks;
    }
    const [layerBlocks, blocks] = partition(style.children, (i) => i.meta.group === "layer-block" && SupportedLayers.includes(i.meta.type));
    if (layerBlocks.length) {
      updateLayers(layerBlocks, id);
      style.children = blocks;
    }
    const transformed = style.build();
    if (layerBlocks.length)
      (_a = transformOptions == null ? void 0 : transformOptions.onLayerUpdated) == null ? void 0 : _a.call(transformOptions);
    return transformed;
  }
  const layers = {
    base: {},
    utilities: {},
    components: {}
  };
  const layerStylesMap = new Map();
  function updateLayers(styles, filepath, replace = true) {
    var _a;
    const timestamp = +Date.now();
    debug.compileLayer("update", filepath);
    const changedLayers = new Set();
    styles.forEach((i) => changedLayers.add(i.meta.type));
    if (replace) {
      (_a = layerStylesMap.get(filepath)) == null ? void 0 : _a.forEach((i) => changedLayers.add(i.meta.type));
      layerStylesMap.set(filepath, styles);
    } else {
      const prevStyles = layerStylesMap.get(filepath) || [];
      layerStylesMap.set(filepath, prevStyles.concat(styles));
    }
    for (const name2 of changedLayers) {
      const layer = layers[name2];
      if (layer) {
        layer.timestamp = timestamp;
        layer.cssCache = void 0;
      }
    }
  }
  function buildLayerCss(name2) {
    var _a;
    const layer = layers[name2];
    if (layer.cssCache == null) {
      const style = new StyleSheet$1(Array.from(layerStylesMap.values()).flatMap((i) => i).filter((i) => i.meta.type === name2));
      style.prefixer = (_a = options.config.prefixer) != null ? _a : true;
      debug.compileLayer(name2, style.children.length);
      if (options.sortUtilities)
        style.sort();
      layer.cssCache = `/* windicss layer ${name2} */
${style.build()}`;
    }
    return layer.cssCache;
  }
  function buildPendingStyles() {
    var _a, _b;
    (_a = options.onBeforeGenerate) == null ? void 0 : _a.call(options, {
      classesPending,
      tagsPending
    });
    if (classesPending.size) {
      const result = processor.interpret(Array.from(classesPending).join(" "));
      if (result.success.length) {
        debug.compile(`compiled ${result.success.length} classes out of ${classesPending.size}`);
        debug.compile(result.success);
        updateLayers(result.styleSheet.children, "__classes", false);
        include(classesGenerated, result.success);
        classesPending.clear();
      }
    }
    if (options.enablePreflight) {
      if (options.preflightOptions.includeAll) {
        if (!layerStylesMap.has("__preflights")) {
          const preflightStyle = processor.preflight(void 0, options.preflightOptions.includeBase, options.preflightOptions.includeGlobal, options.preflightOptions.includePlugin);
          updateLayers(preflightStyle.children, "__preflights", true);
        }
      } else if (tagsPending.size) {
        const preflightStyle = processor.preflight(Array.from(tagsPending).map((i) => `<${i}/>`).join(" "), options.preflightOptions.includeBase, options.preflightOptions.includeGlobal, options.preflightOptions.includePlugin);
        updateLayers(preflightStyle.children, "__preflights", false);
        include(tagsGenerated, tagsPending);
        tagsPending.clear();
      }
    }
    if (options.config.attributify) {
      if (attributes.length) {
        const attributesObject = {};
        attributes.forEach(([name2, value]) => {
          if (!attributesObject[name2])
            attributesObject[name2] = [];
          attributesObject[name2].push(...value.split(regexClassSplitter).filter(Boolean));
        });
        const attributifyStyle = processor.attributify(attributesObject);
        updateLayers(attributifyStyle.styleSheet.children, "__attributify", false);
        attributes.length = 0;
      }
    }
    (_b = options.onGenerated) == null ? void 0 : _b.call(options, {
      classes: classesGenerated,
      tags: tagsGenerated
    });
  }
  async function generateCSS(layer) {
    await ensureInit();
    if (options.enableScan && options.scanOptions.runOnStartup)
      await scan();
    buildPendingStyles();
    return layer ? buildLayerCss(layer) : [
      buildLayerCss("base"),
      buildLayerCss("components"),
      buildLayerCss("utilities")
    ].join("\n").trim();
  }
  function clearCache(clearAll = false) {
    layers.base = {};
    layers.utilities = {};
    layers.components = {};
    completions = void 0;
    if (clearAll) {
      classesPending.clear();
      tagsPending.clear();
      tagsAvailable.clear();
    } else {
      include(classesPending, classesGenerated);
      include(tagsPending, tagsGenerated);
      include(tagsPending, preflightTags);
      include(tagsAvailable, htmlTags);
    }
    include(classesPending, options.safelist);
    include(tagsPending, options.preflightOptions.safelist);
    exclude(tagsAvailable, preflightTags);
    exclude(tagsAvailable, options.preflightOptions.safelist);
    classesGenerated.clear();
    tagsGenerated.clear();
    attrsGenerated.clear();
  }
  const utils = {
    init,
    ensureInit,
    extractFile,
    applyExtractors: applyExtractors2,
    generateCSS,
    getFiles,
    clearCache,
    transformCSS,
    transformGroups,
    get transformAlias() {
      return _transformAlias;
    },
    buildPendingStyles,
    isDetectTarget,
    isScanTarget,
    isCssTransformTarget,
    isExcluded,
    scan,
    classesGenerated,
    classesPending,
    tagsGenerated,
    tagsPending,
    tagsAvailable,
    layersMeta: layers,
    addClasses,
    addTags,
    getCompletions,
    get initialized() {
      return !!processor;
    },
    get options() {
      return options;
    },
    get files() {
      return files;
    },
    get globs() {
      return options.scanOptions.include;
    },
    get processor() {
      return processor;
    },
    get scanned() {
      return scanned;
    },
    get configFilePath() {
      return options.configFilePath;
    },
    get hasPending() {
      return Boolean(tagsPending.size || classesPending.size);
    }
  };
  async function _init() {
    var _a;
    options = await resolveOptions(userOptions, utilsOptions, true);
    files = [];
    processor = new Processor(options.config);
    clearCache(false);
    (_a = options.onInitialized) == null ? void 0 : _a.call(options, utils);
    _transformAlias = buildAliasTransformer(options.config.alias);
    return processor;
  }
  let _promise_init;
  async function init() {
    _promise_init = _init();
    return _promise_init;
  }
  async function ensureInit() {
    if (processor)
      return processor;
    if (!_promise_init)
      _promise_init = _init();
    return _promise_init;
  }
  return utils;
}

var src$1 = {exports: {}};

var browser$1 = {exports: {}};

var debug$2 = {exports: {}};

/**
 * Helpers.
 */

var s$1 = 1000;
var m$1 = s$1 * 60;
var h$1 = m$1 * 60;
var d$1 = h$1 * 24;
var y$1 = d$1 * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms$1 = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$2(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong$1(val) : fmtShort$1(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$2(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y$1;
    case 'days':
    case 'day':
    case 'd':
      return n * d$1;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h$1;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m$1;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$1;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort$1(ms) {
  if (ms >= d$1) {
    return Math.round(ms / d$1) + 'd';
  }
  if (ms >= h$1) {
    return Math.round(ms / h$1) + 'h';
  }
  if (ms >= m$1) {
    return Math.round(ms / m$1) + 'm';
  }
  if (ms >= s$1) {
    return Math.round(ms / s$1) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong$1(ms) {
  return plural$1(ms, d$1, 'day') ||
    plural$1(ms, h$1, 'hour') ||
    plural$1(ms, m$1, 'minute') ||
    plural$1(ms, s$1, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural$1(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms$1;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
}(debug$2, debug$2.exports));

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

(function (module, exports) {
exports = module.exports = debug$2.exports;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
}(browser$1, browser$1.exports));

var node$1 = {exports: {}};

/**
 * Module dependencies.
 */

(function (module, exports) {
var tty = require$$0__default$3['default'];
var util = require$$1__default['default'];

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$2.exports;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = fs__default['default'];
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$4__default['default'];
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
}(node$1, node$1.exports));

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  src$1.exports = browser$1.exports;
} else {
  src$1.exports = node$1.exports;
}

var src = {exports: {}};

var browser = {exports: {}};

var debug$1 = {exports: {}};

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$1(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$1(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
}(debug$1, debug$1.exports));

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

(function (module, exports) {
exports = module.exports = debug$1.exports;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
}(browser, browser.exports));

var node = {exports: {}};

/**
 * Module dependencies.
 */

(function (module, exports) {
var tty = require$$0__default$3['default'];
var util = require$$1__default['default'];

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$1.exports;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = fs__default['default'];
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$4__default['default'];
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
}(node, node.exports));

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  src.exports = browser.exports;
} else {
  src.exports = node.exports;
}

var onFinished$2 = {exports: {}};

/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var eeFirst = first$1;

/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */

function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError('arg must be an array of [ee, events...] arrays')

  var cleanups = [];

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];

    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError('each array member must be [ee, events...]')

    var ee = arr[0];

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);

      // listen to the event
      ee.on(event, fn);
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn,
      });
    }
  }

  function callback() {
    cleanup();
    done.apply(null, arguments);
  }

  function cleanup() {
    var x;
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i];
      x.ee.removeListener(x.event, x.fn);
    }
  }

  function thunk(fn) {
    done = fn;
  }

  thunk.cancel = cleanup;

  return thunk
}

/**
 * Create the event listener.
 * @private
 */

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err = event === 'error'
      ? arg1
      : null;

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    done(err, ee, event, args);
  }
}

/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

onFinished$2.exports = onFinished$1;
onFinished$2.exports.isFinished = isFinished;

/**
 * Module dependencies.
 * @private
 */

var first = eeFirst;

/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)); };

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */

function onFinished$1(msg, listener) {
  if (isFinished(msg) !== false) {
    defer(listener, null, msg);
    return msg
  }

  // attach the listener to the message
  attachListener(msg, listener);

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */

function isFinished(msg) {
  var socket = msg.socket;

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;

  function onFinish(error) {
    eeMsg.cancel();
    eeSocket.cancel();

    finished = true;
    callback(error);
  }

  // finished on first message event
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);

  function onSocket(socket) {
    // remove listener
    msg.removeListener('socket', onSocket);

    if (finished) return
    if (eeMsg !== eeSocket) return

    // finished on first socket event
    eeSocket = first([[socket, 'error', 'close']], onFinish);
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket);
    return
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket);

  if (msg.socket === undefined) {
    // node.js 0.8 patch
    patchAssignSocket(msg, onSocket);
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function attachListener(msg, listener) {
  var attached = msg.__onFinished;

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }

  attached.queue.push(listener);
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function createListener(msg) {
  function listener(err) {
    if (msg.__onFinished === listener) msg.__onFinished = null;
    if (!listener.queue) return

    var queue = listener.queue;
    listener.queue = null;

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg);
    }
  }

  listener.queue = [];

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket;

  if (typeof assignSocket !== 'function') return

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}

var parseurl$1 = {exports: {}};

/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var url = require$$7__default['default'];
var parse = url.parse;
var Url = url.Url;

/**
 * Module exports.
 * @public
 */

parseurl$1.exports = parseurl;
parseurl$1.exports.original = originalurl;

/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function parseurl (req) {
  var url = req.url;

  if (url === undefined) {
    // URL is undefined
    return undefined
  }

  var parsed = req._parsedUrl;

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url);
  parsed._raw = url;

  return (req._parsedUrl = parsed)
}
/**
 * Parse the `req` original url with fallback and memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function originalurl (req) {
  var url = req.originalUrl;

  if (typeof url !== 'string') {
    // Fallback
    return parseurl(req)
  }

  var parsed = req._parsedOriginalUrl;

  if (fresh(url, parsed)) {
    // Return cached URL parse
    return parsed
  }

  // Parse the URL
  parsed = fastparse(url);
  parsed._raw = url;

  return (req._parsedOriginalUrl = parsed)
}
/**
 * Parse the `str` url with fast-path short-cut.
 *
 * @param {string} str
 * @return {Object}
 * @private
 */

function fastparse (str) {
  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
    return parse(str)
  }

  var pathname = str;
  var query = null;
  var search = null;

  // This takes the regexp from https://github.com/joyent/node/pull/7878
  // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
  // And unrolls it into a for loop
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 0x3f: /* ?  */
        if (search === null) {
          pathname = str.substring(0, i);
          query = str.substring(i + 1);
          search = str.substring(i);
        }
        break
      case 0x09: /* \t */
      case 0x0a: /* \n */
      case 0x0c: /* \f */
      case 0x0d: /* \r */
      case 0x20: /*    */
      case 0x23: /* #  */
      case 0xa0:
      case 0xfeff:
        return parse(str)
    }
  }

  var url = Url !== undefined
    ? new Url()
    : {};

  url.path = str;
  url.href = str;
  url.pathname = pathname;

  if (search !== null) {
    url.query = query;
    url.search = search;
  }

  return url
}

/**
 * Determine if parsed is still fresh for url.
 *
 * @param {string} url
 * @param {object} parsedUrl
 * @return {boolean}
 * @private
 */

function fresh (url, parsedUrl) {
  return typeof parsedUrl === 'object' &&
    parsedUrl !== null &&
    (Url === undefined || parsedUrl instanceof Url) &&
    parsedUrl._raw === url
}

var require$$0 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"306": "(Unused)",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Unordered Collection",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var codes = require$$0;

// status code to message map
status.STATUS_CODES = codes;

// array of status codes
status.codes = populateStatusesMap(status, codes);

// status codes for redirects
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};

// status codes for empty bodies
status.empty = {
  204: true,
  205: true,
  304: true
};

// status codes for when you should retry the request
status.retry = {
  502: true,
  503: true,
  504: true
};

/**
 * Populate the statuses map for given codes.
 * @private
 */

function populateStatusesMap (statuses, codes) {
  var arr = [];

  Object.keys(codes).forEach(function forEachCode (code) {
    var message = codes[code];
    var status = Number(code);

    // Populate properties
    statuses[status] = message;
    statuses[message] = status;
    statuses[message.toLowerCase()] = status;

    // Add to array
    arr.push(status);
  });

  return arr
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status (code) {
  if (typeof code === 'number') {
    if (!status[code]) throw new Error('invalid status code: ' + code)
    return code
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string')
  }

  // '403'
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    if (!status[n]) throw new Error('invalid status code: ' + n)
    return n
  }

  n = status[code.toLowerCase()];
  if (!n) throw new Error('invalid status message: "' + code + '"')
  return n
}

/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

src.exports('finalhandler');
var onFinished = onFinished$2.exports;

/* istanbul ignore next */
typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)); };
onFinished.isFinished;

var utilsMerge = {exports: {}};

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

(function (module, exports) {
module.exports = function(a, b){
  if (a && b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
};
}(utilsMerge));

/*!
 * connect
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

src$1.exports('connect:dispatcher');
require$$0__default$5['default'].EventEmitter;

/**
 * Module variables.
 * @private
 */

process.env.NODE_ENV || 'development';

/* istanbul ignore next */
typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)); };

/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */
function Mime$1() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */
Mime$1.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];

      // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.
      if (ext[0] === '*') {
        continue;
      }

      if (!force && (ext in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + ext +
          '" extension from "' + this._types[ext] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + ext +
          '" from the list of extensions for "' + type + '".'
        );
      }

      this._types[ext] = type;
    }

    // Use first extension as default
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
    }
  }
};

/**
 * Lookup a mime type based on extension
 */
Mime$1.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let ext = last.replace(/^.*\./, '').toLowerCase();

  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[ext] || null;
};

/**
 * Return file extension associated with a mime type
 */
Mime$1.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

var Mime_1 = Mime$1;

var standard = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["ecma","es"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/mrb-consumer+xml":["*xdf"],"application/mrb-publish+xml":["*xdf"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["*xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-error+xml":["xer"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};

let Mime = Mime_1;
new Mime(standard);

var fs$i = {};

var universalify$1 = {};

universalify$1.fromCallback = function (fn) {
  return Object.defineProperty(function (...args) {
    if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
    else {
      return new Promise((resolve, reject) => {
        fn.call(
          this,
          ...args,
          (err, res) => (err != null) ? reject(err) : resolve(res)
        );
      })
    }
  }, 'name', { value: fn.name })
};

universalify$1.fromPromise = function (fn) {
  return Object.defineProperty(function (...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== 'function') return fn.apply(this, args)
    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb);
  }, 'name', { value: fn.name })
};

var constants = require$$0__default$6['default'];

var origCwd = process.cwd;
var cwd = null;

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd
};
try {
  process.cwd();
} catch (er) {}

// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
  var chdir = process.chdir;
  process.chdir = function (d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}

var polyfills$1 = patch$1;

function patch$1 (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs);
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs);
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown);
  fs.fchown = chownFix(fs.fchown);
  fs.lchown = chownFix(fs.lchown);

  fs.chmod = chmodFix(fs.chmod);
  fs.fchmod = chmodFix(fs.fchmod);
  fs.lchmod = chmodFix(fs.lchmod);

  fs.chownSync = chownFixSync(fs.chownSync);
  fs.fchownSync = chownFixSync(fs.fchownSync);
  fs.lchownSync = chownFixSync(fs.lchownSync);

  fs.chmodSync = chmodFixSync(fs.chmodSync);
  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
  fs.lchmodSync = chmodFixSync(fs.lchmodSync);

  fs.stat = statFix(fs.stat);
  fs.fstat = statFix(fs.fstat);
  fs.lstat = statFix(fs.lstat);

  fs.statSync = statFixSync(fs.statSync);
  fs.fstatSync = statFixSync(fs.fstatSync);
  fs.lstatSync = statFixSync(fs.lstatSync);

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchmodSync = function () {};
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchownSync = function () {};
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now();
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er);
            });
          }, backoff);
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er);
      });
    }})(fs.rename);
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0;
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++;
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
    return read
  })(fs.read);

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0;
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++;
          continue
        }
        throw er
      }
    }
  }})(fs.readSync);

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err);
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2);
          });
        });
      });
    };

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true;
      var ret;
      try {
        ret = fs.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd);
          } catch (er) {}
        } else {
          fs.closeSync(fd);
        }
      }
      return ret
    };
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er);
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2);
            });
          });
        });
      };

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd);
            } catch (er) {}
          } else {
            fs.closeSync(fd);
          }
        }
        return ret
      };

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb); };
      fs.lutimesSync = function () {};
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = null;
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000;
          if (stats.gid < 0) stats.gid += 0x100000000;
        }
        if (cb) cb.apply(this, arguments);
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target);
      if (stats.uid < 0) stats.uid += 0x100000000;
      if (stats.gid < 0) stats.gid += 0x100000000;
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}

var Stream = require$$0__default$4['default'].Stream;

var legacyStreams = legacy$1;

function legacy$1 (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    });
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

var clone_1 = clone$1;

var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__
};

function clone$1 (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) };
  else
    var copy = Object.create(null);

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });

  return copy
}

var fs$h = fs__default['default'];
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;

var util$1 = require$$1__default['default'];

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue;
var previousSymbol;

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue');
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous');
} else {
  gracefulQueue = '___graceful-fs.queue';
  previousSymbol = '___graceful-fs.previous';
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  });
}

var debug = noop;
if (util$1.debuglog)
  debug = util$1.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util$1.format.apply(util$1, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
  };

// Once time initialization
if (!fs$h[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$h, queue);

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs$h.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs$h, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          retry();
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments);
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close
  })(fs$h.close);

  fs$h.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs$h, arguments);
      retry();
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync
  })(fs$h.closeSync);

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs$h[gracefulQueue]);
      require$$0__default$2['default'].equal(fs$h[gracefulQueue].length, 0);
    });
  }
}

if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$h[gracefulQueue]);
}

var gracefulFs = patch(clone(fs$h));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$h.__patched) {
    gracefulFs = patch(fs$h);
    fs$h.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs);
  fs.gracefulify = patch;

  fs.createReadStream = createReadStream;
  fs.createWriteStream = createWriteStream;
  var fs$readFile = fs.readFile;
  fs.readFile = readFile;
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile;
  fs.writeFile = writeFile;
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile;
  if (fs$appendFile)
    fs.appendFile = appendFile;
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$copyFile = fs.copyFile;
  if (fs$copyFile)
    fs.copyFile = copyFile;
  function copyFile (src, dest, flags, cb) {
    if (typeof flags === 'function') {
      cb = flags;
      flags = 0;
    }
    return fs$copyFile(src, dest, flags, function (err) {
      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([fs$copyFile, [src, dest, flags, cb]]);
      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments);
        retry();
      }
    })
  }

  var fs$readdir = fs.readdir;
  fs.readdir = readdir;
  function readdir (path, options, cb) {
    var args = [path];
    if (typeof options !== 'function') {
      args.push(options);
    } else {
      cb = options;
    }
    args.push(go$readdir$cb);

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files && files.sort)
        files.sort();

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([go$readdir, [args]]);

      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments);
        retry();
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs, args)
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }

  var fs$ReadStream = fs.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }

  var fs$WriteStream = fs.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });

  // legacy names
  var FileReadStream = ReadStream;
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open;
  fs.open = open;
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null;

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1]);
  fs$h[gracefulQueue].push(elem);
}

function retry () {
  var elem = fs$h[gracefulQueue].shift();
  if (elem) {
    debug('RETRY', elem[0].name, elem[1]);
    elem[0].apply(null, elem[1]);
  }
}

(function (exports) {
// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = universalify$1.fromCallback;
const fs = gracefulFs;

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchmod',
  'lchown',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'opendir',
  'readdir',
  'readFile',
  'readlink',
  'realpath',
  'rename',
  'rm',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.opendir was added in Node.js v12.12.0
  // fs.rm was added in Node.js v14.14.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
});

// Export cloned fs:
Object.assign(exports, fs);

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method]);
});
exports.realpath.native = u(fs.realpath.native);

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve)
  })
};

// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer });
    });
  })
};

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer });
    });
  })
};

// fs.writev only available in Node v12.9.0+
if (typeof fs.writev === 'function') {
  // Function signature is
  // s.writev(fd, buffers[, position], callback)
  // We need to handle the optional arg, so we use ...args
  exports.writev = function (fd, buffers, ...args) {
    if (typeof args[args.length - 1] === 'function') {
      return fs.writev(fd, buffers, ...args)
    }

    return new Promise((resolve, reject) => {
      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
        if (err) return reject(err)
        resolve({ bytesWritten, buffers });
      });
    })
  };
}
}(fs$i));

var makeDir$1 = {};

var utils$1 = {};

const path$c = require$$0__default$1['default'];

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
utils$1.checkPath = function checkPath (pth) {
  if (process.platform === 'win32') {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$c.parse(pth).root, ''));

    if (pathHasInvalidWinCharacters) {
      const error = new Error(`Path contains invalid characters: ${pth}`);
      error.code = 'EINVAL';
      throw error
    }
  }
};

const fs$g = fs$i;
const { checkPath } = utils$1;

const getMode = options => {
  const defaults = { mode: 0o777 };
  if (typeof options === 'number') return options
  return ({ ...defaults, ...options }).mode
};

makeDir$1.makeDir = async (dir, options) => {
  checkPath(dir);

  return fs$g.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  })
};

makeDir$1.makeDirSync = (dir, options) => {
  checkPath(dir);

  return fs$g.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  })
};

const u$a = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$a(_makeDir);

var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};

const fs$f = gracefulFs;

function utimesMillis$1 (path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs$f.open(path, 'r+', (err, fd) => {
    if (err) return callback(err)
    fs$f.futimes(fd, atime, mtime, futimesErr => {
      fs$f.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr);
      });
    });
  });
}

function utimesMillisSync$1 (path, atime, mtime) {
  const fd = fs$f.openSync(path, 'r+');
  fs$f.futimesSync(fd, atime, mtime);
  return fs$f.closeSync(fd)
}

var utimes = {
  utimesMillis: utimesMillis$1,
  utimesMillisSync: utimesMillisSync$1
};

const fs$e = fs$i;
const path$b = require$$0__default$1['default'];
const util = require$$1__default['default'];

function getStats$2 (src, dest, opts) {
  const statFunc = opts.dereference
    ? (file) => fs$e.stat(file, { bigint: true })
    : (file) => fs$e.lstat(file, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch(err => {
      if (err.code === 'ENOENT') return null
      throw err
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))
}

function getStatsSync (src, dest, opts) {
  let destStat;
  const statFunc = opts.dereference
    ? (file) => fs$e.statSync(file, { bigint: true })
    : (file) => fs$e.lstatSync(file, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null }
    throw err
  }
  return { srcStat, destStat }
}

function checkPaths (src, dest, funcName, opts, cb) {
  util.callbackify(getStats$2)(src, dest, opts, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats;

    if (destStat) {
      if (areIdentical$2(srcStat, destStat)) {
        const srcBaseName = path$b.basename(src);
        const destBaseName = path$b.basename(dest);
        if (funcName === 'move' &&
          srcBaseName !== destBaseName &&
          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true })
        }
        return cb(new Error('Source and destination must not be the same.'))
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))
      }
    }

    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return cb(null, { srcStat, destStat })
  });
}

function checkPathsSync (src, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts);

  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$b.basename(src);
      const destBaseName = path$b.basename(dest);
      if (funcName === 'move' &&
        srcBaseName !== destBaseName &&
        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true }
      }
      throw new Error('Source and destination must not be the same.')
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return { srcStat, destStat }
}

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
function checkParentPaths (src, srcStat, dest, funcName, cb) {
  const srcParent = path$b.resolve(path$b.dirname(src));
  const destParent = path$b.resolve(path$b.dirname(dest));
  if (destParent === srcParent || destParent === path$b.parse(destParent).root) return cb()
  fs$e.stat(destParent, { bigint: true }, (err, destStat) => {
    if (err) {
      if (err.code === 'ENOENT') return cb()
      return cb(err)
    }
    if (areIdentical$2(srcStat, destStat)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return checkParentPaths(src, srcStat, destParent, funcName, cb)
  });
}

function checkParentPathsSync (src, srcStat, dest, funcName) {
  const srcParent = path$b.resolve(path$b.dirname(src));
  const destParent = path$b.resolve(path$b.dirname(dest));
  if (destParent === srcParent || destParent === path$b.parse(destParent).root) return
  let destStat;
  try {
    destStat = fs$e.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName)
}

function areIdentical$2 (srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev
}

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = path$b.resolve(src).split(path$b.sep).filter(i => i);
  const destArr = path$b.resolve(dest).split(path$b.sep).filter(i => i);
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
}

function errMsg (src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
}

var stat$4 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical: areIdentical$2
};

const fs$d = gracefulFs;
const path$a = require$$0__default$1['default'];
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$3 = stat$4;

function copySync$2 (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  opts = opts || {};
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  const { srcStat, destStat } = stat$3.checkPathsSync(src, dest, 'copy', opts);
  stat$3.checkParentPathsSync(src, srcStat, dest, 'copy');
  return handleFilterAndCopy(destStat, src, dest, opts)
}

function handleFilterAndCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  const destParent = path$a.dirname(dest);
  if (!fs$d.existsSync(destParent)) mkdirsSync$1(destParent);
  return getStats$1(destStat, src, dest, opts)
}

function startCopy$1 (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats$1(destStat, src, dest, opts)
}

function getStats$1 (destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs$d.statSync : fs$d.lstatSync;
  const srcStat = statSync(src);

  if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink$1(destStat, src, dest, opts)
  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)
  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)
  throw new Error(`Unknown file: ${src}`)
}

function onFile$1 (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile$1(srcStat, src, dest, opts)
  return mayCopyFile$1(srcStat, src, dest, opts)
}

function mayCopyFile$1 (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs$d.unlinkSync(dest);
    return copyFile$1(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile$1 (srcStat, src, dest, opts) {
  fs$d.copyFileSync(src, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
  return setDestMode$1(dest, srcStat.mode)
}

function handleTimestamps (srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable$1(srcMode)) makeFileWritable$1(dest, srcMode);
  return setDestTimestamps$1(src, dest)
}

function fileIsNotWritable$1 (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable$1 (dest, srcMode) {
  return setDestMode$1(dest, srcMode | 0o200)
}

function setDestMode$1 (dest, srcMode) {
  return fs$d.chmodSync(dest, srcMode)
}

function setDestTimestamps$1 (src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = fs$d.statSync(src);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
}

function onDir$1 (srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy$1(srcStat.mode, src, dest, opts)
  return copyDir$1(src, dest, opts)
}

function mkDirAndCopy$1 (srcMode, src, dest, opts) {
  fs$d.mkdirSync(dest);
  copyDir$1(src, dest, opts);
  return setDestMode$1(dest, srcMode)
}

function copyDir$1 (src, dest, opts) {
  fs$d.readdirSync(src).forEach(item => copyDirItem$1(item, src, dest, opts));
}

function copyDirItem$1 (item, src, dest, opts) {
  const srcItem = path$a.join(src, item);
  const destItem = path$a.join(dest, item);
  const { destStat } = stat$3.checkPathsSync(srcItem, destItem, 'copy', opts);
  return startCopy$1(destStat, srcItem, destItem, opts)
}

function onLink$1 (destStat, src, dest, opts) {
  let resolvedSrc = fs$d.readlinkSync(src);
  if (opts.dereference) {
    resolvedSrc = path$a.resolve(process.cwd(), resolvedSrc);
  }

  if (!destStat) {
    return fs$d.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$d.readlinkSync(dest);
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs$d.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path$a.resolve(process.cwd(), resolvedDest);
    }
    if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs$d.statSync(dest).isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink$1(resolvedSrc, dest)
  }
}

function copyLink$1 (resolvedSrc, dest) {
  fs$d.unlinkSync(dest);
  return fs$d.symlinkSync(resolvedSrc, dest)
}

var copySync_1 = copySync$2;

var copySync$1 = {
  copySync: copySync_1
};

const u$9 = universalify$1.fromPromise;
const fs$c = fs$i;

function pathExists$6 (path) {
  return fs$c.access(path).then(() => true).catch(() => false)
}

var pathExists_1 = {
  pathExists: u$9(pathExists$6),
  pathExistsSync: fs$c.existsSync
};

const fs$b = gracefulFs;
const path$9 = require$$0__default$1['default'];
const mkdirs$1 = mkdirs$2.mkdirs;
const pathExists$5 = pathExists_1.pathExists;
const utimesMillis = utimes.utimesMillis;
const stat$2 = stat$4;

function copy$2 (src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  cb = cb || function () {};
  opts = opts || {};

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  stat$2.checkPaths(src, dest, 'copy', opts, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats;
    stat$2.checkParentPaths(src, srcStat, dest, 'copy', err => {
      if (err) return cb(err)
      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
      return checkParentDir(destStat, src, dest, opts, cb)
    });
  });
}

function checkParentDir (destStat, src, dest, opts, cb) {
  const destParent = path$9.dirname(dest);
  pathExists$5(destParent, (err, dirExists) => {
    if (err) return cb(err)
    if (dirExists) return getStats(destStat, src, dest, opts, cb)
    mkdirs$1(destParent, err => {
      if (err) return cb(err)
      return getStats(destStat, src, dest, opts, cb)
    });
  });
}

function handleFilter (onInclude, destStat, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) return onInclude(destStat, src, dest, opts, cb)
    return cb()
  }, error => cb(error));
}

function startCopy (destStat, src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
  return getStats(destStat, src, dest, opts, cb)
}

function getStats (destStat, src, dest, opts, cb) {
  const stat = opts.dereference ? fs$b.stat : fs$b.lstat;
  stat(src, (err, srcStat) => {
    if (err) return cb(err)

    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isFile() ||
             srcStat.isCharacterDevice() ||
             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
    else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src}`))
    else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src}`))
    return cb(new Error(`Unknown file: ${src}`))
  });
}

function onFile (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
  return mayCopyFile(srcStat, src, dest, opts, cb)
}

function mayCopyFile (srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs$b.unlink(dest, err => {
      if (err) return cb(err)
      return copyFile(srcStat, src, dest, opts, cb)
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`))
  } else return cb()
}

function copyFile (srcStat, src, dest, opts, cb) {
  fs$b.copyFile(src, dest, err => {
    if (err) return cb(err)
    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)
    return setDestMode(dest, srcStat.mode, cb)
  });
}

function handleTimestampsAndMode (srcMode, src, dest, cb) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) {
    return makeFileWritable(dest, srcMode, err => {
      if (err) return cb(err)
      return setDestTimestampsAndMode(srcMode, src, dest, cb)
    })
  }
  return setDestTimestampsAndMode(srcMode, src, dest, cb)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode, cb) {
  return setDestMode(dest, srcMode | 0o200, cb)
}

function setDestTimestampsAndMode (srcMode, src, dest, cb) {
  setDestTimestamps(src, dest, err => {
    if (err) return cb(err)
    return setDestMode(dest, srcMode, cb)
  });
}

function setDestMode (dest, srcMode, cb) {
  return fs$b.chmod(dest, srcMode, cb)
}

function setDestTimestamps (src, dest, cb) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  fs$b.stat(src, (err, updatedSrcStat) => {
    if (err) return cb(err)
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)
  });
}

function onDir (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)
  return copyDir(src, dest, opts, cb)
}

function mkDirAndCopy (srcMode, src, dest, opts, cb) {
  fs$b.mkdir(dest, err => {
    if (err) return cb(err)
    copyDir(src, dest, opts, err => {
      if (err) return cb(err)
      return setDestMode(dest, srcMode, cb)
    });
  });
}

function copyDir (src, dest, opts, cb) {
  fs$b.readdir(src, (err, items) => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  });
}

function copyDirItems (items, src, dest, opts, cb) {
  const item = items.pop();
  if (!item) return cb()
  return copyDirItem(items, item, src, dest, opts, cb)
}

function copyDirItem (items, item, src, dest, opts, cb) {
  const srcItem = path$9.join(src, item);
  const destItem = path$9.join(dest, item);
  stat$2.checkPaths(srcItem, destItem, 'copy', opts, (err, stats) => {
    if (err) return cb(err)
    const { destStat } = stats;
    startCopy(destStat, srcItem, destItem, opts, err => {
      if (err) return cb(err)
      return copyDirItems(items, src, dest, opts, cb)
    });
  });
}

function onLink (destStat, src, dest, opts, cb) {
  fs$b.readlink(src, (err, resolvedSrc) => {
    if (err) return cb(err)
    if (opts.dereference) {
      resolvedSrc = path$9.resolve(process.cwd(), resolvedSrc);
    }

    if (!destStat) {
      return fs$b.symlink(resolvedSrc, dest, cb)
    } else {
      fs$b.readlink(dest, (err, resolvedDest) => {
        if (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs$b.symlink(resolvedSrc, dest, cb)
          return cb(err)
        }
        if (opts.dereference) {
          resolvedDest = path$9.resolve(process.cwd(), resolvedDest);
        }
        if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
        }

        // do not copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (destStat.isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
        }
        return copyLink(resolvedSrc, dest, cb)
      });
    }
  });
}

function copyLink (resolvedSrc, dest, cb) {
  fs$b.unlink(dest, err => {
    if (err) return cb(err)
    return fs$b.symlink(resolvedSrc, dest, cb)
  });
}

var copy_1 = copy$2;

const u$8 = universalify$1.fromCallback;
var copy$1 = {
  copy: u$8(copy_1)
};

const fs$a = gracefulFs;
const path$8 = require$$0__default$1['default'];
const assert = require$$0__default$2['default'];

const isWindows = (process.platform === 'win32');

function defaults (options) {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ];
  methods.forEach(m => {
    options[m] = options[m] || fs$a[m];
    m = m + 'Sync';
    options[m] = options[m] || fs$a[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
}

function rimraf$1 (p, options, cb) {
  let busyTries = 0;

  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  assert(p, 'rimraf: missing path');
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required');
  assert(options, 'rimraf: invalid options argument provided');
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

  defaults(options);

  rimraf_(p, options, function CB (er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) {
        busyTries++;
        const time = busyTries * 100;
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
      }

      // already gone
      if (er.code === 'ENOENT') er = null;
    }

    cb(er);
  });
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null)
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb)
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb)
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null)
        }
        if (er.code === 'EPERM') {
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb)
        }
      }
      return cb(er)
    });
  });
}

function fixWinEPERM (p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}

function fixWinEPERMSync (p, options, er) {
  let stats;

  assert(p);
  assert(options);

  try {
    options.chmodSync(p, 0o666);
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}

function rmdir (p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb);
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}

function rmkids (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.readdir(p, (er, files) => {
    if (er) return cb(er)

    let n = files.length;
    let errState;

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => {
      rimraf$1(path$8.join(p, f), options, er => {
        if (errState) {
          return
        }
        if (er) return cb(errState = er)
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  let st;

  options = options || {};
  defaults(options);

  assert(p, 'rimraf: missing path');
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
  assert(options, 'rimraf: missing options');
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    } else if (er.code !== 'EISDIR') {
      throw er
    }
    rmdirSync(p, options, er);
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p);
  assert(options);

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options);
    } else if (er.code !== 'ENOENT') {
      throw er
    }
  }
}

function rmkidsSync (p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(f => rimrafSync(path$8.join(p, f), options));

  if (isWindows) {
    // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.
    const startTime = Date.now();
    do {
      try {
        const ret = options.rmdirSync(p, options);
        return ret
      } catch {}
    } while (Date.now() - startTime < 500) // give up after 500ms
  } else {
    const ret = options.rmdirSync(p, options);
    return ret
  }
}

var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;

const fs$9 = gracefulFs;
const u$7 = universalify$1.fromCallback;
const rimraf = rimraf_1;

function remove$2 (path, callback) {
  // Node 14.14.0+
  if (fs$9.rm) return fs$9.rm(path, { recursive: true, force: true }, callback)
  rimraf(path, callback);
}

function removeSync$1 (path) {
  // Node 14.14.0+
  if (fs$9.rmSync) return fs$9.rmSync(path, { recursive: true, force: true })
  rimraf.sync(path);
}

var remove_1 = {
  remove: u$7(remove$2),
  removeSync: removeSync$1
};

const u$6 = universalify$1.fromPromise;
const fs$8 = fs$i;
const path$7 = require$$0__default$1['default'];
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;

const emptyDir = u$6(async function emptyDir (dir) {
  let items;
  try {
    items = await fs$8.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir)
  }

  return Promise.all(items.map(item => remove$1.remove(path$7.join(dir, item))))
});

function emptyDirSync (dir) {
  let items;
  try {
    items = fs$8.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path$7.join(dir, item);
    remove$1.removeSync(item);
  });
}

var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};

const u$5 = universalify$1.fromCallback;
const path$6 = require$$0__default$1['default'];
const fs$7 = gracefulFs;
const mkdir$2 = mkdirs$2;

function createFile (file, callback) {
  function makeFile () {
    fs$7.writeFile(file, '', err => {
      if (err) return callback(err)
      callback();
    });
  }

  fs$7.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback()
    const dir = path$6.dirname(file);
    fs$7.stat(dir, (err, stats) => {
      if (err) {
        // if the directory doesn't exist, make it
        if (err.code === 'ENOENT') {
          return mkdir$2.mkdirs(dir, err => {
            if (err) return callback(err)
            makeFile();
          })
        }
        return callback(err)
      }

      if (stats.isDirectory()) makeFile();
      else {
        // parent is not a directory
        // This is just to cause an internal ENOTDIR error to be thrown
        fs$7.readdir(dir, err => {
          if (err) return callback(err)
        });
      }
    });
  });
}

function createFileSync (file) {
  let stats;
  try {
    stats = fs$7.statSync(file);
  } catch {}
  if (stats && stats.isFile()) return

  const dir = path$6.dirname(file);
  try {
    if (!fs$7.statSync(dir).isDirectory()) {
      // parent is not a directory
      // This is just to cause an internal ENOTDIR error to be thrown
      fs$7.readdirSync(dir);
    }
  } catch (err) {
    // If the stat call above failed because the directory doesn't exist, create it
    if (err && err.code === 'ENOENT') mkdir$2.mkdirsSync(dir);
    else throw err
  }

  fs$7.writeFileSync(file, '');
}

var file$1 = {
  createFile: u$5(createFile),
  createFileSync
};

const u$4 = universalify$1.fromCallback;
const path$5 = require$$0__default$1['default'];
const fs$6 = gracefulFs;
const mkdir$1 = mkdirs$2;
const pathExists$4 = pathExists_1.pathExists;
const { areIdentical: areIdentical$1 } = stat$4;

function createLink (srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    fs$6.link(srcpath, dstpath, err => {
      if (err) return callback(err)
      callback(null);
    });
  }

  fs$6.lstat(dstpath, (_, dstStat) => {
    fs$6.lstat(srcpath, (err, srcStat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        return callback(err)
      }
      if (dstStat && areIdentical$1(srcStat, dstStat)) return callback(null)

      const dir = path$5.dirname(dstpath);
      pathExists$4(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdir$1.mkdirs(dir, err => {
          if (err) return callback(err)
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}

function createLinkSync (srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$6.lstatSync(dstpath);
  } catch {}

  try {
    const srcStat = fs$6.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat)) return
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink');
    throw err
  }

  const dir = path$5.dirname(dstpath);
  const dirExists = fs$6.existsSync(dir);
  if (dirExists) return fs$6.linkSync(srcpath, dstpath)
  mkdir$1.mkdirsSync(dir);

  return fs$6.linkSync(srcpath, dstpath)
}

var link$1 = {
  createLink: u$4(createLink),
  createLinkSync
};

const path$4 = require$$0__default$1['default'];
const fs$5 = gracefulFs;
const pathExists$3 = pathExists_1.pathExists;

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths$1 (srcpath, dstpath, callback) {
  if (path$4.isAbsolute(srcpath)) {
    return fs$5.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink');
        return callback(err)
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      })
    })
  } else {
    const dstdir = path$4.dirname(dstpath);
    const relativeToDst = path$4.join(dstdir, srcpath);
    return pathExists$3(relativeToDst, (err, exists) => {
      if (err) return callback(err)
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        })
      } else {
        return fs$5.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink');
            return callback(err)
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$4.relative(dstdir, srcpath)
          })
        })
      }
    })
  }
}

function symlinkPathsSync$1 (srcpath, dstpath) {
  let exists;
  if (path$4.isAbsolute(srcpath)) {
    exists = fs$5.existsSync(srcpath);
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      toCwd: srcpath,
      toDst: srcpath
    }
  } else {
    const dstdir = path$4.dirname(dstpath);
    const relativeToDst = path$4.join(dstdir, srcpath);
    exists = fs$5.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      }
    } else {
      exists = fs$5.existsSync(srcpath);
      if (!exists) throw new Error('relative srcpath does not exist')
      return {
        toCwd: srcpath,
        toDst: path$4.relative(dstdir, srcpath)
      }
    }
  }
}

var symlinkPaths_1 = {
  symlinkPaths: symlinkPaths$1,
  symlinkPathsSync: symlinkPathsSync$1
};

const fs$4 = gracefulFs;

function symlinkType$1 (srcpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;
  if (type) return callback(null, type)
  fs$4.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file')
    type = (stats && stats.isDirectory()) ? 'dir' : 'file';
    callback(null, type);
  });
}

function symlinkTypeSync$1 (srcpath, type) {
  let stats;

  if (type) return type
  try {
    stats = fs$4.lstatSync(srcpath);
  } catch {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

var symlinkType_1 = {
  symlinkType: symlinkType$1,
  symlinkTypeSync: symlinkTypeSync$1
};

const u$3 = universalify$1.fromCallback;
const path$3 = require$$0__default$1['default'];
const fs$3 = fs$i;
const _mkdirs = mkdirs$2;
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;

const _symlinkPaths = symlinkPaths_1;
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

const _symlinkType = symlinkType_1;
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;

const pathExists$2 = pathExists_1.pathExists;

const { areIdentical } = stat$4;

function createSymlink (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;

  fs$3.lstat(dstpath, (err, stats) => {
    if (!err && stats.isSymbolicLink()) {
      Promise.all([
        fs$3.stat(srcpath),
        fs$3.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical(srcStat, dstStat)) return callback(null)
        _createSymlink(srcpath, dstpath, type, callback);
      });
    } else _createSymlink(srcpath, dstpath, type, callback);
  });
}

function _createSymlink (srcpath, dstpath, type, callback) {
  symlinkPaths(srcpath, dstpath, (err, relative) => {
    if (err) return callback(err)
    srcpath = relative.toDst;
    symlinkType(relative.toCwd, type, (err, type) => {
      if (err) return callback(err)
      const dir = path$3.dirname(dstpath);
      pathExists$2(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return fs$3.symlink(srcpath, dstpath, type, callback)
        mkdirs(dir, err => {
          if (err) return callback(err)
          fs$3.symlink(srcpath, dstpath, type, callback);
        });
      });
    });
  });
}

function createSymlinkSync (srcpath, dstpath, type) {
  let stats;
  try {
    stats = fs$3.lstatSync(dstpath);
  } catch {}
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$3.statSync(srcpath);
    const dstStat = fs$3.statSync(dstpath);
    if (areIdentical(srcStat, dstStat)) return
  }

  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type = symlinkTypeSync(relative.toCwd, type);
  const dir = path$3.dirname(dstpath);
  const exists = fs$3.existsSync(dir);
  if (exists) return fs$3.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir);
  return fs$3.symlinkSync(srcpath, dstpath, type)
}

var symlink$1 = {
  createSymlink: u$3(createSymlink),
  createSymlinkSync
};

const file = file$1;
const link = link$1;
const symlink = symlink$1;

var ensure = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};

function stringify$3 (obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : '';
  const str = JSON.stringify(obj, replacer, spaces);

  return str.replace(/\n/g, EOL) + EOF
}

function stripBom$1 (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8');
  return content.replace(/^\uFEFF/, '')
}

var utils = { stringify: stringify$3, stripBom: stripBom$1 };

let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = fs__default['default'];
}
const universalify = universalify$1;
const { stringify: stringify$2, stripBom } = utils;

async function _readFile (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  const fs = options.fs || _fs;

  const shouldThrow = 'throws' in options ? options.throws : true;

  let data = await universalify.fromCallback(fs.readFile)(file, options);

  data = stripBom(data);

  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`;
      throw err
    } else {
      return null
    }
  }

  return obj
}

const readFile = universalify.fromPromise(_readFile);

function readFileSync (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  const fs = options.fs || _fs;

  const shouldThrow = 'throws' in options ? options.throws : true;

  try {
    let content = fs.readFileSync(file, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`;
      throw err
    } else {
      return null
    }
  }
}

async function _writeFile (file, obj, options = {}) {
  const fs = options.fs || _fs;

  const str = stringify$2(obj, options);

  await universalify.fromCallback(fs.writeFile)(file, str, options);
}

const writeFile = universalify.fromPromise(_writeFile);

function writeFileSync (file, obj, options = {}) {
  const fs = options.fs || _fs;

  const str = stringify$2(obj, options);
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

const jsonfile$1 = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
};

var jsonfile_1 = jsonfile$1;

const jsonFile$1 = jsonfile_1;

var jsonfile = {
  // jsonfile exports
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};

const u$2 = universalify$1.fromCallback;
const fs$2 = gracefulFs;
const path$2 = require$$0__default$1['default'];
const mkdir = mkdirs$2;
const pathExists$1 = pathExists_1.pathExists;

function outputFile$1 (file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding;
    encoding = 'utf8';
  }

  const dir = path$2.dirname(file);
  pathExists$1(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return fs$2.writeFile(file, data, encoding, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)

      fs$2.writeFile(file, data, encoding, callback);
    });
  });
}

function outputFileSync$1 (file, ...args) {
  const dir = path$2.dirname(file);
  if (fs$2.existsSync(dir)) {
    return fs$2.writeFileSync(file, ...args)
  }
  mkdir.mkdirsSync(dir);
  fs$2.writeFileSync(file, ...args);
}

var output = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};

const { stringify: stringify$1 } = utils;
const { outputFile } = output;

async function outputJson (file, data, options = {}) {
  const str = stringify$1(data, options);

  await outputFile(file, str, options);
}

var outputJson_1 = outputJson;

const { stringify } = utils;
const { outputFileSync } = output;

function outputJsonSync (file, data, options) {
  const str = stringify(data, options);

  outputFileSync(file, str, options);
}

var outputJsonSync_1 = outputJsonSync;

const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;

jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
// aliases
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;

var json = jsonFile;

const fs$1 = gracefulFs;
const path$1 = require$$0__default$1['default'];
const copySync = copySync$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat$1 = stat$4;

function moveSync$1 (src, dest, opts) {
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;

  const { srcStat, isChangingCase = false } = stat$1.checkPathsSync(src, dest, 'move', opts);
  stat$1.checkParentPathsSync(src, srcStat, dest, 'move');
  if (!isParentRoot$1(dest)) mkdirpSync(path$1.dirname(dest));
  return doRename$1(src, dest, overwrite, isChangingCase)
}

function isParentRoot$1 (dest) {
  const parent = path$1.dirname(dest);
  const parsedPath = path$1.parse(parent);
  return parsedPath.root === parent
}

function doRename$1 (src, dest, overwrite, isChangingCase) {
  if (isChangingCase) return rename$1(src, dest, overwrite)
  if (overwrite) {
    removeSync(dest);
    return rename$1(src, dest, overwrite)
  }
  if (fs$1.existsSync(dest)) throw new Error('dest already exists.')
  return rename$1(src, dest, overwrite)
}

function rename$1 (src, dest, overwrite) {
  try {
    fs$1.renameSync(src, dest);
  } catch (err) {
    if (err.code !== 'EXDEV') throw err
    return moveAcrossDevice$1(src, dest, overwrite)
  }
}

function moveAcrossDevice$1 (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copySync(src, dest, opts);
  return removeSync(src)
}

var moveSync_1 = moveSync$1;

var moveSync = {
  moveSync: moveSync_1
};

const fs = gracefulFs;
const path = require$$0__default$1['default'];
const copy = copy$1.copy;
const remove = remove_1.remove;
const mkdirp = mkdirs$2.mkdirp;
const pathExists = pathExists_1.pathExists;
const stat = stat$4;

function move$1 (src, dest, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }

  const overwrite = opts.overwrite || opts.clobber || false;

  stat.checkPaths(src, dest, 'move', opts, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, isChangingCase = false } = stats;
    stat.checkParentPaths(src, srcStat, dest, 'move', err => {
      if (err) return cb(err)
      if (isParentRoot(dest)) return doRename(src, dest, overwrite, isChangingCase, cb)
      mkdirp(path.dirname(dest), err => {
        if (err) return cb(err)
        return doRename(src, dest, overwrite, isChangingCase, cb)
      });
    });
  });
}

function isParentRoot (dest) {
  const parent = path.dirname(dest);
  const parsedPath = path.parse(parent);
  return parsedPath.root === parent
}

function doRename (src, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase) return rename(src, dest, overwrite, cb)
  if (overwrite) {
    return remove(dest, err => {
      if (err) return cb(err)
      return rename(src, dest, overwrite, cb)
    })
  }
  pathExists(dest, (err, destExists) => {
    if (err) return cb(err)
    if (destExists) return cb(new Error('dest already exists.'))
    return rename(src, dest, overwrite, cb)
  });
}

function rename (src, dest, overwrite, cb) {
  fs.rename(src, dest, err => {
    if (!err) return cb()
    if (err.code !== 'EXDEV') return cb(err)
    return moveAcrossDevice(src, dest, overwrite, cb)
  });
}

function moveAcrossDevice (src, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copy(src, dest, opts, err => {
    if (err) return cb(err)
    return remove(src, cb)
  });
}

var move_1 = move$1;

const u = universalify$1.fromCallback;
var move = {
  move: u(move_1)
};

({
  // Export promiseified graceful-fs:
  ...fs$i,
  // Export extra methods:
  ...copySync$1,
  ...copy$1,
  ...empty,
  ...ensure,
  ...json,
  ...mkdirs$2,
  ...moveSync,
  ...move,
  ...output,
  ...pathExists_1,
  ...remove_1
});

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// node_modules/.pnpm/duplexer@0.1.2/node_modules/duplexer/index.js
var require_duplexer = __commonJS({
  "node_modules/.pnpm/duplexer@0.1.2/node_modules/duplexer/index.js"(exports, module) {
    var Stream = __require("stream");
    var writeMethods = ["write", "end", "destroy"];
    var readMethods = ["resume", "pause"];
    var readEvents = ["data", "close"];
    var slice = Array.prototype.slice;
    module.exports = duplex;
    function forEach(arr, fn) {
      if (arr.forEach) {
        return arr.forEach(fn);
      }
      for (var i = 0; i < arr.length; i++) {
        fn(arr[i], i);
      }
    }
    function duplex(writer, reader) {
      var stream = new Stream();
      var ended = false;
      forEach(writeMethods, proxyWriter);
      forEach(readMethods, proxyReader);
      forEach(readEvents, proxyStream);
      reader.on("end", handleEnd);
      writer.on("drain", function() {
        stream.emit("drain");
      });
      writer.on("error", reemit);
      reader.on("error", reemit);
      stream.writable = writer.writable;
      stream.readable = reader.readable;
      return stream;
      function proxyWriter(methodName) {
        stream[methodName] = method;
        function method() {
          return writer[methodName].apply(writer, arguments);
        }
      }
      function proxyReader(methodName) {
        stream[methodName] = method;
        function method() {
          stream.emit(methodName);
          var func = reader[methodName];
          if (func) {
            return func.apply(reader, arguments);
          }
          reader.emit(methodName);
        }
      }
      function proxyStream(methodName) {
        reader.on(methodName, reemit2);
        function reemit2() {
          var args = slice.call(arguments);
          args.unshift(methodName);
          stream.emit.apply(stream, args);
        }
      }
      function handleEnd() {
        if (ended) {
          return;
        }
        ended = true;
        var args = slice.call(arguments);
        args.unshift("end");
        stream.emit.apply(stream, args);
      }
      function reemit(err) {
        stream.emit("error", err);
      }
    }
  }
});

// node_modules/.pnpm/gzip-size@6.0.0/node_modules/gzip-size/index.js
var require_gzip_size = __commonJS({
  "node_modules/.pnpm/gzip-size@6.0.0/node_modules/gzip-size/index.js"(exports, module) {
    var fs4 = __require("fs");
    var stream = __require("stream");
    var zlib = __require("zlib");
    var { promisify } = __require("util");
    var duplexer = require_duplexer();
    var getOptions = (options) => __spreadValues({ level: 9 }, options);
    var gzip = promisify(zlib.gzip);
    module.exports = async (input, options) => {
      if (!input) {
        return 0;
      }
      const data = await gzip(input, getOptions(options));
      return data.length;
    };
    module.exports.sync = (input, options) => zlib.gzipSync(input, getOptions(options)).length;
    module.exports.stream = (options) => {
      const input = new stream.PassThrough();
      const output = new stream.PassThrough();
      const wrapper = duplexer(input, output);
      let gzipSize2 = 0;
      const gzip2 = zlib.createGzip(getOptions(options)).on("data", (buf) => {
        gzipSize2 += buf.length;
      }).on("error", () => {
        wrapper.gzipSize = 0;
      }).on("end", () => {
        wrapper.gzipSize = gzipSize2;
        wrapper.emit("gzip-size", gzipSize2);
        output.end();
      });
      input.pipe(gzip2);
      input.pipe(output, { end: false });
      return wrapper;
    };
    module.exports.file = (path, options) => {
      return new Promise((resolve3, reject) => {
        const stream2 = fs4.createReadStream(path);
        stream2.on("error", reject);
        const gzipStream = stream2.pipe(module.exports.stream(options));
        gzipStream.on("error", reject);
        gzipStream.on("gzip-size", resolve3);
      });
    };
    module.exports.fileSync = (path, options) => module.exports.sync(fs4.readFileSync(path), options);
  }
});

// node_modules/.pnpm/filesize@6.4.0/node_modules/filesize/lib/filesize.js
var require_filesize = __commonJS({
  "node_modules/.pnpm/filesize@6.4.0/node_modules/filesize/lib/filesize.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.filesize = factory());
    })(exports, function() {
      var b = /^(b|B)$/, symbol = {
        iec: {
          bits: ["b", "Kib", "Mib", "Gib", "Tib", "Pib", "Eib", "Zib", "Yib"],
          bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
        },
        jedec: {
          bits: ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"],
          bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
        }
      }, fullform = {
        iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
        jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
      }, roundingFuncs = {
        floor: Math.floor,
        ceil: Math.ceil
      };
      function filesize(arg) {
        var descriptor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var result = [], val = 0, e, base, bits, ceil, full, fullforms, locale, localeOptions, neg, num, output, pad, round, u, unix, separator, spacer, standard, symbols, roundingFunc, precision;
        if (isNaN(arg)) {
          throw new TypeError("Invalid number");
        }
        bits = descriptor.bits === true;
        unix = descriptor.unix === true;
        pad = descriptor.pad === true;
        base = descriptor.base || 2;
        round = descriptor.round !== void 0 ? descriptor.round : unix ? 1 : 2;
        locale = descriptor.locale !== void 0 ? descriptor.locale : "";
        localeOptions = descriptor.localeOptions || {};
        separator = descriptor.separator !== void 0 ? descriptor.separator : "";
        spacer = descriptor.spacer !== void 0 ? descriptor.spacer : unix ? "" : " ";
        symbols = descriptor.symbols || {};
        standard = base === 2 ? descriptor.standard || "jedec" : "jedec";
        output = descriptor.output || "string";
        full = descriptor.fullform === true;
        fullforms = descriptor.fullforms instanceof Array ? descriptor.fullforms : [];
        e = descriptor.exponent !== void 0 ? descriptor.exponent : -1;
        roundingFunc = roundingFuncs[descriptor.roundingMethod] || Math.round;
        num = Number(arg);
        neg = num < 0;
        ceil = base > 2 ? 1e3 : 1024;
        precision = isNaN(descriptor.precision) === false ? parseInt(descriptor.precision, 10) : 0;
        if (neg) {
          num = -num;
        }
        if (e === -1 || isNaN(e)) {
          e = Math.floor(Math.log(num) / Math.log(ceil));
          if (e < 0) {
            e = 0;
          }
        }
        if (e > 8) {
          if (precision > 0) {
            precision += 8 - e;
          }
          e = 8;
        }
        if (output === "exponent") {
          return e;
        }
        if (num === 0) {
          result[0] = 0;
          u = result[1] = unix ? "" : symbol[standard][bits ? "bits" : "bytes"][e];
        } else {
          val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1e3, e));
          if (bits) {
            val = val * 8;
            if (val >= ceil && e < 8) {
              val = val / ceil;
              e++;
            }
          }
          var p = Math.pow(10, e > 0 ? round : 0);
          result[0] = roundingFunc(val * p) / p;
          if (result[0] === ceil && e < 8 && descriptor.exponent === void 0) {
            result[0] = 1;
            e++;
          }
          u = result[1] = base === 10 && e === 1 ? bits ? "kb" : "kB" : symbol[standard][bits ? "bits" : "bytes"][e];
          if (unix) {
            result[1] = standard === "jedec" ? result[1].charAt(0) : e > 0 ? result[1].replace(/B$/, "") : result[1];
            if (b.test(result[1])) {
              result[0] = Math.floor(result[0]);
              result[1] = "";
            }
          }
        }
        if (neg) {
          result[0] = -result[0];
        }
        if (precision > 0) {
          result[0] = result[0].toPrecision(precision);
        }
        result[1] = symbols[result[1]] || result[1];
        if (locale === true) {
          result[0] = result[0].toLocaleString();
        } else if (locale.length > 0) {
          result[0] = result[0].toLocaleString(locale, localeOptions);
        } else if (separator.length > 0) {
          result[0] = result[0].toString().replace(".", separator);
        }
        if (pad && Number.isInteger(result[0]) === false && round > 0) {
          var x = separator || ".", tmp = result[0].toString().split(x), s = tmp[1] || "", l = s.length, n = round - l;
          result[0] = "".concat(tmp[0]).concat(x).concat(s.padEnd(l + n, "0"));
        }
        if (full) {
          result[1] = fullforms[e] ? fullforms[e] : fullform[standard][e] + (bits ? "bit" : "byte") + (result[0] === 1 ? "" : "s");
        }
        return output === "array" ? result : output === "object" ? {
          value: result[0],
          symbol: result[1],
          exponent: e,
          unit: u
        } : result.join(spacer);
      }
      filesize.partial = function(opt) {
        return function(arg) {
          return filesize(arg, opt);
        };
      };
      return filesize;
    });
  }
});

// node_modules/.pnpm/is-docker@2.1.1/node_modules/is-docker/index.js
var require_is_docker = __commonJS({
  "node_modules/.pnpm/is-docker@2.1.1/node_modules/is-docker/index.js"(exports, module) {
    var fs4 = __require("fs");
    var isDocker;
    function hasDockerEnv() {
      try {
        fs4.statSync("/.dockerenv");
        return true;
      } catch (_) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs4.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_) {
        return false;
      }
    }
    module.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// node_modules/.pnpm/is-wsl@2.2.0/node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
  "node_modules/.pnpm/is-wsl@2.2.0/node_modules/is-wsl/index.js"(exports, module) {
    var os = __require("os");
    var fs4 = __require("fs");
    var isDocker = require_is_docker();
    var isWsl = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs4.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module.exports = isWsl;
    } else {
      module.exports = isWsl();
    }
  }
});

// node_modules/.pnpm/define-lazy-prop@2.0.0/node_modules/define-lazy-prop/index.js
var require_define_lazy_prop = __commonJS({
  "node_modules/.pnpm/define-lazy-prop@2.0.0/node_modules/define-lazy-prop/index.js"(exports, module) {
    module.exports = (object, propertyName, fn) => {
      const define2 = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
      Object.defineProperty(object, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result = fn();
          define2(result);
          return result;
        },
        set(value) {
          define2(value);
        }
      });
      return object;
    };
  }
});

// node_modules/.pnpm/open@8.2.1/node_modules/open/index.js
var require_open = __commonJS({
  "node_modules/.pnpm/open@8.2.1/node_modules/open/index.js"(exports, module) {
    var path = __require("path");
    var childProcess = __require("child_process");
    var { promises: fs4, constants: fsConstants } = __require("fs");
    var isWsl = require_is_wsl();
    var isDocker = require_is_docker();
    var defineLazyProperty = require_define_lazy_prop();
    var localXdgOpenPath = path.join(__dirname, "xdg-open");
    var { platform, arch } = process;
    var getWslDrivesMountPoint = (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs4.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs4.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    var pTryEach = async (array, mapper) => {
      let latestError;
      for (const item of array) {
        try {
          return await mapper(item);
        } catch (error) {
          latestError = error;
        }
      }
      throw latestError;
    };
    var open = async (target, options) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      options = __spreadValues({
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false
      }, options);
      if (Array.isArray(options.app)) {
        return pTryEach(options.app, (singleApp) => open(target, __spreadProps(__spreadValues({}, options), {
          app: singleApp
        })));
      }
      let { name: app, arguments: appArguments = [] } = options.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => open(target, __spreadProps(__spreadValues({}, options), {
          app: {
            name: appName,
            arguments: appArguments
          }
        })));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options.background) {
          cliArguments.push("--background");
        }
        if (options.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || isWsl && !isDocker()) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push("-NoProfile", "-NonInteractive", "\u2013ExecutionPolicy", "Bypass", "-EncodedCommand");
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          appArguments.unshift(target);
        } else {
          encodedArguments.push(`"${target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs4.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      cliArguments.push(target);
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      if (options.wait) {
        return new Promise((resolve3, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (options.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve3(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    function detectArchBinary(binary) {
      if (typeof binary === "string" || Array.isArray(binary)) {
        return binary;
      }
      const { [arch]: archBinary } = binary;
      if (!archBinary) {
        throw new Error(`${arch} is not supported`);
      }
      return archBinary;
    }
    function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
      if (wsl && isWsl) {
        return detectArchBinary(wsl);
      }
      if (!platformBinary) {
        throw new Error(`${platform} is not supported`);
      }
      return detectArchBinary(platformBinary);
    }
    var apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: "microsoft-edge"
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open.apps = apps;
    module.exports = open;
  }
});

// node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports, module) {
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert;
  }
});

// node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports, module) {
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports, module) {
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports, module) {
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/util.js"(exports, module) {
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/templates.js"(exports, module) {
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/index.js"(exports, module) {
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, __spreadProps(__spreadValues({}, styles), {
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    }));
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module.exports = chalk;
  }
});
function uniq(data) {
  return Array.from(new Set(data));
}
function countElement(arr, element) {
  let num = 0;
  arr.forEach((i) => {
    if (i === element)
      num += 1;
  });
  return num;
}

// node/analysis/index.ts
var import_gzip_size = __toModule(require_gzip_size());
var import_filesize = __toModule(require_filesize());

// node/analysis/tools.ts
function hex2RGB(hex) {
  const RGB_HEX = /^#?(?:([\da-f]{3})[\da-f]?|([\da-f]{6})(?:[\da-f]{2})?)$/i;
  const [, short, long] = String(hex).match(RGB_HEX) || [];
  if (long) {
    const value = Number.parseInt(long, 16);
    return [value >> 16, value >> 8 & 255, value & 255];
  } else if (short) {
    return Array.from(short, (s) => Number.parseInt(s, 16)).map((n) => n << 4 | n);
  }
}
function flatColors(colors, head) {
  let flatten = {};
  for (const [key, value] of Object.entries(colors)) {
    if (typeof value === "string" || Array.isArray(value))
      flatten[head && key === "DEFAULT" ? head : head ? `${head}-${key}` : key] = value;
    else
      flatten = __spreadValues(__spreadValues({}, flatten), flatColors(value, head ? `${head}-${key}` : key));
  }
  return flatten;
}

// node/analysis/colors.ts
function parseColor(value, map) {
  let color;
  let name;
  if (map && typeof map === "object") {
    const colors = flatColors(map);
    const body = value.replace(/^ring-offset|outline-solid|outline-dotted/, "head").replace(/^\w+-/, "");
    if (body in colors) {
      color = colors[body];
      if (Array.isArray(color))
        color = color[0];
      name = body;
    } else if (body.startsWith("hex-")) {
      const hex = body.slice(4);
      if (hex2RGB(hex)) {
        color = `#${hex}`;
        name = body;
      }
    } else if (body.startsWith("[#") && body.endsWith("]")) {
      const hex = body.slice(2, -1);
      if (hex2RGB(hex)) {
        color = `#${hex}`;
        name = body;
      }
    }
  }
  return { color, name };
}

// node/analysis/categories.ts
var staticUtilities = {
  "box-border": "boxSizing",
  "box-content": "boxSizing",
  "block": "display",
  "inline-block": "display",
  "inline": "display",
  "flex": "display",
  "inline-flex": "display",
  "table": "display",
  "table-caption": "display",
  "table-cell": "display",
  "table-column": "display",
  "table-column-group": "display",
  "table-footer-group": "display",
  "table-header-group": "display",
  "table-row-group": "display",
  "table-row": "display",
  "flow-root": "display",
  "grid": "display",
  "inline-grid": "display",
  "contents": "display",
  "hidden": "display",
  "float-right": "float",
  "float-left": "float",
  "float-none": "float",
  "clear-left": "clear",
  "clear-right": "clear",
  "clear-both": "clear",
  "clear-none": "clear",
  "object-contain": "objectFit",
  "object-cover": "objectFit",
  "object-fill": "objectFit",
  "object-none": "objectFit",
  "object-scale-down": "objectFit",
  "overflow-auto": "overflow",
  "overflow-hidden": "overflow",
  "overflow-visible": "overflow",
  "overflow-scroll": "overflow",
  "overflow-x-auto": "overflow",
  "overflow-y-auto": "overflow",
  "overflow-x-hidden": "overflow",
  "overflow-y-hidden": "overflow",
  "overflow-x-visible": "overflow",
  "overflow-y-visible": "overflow",
  "overflow-x-scroll": "overflow",
  "overflow-y-scroll": "overflow",
  "overscroll-auto": "overscrollBehavior",
  "overscroll-contain": "overscrollBehavior",
  "overscroll-none": "overscrollBehavior",
  "overscroll-y-auto": "overscrollBehavior",
  "overscroll-y-contain": "overscrollBehavior",
  "overscroll-y-none": "overscrollBehavior",
  "overscroll-x-auto": "overscrollBehavior",
  "overscroll-x-contain": "overscrollBehavior",
  "overscroll-x-none": "overscrollBehavior",
  "static": "position",
  "fixed": "position",
  "absolute": "position",
  "relative": "position",
  "sticky": "position",
  "visible": "visibility",
  "invisible": "visibility",
  "flex-row": "flex",
  "flex-row-reverse": "flex",
  "flex-col": "flex",
  "flex-col-reverse": "flex",
  "flex-wrap": "flex",
  "flex-wrap-reverse": "flex",
  "flex-nowrap": "flex",
  "col-auto": "grid",
  "row-auto": "grid",
  "grid-flow-row": "grid",
  "grid-flow-col": "grid",
  "grid-flow-row-dense": "grid",
  "grid-flow-col-dense": "grid",
  "justify-start": "justifyContent",
  "justify-end": "justifyContent",
  "justify-center": "justifyContent",
  "justify-between": "justifyContent",
  "justify-around": "justifyContent",
  "justify-evenly": "justifyContent",
  "justify-items-auto": "justifyItems",
  "justify-items-start": "justifyItems",
  "justify-items-end": "justifyItems",
  "justify-items-center": "justifyItems",
  "justify-items-stretch": "justifyItems",
  "justify-self-auto": "justifySelf",
  "justify-self-start": "justifySelf",
  "justify-self-end": "justifySelf",
  "justify-self-center": "justifySelf",
  "justify-self-stretch": "justifySelf",
  "content-center": "alignContent",
  "content-start": "alignContent",
  "content-end": "alignContent",
  "content-between": "alignContent",
  "content-around": "alignContent",
  "content-evenly": "alignContent",
  "items-start": "alignItems",
  "items-end": "alignItems",
  "items-center": "alignItems",
  "items-baseline": "alignItems",
  "items-stretch": "alignItems",
  "self-auto": "alignSelf",
  "self-start": "alignSelf",
  "self-end": "alignSelf",
  "self-center": "alignSelf",
  "self-stretch": "alignSelf",
  "place-content-center": "placeContent",
  "place-content-start": "placeContent",
  "place-content-end": "placeContent",
  "place-content-between": "placeContent",
  "place-content-around": "placeContent",
  "place-content-evenly": "placeContent",
  "place-content-stretch": "placeContent",
  "place-items-auto": "placeItems",
  "place-items-start": "placeItems",
  "place-items-end": "placeItems",
  "place-items-center": "placeItems",
  "place-items-stretch": "placeItems",
  "place-self-auto": "placeSelf",
  "place-self-start": "placeSelf",
  "place-self-end": "placeSelf",
  "place-self-center": "placeSelf",
  "place-self-stretch": "placeSelf",
  "antialiased": "fontSmoothing",
  "subpixel-antialiased": "font",
  "italic": "font",
  "not-italic": "font",
  "normal-nums": "font",
  "ordinal": "font",
  "slashed-zero": "font",
  "lining-nums": "font",
  "oldstyle-nums": "font",
  "proportional-nums": "font",
  "tabular-nums": "font",
  "diagonal-fractions": "font",
  "stacked-fractions": "font",
  "list-inside": "listStylePosition",
  "list-outside": "listStylePosition",
  "text-left": "textAlign",
  "text-center": "textAlign",
  "text-right": "textAlign",
  "text-justify": "textAlign",
  "underline": "textDecoration",
  "line-through": "textDecoration",
  "no-underline": "textDecoration",
  "uppercase": "textTransform",
  "lowercase": "textTransform",
  "capitalize": "textTransform",
  "normal-case": "textTransform",
  "truncate": "textOverflow",
  "overflow-ellipsis": "textOverflow",
  "overflow-clip": "textOverflow",
  "align-baseline": "verticalAlign",
  "align-top": "verticalAlign",
  "align-middle": "verticalAlign",
  "align-bottom": "verticalAlign",
  "align-text-top": "verticalAlign",
  "align-text-bottom": "verticalAlign",
  "whitespace-normal": "whitespace",
  "whitespace-nowrap": "whitespace",
  "whitespace-pre": "whitespace",
  "whitespace-pre-line": "whitespace",
  "whitespace-pre-wrap": "whitespace",
  "break-normal": "wordBreak",
  "break-words": "wordBreak",
  "break-all": "wordBreak",
  "bg-fixed": "background",
  "bg-local": "background",
  "bg-scroll": "background",
  "bg-clip-border": "background",
  "bg-clip-padding": "background",
  "bg-clip-content": "background",
  "bg-clip-text": "background",
  "bg-repeat": "background",
  "bg-no-repeat": "background",
  "bg-repeat-x": "background",
  "bg-repeat-y": "background",
  "bg-repeat-round": "background",
  "bg-repeat-space": "background",
  "border-solid": "border",
  "border-dashed": "border",
  "border-dotted": "border",
  "border-double": "border",
  "border-none": "border",
  "border-collapse": "border",
  "border-separate": "border",
  "table-auto": "table",
  "table-fixed": "table",
  "transform": "transform",
  "transform-gpu": "transform",
  "transform-none": "transform",
  "appearance-none": "appearance",
  "pointer-events-none": "pointerEvents",
  "pointer-events-auto": "pointerEvents",
  "resize-none": "resize",
  "resize-y": "resize",
  "resize-x": "resize",
  "resize": "resize",
  "select-none": "userSelect",
  "select-text": "userSelect",
  "select-all": "userSelect",
  "select-auto": "userSelect",
  "fill-current": "fill",
  "stroke-current": "stroke",
  "sr-only": "accessibility",
  "not-sr-only": "accessibility"
};
var dynamicUtilities = {
  container: "container",
  space: "space",
  divide: "divide",
  bg: "background",
  from: "gradientColor",
  via: "gradientColor",
  to: "gradientColor",
  border: "border",
  rounded: "borderRadius",
  cursor: "cursor",
  flex: "flex",
  order: "order",
  font: "font",
  h: "size",
  leading: "lineHeight",
  list: "listStyleType",
  m: "margin",
  my: "margin",
  mx: "margin",
  mt: "margin",
  mr: "margin",
  mb: "margin",
  ml: "margin",
  min: "size",
  max: "size",
  object: "objectPosition",
  opacity: "opacity",
  outline: "outline",
  p: "padding",
  py: "padding",
  px: "padding",
  pt: "padding",
  pr: "padding",
  pb: "padding",
  pl: "padding",
  placeholder: "placeholder",
  inset: "inset",
  top: "position",
  right: "position",
  bottom: "position",
  left: "position",
  shadow: "boxShadow",
  ring: "ring",
  fill: "fill",
  stroke: "stroke",
  text: "text",
  tracking: "letterSpacing",
  w: "size",
  z: "zIndex",
  gap: "gap",
  auto: "grid",
  grid: "grid",
  col: "grid",
  row: "grid",
  origin: "transform",
  scale: "transform",
  rotate: "transform",
  translate: "transform",
  skew: "transform",
  transition: "animation",
  ease: "animation",
  duration: "animation",
  delay: "animation",
  animate: "animation"
};

// node/analysis/parse.ts
function parseUtility(name, processor) {
  const info = {};
  const shortcuts = processor.config("shortcuts") || {};
  if (shortcuts[name]) {
    info.shortcut = shortcuts[name];
    info.category = "shortcut";
  }
  if (name[0] === "!") {
    info.important = true;
    name = name.slice(1);
  }
  if (name.includes(":")) {
    const variants = name.split(/:/g);
    info.prefixes = variants.slice(0, -1);
    name = variants.slice(-1)[0];
  }
  info.base = name;
  const [type] = (name.startsWith("-") ? name.slice(1) : name).split("-");
  if (!info.category) {
    if (name.includes("$")) {
      info.category = "variable";
    } else if (name in staticUtilities) {
      info.category = staticUtilities[name];
      info.type = type;
    } else if (type in dynamicUtilities) {
      info.category = dynamicUtilities[type];
    }
  }
  info.category = info.category || "unknown";
  info.type = info.type || type;
  const color = parseColor(info.base, processor.theme("colors"));
  if (color.name) {
    info.colorHex = color.color;
    info.colorName = color.name;
  }
  return info;
}

// node/analysis/index.ts
var NAME = "windicss-analysis";
async function runAnalysis(userOptions = {}, options = {}) {
  var _a;
  const {
    interpretUtilities = false
  } = options;
  const utils = createUtils(userOptions, { name: NAME });
  await utils.init();
  const root = utils.options.root;
  const files = [];
  const allcodes = [];
  for (const filepath of await utils.getFiles()) {
    let code = await fs$r.promises.readFile(filepath, "utf-8");
    code = ((_a = utils.transformGroups(code)) == null ? void 0 : _a.code) || code;
    const { classes } = await utils.applyExtractors(code, filepath);
    files.push({
      utilities: classes || [],
      filepath
    });
    allcodes.push({ filepath, code });
  }
  const shortcuts = utils.processor.config("shortcuts") || {};
  const { success: utilityNames, styleSheet } = utils.processor.interpret(files.flatMap((i) => i.utilities).join(" "));
  files.forEach((i) => i.utilities = i.utilities.filter((c) => utilityNames.includes(c)));
  const allUsages = files.flatMap((i) => i.utilities);
  const utilitiesList = utilityNames.map((i) => __spreadValues({
    count: countElement(allUsages, i),
    base: i,
    full: i
  }, parseUtility(i, utils.processor)));
  if (interpretUtilities) {
    utilitiesList.forEach((i) => {
      i.css = utils.processor.interpret(i.full).styleSheet.build();
    });
  }
  const utilities = Object.fromEntries(utilitiesList.map((i) => [i.full, i]));
  const baseNames = uniq(utilitiesList.map((u) => u.base));
  const bases = Object.fromEntries(baseNames.map((i) => [i, {
    count: utilitiesList.filter((u) => u.base === i).reduce((a, b) => a.count + b.count, { count: 0 }),
    base: i,
    variants: utilitiesList.filter((u) => u.base === i).map((i2) => i2.full)
  }]));
  const css = styleSheet.build().replace(/[\s\n]+/gm, "");
  const size = await (0, import_gzip_size.default)(css);
  const colors = Object.fromEntries(uniq(utilitiesList.map((u) => u.colorName).filter((i) => i)).map((i) => [i, {
    name: i,
    hex: utilitiesList.find((u) => u.colorName === i).colorHex || "",
    utilities: utilitiesList.filter((u) => u.colorName === i).map((i2) => i2.full),
    prefixes: uniq(utilitiesList.filter((u) => u.colorName === i).flatMap((i2) => i2.prefixes || []))
  }]));
  const _files = {};
  const _groups = await declass_1(allcodes.map(({ code }) => code).join("\n"));
  allcodes.forEach(({ code, filepath }) => {
    const g = [];
    _groups.forEach((group) => {
      for (const e of group.uses) {
        if (code.search(e) !== -1)
          g.push(group.class);
      }
    });
    if (Object.keys(g).length > 0)
      _files[filepath] = g;
  });
  const result = {
    root,
    include: utils.options.scanOptions.include,
    exclude: utils.options.scanOptions.exclude,
    colors,
    files,
    groups: {
      files: _files,
      groups: _groups
    },
    utilities,
    shortcuts,
    bases,
    dist: {
      gzip: (0, import_filesize.default)(size)
    }
  };
  const packageJsonPath = require$$0$4.join(root, "package.json");
  if (fs$r.existsSync(packageJsonPath)) {
    const { name, version: version2 } = JSON.parse(await fs$r.promises.readFile(packageJsonPath, "utf-8"));
    result.name = name;
    result.version = version2;
  }
  return {
    result,
    utils
  };
}

// node/server.ts
__toModule(require_open());
__toModule(require_source());
/**
 * filesize
 *
 * @copyright 2021 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 6.4.0
 */

exports.Processor = Processor;
exports.jiti = lib$c;
exports.runAnalysis = runAnalysis;
